<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="沙盒基础知识 在 CTF 的 pwn 题中一般有两种函数调用方式实现沙盒机制： 使用 prctl 系统调用： 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stddef.h&gt;#inclu">
<meta property="og:type" content="article">
<meta property="og:title" content="Principles：沙盒底层原理">
<meta property="og:url" content="http://example.com/2023/11/21/Principles%EF%BC%9A%E6%B2%99%E7%9B%92%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="沙盒基础知识 在 CTF 的 pwn 题中一般有两种函数调用方式实现沙盒机制： 使用 prctl 系统调用： 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stddef.h&gt;#inclu">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/11/21/Principles%EF%BC%9A%E6%B2%99%E7%9B%92%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1700624107072.png">
<meta property="article:published_time" content="2023-11-21T12:50:47.000Z">
<meta property="article:modified_time" content="2023-11-23T04:11:20.632Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="Principles">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/11/21/Principles%EF%BC%9A%E6%B2%99%E7%9B%92%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1700624107072.png">

<link rel="canonical" href="http://example.com/2023/11/21/Principles%EF%BC%9A%E6%B2%99%E7%9B%92%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Principles：沙盒底层原理 | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/21/Principles%EF%BC%9A%E6%B2%99%E7%9B%92%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Principles：沙盒底层原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-21 20:50:47" itemprop="dateCreated datePublished" datetime="2023-11-21T20:50:47+08:00">2023-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-23 12:11:20" itemprop="dateModified" datetime="2023-11-23T12:11:20+08:00">2023-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles/" itemprop="url" rel="index"><span itemprop="name">Principles</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>28 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>沙盒基础知识</strong></p>
<p>在 CTF 的 pwn 题中一般有两种函数调用方式实现沙盒机制：</p>
<p>使用 <code>prctl</code> 系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/prctl.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/bpf.h&gt;</span>             </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[]=</span>&#123;</span><br><span class="line">        BPF_STMT(BPF_LD|BPF_W|BPF_ABS, <span class="number">0</span>),   </span><br><span class="line">        BPF_JUMP(BPF_JMP|BPF_JEQ, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>), </span><br><span class="line">        BPF_JUMP(BPF_JMP|BPF_JGE, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ERRNO),</span><br><span class="line">        BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span>=</span>&#123;</span><br><span class="line">        .len=<span class="keyword">sizeof</span>(filter)/<span class="keyword">sizeof</span>(filter[<span class="number">0</span>]),</span><br><span class="line">        .filter=filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);</span><br><span class="line">    syscall(<span class="number">59</span>,<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0003</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x35</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A &gt;= <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0004</span></span><br><span class="line"><span class="number">0003</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00050000</span>  <span class="keyword">return</span> ERRNO(<span class="number">0</span>)</span><br><span class="line"><span class="number">0004</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br></pre></td></tr></table></figure>
<p>使用 <code>seccomp</code> 库函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    scmp_filter_ctx ctx;</span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>);</span><br><span class="line">    seccomp_load(ctx);</span><br><span class="line">    syscall(<span class="number">59</span>,<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x05</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0007</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x02</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0007</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0007</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure>
<ul>
<li>对 <code>seccomp_load</code> 函数进行逆向分析，可以发现其底层也是使用 <code>prctl</code> 系统调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v17 = prctl(<span class="number">38LL</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>); <span class="comment">/* PR_SET_NO_NEW_PRIVS */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v14 = prctl(<span class="number">22LL</span>, <span class="number">2LL</span>, v10, v10, v7); <span class="comment">/* PR_SET_SECCOMP */</span></span><br></pre></td></tr></table></figure>
<p><strong>prctl 系统调用</strong></p>
<p><code>prctl</code>（Process Control Language，进程控制语言）是一个 Linux 系统调用的一个重要工具，它可以对进程进行各种管理和控制操作</p>
<p><code>prctl</code> 提供了对进程的许多控制和设置，使用第一个参数来指定其功能：</p>
<ul>
<li>设置进程的权限级别</li>
<li>设置进程的调度参数</li>
<li>设置进程的内存限制</li>
<li>设置进程的 CPU 时间限制</li>
<li>设置进程的信号处理</li>
<li>设置进程的资源限制</li>
<li>设置进程的属性</li>
<li>获取进程的属性</li>
</ul>
<p>沙盒需要的 <code>prctl</code> 功能如下：</p>
<ul>
<li><code>prctl(PR_SET_NO_NEW_PRIVS)</code>：命名空间内以 <code>CAP_SYS_ADMIN</code> 权限运行（子进程会保证不会赋予运行进程新的权限）</li>
<li><code>prctl(PR_SET_SECCOMP)</code>：第二个参数是设置的过滤模式，第三个参数是设置的过滤规则</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(prctl, <span class="keyword">int</span>, option, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg3,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span>, arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span>, arg5)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">me</span> =</span> current;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> comm[<span class="keyword">sizeof</span>(me-&gt;comm)];</span><br><span class="line">	<span class="keyword">long</span> error;</span><br><span class="line"></span><br><span class="line">	error = security_task_prctl(option, arg2, arg3, arg4, arg5);</span><br><span class="line">	<span class="keyword">if</span> (error != -ENOSYS)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	error = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span> (option) &#123;</span><br><span class="line">            ......</span><br><span class="line">                </span><br><span class="line">	<span class="keyword">case</span> PR_SET_SECCOMP: </span><br><span class="line">		error = prctl_set_seccomp(arg2, (<span class="keyword">char</span> __user *)arg3);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            ......</span><br><span class="line">             </span><br><span class="line">	<span class="keyword">case</span> PR_SET_NO_NEW_PRIVS: </span><br><span class="line">		<span class="keyword">if</span> (arg2 != <span class="number">1</span> || arg3 || arg4 || arg5)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		task_set_no_new_privs(current);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            ......</span><br><span class="line">                </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		error = -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心函数 <code>prctl_set_seccomp</code> 的调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">prctl_set_seccomp</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> seccomp_mode, <span class="keyword">void</span> __user *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> op;</span><br><span class="line">	<span class="keyword">void</span> __user *uargs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (seccomp_mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_MODE_STRICT: <span class="comment">/* 严格模式(所有的syscall都被检查和过滤) */</span></span><br><span class="line">		op = SECCOMP_SET_MODE_STRICT;</span><br><span class="line">		uargs = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_MODE_FILTER: <span class="comment">/* 过滤模式(所有的syscall都被允许,但是某些syscall可能会被过滤器拒绝) */</span></span><br><span class="line">		op = SECCOMP_SET_MODE_FILTER;</span><br><span class="line">		uargs = filter;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> do_seccomp(op, <span class="number">0</span>, uargs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">do_seccomp</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> op, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">void</span> __user *uargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_SET_MODE_STRICT: <span class="comment">/* 严格模式 */</span></span><br><span class="line">		<span class="keyword">if</span> (flags != <span class="number">0</span> || uargs != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">return</span> seccomp_set_mode_strict();</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_SET_MODE_FILTER: <span class="comment">/* 过滤模式 */</span></span><br><span class="line">		<span class="keyword">return</span> seccomp_set_mode_filter(flags, uargs);</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_GET_ACTION_AVAIL: <span class="comment">/* 用于查询特定的action是否被内核支持 */</span></span><br><span class="line">		<span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> seccomp_get_action_avail(uargs);</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_GET_NOTIF_SIZES: <span class="comment">/* 获取指定进程的安全上下文通知大小 */</span></span><br><span class="line">		<span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> seccomp_get_notif_sizes(uargs);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们重点分析过滤模式的 <code>seccomp_set_mode_filter</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">seccomp_set_mode_filter</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">				    <span class="keyword">const</span> <span class="keyword">char</span> __user *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> seccomp_mode = SECCOMP_MODE_FILTER;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">prepared</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">long</span> ret = -EINVAL;</span><br><span class="line">	<span class="keyword">int</span> listener = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">listener_f</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	prepared = seccomp_prepare_user_filter(filter); <span class="comment">/* 在持有锁之前准备新过滤器 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(prepared))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(prepared);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_NEW_LISTENER) &#123;</span><br><span class="line">		listener = get_unused_fd_flags(O_CLOEXEC);</span><br><span class="line">		<span class="keyword">if</span> (listener &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = listener;</span><br><span class="line">			<span class="keyword">goto</span> out_free;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		listener_f = init_listener(prepared); <span class="comment">/* 初始化一个监听器,用于接收来自内核的通知和事件 */</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(listener_f)) &#123;</span><br><span class="line">			put_unused_fd(listener);</span><br><span class="line">			ret = PTR_ERR(listener_f);</span><br><span class="line">			<span class="keyword">goto</span> out_free;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_TSYNC &amp;&amp;</span><br><span class="line">	    mutex_lock_killable(&amp;current-&gt;signal-&gt;cred_guard_mutex))</span><br><span class="line">		<span class="keyword">goto</span> out_put_fd;</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!seccomp_may_assign_mode(seccomp_mode))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (has_duplicate_listener(prepared)) &#123; <span class="comment">/* 检查一个进程是否已经有一个监听器 */</span></span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = seccomp_attach_filter(flags, prepared); <span class="comment">/* 将一个过滤器附加到受限制的安全上下文中 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">/* Do not free the successfully attached filter. */</span></span><br><span class="line">	prepared = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	seccomp_assign_mode(current, seccomp_mode, flags); <span class="comment">/* 将一个受限制的安全上下文分配给一个进程(current当前进程) */</span></span><br><span class="line">out:</span><br><span class="line">	spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_TSYNC)</span><br><span class="line">		mutex_unlock(&amp;current-&gt;signal-&gt;cred_guard_mutex);</span><br><span class="line">out_put_fd:</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_NEW_LISTENER) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			listener_f-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">			fput(listener_f); <span class="comment">/* 释放对文件的最后一个引用 */</span></span><br><span class="line">			put_unused_fd(listener); <span class="comment">/* 说明目标文件描述符已经不再使用 */</span></span><br><span class="line">			seccomp_notify_detach(prepared);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fd_install(listener, listener_f);</span><br><span class="line">			ret = listener;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">out_free:</span><br><span class="line">	seccomp_filter_free(prepared);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其最核心的工作就是在 <code>current-&gt;seccomp.filter</code> 中注册过滤器：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filter-&gt;prev = current-&gt;seccomp.filter;</span><br><span class="line">current-&gt;seccomp.filter = filter;</span><br><span class="line">atomic_inc(&amp;current-&gt;seccomp.filter_count);</span><br></pre></td></tr></table></figure>
<p>如果使用了 FILTER 模式，则调用 <code>seccomp_run_filters</code> 函数来进行所有指令判断过滤，系统调用号作为参数传递，根据返回值来进行后续处理</p>
<p>这里我们分析一下从 syscall 入口函数 <code>entry_SYSCALL_compat</code> 到 <code>seccomp_run_filters</code> 的调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START(entry_SYSCALL_compat)</span><br><span class="line">	UNWIND_HINT_EMPTY</span><br><span class="line">	/* Interrupts are off on entry. */</span><br><span class="line">	swapgs</span><br><span class="line"></span><br><span class="line">	/* Stash user ESP */</span><br><span class="line">	movl	%esp, %r8d</span><br><span class="line"></span><br><span class="line">	/* Use %rsp as scratch reg. User ESP is stashed in r8 */</span><br><span class="line">	SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</span><br><span class="line">	......</span><br><span class="line">	movq	%rsp, %rdi</span><br><span class="line">	call	do_fast_syscall_32</span><br><span class="line">	......</span><br><span class="line">	SWITCH_TO_USER_CR3_NOSTACK scratch_reg=%r8 scratch_reg2=%r9</span><br><span class="line"></span><br><span class="line">	xorl	%r8d, %r8d</span><br><span class="line">	xorl	%r9d, %r9d</span><br><span class="line">	xorl	%r10d, %r10d</span><br><span class="line">	swapgs</span><br><span class="line">	sysretl</span><br><span class="line">SYM_CODE_END(entry_SYSCALL_compat)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> noinstr <span class="keyword">bool</span> __do_fast_syscall_32(struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> nr = syscall_32_enter(regs);</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The case truncates any ptrace induced syscall nr &gt; 2^32 -1 */</span></span><br><span class="line">	nr = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)syscall_enter_from_user_mode_work(regs, nr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now this is just like a normal syscall. */</span></span><br><span class="line">	do_syscall_32_irqs_on(regs, nr);</span><br><span class="line">	syscall_exit_to_user_mode(regs);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">syscall_enter_from_user_mode_work</span><span class="params">(struct pt_regs *regs, <span class="keyword">long</span> syscall)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __syscall_enter_from_user_work(regs, syscall);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">long</span></span><br><span class="line">__syscall_enter_from_user_work(struct pt_regs *regs, <span class="keyword">long</span> syscall)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ti_work;</span><br><span class="line"></span><br><span class="line">	ti_work = READ_ONCE(current_thread_info()-&gt;flags);</span><br><span class="line">	<span class="keyword">if</span> (ti_work &amp; SYSCALL_ENTER_WORK)</span><br><span class="line">		syscall = syscall_trace_enter(regs, syscall, ti_work);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> syscall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">syscall_trace_enter</span><span class="params">(struct pt_regs *regs, <span class="keyword">long</span> syscall,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">unsigned</span> <span class="keyword">long</span> ti_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (ti_work &amp; _TIF_SECCOMP) &#123;</span><br><span class="line">		ret = __secure_computing(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">-1L</span>)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret ? : syscall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __secure_computing(<span class="keyword">const</span> struct seccomp_data *sd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> mode = current-&gt;seccomp.mode;</span><br><span class="line">	<span class="keyword">int</span> this_syscall;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) &amp;&amp;</span><br><span class="line">	    unlikely(current-&gt;ptrace &amp; PT_SUSPEND_SECCOMP))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	this_syscall =</span><br><span class="line">		sd ? sd-&gt;nr : syscall_get_nr(current, task_pt_regs(current));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_MODE_STRICT:</span><br><span class="line">		__secure_computing_strict(this_syscall); <span class="comment">/* may call do_exit */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_MODE_FILTER:</span><br><span class="line">		<span class="keyword">return</span> __seccomp_filter(this_syscall, sd, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		BUG();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __seccomp_filter(<span class="keyword">int</span> this_syscall, <span class="keyword">const</span> struct seccomp_data *sd,</span><br><span class="line">			    <span class="keyword">const</span> <span class="keyword">bool</span> recheck_after_trace)</span><br><span class="line">&#123;</span><br><span class="line">	u32 filter_ret, action;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">match</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> <span class="title">sd_local</span>;</span></span><br><span class="line"></span><br><span class="line">	rmb();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sd) &#123;</span><br><span class="line">		populate_seccomp_data(&amp;sd_local);</span><br><span class="line">		sd = &amp;sd_local;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filter_ret = seccomp_run_filters(sd, &amp;match);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">skip:</span><br><span class="line">	seccomp_log(this_syscall, <span class="number">0</span>, action, match ? match-&gt;<span class="built_in">log</span> : <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指令过滤函数 <code>seccomp_run_filters</code> 的源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">seccomp_run_filters</span><span class="params">(<span class="keyword">const</span> struct seccomp_data *sd,</span></span></span><br><span class="line"><span class="params"><span class="function">			       struct seccomp_filter **match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 ret = SECCOMP_RET_ALLOW;</span><br><span class="line">	<span class="comment">/* Make sure cross-thread synced filter points somewhere sane. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">f</span> =</span> READ_ONCE(current-&gt;seccomp.filter);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Ensure unexpected behavior doesn&#x27;t result in failing open. */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(f == <span class="literal">NULL</span>))</span><br><span class="line">		<span class="keyword">return</span> SECCOMP_RET_KILL_PROCESS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All filters in the list are evaluated and the lowest BPF return</span></span><br><span class="line"><span class="comment">	 * value always takes priority (ignoring the DATA).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (; f; f = f-&gt;prev) &#123;</span><br><span class="line">		u32 cur_ret = bpf_prog_run_pin_on_cpu(f-&gt;prog, sd); <span class="comment">/* 用于运行BPF程序的函数 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ACTION_ONLY(cur_ret) &lt; ACTION_ONLY(ret)) &#123;</span><br><span class="line">			ret = cur_ret;</span><br><span class="line">			*match = f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bpf_prog_run_pin_on_cpu</code> 是一个用于运行 BPF 程序的函数，该函数将 BPF 程序加载到指定 CPU 的内存中，并将其附加到指定 CPU 的运行队列中 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u32 <span class="title">bpf_prog_run_pin_on_cpu</span><span class="params">(<span class="keyword">const</span> struct bpf_prog *prog,</span></span></span><br><span class="line"><span class="params"><span class="function">					  <span class="keyword">const</span> <span class="keyword">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 ret;</span><br><span class="line"></span><br><span class="line">	migrate_disable(); <span class="comment">/* 禁用内核进程迁移 */</span></span><br><span class="line">	ret = __BPF_PROG_RUN(prog, ctx, bpf_dispatcher_nop_func); <span class="comment">/* 运行BPF程序 */</span></span><br><span class="line">	migrate_enable(); <span class="comment">/* 启用内核进程迁移 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>eBPF 虚拟机</strong></p>
<p>Linux 下 eBPF 的整体架构如下图所示：</p>
<img src="/2023/11/21/Principles%EF%BC%9A%E6%B2%99%E7%9B%92%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1700624107072.png" class width="1700624107072">  
<ul>
<li>传入：用户进程首先在用户空间编写相应的 BPF 字节码程序，传入内核</li>
<li>检查：内核通过 <code>verifier</code> 对字节码程序进行安全性检查</li>
<li>编译 or 解释：通过检查后便通过 JIT 编译运行，或者直接解释运行 BPF 字节码</li>
<li>映射：用以保存数据的通用结构，可以在不同的 eBPF 程序之间或是用户进程与内核间共享数据（不同的 eBPF 程序之间可以共享同一个映射）</li>
</ul>
<p>eBPF 底层是一个使用 RISC 指令集的虚拟机，使用11个64位寄存器和一个固定大小为512字节的栈：</p>
<ul>
<li>其中9个寄存器是通用寄存器</li>
<li>一个只读栈帧寄存器</li>
</ul>
<p>寄存器总是64位大小，在32位机器上会默认把前32位置零，这也为 eBPF 提供了交叉编译的兼容性，各个寄存器的功能如下：</p>
<ul>
<li>R0: RAX，存放函数返回值或程序退出状态码</li>
<li>R1: RDI，第一个实参</li>
<li>R2: RSI，第二个实参</li>
<li>R3: RDX，第三个实参</li>
<li>R4: RCX，第四个实参</li>
<li>R5: R8，第五个实参</li>
<li>R6: RBX，callee saved</li>
<li>R7: R13，callee saved</li>
<li>R8: R14，callee saved</li>
<li>R9: R15，callee saved</li>
<li>R10: RBP，只读栈帧</li>
</ul>
<p>在 eBPF 中，一个寄存器的状态信息使用 <code>bpf_reg_state</code> 进行表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Ordering of fields matters.  See states_equal() */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_type</span> <span class="title">type</span>;</span> <span class="comment">/* 记录寄存器类型 */</span></span><br><span class="line">	<span class="comment">/* Fixed part of pointer offset, pointer types only */</span></span><br><span class="line">	s32 off;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* valid when type == PTR_TO_PACKET */</span></span><br><span class="line">		<span class="keyword">int</span> range;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* valid when type == CONST_PTR_TO_MAP | PTR_TO_MAP_VALUE |</span></span><br><span class="line"><span class="comment">		 *   PTR_TO_MAP_VALUE_OR_NULL</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* for PTR_TO_BTF_ID */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line">			u32 btf_id;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		u32 mem_size; <span class="comment">/* for PTR_TO_MEM | PTR_TO_MEM_OR_NULL */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Max size from any of the above. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> raw1;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> raw2;</span><br><span class="line">		&#125; raw;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/* For PTR_TO_PACKET, used to find other pointers with the same variable</span></span><br><span class="line"><span class="comment">	 * offset, so they can share range knowledge.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_MAP_VALUE_OR_NULL this is used to share which map value we</span></span><br><span class="line"><span class="comment">	 * came from, when one is tested for != NULL.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_MEM_OR_NULL this is used to identify memory allocation</span></span><br><span class="line"><span class="comment">	 * for the purpose of tracking that it&#x27;s freed.</span></span><br><span class="line"><span class="comment">	 * For PTR_TO_SOCKET this is used to share which pointers retain the</span></span><br><span class="line"><span class="comment">	 * same reference to the socket, to determine proper reference freeing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="comment">/* PTR_TO_SOCKET and PTR_TO_TCP_SOCK could be a ptr returned</span></span><br><span class="line"><span class="comment">	 * from a pointer-cast helper, bpf_sk_fullsock() and</span></span><br><span class="line"><span class="comment">	 * bpf_tcp_sock().</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Consider the following where &quot;sk&quot; is a reference counted</span></span><br><span class="line"><span class="comment">	 * pointer returned from &quot;sk = bpf_sk_lookup_tcp();&quot;:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1: sk = bpf_sk_lookup_tcp();</span></span><br><span class="line"><span class="comment">	 * 2: if (!sk) &#123; return 0; &#125;</span></span><br><span class="line"><span class="comment">	 * 3: fullsock = bpf_sk_fullsock(sk);</span></span><br><span class="line"><span class="comment">	 * 4: if (!fullsock) &#123; bpf_sk_release(sk); return 0; &#125;</span></span><br><span class="line"><span class="comment">	 * 5: tp = bpf_tcp_sock(fullsock);</span></span><br><span class="line"><span class="comment">	 * 6: if (!tp) &#123; bpf_sk_release(sk); return 0; &#125;</span></span><br><span class="line"><span class="comment">	 * 7: bpf_sk_release(sk);</span></span><br><span class="line"><span class="comment">	 * 8: snd_cwnd = tp-&gt;snd_cwnd;  // verifier will complain</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After bpf_sk_release(sk) at line 7, both &quot;fullsock&quot; ptr and</span></span><br><span class="line"><span class="comment">	 * &quot;tp&quot; ptr should be invalidated also.  In order to do that,</span></span><br><span class="line"><span class="comment">	 * the reg holding &quot;fullsock&quot; and &quot;sk&quot; need to remember</span></span><br><span class="line"><span class="comment">	 * the original refcounted ptr id (i.e. sk_reg-&gt;id) in ref_obj_id</span></span><br><span class="line"><span class="comment">	 * such that the verifier can reset all regs which have</span></span><br><span class="line"><span class="comment">	 * ref_obj_id matching the sk_reg-&gt;id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * sk_reg-&gt;ref_obj_id is set to sk_reg-&gt;id at line 1.</span></span><br><span class="line"><span class="comment">	 * sk_reg-&gt;id will stay as NULL-marking purpose only.</span></span><br><span class="line"><span class="comment">	 * After NULL-marking is done, sk_reg-&gt;id can be reset to 0.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After &quot;fullsock = bpf_sk_fullsock(sk);&quot; at line 3,</span></span><br><span class="line"><span class="comment">	 * fullsock_reg-&gt;ref_obj_id is set to sk_reg-&gt;ref_obj_id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * After &quot;tp = bpf_tcp_sock(fullsock);&quot; at line 5,</span></span><br><span class="line"><span class="comment">	 * tp_reg-&gt;ref_obj_id is set to fullsock_reg-&gt;ref_obj_id</span></span><br><span class="line"><span class="comment">	 * which is the same as sk_reg-&gt;ref_obj_id.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * From the verifier perspective, if sk, fullsock and tp</span></span><br><span class="line"><span class="comment">	 * are not NULL, they are the same ptr with different</span></span><br><span class="line"><span class="comment">	 * reg-&gt;type.  In particular, bpf_sk_release(tp) is also</span></span><br><span class="line"><span class="comment">	 * allowed and has the same effect as bpf_sk_release(sk).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 ref_obj_id;</span><br><span class="line">	<span class="comment">/* For scalar types (SCALAR_VALUE), this represents our knowledge of</span></span><br><span class="line"><span class="comment">	 * the actual value.</span></span><br><span class="line"><span class="comment">	 * For pointer types, this represents the variable part of the offset</span></span><br><span class="line"><span class="comment">	 * from the pointed-to object, and is shared with all bpf_reg_states</span></span><br><span class="line"><span class="comment">	 * with the same id as us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var_off</span>;</span></span><br><span class="line">	<span class="comment">/* Used to determine if any memory access using this register will</span></span><br><span class="line"><span class="comment">	 * result in a bad access.</span></span><br><span class="line"><span class="comment">	 * These refer to the same value as var_off, not necessarily the actual</span></span><br><span class="line"><span class="comment">	 * contents of the register.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s64 smin_value; <span class="comment">/* minimum possible (s64)value */</span></span><br><span class="line">	s64 smax_value; <span class="comment">/* maximum possible (s64)value */</span></span><br><span class="line">	u64 umin_value; <span class="comment">/* minimum possible (u64)value */</span></span><br><span class="line">	u64 umax_value; <span class="comment">/* maximum possible (u64)value */</span></span><br><span class="line">	s32 s32_min_value; <span class="comment">/* minimum possible (s32)value */</span></span><br><span class="line">	s32 s32_max_value; <span class="comment">/* maximum possible (s32)value */</span></span><br><span class="line">	u32 u32_min_value; <span class="comment">/* minimum possible (u32)value */</span></span><br><span class="line">	u32 u32_max_value; <span class="comment">/* maximum possible (u32)value */</span></span><br><span class="line">	<span class="comment">/* parentage chain for liveness checking */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_reg_state</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="comment">/* Inside the callee two registers can be both PTR_TO_STACK like</span></span><br><span class="line"><span class="comment">	 * R1=fp-8 and R2=fp-8, but one of them points to this function stack</span></span><br><span class="line"><span class="comment">	 * while another to the caller&#x27;s stack. To differentiate them &#x27;frameno&#x27;</span></span><br><span class="line"><span class="comment">	 * is used which is an index in bpf_verifier_state-&gt;frame[] array</span></span><br><span class="line"><span class="comment">	 * pointing to bpf_func_state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 frameno;</span><br><span class="line">	<span class="comment">/* Tracks subreg definition. The stored value is the insn_idx of the</span></span><br><span class="line"><span class="comment">	 * writing insn. This is safe because subreg_def is used before any insn</span></span><br><span class="line"><span class="comment">	 * patching which only happens after main verification finished.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	s32 subreg_def;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_reg_liveness</span> <span class="title">live</span>;</span></span><br><span class="line">	<span class="comment">/* if (!precise &amp;&amp; SCALAR_VALUE) min/max/tnum don&#x27;t affect safety */</span></span><br><span class="line">	<span class="keyword">bool</span> precise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当 eBPF 字节码载入到内核中后，verifier 会对 eBPF 字节码进行一系列的检查，主要关注以下几个字段：</p>
<ul>
<li><code>smin_value</code>、<code>smax_value</code>：64 位有符号的值的可能取值边界</li>
<li><code>umin_value</code>、<code>umax_value</code>：64 位无符号的值的可能取值边界</li>
<li><code>s32_min_value</code>、<code>s32_max_value</code>：32 位有符号的值的可能取值边界</li>
<li><code>u32_min_value</code>、<code>u32_max_value</code>：32 位无符号的值的可能取值边界</li>
</ul>
<p>核心检查函数就是 <code>bpf_check</code>，一个静态代码分析器：</p>
<ul>
<li>逐条遍历 eBPF 程序中的指令并更新寄存器 / 堆栈的状态，条件分支的所有路径都会被分析，直到 <code>bpf_exit</code> 指令</li>
<li>这其实是一个模拟执行的过程，verifier 会推测寄存器的边界值，检查其是否符合规则</li>
<li>模拟通过后才能正常加载 eBPF 程序</li>
</ul>
<p>在其中用于检测指令合法性的函数为 <code>do_check</code>，该函数会遍历每一条指令并根据指令的不同类型进行不同操作，对于算术指令（<code>BPF_ALU</code> / <code>BPF_ALU64</code>）而言有如下调用链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_check()        					<span class="comment">// 遍历每一条指令并根据类型调用相应函数处理</span></span><br><span class="line">-&gt;check_alu_op()       				 <span class="comment">// 根据算术指令的opcode进行不同处理</span></span><br><span class="line">-&gt;adjust_reg_min_max_vals()        	<span class="comment">// 计算新的寄存器边界值</span></span><br><span class="line">-&gt;adjust_scalar_min_max_vals()		<span class="comment">// 根据opcode计算具体的新边界值</span></span><br></pre></td></tr></table></figure>
<p>当 eBPF 字节码载入到内核中后，内核最终会使用一个 <code>bpf_prog</code> 结构体来表示一个 eBPF 程序： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> &#123;</span></span><br><span class="line">	u16			pages;		<span class="comment">/* Number of allocated pages */</span></span><br><span class="line">	u16			jited:<span class="number">1</span>,	<span class="comment">/* Is our filter JIT&#x27;ed? */</span></span><br><span class="line">				jit_requested:<span class="number">1</span>,<span class="comment">/* archs need to JIT the prog */</span></span><br><span class="line">				gpl_compatible:<span class="number">1</span>, <span class="comment">/* Is filter GPL compatible? */</span></span><br><span class="line">				cb_access:<span class="number">1</span>,	<span class="comment">/* Is control block accessed? */</span></span><br><span class="line">				dst_needed:<span class="number">1</span>,	<span class="comment">/* Do we need dst entry? */</span></span><br><span class="line">				blinded:<span class="number">1</span>,	<span class="comment">/* Was blinded */</span></span><br><span class="line">				is_func:<span class="number">1</span>,	<span class="comment">/* program is a bpf function */</span></span><br><span class="line">				kprobe_override:<span class="number">1</span>, <span class="comment">/* Do we override a kprobe? */</span></span><br><span class="line">				has_callchain_buf:<span class="number">1</span>, <span class="comment">/* callchain buffer allocated? */</span></span><br><span class="line">				enforce_expected_attach_type:<span class="number">1</span>, <span class="comment">/* Enforce expected_attach_type checking at attach time */</span></span><br><span class="line">				call_get_stack:<span class="number">1</span>; <span class="comment">/* Do we call bpf_get_stack() or bpf_get_stackid() */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span>	<span class="title">type</span>;</span>		<span class="comment">/* Type of BPF program */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_attach_type</span>	<span class="title">expected_attach_type</span>;</span> <span class="comment">/* For some prog types */</span></span><br><span class="line">	u32			len;		<span class="comment">/* Number of filter blocks */</span></span><br><span class="line">	u32			jited_len;	<span class="comment">/* Size of jited insns in bytes */</span></span><br><span class="line">	u8			tag[BPF_TAG_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog_aux</span>	*<span class="title">aux</span>;</span>		<span class="comment">/* Auxiliary fields */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog_kern</span>	*<span class="title">orig_prog</span>;</span>	<span class="comment">/* Original BPF program */</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span>		<span class="params">(*bpf_func)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">					    <span class="keyword">const</span> struct bpf_insn *insn)</span></span>;</span><br><span class="line">	<span class="comment">/* Instructions for interpreter */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span>	<span class="title">insns</span>[0];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span>		<span class="title">insnsi</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接着就是编译，解释 eBPF 字节码，生成 bpf map 并记录在 <code>bpf_reg_state-&gt;map_ptr</code> 中</p>
<p>bpf map 是一个通用的用以储存不同种类数据的结构，用以在用户进程与 eBPF 程序、eBPF 程序与 eBPF 程序之间进行数据共享（这些数据以二进制形式储存，因此用户在创建时只需要指定 key 与 value 的 size）</p>
<p>核心结构体 <code>bpf_map</code> 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first two cachelines with read-mostly members of which some</span></span><br><span class="line"><span class="comment">	 * are also accessed in fast-path (e.g. ops, max_entries).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> <span class="title">map_type</span>;</span> <span class="comment">/* map的数据结构类型 */</span></span><br><span class="line">	u32 key_size; <span class="comment">/* 以字节为单位的用以索引一个元素的key的size(在数组映射中使用) */</span></span><br><span class="line">	u32 value_size; <span class="comment">/* 以字节为单位的每个元素的size */</span></span><br><span class="line">	u32 max_entries; <span class="comment">/* map中entries的最大数量 */</span></span><br><span class="line">	u32 map_flags; <span class="comment">/* 描述map的独特特征(例如是否整个map的内存应被预先分配等) */</span></span><br><span class="line">	<span class="keyword">int</span> spin_lock_off; <span class="comment">/* &gt;=0 valid offset, &lt;0 error */</span></span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="keyword">int</span> numa_node;</span><br><span class="line">	u32 btf_key_type_id;</span><br><span class="line">	u32 btf_value_type_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG_KMEM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">char</span> name[BPF_OBJ_NAME_LEN];</span><br><span class="line">	u32 btf_vmlinux_value_type_id;</span><br><span class="line">	<span class="keyword">bool</span> bypass_spec_v1;</span><br><span class="line">	<span class="keyword">bool</span> frozen; <span class="comment">/* write-once; write-protected by freeze_mutex */</span></span><br><span class="line">	<span class="comment">/* 22 bytes hole */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The 3rd and 4th cacheline with misc members to avoid false sharing</span></span><br><span class="line"><span class="comment">	 * particularly with refcounting.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">atomic64_t</span> refcnt ____cacheline_aligned;</span><br><span class="line">	<span class="keyword">atomic64_t</span> usercnt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">freeze_mutex</span>;</span></span><br><span class="line">	u64 writecnt; <span class="comment">/* writable mmap cnt; protected by freeze_mutex */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bpf map 有多种类型，记录于 <code>bpf_map_type</code> 枚举中： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> &#123;</span></span><br><span class="line">	BPF_MAP_TYPE_UNSPEC,</span><br><span class="line">	BPF_MAP_TYPE_HASH, <span class="comment">/* 以哈希表形式存储键值对(最常见) */</span></span><br><span class="line">	BPF_MAP_TYPE_ARRAY, <span class="comment">/* 以数组形式存储键值对,key即为数组下标,value初始化为&#x27;0&#x27; */</span></span><br><span class="line">	BPF_MAP_TYPE_PROG_ARRAY, <span class="comment">/* 特殊的数组映射,value为其他eBPF程序的文件描述符 */</span></span><br><span class="line">	BPF_MAP_TYPE_PERF_EVENT_ARRAY,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_HASH,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_ARRAY,</span><br><span class="line">	BPF_MAP_TYPE_STACK_TRACE,</span><br><span class="line">	BPF_MAP_TYPE_CGROUP_ARRAY,</span><br><span class="line">	BPF_MAP_TYPE_LRU_HASH,</span><br><span class="line">	BPF_MAP_TYPE_LRU_PERCPU_HASH,</span><br><span class="line">	BPF_MAP_TYPE_LPM_TRIE,</span><br><span class="line">	BPF_MAP_TYPE_ARRAY_OF_MAPS,</span><br><span class="line">	BPF_MAP_TYPE_HASH_OF_MAPS,</span><br><span class="line">	BPF_MAP_TYPE_DEVMAP,</span><br><span class="line">	BPF_MAP_TYPE_SOCKMAP,</span><br><span class="line">	BPF_MAP_TYPE_CPUMAP,</span><br><span class="line">	BPF_MAP_TYPE_XSKMAP,</span><br><span class="line">	BPF_MAP_TYPE_SOCKHASH,</span><br><span class="line">	BPF_MAP_TYPE_CGROUP_STORAGE,</span><br><span class="line">	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY,</span><br><span class="line">	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE,</span><br><span class="line">	BPF_MAP_TYPE_QUEUE,</span><br><span class="line">	BPF_MAP_TYPE_STACK, <span class="comment">/* 以栈形式存储数据 */</span></span><br><span class="line">	BPF_MAP_TYPE_SK_STORAGE,</span><br><span class="line">	BPF_MAP_TYPE_DEVMAP_HASH,</span><br><span class="line">	BPF_MAP_TYPE_STRUCT_OPS,</span><br><span class="line">	BPF_MAP_TYPE_RINGBUF,</span><br><span class="line">	BPF_MAP_TYPE_INODE_STORAGE,</span><br><span class="line">	BPF_MAP_TYPE_TASK_STORAGE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Seccomp BPF</strong></p>
<p>柏克莱封包过滤器（Berkeley Packet Filter，缩写 BPF），是类 Unix 系统上数据链路层的一种原始接口，提供原始链路层封包的收发，除此之外，如果网卡驱动支持洪泛模式，那么它可以让网卡处于此种模式，这样可以收到网络上的所有包，不管他们的目的地是不是所在主机 </p>
<p>Seccomp BPF 是一种基于 Linux 内核的 BPF 过滤器，用于对 Linux 进程的系统调用进行过滤和拦截（eBPF 的一部分）</p>
<p>BPF 的指令集比较简单，开发人员定义了符号常量和两个方便的宏 <code>BPF_STMT</code> 和 <code>BPF_JUMP</code> 可以用来方便的编写 BPF 规则 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BPF_STMT(BPF_LD | BPF_W | BPF_ABS,(offsetof(struct seccomp_data, arch)))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BPF_LD</code>：建一个 BPF 加载操作 </li>
<li><code>BPF_W</code>：操作数大小是一个字</li>
<li><code>BPF_ABS</code>：使用绝对偏移，即使用指令中的值作为数据区的偏移量，该值是体系结构字段与数据区域的偏移量 </li>
<li><code>offsetof()</code>：生成数据区域中期望字段的偏移量 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K ,AUDIT_ARCH_X86_64 , <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>BPF_JMP | BPF JEQ</code> 会创建一个相等跳转指令，它将指令中的值（即第二个参数）与累加器中的值（BPF_K）进行比较，判断是否相等<ul>
<li>如果架构是则跳过下一条指令（jt=1，代表测试为真，跳过一条指令）</li>
<li>否则将执行下一条指令（jf=0，代表测试为假，继续执行下一条指令）</li>
</ul>
</li>
</ul>
<p>用户编写的 eBPF 程序最终会被编译成 eBPF 字节码，eBPF 字节码使用 <code>bpf_insn</code> 结构来表示，如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> &#123;</span></span><br><span class="line">	__u8	code;		<span class="comment">/* 操作码 */</span></span><br><span class="line">	__u8	dst_reg:<span class="number">4</span>;	<span class="comment">/* 目标寄存器 */</span></span><br><span class="line">	__u8	src_reg:<span class="number">4</span>;	<span class="comment">/* 源寄存器 */</span></span><br><span class="line">	__s16	off;		<span class="comment">/* 偏移量 */</span></span><br><span class="line">	__s32	imm;		<span class="comment">/* 立即操作数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>eBPF 程序会被 LLVM/Clang 编译成 <code>bpf_insn</code> 结构数组，这里使用了 JIT 即时编译技术（PS：当 eBPF 字节码被加载到内核时，内核会根据是否开启了 JIT 功能选项，来决定是否将 eBPF 字节码编译成机器码）</p>
<p>内核通过 <code>bpf_prog_load</code> 函数来加载 eBPF 字节码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr, <span class="keyword">union</span> bpf_attr __user *uattr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> <span class="title">type</span> =</span> attr-&gt;prog_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span> <span class="comment">/* 保存eBPF程序的信息 */</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">char</span> license[<span class="number">128</span>];</span><br><span class="line">	<span class="keyword">bool</span> is_gpl;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* plain bpf_prog allocation */</span></span><br><span class="line">	prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER); <span class="comment">/* 初始化bpf_prog结构体  */</span></span><br><span class="line">	<span class="keyword">if</span> (!prog)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* run eBPF verifier */</span></span><br><span class="line">	err = bpf_check(&amp;prog, attr, uattr);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	prog = bpf_prog_select_runtime(prog, &amp;err); <span class="comment">/* 判断并使用jit进行编译 */</span></span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line"></span><br><span class="line">	err = bpf_prog_alloc_id(prog);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> free_used_maps;</span><br><span class="line">    </span><br><span class="line">	bpf_prog_kallsyms_add(prog);</span><br><span class="line">	perf_event_bpf_event(prog, PERF_BPF_EVENT_PROG_LOAD, <span class="number">0</span>);</span><br><span class="line">	bpf_audit_prog(prog, BPF_AUDIT_LOAD);</span><br><span class="line"></span><br><span class="line">	err = bpf_prog_new_fd(prog);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		bpf_prog_put(prog);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">free_used_maps:</span><br><span class="line">	<span class="comment">/* In case we have subprogs, we need to wait for a grace</span></span><br><span class="line"><span class="comment">	 * period before we can tear down JIT memory since symbols</span></span><br><span class="line"><span class="comment">	 * are already exposed under kallsyms.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__bpf_prog_put_noref(prog, prog-&gt;aux-&gt;func_cnt);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">free_prog:</span><br><span class="line">	bpf_prog_uncharge_memlock(prog);</span><br><span class="line">free_prog_sec:</span><br><span class="line">	security_bpf_prog_free(prog-&gt;aux);</span><br><span class="line">free_prog_nouncharge:</span><br><span class="line">	bpf_prog_free(prog);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>bpf_prog_load</code> 会调用 <code>bpf_prog_select_runtime</code> 函数来判断是否使用 JIT</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_prog *<span class="title">bpf_prog_select_runtime</span><span class="params">(struct bpf_prog *fp, <span class="keyword">int</span> *err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fp-&gt;bpf_func)</span><br><span class="line">		<span class="keyword">goto</span> finalize;</span><br><span class="line"></span><br><span class="line">	bpf_prog_select_func(fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!bpf_prog_is_dev_bound(fp-&gt;aux)) &#123;</span><br><span class="line">		*err = bpf_prog_alloc_jited_linfo(fp);</span><br><span class="line">		<span class="keyword">if</span> (*err)</span><br><span class="line">			<span class="keyword">return</span> fp;</span><br><span class="line"></span><br><span class="line">		fp = bpf_int_jit_compile(fp); <span class="comment">/* 判断是否需要将eBPF字节码编译成机器码 */</span></span><br><span class="line">		<span class="keyword">if</span> (!fp-&gt;jited) &#123;</span><br><span class="line">			bpf_prog_free_jited_linfo(fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BPF_JIT_ALWAYS_ON</span></span><br><span class="line">			*err = -ENOTSUPP;</span><br><span class="line">			<span class="keyword">return</span> fp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			bpf_prog_free_unused_jited_linfo(fp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*err = bpf_prog_offload_compile(fp);</span><br><span class="line">		<span class="keyword">if</span> (*err)</span><br><span class="line">			<span class="keyword">return</span> fp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">finalize:</span><br><span class="line">	bpf_prog_lock_ro(fp);</span><br><span class="line"></span><br><span class="line">	*err = bpf_check_tail_call(fp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(bpf_prog_select_runtime);</span><br></pre></td></tr></table></figure>
<ul>
<li>对于不同的架构，函数 <code>bpf_int_jit_compile</code> 有不同的实现</li>
<li>这里我们只分析 x86_64 架构下的 <code>bpf_int_jit_compile</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bpf_prog *<span class="title">bpf_int_jit_compile</span><span class="params">(struct bpf_prog *prog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_binary_header</span> *<span class="title">header</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">tmp</span>, *<span class="title">orig_prog</span> =</span> prog;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">x64_jit_data</span> *<span class="title">jit_data</span>;</span></span><br><span class="line">	<span class="keyword">int</span> proglen, oldproglen = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">jit_context</span> <span class="title">ctx</span> =</span> &#123;&#125;;</span><br><span class="line">	<span class="keyword">bool</span> tmp_blinded = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">bool</span> extra_pass = <span class="literal">false</span>;</span><br><span class="line">	u8 *image = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> *addrs;</span><br><span class="line">	<span class="keyword">int</span> pass;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!prog-&gt;jit_requested) <span class="comment">/* 判断是否支持jit */</span></span><br><span class="line">		<span class="keyword">return</span> orig_prog;</span><br><span class="line"></span><br><span class="line">	tmp = bpf_jit_blind_constants(prog);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If blinding was requested and we failed during blinding,</span></span><br><span class="line"><span class="comment">	 * we must fall back to the interpreter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tmp))</span><br><span class="line">		<span class="keyword">return</span> orig_prog;</span><br><span class="line">	<span class="keyword">if</span> (tmp != prog) &#123;</span><br><span class="line">		tmp_blinded = <span class="literal">true</span>;</span><br><span class="line">		prog = tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jit_data = prog-&gt;aux-&gt;jit_data;</span><br><span class="line">	<span class="keyword">if</span> (!jit_data) &#123;</span><br><span class="line">		jit_data = kzalloc(<span class="keyword">sizeof</span>(*jit_data), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!jit_data) &#123;</span><br><span class="line">			prog = orig_prog;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		prog-&gt;aux-&gt;jit_data = jit_data;</span><br><span class="line">	&#125;</span><br><span class="line">	addrs = jit_data-&gt;addrs;</span><br><span class="line">	<span class="keyword">if</span> (addrs) &#123;</span><br><span class="line">		ctx = jit_data-&gt;ctx;</span><br><span class="line">		oldproglen = jit_data-&gt;proglen;</span><br><span class="line">		image = jit_data-&gt;image;</span><br><span class="line">		header = jit_data-&gt;header;</span><br><span class="line">		extra_pass = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">goto</span> skip_init_addrs;</span><br><span class="line">	&#125;</span><br><span class="line">	addrs = kmalloc_array(prog-&gt;len + <span class="number">1</span>, <span class="keyword">sizeof</span>(*addrs), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!addrs) &#123;</span><br><span class="line">		prog = orig_prog;</span><br><span class="line">		<span class="keyword">goto</span> out_addrs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Before first pass, make a rough estimation of addrs[]</span></span><br><span class="line"><span class="comment">	 * each BPF instruction is translated to less than 64 bytes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (proglen = <span class="number">0</span>, i = <span class="number">0</span>; i &lt;= prog-&gt;len; i++) &#123;</span><br><span class="line">		proglen += <span class="number">64</span>;</span><br><span class="line">		addrs[i] = proglen;</span><br><span class="line">	&#125;</span><br><span class="line">	ctx.cleanup_addr = proglen;</span><br><span class="line">skip_init_addrs:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * JITed image shrinks with every pass and the loop iterates</span></span><br><span class="line"><span class="comment">	 * until the image stops shrinking. Very large BPF programs</span></span><br><span class="line"><span class="comment">	 * may converge on the last pass. In such case do one more</span></span><br><span class="line"><span class="comment">	 * pass to emit the final image.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (pass = <span class="number">0</span>; pass &lt; <span class="number">20</span> || image; pass++) &#123;</span><br><span class="line">		proglen = do_jit(prog, addrs, image, oldproglen, &amp;ctx); <span class="comment">/* 将eBPF字节码编译成本地机器码 */</span></span><br><span class="line">		<span class="keyword">if</span> (proglen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">out_image:</span><br><span class="line">			image = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> (header)</span><br><span class="line">				bpf_jit_binary_free(header);</span><br><span class="line">			prog = orig_prog;</span><br><span class="line">			<span class="keyword">goto</span> out_addrs;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (image) &#123;</span><br><span class="line">			<span class="keyword">if</span> (proglen != oldproglen) &#123;</span><br><span class="line">				pr_err(<span class="string">&quot;bpf_jit: proglen=%d != oldproglen=%d\n&quot;</span>,</span><br><span class="line">				       proglen, oldproglen);</span><br><span class="line">				<span class="keyword">goto</span> out_image;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (proglen == oldproglen) &#123;</span><br><span class="line">			u32 align = __alignof__(struct exception_table_entry);</span><br><span class="line">			u32 extable_size = prog-&gt;aux-&gt;num_exentries *</span><br><span class="line">				<span class="keyword">sizeof</span>(struct exception_table_entry);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* allocate module memory for x86 insns and extable */</span></span><br><span class="line">			header = bpf_jit_binary_alloc(roundup(proglen, align) + extable_size,</span><br><span class="line">						      &amp;image, align, jit_fill_hole);</span><br><span class="line">			<span class="keyword">if</span> (!header) &#123;</span><br><span class="line">				prog = orig_prog;</span><br><span class="line">				<span class="keyword">goto</span> out_addrs;</span><br><span class="line">			&#125;</span><br><span class="line">			prog-&gt;aux-&gt;extable = (<span class="keyword">void</span> *) image + roundup(proglen, align);</span><br><span class="line">		&#125;</span><br><span class="line">		oldproglen = proglen;</span><br><span class="line">		cond_resched();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bpf_jit_enable &gt; <span class="number">1</span>)</span><br><span class="line">		bpf_jit_dump(prog-&gt;len, proglen, pass + <span class="number">1</span>, image); <span class="comment">/* 打印eBPF字节码编译后的机器码 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (image) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!prog-&gt;is_func || extra_pass) &#123;</span><br><span class="line">			bpf_tail_call_direct_fixup(prog);</span><br><span class="line">			bpf_jit_binary_lock_ro(header);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			jit_data-&gt;addrs = addrs;</span><br><span class="line">			jit_data-&gt;ctx = ctx;</span><br><span class="line">			jit_data-&gt;proglen = proglen;</span><br><span class="line">			jit_data-&gt;image = image;</span><br><span class="line">			jit_data-&gt;header = header;</span><br><span class="line">		&#125;</span><br><span class="line">		prog-&gt;bpf_func = (<span class="keyword">void</span> *)image; <span class="comment">/* 将eBPF执行函数设置成编译后的机器码 */</span></span><br><span class="line">		prog-&gt;jited = <span class="number">1</span>;</span><br><span class="line">		prog-&gt;jited_len = proglen;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		prog = orig_prog;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!image || !prog-&gt;is_func || extra_pass) &#123;</span><br><span class="line">		<span class="keyword">if</span> (image)</span><br><span class="line">			bpf_prog_fill_jited_linfo(prog, addrs + <span class="number">1</span>);</span><br><span class="line">out_addrs:</span><br><span class="line">		kfree(addrs);</span><br><span class="line">		kfree(jit_data);</span><br><span class="line">		prog-&gt;aux-&gt;jit_data = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (tmp_blinded)</span><br><span class="line">		bpf_jit_prog_release_other(prog, prog == orig_prog ?</span><br><span class="line">					   tmp : orig_prog);</span><br><span class="line">	<span class="keyword">return</span> prog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数 <code>do_jit</code> 将 eBPF 码编译为字节码后，可以直接调用 <code>prog-&gt;bpf_func</code> 来执行字节码</p>
<p>当内核要执行 eBPF 字节码时，会调用原本位于 <code>prog-&gt;bpf_func</code> 的函数 <code>__bpf_prog_run</code>，该函数是 BPF 的核心函数入口，该函数被多个不同 stack size 的函数调用： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> u64 ___bpf_prog_run(u64 *regs, <span class="keyword">const</span> struct bpf_insn *insn, u64 *<span class="built_in">stack</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_INSN_2_LBL(x, y)    [BPF_##x | BPF_##y] = &amp;&amp;x##_##y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_INSN_3_LBL(x, y, z) [BPF_##x | BPF_##y | BPF_##z] = &amp;&amp;x##_##y##_##z</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> jumptable[<span class="number">256</span>] __annotate_jump_table = &#123;</span><br><span class="line">		[<span class="number">0</span> ... <span class="number">255</span>] = &amp;&amp;default_label,</span><br><span class="line">		<span class="comment">/* Now overwrite non-defaults ... */</span></span><br><span class="line">		BPF_INSN_MAP(BPF_INSN_2_LBL, BPF_INSN_3_LBL),</span><br><span class="line">		<span class="comment">/* Non-UAPI available opcodes. */</span></span><br><span class="line">		[BPF_JMP | BPF_CALL_ARGS] = &amp;&amp;JMP_CALL_ARGS,</span><br><span class="line">		[BPF_JMP | BPF_TAIL_CALL] = &amp;&amp;JMP_TAIL_CALL,</span><br><span class="line">		[BPF_LDX | BPF_PROBE_MEM | BPF_B] = &amp;&amp;LDX_PROBE_MEM_B,</span><br><span class="line">		[BPF_LDX | BPF_PROBE_MEM | BPF_H] = &amp;&amp;LDX_PROBE_MEM_H,</span><br><span class="line">		[BPF_LDX | BPF_PROBE_MEM | BPF_W] = &amp;&amp;LDX_PROBE_MEM_W,</span><br><span class="line">		[BPF_LDX | BPF_PROBE_MEM | BPF_DW] = &amp;&amp;LDX_PROBE_MEM_DW,</span><br><span class="line">	&#125;; <span class="comment">/* 维护了一个跳表,根据opcode来进行跳转 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BPF_INSN_3_LBL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> BPF_INSN_2_LBL</span></span><br><span class="line">	u32 tail_call_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONT	 (&#123; insn++; goto select_insn; &#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONT_JMP (&#123; insn++; goto select_insn; &#125;)</span></span><br><span class="line"></span><br><span class="line">select_insn:</span><br><span class="line">	<span class="keyword">goto</span> *jumptable[insn-&gt;code];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ALU */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALU(OPCODE, OP)			\</span></span><br><span class="line"><span class="meta">	ALU64_##OPCODE##_X:		\</span></span><br><span class="line"><span class="meta">		DST = DST OP SRC;	\</span></span><br><span class="line"><span class="meta">		CONT;			\</span></span><br><span class="line"><span class="meta">	ALU_##OPCODE##_X:		\</span></span><br><span class="line"><span class="meta">		DST = (u32) DST OP (u32) SRC;	\</span></span><br><span class="line"><span class="meta">		CONT;			\</span></span><br><span class="line"><span class="meta">	ALU64_##OPCODE##_K:		\</span></span><br><span class="line"><span class="meta">		DST = DST OP IMM;		\</span></span><br><span class="line"><span class="meta">		CONT;			\</span></span><br><span class="line"><span class="meta">	ALU_##OPCODE##_K:		\</span></span><br><span class="line"><span class="meta">		DST = (u32) DST OP (u32) IMM;	\</span></span><br><span class="line"><span class="meta">		CONT;</span></span><br><span class="line"></span><br><span class="line">	ALU(ADD,  +)</span><br><span class="line">	ALU(SUB,  -)</span><br><span class="line">	ALU(AND,  &amp;)</span><br><span class="line">	ALU(OR,   |)</span><br><span class="line">	ALU(LSH, &lt;&lt;)</span><br><span class="line">	ALU(RSH, &gt;&gt;)</span><br><span class="line">	ALU(XOR,  ^)</span><br><span class="line">	ALU(MUL,  *)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ALU</span></span><br><span class="line">	ALU_NEG:</span><br><span class="line">		DST = (u32) -DST;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_NEG:</span><br><span class="line">		DST = -DST;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_MOV_X:</span><br><span class="line">		DST = (u32) SRC;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_MOV_K:</span><br><span class="line">		DST = (u32) IMM;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_MOV_X:</span><br><span class="line">		DST = SRC;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_MOV_K:</span><br><span class="line">		DST = IMM;</span><br><span class="line">		CONT;</span><br><span class="line">	LD_IMM_DW:</span><br><span class="line">		DST = (u64) (u32) insn[<span class="number">0</span>].imm | ((u64) (u32) insn[<span class="number">1</span>].imm) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">		insn++;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_ARSH_X:</span><br><span class="line">		DST = (u64) (u32) (((s32) DST) &gt;&gt; SRC);</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_ARSH_K:</span><br><span class="line">		DST = (u64) (u32) (((s32) DST) &gt;&gt; IMM);</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_ARSH_X:</span><br><span class="line">		(*(s64 *) &amp;DST) &gt;&gt;= SRC;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_ARSH_K:</span><br><span class="line">		(*(s64 *) &amp;DST) &gt;&gt;= IMM;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_MOD_X:</span><br><span class="line">		div64_u64_rem(DST, SRC, &amp;AX);</span><br><span class="line">		DST = AX;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_MOD_X:</span><br><span class="line">		AX = (u32) DST;</span><br><span class="line">		DST = do_div(AX, (u32) SRC);</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_MOD_K:</span><br><span class="line">		div64_u64_rem(DST, IMM, &amp;AX);</span><br><span class="line">		DST = AX;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_MOD_K:</span><br><span class="line">		AX = (u32) DST;</span><br><span class="line">		DST = do_div(AX, (u32) IMM);</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_DIV_X:</span><br><span class="line">		DST = div64_u64(DST, SRC);</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_DIV_X:</span><br><span class="line">		AX = (u32) DST;</span><br><span class="line">		do_div(AX, (u32) SRC);</span><br><span class="line">		DST = (u32) AX;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU64_DIV_K:</span><br><span class="line">		DST = div64_u64(DST, IMM);</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_DIV_K:</span><br><span class="line">		AX = (u32) DST;</span><br><span class="line">		do_div(AX, (u32) IMM);</span><br><span class="line">		DST = (u32) AX;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_END_TO_BE:</span><br><span class="line">		<span class="keyword">switch</span> (IMM) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">			DST = (__force u16) cpu_to_be16(DST);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">			DST = (__force u32) cpu_to_be32(DST);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">			DST = (__force u64) cpu_to_be64(DST);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line">	ALU_END_TO_LE:</span><br><span class="line">		<span class="keyword">switch</span> (IMM) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">			DST = (__force u16) cpu_to_le16(DST);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">			DST = (__force u32) cpu_to_le32(DST);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">64</span>:</span><br><span class="line">			DST = (__force u64) cpu_to_le64(DST);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		CONT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CALL */</span></span><br><span class="line">	JMP_CALL:</span><br><span class="line">		<span class="comment">/* Function call scratches BPF_R1-BPF_R5 registers,</span></span><br><span class="line"><span class="comment">		 * preserves BPF_R6-BPF_R9, and stores return value</span></span><br><span class="line"><span class="comment">		 * into BPF_R0.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		BPF_R0 = (__bpf_call_base + insn-&gt;imm)(BPF_R1, BPF_R2, BPF_R3,</span><br><span class="line">						       BPF_R4, BPF_R5);</span><br><span class="line">		CONT;</span><br><span class="line"></span><br><span class="line">	JMP_CALL_ARGS:</span><br><span class="line">		BPF_R0 = (__bpf_call_base_args + insn-&gt;imm)(BPF_R1, BPF_R2,</span><br><span class="line">							    BPF_R3, BPF_R4,</span><br><span class="line">							    BPF_R5,</span><br><span class="line">							    insn + insn-&gt;off + <span class="number">1</span>);</span><br><span class="line">		CONT;</span><br><span class="line"></span><br><span class="line">	JMP_TAIL_CALL: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">map</span> =</span> (struct bpf_map *) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) BPF_R2;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> *<span class="title">array</span> =</span> container_of(<span class="built_in">map</span>, struct bpf_array, <span class="built_in">map</span>);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">		u32 index = BPF_R3;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(index &gt;= <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(tail_call_cnt &gt; MAX_TAIL_CALL_CNT))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		tail_call_cnt++;</span><br><span class="line"></span><br><span class="line">		prog = READ_ONCE(<span class="built_in">array</span>-&gt;ptrs[index]);</span><br><span class="line">		<span class="keyword">if</span> (!prog)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* ARG1 at this point is guaranteed to point to CTX from</span></span><br><span class="line"><span class="comment">		 * the verifier side due to the fact that the tail call is</span></span><br><span class="line"><span class="comment">		 * handled like a helper, that is, bpf_tail_call_proto,</span></span><br><span class="line"><span class="comment">		 * where arg1_type is ARG_PTR_TO_CTX.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		insn = prog-&gt;insnsi;</span><br><span class="line">		<span class="keyword">goto</span> select_insn;</span><br><span class="line">out:</span><br><span class="line">		CONT;</span><br><span class="line">	&#125;</span><br><span class="line">	JMP_JA:</span><br><span class="line">		insn += insn-&gt;off;</span><br><span class="line">		CONT;</span><br><span class="line">	JMP_EXIT:</span><br><span class="line">		<span class="keyword">return</span> BPF_R0;</span><br><span class="line">	<span class="comment">/* JMP */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COND_JMP(SIGN, OPCODE, CMP_OP)				\</span></span><br><span class="line"><span class="meta">	JMP_##OPCODE##_X:					\</span></span><br><span class="line"><span class="meta">		<span class="meta-keyword">if</span> ((SIGN##64) DST CMP_OP (SIGN##64) SRC) &#123;	\</span></span><br><span class="line"><span class="meta">			insn += insn-&gt;off;			\</span></span><br><span class="line"><span class="meta">			CONT_JMP;				\</span></span><br><span class="line"><span class="meta">		&#125;						\</span></span><br><span class="line"><span class="meta">		CONT;						\</span></span><br><span class="line"><span class="meta">	JMP32_##OPCODE##_X:					\</span></span><br><span class="line"><span class="meta">		<span class="meta-keyword">if</span> ((SIGN##32) DST CMP_OP (SIGN##32) SRC) &#123;	\</span></span><br><span class="line"><span class="meta">			insn += insn-&gt;off;			\</span></span><br><span class="line"><span class="meta">			CONT_JMP;				\</span></span><br><span class="line"><span class="meta">		&#125;						\</span></span><br><span class="line"><span class="meta">		CONT;						\</span></span><br><span class="line"><span class="meta">	JMP_##OPCODE##_K:					\</span></span><br><span class="line"><span class="meta">		<span class="meta-keyword">if</span> ((SIGN##64) DST CMP_OP (SIGN##64) IMM) &#123;	\</span></span><br><span class="line"><span class="meta">			insn += insn-&gt;off;			\</span></span><br><span class="line"><span class="meta">			CONT_JMP;				\</span></span><br><span class="line"><span class="meta">		&#125;						\</span></span><br><span class="line"><span class="meta">		CONT;						\</span></span><br><span class="line"><span class="meta">	JMP32_##OPCODE##_K:					\</span></span><br><span class="line"><span class="meta">		<span class="meta-keyword">if</span> ((SIGN##32) DST CMP_OP (SIGN##32) IMM) &#123;	\</span></span><br><span class="line"><span class="meta">			insn += insn-&gt;off;			\</span></span><br><span class="line"><span class="meta">			CONT_JMP;				\</span></span><br><span class="line"><span class="meta">		&#125;						\</span></span><br><span class="line"><span class="meta">		CONT;</span></span><br><span class="line">	COND_JMP(u, JEQ, ==)</span><br><span class="line">	COND_JMP(u, JNE, !=)</span><br><span class="line">	COND_JMP(u, JGT, &gt;)</span><br><span class="line">	COND_JMP(u, JLT, &lt;)</span><br><span class="line">	COND_JMP(u, JGE, &gt;=)</span><br><span class="line">	COND_JMP(u, JLE, &lt;=)</span><br><span class="line">	COND_JMP(u, JSET, &amp;)</span><br><span class="line">	COND_JMP(s, JSGT, &gt;)</span><br><span class="line">	COND_JMP(s, JSLT, &lt;)</span><br><span class="line">	COND_JMP(s, JSGE, &gt;=)</span><br><span class="line">	COND_JMP(s, JSLE, &lt;=)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> COND_JMP</span></span><br><span class="line">	<span class="comment">/* STX and ST and LDX*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LDST(SIZEOP, SIZE)						\</span></span><br><span class="line"><span class="meta">	STX_MEM_##SIZEOP:						\</span></span><br><span class="line"><span class="meta">		*(SIZE *)(unsigned long) (DST + insn-&gt;off) = SRC;	\</span></span><br><span class="line"><span class="meta">		CONT;							\</span></span><br><span class="line"><span class="meta">	ST_MEM_##SIZEOP:						\</span></span><br><span class="line"><span class="meta">		*(SIZE *)(unsigned long) (DST + insn-&gt;off) = IMM;	\</span></span><br><span class="line"><span class="meta">		CONT;							\</span></span><br><span class="line"><span class="meta">	LDX_MEM_##SIZEOP:						\</span></span><br><span class="line"><span class="meta">		DST = *(SIZE *)(unsigned long) (SRC + insn-&gt;off);	\</span></span><br><span class="line"><span class="meta">		CONT;</span></span><br><span class="line"></span><br><span class="line">	LDST(B,   u8)</span><br><span class="line">	LDST(H,  u16)</span><br><span class="line">	LDST(W,  u32)</span><br><span class="line">	LDST(DW, u64)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LDST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LDX_PROBE(SIZEOP, SIZE)							\</span></span><br><span class="line"><span class="meta">	LDX_PROBE_MEM_##SIZEOP:							\</span></span><br><span class="line"><span class="meta">		bpf_probe_read_kernel(&amp;DST, SIZE, (const void *)(long) (SRC + insn-&gt;off));	\</span></span><br><span class="line"><span class="meta">		CONT;</span></span><br><span class="line">	LDX_PROBE(B,  <span class="number">1</span>)</span><br><span class="line">	LDX_PROBE(H,  <span class="number">2</span>)</span><br><span class="line">	LDX_PROBE(W,  <span class="number">4</span>)</span><br><span class="line">	LDX_PROBE(DW, <span class="number">8</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LDX_PROBE</span></span><br><span class="line"></span><br><span class="line">	STX_XADD_W: <span class="comment">/* lock xadd *(u32 *)(dst_reg + off16) += src_reg */</span></span><br><span class="line">		atomic_add((u32) SRC, (<span class="keyword">atomic_t</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">			   (DST + insn-&gt;off));</span><br><span class="line">		CONT;</span><br><span class="line">	STX_XADD_DW: <span class="comment">/* lock xadd *(u64 *)(dst_reg + off16) += src_reg */</span></span><br><span class="line">		atomic64_add((u64) SRC, (<span class="keyword">atomic64_t</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br><span class="line">			     (DST + insn-&gt;off));</span><br><span class="line">		CONT;</span><br><span class="line"></span><br><span class="line">	default_label:</span><br><span class="line">		<span class="comment">/* If we ever reach this, we have a bug somewhere. Die hard here</span></span><br><span class="line"><span class="comment">		 * instead of just returning 0; we could be somewhere in a subprog,</span></span><br><span class="line"><span class="comment">		 * so execution could continue otherwise which we do /not/ want.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Note, verifier whitelists all opcodes in bpf_opcode_in_insntable().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		pr_warn(<span class="string">&quot;BPF interpreter: unknown opcode %02x\n&quot;</span>, insn-&gt;code);</span><br><span class="line">		BUG_ON(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Principles/" rel="tag"><i class="fa fa-tag"></i> Principles</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/11/20/Cpp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86+%E5%BA%95%E5%B1%82%E9%80%86%E5%90%91/" rel="prev" title="Cpp基础知识+底层逆向">
      <i class="fa fa-chevron-left"></i> Cpp基础知识+底层逆向
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/11/24/ebpf%20pwn+CVE-2021-3490/" rel="next" title="ebpf pwn+CVE-2021-3490">
      ebpf pwn+CVE-2021-3490 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">306</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">158</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">66:38</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
