<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第一个任务通过前面对 AST 遍历，完成了语义分析后，如果没有语法语义错误，就可以再次对 AST 进行遍历，计算相关的属性值，建立符号表，并生成以三地址代码 TAC 作为中间语言的中间语言代码序列 在这里对本实验的实现做了一些限制，假设数据类型只包含整数类型，不包含如浮点数、数组、结构和指针等其它数据类型 实验目标：完成语义分析的下半部分，以根据 AST 生成中间语言 TAC 三地址代码 TAC">
<meta property="og:type" content="article">
<meta property="og:title" content="编译原理-Lab3">
<meta property="og:url" content="http://example.com/2023/03/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lab3/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="第一个任务通过前面对 AST 遍历，完成了语义分析后，如果没有语法语义错误，就可以再次对 AST 进行遍历，计算相关的属性值，建立符号表，并生成以三地址代码 TAC 作为中间语言的中间语言代码序列 在这里对本实验的实现做了一些限制，假设数据类型只包含整数类型，不包含如浮点数、数组、结构和指针等其它数据类型 实验目标：完成语义分析的下半部分，以根据 AST 生成中间语言 TAC 三地址代码 TAC">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-03-21T15:40:54.000Z">
<meta property="article:modified_time" content="2023-03-21T16:53:42.002Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="miscellaneous">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="Compilers Principles">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/03/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lab3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>编译原理-Lab3 | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编译原理-Lab3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-21 23:40:54" itemprop="dateCreated datePublished" datetime="2023-03-21T23:40:54+08:00">2023-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-22 00:53:42" itemprop="dateModified" datetime="2023-03-22T00:53:42+08:00">2023-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>25 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="第一个任务"><a href="#第一个任务" class="headerlink" title="第一个任务"></a>第一个任务</h2><p>通过前面对 AST 遍历，完成了语义分析后，如果没有语法语义错误，就可以再次对 AST 进行遍历，计算相关的属性值，建立符号表，并生成以三地址代码 TAC 作为中间语言的中间语言代码序列</p>
<p>在这里对本实验的实现做了一些限制，假设数据类型只包含整数类型，不包含如浮点数、数组、结构和指针等其它数据类型</p>
<p>实验目标：完成语义分析的下半部分，以根据 AST 生成中间语言 TAC</p>
<p><strong>三地址代码 TAC</strong></p>
<p>中间语言（中间代码）是一种面向语法，易于翻译成目标程序的等效内部表示代码（二进制码）</p>
<p>其可理解性及易于生成目标代码的程度介于源语言和目标语言之间 </p>
<p>三地址中间代码 TAC 是一个4元组，逻辑上包含 <code>(op、opn1、opn2、result)</code>：</p>
<ul>
<li>op：表示操作类型说明</li>
<li>opn1 和 opn2：表示2个操作数</li>
<li>result：表示运算结果</li>
</ul>
<p>后续还需要根据 TAC 序列生成目标代码，所以设计其存储结构时，每一部分要考虑目标代码生成时所需要的信息</p>
<p>表 4-1 中间代码定义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>描述</strong></th>
<th><strong>Op</strong></th>
<th><strong>Opn1</strong></th>
<th><strong>Opn2</strong></th>
<th><strong>Result</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>LABEL x</td>
<td>定义标号 x</td>
<td>LABEL</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>FUNCTION f:</td>
<td>定义函数 f</td>
<td>FUNCTION</td>
<td></td>
<td></td>
<td>F</td>
</tr>
<tr>
<td>x := y</td>
<td>赋值操作</td>
<td>ASSIGN</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>x := y + z</td>
<td>加法操作</td>
<td>PLUS</td>
<td>Y</td>
<td>Z</td>
<td>X</td>
</tr>
<tr>
<td>x := y - z</td>
<td>减法操作</td>
<td>MINUS</td>
<td>Y</td>
<td>Z</td>
<td>X</td>
</tr>
<tr>
<td>x := y * z</td>
<td>乘法操作</td>
<td>STAR</td>
<td>Y</td>
<td>Z</td>
<td>X</td>
</tr>
<tr>
<td>x := y / z</td>
<td>除法操作</td>
<td>DIV</td>
<td>Y</td>
<td>Z</td>
<td>X</td>
</tr>
<tr>
<td>GOTO x</td>
<td>无条件转移</td>
<td>GOTO</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>IF x [relop] y GOTO z</td>
<td>条件转移</td>
<td>[relop]</td>
<td>X</td>
<td>Y</td>
<td>Z</td>
</tr>
<tr>
<td>RETURN x</td>
<td>返回语句</td>
<td>RETURN</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>ARG x</td>
<td>传实参 x</td>
<td>ARG</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>x:=CALL f</td>
<td>调用函数</td>
<td>CALL</td>
<td>F</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>PARAM x</td>
<td>函数形参</td>
<td>PARAM</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>READ x</td>
<td>读入</td>
<td>READ</td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>WRITE x</td>
<td>打印</td>
<td>WRITE</td>
<td></td>
<td></td>
<td>X</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>运算符：<ul>
<li>表示这条指令需要完成的运算，可以用枚举常量表示，如 PLUS 表示双目加，JLE 表示小于等于，PARAM 表示形参，ARG 表示实参等</li>
</ul>
</li>
<li>操作数与运算结果：<ul>
<li>这些部分包含的数据类型有多种，整常量，实常量，还有使用标识符的情况，如变量的别名、变量在其数据区的偏移量和层号、转移语句中的标号等</li>
<li>类型不同，所以考虑使用联合，为了明确联合中的有效成员，将操作数与运算结果设计成结构类型，包含 kind，联合等几个成员，kind 说明联合中的有效，联合成员是整常量，实常量或标识符表示的别名或标号或函数名等</li>
</ul>
</li>
<li>为了配合后续的 TAC 代码序列的生成，将 TAC 代码作为数据元素，用双向循环链表表示 TAC 代码序列</li>
</ul>
<p><strong>翻译模式</strong></p>
<p>翻译模式：把语义规则（也称为语义动作），用花括号 <code>&#123;&#125;</code> 括起来，插入到产生式右部的合适位置上，进一步细化了语义计算的时机 </p>
<p>翻译模式用于指明各个符号的具体含义，当 “词法分析” 和 “语法分析” 都执行完毕以后，程序便会开始 “语义分析”，其大概包含以下两个步骤：</p>
<ul>
<li>生成符号表，并进行：重复检查，未声明/定义检查，类型匹配检查</li>
<li>为 AST 的各个节点类型编写“含义”（根据翻译模式对各个节点的意义进行解释）</li>
</ul>
<p>翻译模式共有两种：</p>
<ul>
<li>S-翻译模式：<ul>
<li>只涉及到综合属性，语义动作集置于产生式右端的末尾</li>
<li>常采用 LR 的自底向上的分析法，和S-属性文法类似</li>
</ul>
</li>
<li>L-翻译模式：<ul>
<li>包含综合属性，也可以包含继承属性</li>
<li>必须满足以下条件：<ul>
<li>产生式右部符号的继承属性，其语义计算必须位于该符号前，且语义动作不访问右边符号的属性</li>
<li>产生式左部符号的综合属性只有在它所引用的所有属性都计算出来之后才可以计算，计算这种属性的动作通常放在产生式的末尾</li>
<li>继承属性只能依赖于兄长的属性、父亲的继承属性、自身的属性</li>
<li>属性间的依赖图不能形成环路</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>本实验将会采用S-翻译模式和 LR(1) 文法：</p>
<ul>
<li>基础文法 LL(1)：自顶向下计算</li>
<li>基础文法 LR(1)：自底向上计算</li>
</ul>
<p><strong>属性计算</strong></p>
<p>在遍历过程中，需要根据翻译模式给出的计算方法完成属性的计算，本实验中设置的属性如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span>                     </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> level;                  <span class="comment">// 层号</span></span><br><span class="line">    <span class="keyword">int</span> place;                  <span class="comment">// 表示结点对应的变量或运算结果符号表的位置序号</span></span><br><span class="line">    <span class="keyword">char</span> Etrue[<span class="number">15</span>], Efalse[<span class="number">15</span>]; <span class="comment">// 对布尔表达式的翻译时，真假转移目标的标号</span></span><br><span class="line">    <span class="keyword">char</span> Snext[<span class="number">15</span>];             <span class="comment">// 该结点对饮语句执行后的下一条语句位置标号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">codenode</span> *<span class="title">code</span>;</span>      <span class="comment">// 该结点中间代码链表头指针</span></span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> type;   <span class="comment">// 结点对应值的类型</span></span><br><span class="line">    <span class="keyword">int</span> pos;    <span class="comment">// 语法单位所在位置行号</span></span><br><span class="line">    <span class="keyword">int</span> offset; <span class="comment">// 偏移量</span></span><br><span class="line">    <span class="keyword">int</span> width;  <span class="comment">// 占数据字节数</span></span><br><span class="line">    <span class="keyword">int</span> num;	<span class="comment">// 记录个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>.place</strong>：记录该结点操作数在符号表中的位置序号，每次完成了计算后，中间结果需要用一个临时变量保存，临时变量也需要登记到符号表中（返回局部变量会生成一个临时变量，即没有名字的变量）</li>
<li><strong>.type</strong>：记录数据的类型，用于表达式的计算中，该属性也可用于语句，表示语句语义分析的正确性（OK或ERROR）</li>
<li><strong>.offset</strong>：记录外部变量在静态数据区中的偏移量，以及局部变量和临时变量在活动记录中的偏移量（另外对函数，这项保存活动记录的大小）</li>
<li><strong>.width</strong>：记录一个结点表示的语法单位中，定义的变量和临时单元所需要占用的字节数，方便计算变量、临时变量在活动记录中偏移量，以及最后计算函数活动记录的大小</li>
<li><strong>.code</strong>：记录中间代码序列的起始位置，如采用链表表示中间代码序列，该属性就是一个链表的头指针</li>
<li><strong>.Etrue</strong> 和 <strong>.Efalse</strong>：在完成布尔表达式翻译时，表达式值为真假时要转移的程序位置（标号的字符串形式）</li>
<li><strong>.Snext</strong>：该结点的语句序列执行完后，要转移的程序位置（标号的字符串形式）</li>
</ul>
<p>这一步非常复杂，如果有必要的话，我们需要对每个类型的节点都设置一个函数，用于解析它本身的语义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semantic_Analysis</span><span class="params">(struct node *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (T-&gt;kind)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> EXT_DEF_LIST: <span class="comment">// 外部定义列表</span></span><br><span class="line">            ext_def_list(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EXT_VAR_DEF: <span class="comment">// 外部变量声明</span></span><br><span class="line">            ext_var_def(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FUNC_DEF: <span class="comment">// 函数定义</span></span><br><span class="line">            func_def(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FUNC_DEC: <span class="comment">// 函数声明</span></span><br><span class="line">            func_dec(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PARAM_LIST: <span class="comment">// 参数定义列表</span></span><br><span class="line">            param_list(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PARAM_DEC: <span class="comment">// 参数定义</span></span><br><span class="line">            param_dec(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> COMP_STM: <span class="comment">// 复合语句</span></span><br><span class="line">            comp_stm(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DEF_LIST: <span class="comment">// 定义列表</span></span><br><span class="line">            def_list(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> VAR_DEF: <span class="comment">// 定义</span></span><br><span class="line">            var_def(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> STM_LIST: <span class="comment">// 语句列表</span></span><br><span class="line">            stmt_list(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IF_THEN: <span class="comment">// IF ELSE-IF语句</span></span><br><span class="line">            if_then(T);</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> IF_THEN_ELSE: <span class="comment">// IF ELSE语句</span></span><br><span class="line">            if_then_else(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WHILE: <span class="comment">// WHILE语句</span></span><br><span class="line">            while_dec(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FOR: <span class="comment">// FOR语句(改动)</span></span><br><span class="line">            for_dec(T);</span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">        <span class="keyword">case</span> FOR_DEC: <span class="comment">// FOR语句列表(新添)</span></span><br><span class="line">            for_list(T);</span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> EXP_STMT: <span class="comment">// 表达式语句</span></span><br><span class="line">            exp_stmt(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RETURN: <span class="comment">// 返回</span></span><br><span class="line">            return_dec(T);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ID:</span><br><span class="line">        <span class="keyword">case</span> STRUCT_TAG: <span class="comment">// 结构体(新添)</span></span><br><span class="line">        <span class="keyword">case</span> INT:</span><br><span class="line">        <span class="keyword">case</span> FLOAT:</span><br><span class="line">        <span class="keyword">case</span> CHAR:</span><br><span class="line">        <span class="keyword">case</span> STRING:</span><br><span class="line">        <span class="keyword">case</span> ASSIGNOP:</span><br><span class="line">        <span class="keyword">case</span> AND:</span><br><span class="line">        <span class="keyword">case</span> OR:</span><br><span class="line">        <span class="keyword">case</span> RELOP:</span><br><span class="line">        <span class="keyword">case</span> PLUS:</span><br><span class="line">        <span class="keyword">case</span> PPLUS: <span class="comment">// 加加(改名)</span></span><br><span class="line">        <span class="keyword">case</span> PLUSASSIGNOP: <span class="comment">// 加等于(改名)</span></span><br><span class="line">        <span class="keyword">case</span> MINUS:</span><br><span class="line">        <span class="keyword">case</span> MMINUS: <span class="comment">// 减减(改名)</span></span><br><span class="line">        <span class="keyword">case</span> MINUSASSIGNOP: <span class="comment">// 减等于(改名)</span></span><br><span class="line">        <span class="keyword">case</span> STAR:</span><br><span class="line">        <span class="keyword">case</span> STARASSIGNOP: <span class="comment">// 乘等于(改名)</span></span><br><span class="line">        <span class="keyword">case</span> DIV:</span><br><span class="line">        <span class="keyword">case</span> DIVASSIGNOP: <span class="comment">// 除等于(改名)</span></span><br><span class="line">        <span class="keyword">case</span> NOT:</span><br><span class="line">        <span class="keyword">case</span> UMINUS:</span><br><span class="line">        <span class="keyword">case</span> FUNC_CALL:</span><br><span class="line">        <span class="keyword">case</span> EXP_ARRAY:</span><br><span class="line">            Exp(T); <span class="comment">//处理基本表达式</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述展示的节点类型并不完整，有些类型的处理函数会出现在其子函数中</li>
</ul>
<p>这里要补充一下：和上个实验相比，新填了3个节点：</p>
<ul>
<li>STRUCT_TAG：结构体名称</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OptTag	: &#123;$$=<span class="literal">NULL</span>;&#125;</span><br><span class="line">		| ID &#123;$$=mknode(STRUCT_TAG,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,yylineno);<span class="built_in">strcpy</span>($$-&gt;struct_name,$<span class="number">1</span>);&#125;</span><br><span class="line">		;</span><br><span class="line">Tag	: ID &#123;$$=mknode(STRUCT_TAG,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,yylineno);<span class="built_in">strcpy</span>($$-&gt;struct_name,$<span class="number">1</span>);&#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>
<ul>
<li>STRUCT_DEF：结构体定义</li>
<li>STRUCT_DEC：结构体声明</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StructSpecifier : STRUCT OptTag LC DefList RC &#123;$$=mknode(STRUCT_DEF,$<span class="number">2</span>,$<span class="number">4</span>,<span class="literal">NULL</span>,yylineno);&#125;</span><br><span class="line">			   | STRUCT Tag  &#123;$$=mknode(STRUCT_DEC,$<span class="number">2</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,yylineno);&#125;</span><br><span class="line">			   ;</span><br></pre></td></tr></table></figure>
<p>修改了1个节点：（另外几个只是改了名字，代码没有变）</p>
<ul>
<li>FOR：FOR 语句</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stmt:   Exp SEMI    &#123;$$=mknode(EXP_STMT,$<span class="number">1</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,yylineno);&#125;</span><br><span class="line">      | CompSt      &#123;$$=$<span class="number">1</span>;&#125;     </span><br><span class="line">      | RETURN Exp SEMI   &#123;$$=mknode(RETURN,$<span class="number">2</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,yylineno);&#125;</span><br><span class="line">      | IF LP Exp RP Stmt %prec LOWER_THEN_ELSE   &#123;$$=mknode(IF_THEN,$<span class="number">3</span>,$<span class="number">5</span>,<span class="literal">NULL</span>,yylineno);&#125;</span><br><span class="line">      | IF LP Exp RP Stmt ELSE Stmt   &#123;$$=mknode(IF_THEN_ELSE,$<span class="number">3</span>,$<span class="number">5</span>,$<span class="number">7</span>,yylineno);&#125;</span><br><span class="line">      | WHILE LP Exp RP Stmt &#123;$$=mknode(WHILE,$<span class="number">3</span>,$<span class="number">5</span>,<span class="literal">NULL</span>,yylineno);&#125;</span><br><span class="line">      | FOR LP ForDec RP Stmt &#123;$$=mknode(FOR,$<span class="number">3</span>,$<span class="number">5</span>,<span class="literal">NULL</span>,yylineno);&#125;</span><br><span class="line">      ;</span><br></pre></td></tr></table></figure>
<ul>
<li>ForDec：FOR 语句列表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ForDec: Exp SEMI Exp SEMI Exp &#123;$$=mknode(FOR_DEC,$<span class="number">1</span>,$<span class="number">3</span>,$<span class="number">5</span>,yylineno);&#125;</span><br><span class="line">       | SEMI Exp SEMI &#123;$$=mknode(FOR_DEC,<span class="literal">NULL</span>,$<span class="number">2</span>,<span class="literal">NULL</span>,yylineno);&#125;</span><br><span class="line">       ;</span><br></pre></td></tr></table></figure>
<p><strong>中间代码的生成</strong></p>
<p>核心结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">codenode</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="comment">/* 三地址TAC代码结点 */</span></span><br><span class="line">    <span class="keyword">int</span> op;                        <span class="comment">// TAC代码的运算符种类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">opn</span> <span class="title">opn1</span>, <span class="title">opn2</span>, <span class="title">result</span>;</span> <span class="comment">// 2个操作数和运算结果</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">codenode</span> *<span class="title">next</span>, *<span class="title">prior</span>;</span> <span class="comment">// 采用双向循环链表存放中间语言代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于描述操作数的结构体如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> kind; <span class="comment">// 标识操作的类型</span></span><br><span class="line">    <span class="keyword">int</span> type; <span class="comment">// 标识操作数的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> const_int;     <span class="comment">// 整常数值,立即数</span></span><br><span class="line">        <span class="keyword">float</span> const_float; <span class="comment">// 浮点常数值,立即数</span></span><br><span class="line">        <span class="keyword">char</span> const_char;   <span class="comment">// 字符常数值,立即数</span></span><br><span class="line">        <span class="keyword">char</span> *const_string;</span><br><span class="line">        <span class="keyword">char</span> id[<span class="number">33</span>]; <span class="comment">// 变量或临时变量的别名或标号字符串</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Array</span> *<span class="title">type_array</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Struct</span> *<span class="title">type_struct</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> level;  <span class="comment">// 变量的层号,0表示是全局变量,数据保存在静态数据区</span></span><br><span class="line">    <span class="keyword">int</span> offset; <span class="comment">// 变量单元偏移量,或函数在符号表的定义位置序号,目标代码生成时用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>中间代码生成的过程其实就是完成 <code>codenode</code> 双向链表，其中的 <code>opn1, opn2, result</code> 需要根据 “表 4-1 中间代码定义” 来进行填写</p>
<p>接下来就按照逻辑顺序，依次展示各个节点的中间代码的生成过程</p>
<p><strong>全局变量定义</strong>（本实验的外部变量就是全局变量）</p>
<p>EXT_DEF_LIST：外部定义列表（EXT_VAR_DEF | ARRAY_DEF | FUNC_DEF，EXT_DEF_LIST）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ext_def_list</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;ptr[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;offset; <span class="comment">// 语义分析之前先设置偏移地址</span></span><br><span class="line">    semantic_Analysis(T-&gt;ptr[<span class="number">0</span>]); <span class="comment">// 访问外部定义列表中的第一个</span></span><br><span class="line">    T-&gt;code = T-&gt;ptr[<span class="number">0</span>]-&gt;code; <span class="comment">// 之后会合并code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;ptr[<span class="number">1</span>]) <span class="comment">/* 第2棵子树指向下一个EXT_DEF_LIST节点,可为NULL */</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;ptr[<span class="number">0</span>]-&gt;offset + T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">        semantic_Analysis(T-&gt;ptr[<span class="number">1</span>]); <span class="comment">// 访问该外部定义列表中的其它外部定义</span></span><br><span class="line">        T-&gt;code = merge(<span class="number">2</span>, T-&gt;code, T-&gt;ptr[<span class="number">1</span>]-&gt;code); <span class="comment">// 合并code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>merge</code>：合并多个中间代码的双向循环链表，首尾相连</li>
</ul>
<p>EXT_VAR_DEF：外部变量声明（TYPE，EXT_DEC_LIST）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ext_var_def</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;type_id, <span class="string">&quot;int&quot;</span>)) <span class="comment">/* 变量类型判断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;type = T-&gt;ptr[<span class="number">1</span>]-&gt;type = INT;</span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;width = <span class="number">4</span>; <span class="comment">/* 解释该类型的实际大小 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;type_id, <span class="string">&quot;float&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;type = T-&gt;ptr[<span class="number">1</span>]-&gt;type = FLOAT;</span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;width = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;type_id, <span class="string">&quot;char&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;type = T-&gt;ptr[<span class="number">1</span>]-&gt;type = CHAR;</span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;width = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset; 				<span class="comment">// 这个外部变量的偏移量向下传递</span></span><br><span class="line">    ext_var_list(T-&gt;ptr[<span class="number">1</span>]);                        <span class="comment">// 处理外部变量中的标识符序列</span></span><br><span class="line">    T-&gt;width = (T-&gt;ptr[<span class="number">1</span>]-&gt;width) * T-&gt;ptr[<span class="number">1</span>]-&gt;num; <span class="comment">// 计算这个外部变量声明的宽度</span></span><br><span class="line">    T-&gt;code = <span class="literal">NULL</span>;                                 <span class="comment">// 这里假定外部变量不支持初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>EXT_DEC_LIST 节点中可能记录了类型相同的多个变量声明，需要递归处理</li>
<li>假定全局变量不支持初始化，因此不需要设置中间代码 <code>code</code></li>
</ul>
<p>EXT_DEC_LIST：变量名称列表（ID，EXT_DEC_LIST）</p>
<p>ID：变量名称（ID）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ext_var_list</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rtn, num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> (T-&gt;kind)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> EXT_DEC_LIST: <span class="comment">/* EXT_DEC_LIST节点必然存在两棵子树 */</span></span><br><span class="line">        T-&gt;ptr[<span class="number">0</span>]-&gt;type = T-&gt;type;                <span class="comment">//将类型属性向下传递变量结点</span></span><br><span class="line">        T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;offset;            <span class="comment">//外部变量的偏移量向下传递</span></span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;type = T-&gt;type;                <span class="comment">//将类型属性向下传递变量结点</span></span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset + T-&gt;width; <span class="comment">//外部变量的偏移量向下传递</span></span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;width = T-&gt;width;</span><br><span class="line">        ext_var_list(T-&gt;ptr[<span class="number">0</span>]); <span class="comment">/* 进入ID */</span></span><br><span class="line">        ext_var_list(T-&gt;ptr[<span class="number">1</span>]); <span class="comment">/* 进入EXT_DEC_LIST */</span></span><br><span class="line">        T-&gt;num = T-&gt;ptr[<span class="number">1</span>]-&gt;num + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ID:</span><br><span class="line">        rtn = fillSymbolTable(T-&gt;type_id, newAlias(), LEV, T-&gt;type, <span class="string">&#x27;V&#x27;</span>, T-&gt;offset); <span class="comment">// 最后一个变量名</span></span><br><span class="line">        <span class="keyword">if</span> (rtn == <span class="number">-1</span>)</span><br><span class="line">            semantic_error(T-&gt;pos, T-&gt;type_id, <span class="string">&quot;变量重复定义，语义错误&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T-&gt;place = rtn;</span><br><span class="line">        T-&gt;num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>fillSymbolTable</code>：根据 <code>name</code> 查符号表，不能重复定义：<ul>
<li>重复定义，则返回 -1</li>
<li>不重复定义，则填表并返回符号在符号表中的位置序号</li>
</ul>
</li>
</ul>
<p>分析以上这3个函数的流程，就可以大概清楚属性计算的流程，在遍历 AST 的过程中就可以自下而上来分析节点属性</p>
<p><strong>函数定义</strong></p>
<p>FUNC_DEF：函数定义（TYPE，FUNC_DEC，COMP_STM）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_def</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;type_id, <span class="string">&quot;int&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;type = INT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;type_id, <span class="string">&quot;float&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;type = FLOAT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;type_id, <span class="string">&quot;char&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;type = CHAR;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;width = <span class="number">0</span>;            <span class="comment">//函数的宽度设置为0,不会对外部变量的地址分配产生影响</span></span><br><span class="line">    T-&gt;offset = DX;			<span class="comment">//设置局部变量在活动记录中的偏移量初值</span></span><br><span class="line">    semantic_Analysis(T-&gt;ptr[<span class="number">1</span>]);  <span class="comment">//处理函数名和参数结点部分(不考虑寄存器传参)</span></span><br><span class="line">    T-&gt;offset += T-&gt;ptr[<span class="number">1</span>]-&gt;width; <span class="comment">//用形参单元宽度修改函数局部变量的起始偏移量</span></span><br><span class="line">    T-&gt;ptr[<span class="number">2</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">2</span>]-&gt;Snext, newLabel()); <span class="comment">//函数体语句执行结束后的位置属性</span></span><br><span class="line">    semantic_Analysis(T-&gt;ptr[<span class="number">2</span>]);         <span class="comment">//处理函数体结点</span></span><br><span class="line">    <span class="comment">//计算活动记录大小,这里offset属性存放的是活动记录大小,不是偏移</span></span><br><span class="line">    symbolTable.symbols[T-&gt;ptr[<span class="number">1</span>]-&gt;place].offset = T-&gt;offset + T-&gt;ptr[<span class="number">2</span>]-&gt;width;</span><br><span class="line">    T-&gt;code = merge(<span class="number">3</span>, T-&gt;ptr[<span class="number">1</span>]-&gt;code, T-&gt;ptr[<span class="number">2</span>]-&gt;code, genLabel(T-&gt;ptr[<span class="number">2</span>]-&gt;Snext)); <span class="comment">//函数体的代码作为函数的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>newLabel</code>：生成一个标号，标号命名形式为 “LABEL+序号”</li>
<li>函数 <code>genLabel</code>：生成标号语句</li>
</ul>
<p>FUNC_DEC：函数声明（PARAM_LIST）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_dec</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rtn;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">opn</span> <span class="title">opn1</span>, <span class="title">opn2</span>, <span class="title">result</span>;</span></span><br><span class="line">    rtn = fillSymbolTable(T-&gt;type_id, newAlias(), LEV, T-&gt;type, <span class="string">&#x27;F&#x27;</span>, <span class="number">0</span>); <span class="comment">//函数不在数据区中分配单元,偏移量为0</span></span><br><span class="line">    <span class="keyword">if</span> (rtn == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semantic_error(T-&gt;pos, T-&gt;type_id, <span class="string">&quot;函数名重复使用，可能是函数重复定义，语义错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        T-&gt;place = rtn;</span><br><span class="line">    result.kind = ID;</span><br><span class="line">    <span class="built_in">strcpy</span>(result.id, T-&gt;type_id);</span><br><span class="line">    result.offset = rtn;</span><br><span class="line">    T-&gt;code = genIR(FUNCTION, opn1, opn2, result); <span class="comment">//生成中间代码:FUNCTION 函数名</span></span><br><span class="line">    T-&gt;offset = DX;                                <span class="comment">//设置形式参数在活动记录中的偏移量初值</span></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;ptr[<span class="number">0</span>]) <span class="comment">/* 判断是否有参数 */</span></span><br><span class="line">    &#123; </span><br><span class="line">        T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">        semantic_Analysis(T-&gt;ptr[<span class="number">0</span>]); <span class="comment">//处理函数参数列表</span></span><br><span class="line">        T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">        symbolTable.symbols[rtn].paramnum = T-&gt;ptr[<span class="number">0</span>]-&gt;num;</span><br><span class="line">        T-&gt;code = merge(<span class="number">2</span>, T-&gt;code, T-&gt;ptr[<span class="number">0</span>]-&gt;code); <span class="comment">//连接函数名和参数代码序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        symbolTable.symbols[rtn].paramnum = <span class="number">0</span>, T-&gt;width = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>genIR</code>：生成一条 TAC 的中间代码语句<ul>
<li>一般情况下，TAC 中涉及到2个运算对象和运算结果</li>
<li>如果是局部变量或临时变量，表示在运行时，其对应的存储单元在活动记录中，这时需要将其偏移量 offset 和数据类型同时带上，方便最后的目标代码生成</li>
<li>全局变量也需要带上偏移量</li>
</ul>
</li>
<li>查中间代码表可知 “FUNCTION 函数名” 不需要 <code>opn1 opn2</code>，只需要 <code>result</code></li>
</ul>
<p>PARAM_LIST：参数定义列表（PARAM_DEC）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">param_list</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">    semantic_Analysis(T-&gt;ptr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;ptr[<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset + T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">        semantic_Analysis(T-&gt;ptr[<span class="number">1</span>]);</span><br><span class="line">        T-&gt;num = T-&gt;ptr[<span class="number">0</span>]-&gt;num + T-&gt;ptr[<span class="number">1</span>]-&gt;num;             <span class="comment">//统计参数个数</span></span><br><span class="line">        T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width + T-&gt;ptr[<span class="number">1</span>]-&gt;width;       <span class="comment">//累加参数单元宽度</span></span><br><span class="line">        T-&gt;code = merge(<span class="number">2</span>, T-&gt;ptr[<span class="number">0</span>]-&gt;code, T-&gt;ptr[<span class="number">1</span>]-&gt;code); <span class="comment">//连接参数代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;num = T-&gt;ptr[<span class="number">0</span>]-&gt;num;</span><br><span class="line">        T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">        T-&gt;code = T-&gt;ptr[<span class="number">0</span>]-&gt;code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PARAM_DEC：参数定义（TYPE，ID）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">param_dec</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rtn;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">opn</span> <span class="title">opn1</span>, <span class="title">opn2</span>, <span class="title">result</span>;</span></span><br><span class="line">    rtn = fillSymbolTable(T-&gt;ptr[<span class="number">1</span>]-&gt;type_id, newAlias(), <span class="number">1</span>, T-&gt;ptr[<span class="number">0</span>]-&gt;type, <span class="string">&#x27;P&#x27;</span>, T-&gt;offset);</span><br><span class="line">    <span class="keyword">if</span> (rtn == <span class="number">-1</span>)</span><br><span class="line">        semantic_error(T-&gt;ptr[<span class="number">1</span>]-&gt;pos, T-&gt;ptr[<span class="number">1</span>]-&gt;type_id, <span class="string">&quot;参数名重复定义,语义错误&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;place = rtn;</span><br><span class="line">    T-&gt;num = <span class="number">1</span>;                                <span class="comment">//参数个数计算的初始值</span></span><br><span class="line">    T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;type == INT ? <span class="number">4</span> : <span class="number">8</span>; <span class="comment">//参数宽度</span></span><br><span class="line">    result.kind = ID;</span><br><span class="line">    <span class="built_in">strcpy</span>(result.id, symbolTable.symbols[rtn].alias);</span><br><span class="line">    result.offset = T-&gt;offset;</span><br><span class="line">    T-&gt;code = genIR(PARAM, opn1, opn2, result); <span class="comment">//生成:PARAM 形参名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>生成形式参数的中间代码</li>
</ul>
<p>COMP_STM：复合语句（DEF_LIST，STM_LIST）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">comp_stm</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LEV++; <span class="comment">//设置层号加1,并且保存该层局部变量在符号表中的起始位置在symbol_scope_TX</span></span><br><span class="line">    symbol_scope_TX.TX[symbol_scope_TX.top++] = symbolTable.index;</span><br><span class="line">    T-&gt;width = <span class="number">0</span>;</span><br><span class="line">    T-&gt;code = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;ptr[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">        semantic_Analysis(T-&gt;ptr[<span class="number">0</span>]); <span class="comment">//处理该层的局部变量DEF_LIST</span></span><br><span class="line">        T-&gt;width += T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">        T-&gt;code = T-&gt;ptr[<span class="number">0</span>]-&gt;code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;ptr[<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset + T-&gt;width;</span><br><span class="line">        <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">1</span>]-&gt;Snext, T-&gt;Snext); <span class="comment">//S.next属性向下传递</span></span><br><span class="line">        semantic_Analysis(T-&gt;ptr[<span class="number">1</span>]); <span class="comment">//处理复合语句的语句列表STM_LIST</span></span><br><span class="line">        T-&gt;width += T-&gt;ptr[<span class="number">1</span>]-&gt;width;</span><br><span class="line">        T-&gt;code = merge(<span class="number">2</span>, T-&gt;code, T-&gt;ptr[<span class="number">1</span>]-&gt;code);</span><br><span class="line">    &#125;</span><br><span class="line">    LEV--; <span class="comment">//出复合语句,层号减1</span></span><br><span class="line">    symbolTable.index = symbol_scope_TX.TX[--symbol_scope_TX.top]; <span class="comment">//删除该作用域中的符号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>symbol_scope_TX</code> 是一个存放 <code>symbolTable.index</code> 的栈结构</li>
</ul>
<p><strong>表达式</strong></p>
<p>下面给一个通用表达式 Exp 的案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exp</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (T-&gt;kind)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> ID: <span class="comment">// 名称(符号)</span></span><br><span class="line">                id_exp(T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHAR: <span class="comment">// char类型</span></span><br><span class="line">                char_exp(T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> INT: <span class="comment">// int类型</span></span><br><span class="line">                int_exp(T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FLOAT: <span class="comment">// float类型</span></span><br><span class="line">                float_exp(T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ASSIGNOP: <span class="comment">// 赋值</span></span><br><span class="line">                assignop_exp(T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PPLUS: <span class="comment">// 加减</span></span><br><span class="line">            <span class="keyword">case</span> MMINUS: <span class="comment">// 减减</span></span><br><span class="line">                oop_exp(T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AND: <span class="comment">// 且</span></span><br><span class="line">            <span class="keyword">case</span> OR: <span class="comment">// 或</span></span><br><span class="line">            <span class="keyword">case</span> RELOP: <span class="comment">// 二元运算符</span></span><br><span class="line">                relop_exp(T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PLUSASSIGNOP: <span class="comment">// 加等于</span></span><br><span class="line">            <span class="keyword">case</span> MINUSASSIGNOP: <span class="comment">// 减等于</span></span><br><span class="line">            <span class="keyword">case</span> STARASSIGNOP: <span class="comment">// 乘等于</span></span><br><span class="line">            <span class="keyword">case</span> DIVASSIGNOP: <span class="comment">// 除等于</span></span><br><span class="line">            <span class="keyword">case</span> PLUS: <span class="comment">// 加</span></span><br><span class="line">            <span class="keyword">case</span> MINUS: <span class="comment">// 减</span></span><br><span class="line">            <span class="keyword">case</span> STAR: <span class="comment">// 乘</span></span><br><span class="line">            <span class="keyword">case</span> DIV: <span class="comment">// 除</span></span><br><span class="line">                op_exp(T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FUNC_CALL: <span class="comment">//根据T-&gt;type_id查出函数的定义,如果语言中增加了实验教材的read,write需要单独处理一下</span></span><br><span class="line">                func_call_exp(T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ARGS: <span class="comment">//此处仅处理各实参表达式的求值的代码序列,不生成ARG的实参系列</span></span><br><span class="line">                args_exp(T);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式 Exp 的类型很多，这里只选择几个简单分析：</p>
<p>ID：名称（NULL）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">id_exp</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rtn;</span><br><span class="line"></span><br><span class="line">    rtn = searchSymbolTable(T-&gt;type_id);</span><br><span class="line">    <span class="keyword">if</span> (rtn == <span class="number">-1</span>)</span><br><span class="line">        semantic_error(T-&gt;pos, T-&gt;type_id, <span class="string">&quot;变量未声明定义就引用，语义错误&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (symbolTable.symbols[rtn].flag == <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">        semantic_error(T-&gt;pos, T-&gt;type_id, <span class="string">&quot;是函数名，不是普通变量，语义错误&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;place = rtn; <span class="comment">//结点保存变量在符号表中的位置</span></span><br><span class="line">        T-&gt;code = <span class="literal">NULL</span>; <span class="comment">//标识符不需要生成TAC</span></span><br><span class="line">        T-&gt;type = symbolTable.symbols[rtn].type;</span><br><span class="line">        T-&gt;offset = symbolTable.symbols[rtn].offset;</span><br><span class="line">        T-&gt;width = <span class="number">0</span>; <span class="comment">//未再使用新单元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>INT：int 类型（其他基础类型同理）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int_exp</span><span class="params">(struct node *T)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">opn</span> <span class="title">opn1</span>, <span class="title">opn2</span>, <span class="title">result</span>;</span></span><br><span class="line">    T-&gt;place = temp_add(newTemp(), LEV, T-&gt;type, <span class="string">&#x27;T&#x27;</span>, T-&gt;offset); <span class="comment">//为整常量生成一个临时变量</span></span><br><span class="line">    T-&gt;type = INT;</span><br><span class="line">    opn1.kind = INT;</span><br><span class="line">    opn1.const_int = T-&gt;type_int;</span><br><span class="line">    result.kind = ID;</span><br><span class="line">    <span class="built_in">strcpy</span>(result.id, symbolTable.symbols[T-&gt;place].alias);</span><br><span class="line">    result.offset = symbolTable.symbols[T-&gt;place].offset;</span><br><span class="line">    T-&gt;code = genIR(ASSIGNOP, opn1, opn2, result);</span><br><span class="line">    T-&gt;width = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回局部变量会生成一个临时变量，由于 int 和 float 会参与计算，因此需要一个临时变量来存储计算的结果</li>
<li>函数 <code>temp_add</code>：填写临时变量到符号表，返回临时变量在符号表中的位置</li>
</ul>
<p>ASSIGNOP：赋值（ID，Exp）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignop_exp</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">opn</span> <span class="title">opn1</span>, <span class="title">opn2</span>, <span class="title">result</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;ptr[<span class="number">0</span>]-&gt;kind != ID)</span><br><span class="line">    &#123;</span><br><span class="line">        semantic_error(T-&gt;pos, <span class="string">&quot;&quot;</span>, <span class="string">&quot;赋值语句没有左值，语义错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Exp(T-&gt;ptr[<span class="number">0</span>]); <span class="comment">//处理左值,例中仅为变量</span></span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">        Exp(T-&gt;ptr[<span class="number">1</span>]); <span class="comment">//处理右值</span></span><br><span class="line">        T-&gt;type = T-&gt;ptr[<span class="number">0</span>]-&gt;type;</span><br><span class="line">        T-&gt;width = T-&gt;ptr[<span class="number">1</span>]-&gt;width;</span><br><span class="line">        T-&gt;code = merge(<span class="number">2</span>, T-&gt;ptr[<span class="number">0</span>]-&gt;code, T-&gt;ptr[<span class="number">1</span>]-&gt;code);</span><br><span class="line"></span><br><span class="line">        opn1.kind = ID;</span><br><span class="line">        <span class="built_in">strcpy</span>(opn1.id, symbolTable.symbols[T-&gt;ptr[<span class="number">1</span>]-&gt;place].alias); <span class="comment">//右值一定是个变量或临时变量</span></span><br><span class="line">        opn1.offset = symbolTable.symbols[T-&gt;ptr[<span class="number">1</span>]-&gt;place].offset;</span><br><span class="line">        result.kind = ID;</span><br><span class="line">        <span class="built_in">strcpy</span>(result.id, symbolTable.symbols[T-&gt;ptr[<span class="number">0</span>]-&gt;place].alias);</span><br><span class="line">        result.offset = symbolTable.symbols[T-&gt;ptr[<span class="number">0</span>]-&gt;place].offset;</span><br><span class="line">        T-&gt;code = merge(<span class="number">2</span>, T-&gt;code, genIR(ASSIGNOP, opn1, opn2, result)); <span class="comment">//生成:x := y</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>生成赋值语句的中间代码</li>
</ul>
<p>FUNC_CALL：函数调用（ARGS）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_call_exp</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rtn,width;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">T0</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">opn</span> <span class="title">opn1</span>, <span class="title">opn2</span>, <span class="title">result</span>;</span></span><br><span class="line">    rtn = searchSymbolTable(T-&gt;type_id);</span><br><span class="line">    <span class="keyword">if</span> (rtn == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semantic_error(T-&gt;pos, T-&gt;type_id, <span class="string">&quot;函数未定义，语义错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (symbolTable.symbols[rtn].flag != <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        semantic_error(T-&gt;pos, T-&gt;type_id, <span class="string">&quot;不是函数名，不能进行函数调用，语义错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;type = symbolTable.symbols[rtn].type;</span><br><span class="line">    width = T-&gt;type == INT ? <span class="number">4</span> : <span class="number">8</span>; <span class="comment">//存放函数返回值的单数字节数</span></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;ptr[<span class="number">0</span>]) <span class="comment">//有调用参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">        Exp(T-&gt;ptr[<span class="number">0</span>]);                      <span class="comment">//处理所有实参表达式,求值及类型</span></span><br><span class="line">        T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width + width; <span class="comment">//累加上计算实参使用临时变量的单元数</span></span><br><span class="line">        T-&gt;code = T-&gt;ptr[<span class="number">0</span>]-&gt;code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//无调用参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;width = width;</span><br><span class="line">        T-&gt;code = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    match_param(rtn, T-&gt;ptr[<span class="number">0</span>]); <span class="comment">//处理所有参数的匹配</span></span><br><span class="line">    T0 = T-&gt;ptr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (T0) <span class="comment">//处理参数列表的中间代码</span></span><br><span class="line">    &#123;</span><br><span class="line">        result.kind = ID;</span><br><span class="line">        <span class="built_in">strcpy</span>(result.id, symbolTable.symbols[T0-&gt;ptr[<span class="number">0</span>]-&gt;place].alias);</span><br><span class="line">        result.offset = symbolTable.symbols[T0-&gt;ptr[<span class="number">0</span>]-&gt;place].offset;</span><br><span class="line">        T-&gt;code = merge(<span class="number">2</span>, T-&gt;code, genIR(ARG, opn1, opn2, result));</span><br><span class="line">        T0 = T0-&gt;ptr[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;place = temp_add(newTemp(), LEV, T-&gt;type, <span class="string">&#x27;T&#x27;</span>, T-&gt;offset + T-&gt;width - width); <span class="comment">/* 临时变量用于存储函数的返回值 */</span></span><br><span class="line">    opn1.kind = ID;</span><br><span class="line">    <span class="built_in">strcpy</span>(opn1.id, T-&gt;type_id); <span class="comment">//保存函数名</span></span><br><span class="line">    opn1.offset = rtn;           <span class="comment">//这里offset用以保存函数定义入口,在目标代码生成时，能获取相应信息</span></span><br><span class="line">    result.kind = ID;</span><br><span class="line">    <span class="built_in">strcpy</span>(result.id, symbolTable.symbols[T-&gt;place].alias);</span><br><span class="line">    result.offset = symbolTable.symbols[T-&gt;place].offset;</span><br><span class="line">    T-&gt;code = merge(<span class="number">2</span>, T-&gt;code, genIR(CALL, opn1, opn2, result)); <span class="comment">//生成:x := CALL 函数名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>生成函数调用中间代码</li>
<li>函数 <code>match_param</code>：匹配函数参数</li>
</ul>
<p>ARGS：函数参数（Exp | Exp，Args）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">args_exp</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">    Exp(T-&gt;ptr[<span class="number">0</span>]);</span><br><span class="line">    T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">    T-&gt;code = T-&gt;ptr[<span class="number">0</span>]-&gt;code;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;ptr[<span class="number">1</span>]) <span class="comment">//存在多个参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset + T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">        Exp(T-&gt;ptr[<span class="number">1</span>]); <span class="comment">//再次调用args_exp</span></span><br><span class="line">        T-&gt;width += T-&gt;ptr[<span class="number">1</span>]-&gt;width;</span><br><span class="line">        T-&gt;code = merge(<span class="number">2</span>, T-&gt;code, T-&gt;ptr[<span class="number">1</span>]-&gt;code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>语句列表</strong></p>
<p>在开始分析选择/循环语句之前需要先分析：STM_LIST </p>
<p>STM_LIST：语句列表（Stmt-语句节点，STM_LIST）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stmt_list</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T-&gt;ptr[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;code = <span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;width = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;              <span class="comment">//空语句序列</span></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;ptr[<span class="number">1</span>]) <span class="comment">//2条以上语句连接,生成新标号作为第一条语句结束后到达的位置</span></span><br><span class="line">        <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Snext, newLabel());</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//语句序列仅有一条语句,S.next属性向下传递</span></span><br><span class="line">        <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Snext, T-&gt;Snext);</span><br><span class="line">    T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">    semantic_Analysis(T-&gt;ptr[<span class="number">0</span>]); <span class="comment">/* 分析语句Stmt */</span></span><br><span class="line">    T-&gt;code = T-&gt;ptr[<span class="number">0</span>]-&gt;code; <span class="comment">/* 将分析完毕的语句Stmt-code装回 */</span></span><br><span class="line">    T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;ptr[<span class="number">1</span>])</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">1</span>]-&gt;Snext, T-&gt;Snext); <span class="comment">//2条以上语句连接,S.next属性向下传递</span></span><br><span class="line">        T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset; <span class="comment">//顺序结构共享单元方式</span></span><br><span class="line">        semantic_Analysis(T-&gt;ptr[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//序列中第1条为表达式语句,返回语句,复合语句时,第2条前不需要标号</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ptr[<span class="number">0</span>]-&gt;kind == RETURN || T-&gt;ptr[<span class="number">0</span>]-&gt;kind == EXP_STMT || T-&gt;ptr[<span class="number">0</span>]-&gt;kind == COMP_STM)</span><br><span class="line">            T-&gt;code = merge(<span class="number">2</span>, T-&gt;code, T-&gt;ptr[<span class="number">1</span>]-&gt;code);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T-&gt;code = merge(<span class="number">3</span>, T-&gt;code, genLabel(T-&gt;ptr[<span class="number">0</span>]-&gt;Snext), T-&gt;ptr[<span class="number">1</span>]-&gt;code);</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ptr[<span class="number">1</span>]-&gt;width &gt; T-&gt;width)</span><br><span class="line">            T-&gt;width = T-&gt;ptr[<span class="number">1</span>]-&gt;width; <span class="comment">//顺序结构共享单元方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>newLabel</code> 会生成一个标号，用于记录 if 语句为真时跳转的位置</li>
<li>只要 STM_LIST 节点的 STM_LIST 子树存在，程序就会给 Stmt 子树分配一个标号</li>
<li>根据代码逻辑，在选择/循环语句后必定有一个 <code>LABEL labeln</code>，用于标记跳转</li>
</ul>
<p>SEMI：语句（Stmt-语句节点）</p>
<p>语句的类型很多，这里重点分析选择语句和循环语句</p>
<p><strong>选择/循环语句</strong></p>
<p>IF_THEN_ELSE：IF ELSE 语句（Exp，Stmt-语句节点，Stmt-语句节点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">if_then_else</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Etrue, newLabel()); <span class="comment">//设置条件语句真假转移位置</span></span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Efalse, newLabel());</span><br><span class="line">    T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;ptr[<span class="number">2</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">    boolExp(T-&gt;ptr[<span class="number">0</span>]); <span class="comment">//条件,要单独按短路代码处理</span></span><br><span class="line">    T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">1</span>]-&gt;Snext, T-&gt;Snext);</span><br><span class="line">    semantic_Analysis(T-&gt;ptr[<span class="number">1</span>]); <span class="comment">//if子句</span></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;width &lt; T-&gt;ptr[<span class="number">1</span>]-&gt;width)</span><br><span class="line">        T-&gt;width = T-&gt;ptr[<span class="number">1</span>]-&gt;width;</span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">2</span>]-&gt;Snext, T-&gt;Snext);</span><br><span class="line">    semantic_Analysis(T-&gt;ptr[<span class="number">2</span>]); <span class="comment">//else子句</span></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;width &lt; T-&gt;ptr[<span class="number">2</span>]-&gt;width)</span><br><span class="line">        T-&gt;width = T-&gt;ptr[<span class="number">2</span>]-&gt;width;</span><br><span class="line">    T-&gt;code = merge(<span class="number">6</span>, T-&gt;ptr[<span class="number">0</span>]-&gt;code, <span class="comment">/* Exp子句-code */</span></span><br><span class="line">                    genLabel(T-&gt;ptr[<span class="number">0</span>]-&gt;Etrue),</span><br><span class="line">                    T-&gt;ptr[<span class="number">1</span>]-&gt;code, <span class="comment">/* if子句-code */</span></span><br><span class="line">                    genGoto(T-&gt;Snext),</span><br><span class="line">                    genLabel(T-&gt;ptr[<span class="number">0</span>]-&gt;Efalse), </span><br><span class="line">                    T-&gt;ptr[<span class="number">2</span>]-&gt;code); <span class="comment">/* else子句-code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>genGoto</code>：生成 GOTO 语句，返回头指针</li>
<li>函数 <code>genLabel</code>：生成标号语句</li>
<li>函数 <code>boolExp</code> 用于判断 Exp 是否为真</li>
<li>在 “Exp子句” 中会调用一次 <code>genGoto</code>，根据条件跳转到 “if子句”，否则跳转到 “else子句”</li>
<li>在 “if子句” 中也会调用一次 <code>genGoto</code>，跳转到 “if-else语句” 结束</li>
<li>当 “else子句” 执行完毕时，“if-else语句” 结束</li>
<li>注意：程序将直接执行 <code>boolExp</code>，而不是去分析 <code>T-&gt;ptr[0]</code>，这样会导致函数调用无法生效（函数调用的核心代码在 Exp 中）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boolExp</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">opn</span> <span class="title">opn1</span>, <span class="title">opn2</span>, <span class="title">result</span>;</span></span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="keyword">int</span> rtn;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (T-&gt;kind)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> INT: <span class="comment">/* 非&#x27;0&#x27;则真 */</span></span><br><span class="line">                <span class="keyword">if</span> (T-&gt;type_int != <span class="number">0</span>)</span><br><span class="line">                    T-&gt;code = genGoto(T-&gt;Etrue);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    T-&gt;code = genGoto(T-&gt;Efalse);</span><br><span class="line">                T-&gt;width = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FLOAT: <span class="comment">/* 非&#x27;0&#x27;则真 */</span></span><br><span class="line">                <span class="keyword">if</span> (T-&gt;type_float != <span class="number">0.0</span>)</span><br><span class="line">                    T-&gt;code = genGoto(T-&gt;Etrue);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    T-&gt;code = genGoto(T-&gt;Efalse);</span><br><span class="line">                T-&gt;width = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ID: <span class="comment">/* 查符号表,获得符号表中的位置(不支持函数调用) */</span></span><br><span class="line">                rtn = searchSymbolTable(T-&gt;type_id);</span><br><span class="line">                <span class="keyword">if</span> (rtn == <span class="number">-1</span>)</span><br><span class="line">                    semantic_error(T-&gt;pos, T-&gt;type_id, <span class="string">&quot;变量未定义，语义错误&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (symbolTable.symbols[rtn].flag == <span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line">                    semantic_error(T-&gt;pos, T-&gt;type_id, <span class="string">&quot;是函数名，不是普通变量，语义错误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    opn1.kind = ID;</span><br><span class="line">                    <span class="built_in">strcpy</span>(opn1.id, symbolTable.symbols[rtn].alias);</span><br><span class="line">                    opn1.offset = symbolTable.symbols[rtn].offset;</span><br><span class="line">                    opn2.kind = INT;</span><br><span class="line">                    opn2.const_int = <span class="number">0</span>;</span><br><span class="line">                    result.kind = ID;</span><br><span class="line">                    <span class="built_in">strcpy</span>(result.id, T-&gt;Etrue);</span><br><span class="line">                    T-&gt;code = genIR(NEQ, opn1, opn2, result);</span><br><span class="line">                    T-&gt;code = merge(<span class="number">2</span>, T-&gt;code, genGoto(T-&gt;Efalse));</span><br><span class="line">                &#125;</span><br><span class="line">                T-&gt;width = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELOP: <span class="comment">/* 处理关系运算表达式,2个操作数都按基本表达式处理 */</span></span><br><span class="line">                T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">                Exp(T-&gt;ptr[<span class="number">0</span>]);</span><br><span class="line">                T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">                Exp(T-&gt;ptr[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;width &lt; T-&gt;ptr[<span class="number">1</span>]-&gt;width)</span><br><span class="line">                    T-&gt;width = T-&gt;ptr[<span class="number">1</span>]-&gt;width;</span><br><span class="line">                opn1.kind = ID;</span><br><span class="line">                <span class="built_in">strcpy</span>(opn1.id, symbolTable.symbols[T-&gt;ptr[<span class="number">0</span>]-&gt;place].alias);</span><br><span class="line">                opn1.offset = symbolTable.symbols[T-&gt;ptr[<span class="number">0</span>]-&gt;place].offset;</span><br><span class="line">                opn2.kind = ID;</span><br><span class="line">                <span class="built_in">strcpy</span>(opn2.id, symbolTable.symbols[T-&gt;ptr[<span class="number">1</span>]-&gt;place].alias);</span><br><span class="line">                opn2.offset = symbolTable.symbols[T-&gt;ptr[<span class="number">1</span>]-&gt;place].offset;</span><br><span class="line">                result.kind = ID;</span><br><span class="line">                <span class="built_in">strcpy</span>(result.id, T-&gt;Etrue);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(T-&gt;type_id, <span class="string">&quot;&lt;&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    op = JLT;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(T-&gt;type_id, <span class="string">&quot;&lt;=&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    op = JLE;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(T-&gt;type_id, <span class="string">&quot;&gt;&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    op = JGT;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(T-&gt;type_id, <span class="string">&quot;&gt;=&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    op = JGE;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(T-&gt;type_id, <span class="string">&quot;==&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    op = EQ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(T-&gt;type_id, <span class="string">&quot;!=&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    op = NEQ;</span><br><span class="line">                T-&gt;code = genIR(op, opn1, opn2, result);</span><br><span class="line">                T-&gt;code = merge(<span class="number">4</span>, T-&gt;ptr[<span class="number">0</span>]-&gt;code, T-&gt;ptr[<span class="number">1</span>]-&gt;code, T-&gt;code, genGoto(T-&gt;Efalse));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AND:</span><br><span class="line">            <span class="keyword">case</span> OR:</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;kind == AND)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Etrue, newLabel());</span><br><span class="line">                    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Efalse, T-&gt;Efalse);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Etrue, T-&gt;Etrue);</span><br><span class="line">                    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Efalse, newLabel());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">1</span>]-&gt;Etrue, T-&gt;Etrue);</span><br><span class="line">                <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">1</span>]-&gt;Efalse, T-&gt;Efalse);</span><br><span class="line">                T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">                boolExp(T-&gt;ptr[<span class="number">0</span>]);</span><br><span class="line">                T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">                boolExp(T-&gt;ptr[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;width &lt; T-&gt;ptr[<span class="number">1</span>]-&gt;width)</span><br><span class="line">                    T-&gt;width = T-&gt;ptr[<span class="number">1</span>]-&gt;width;</span><br><span class="line">                <span class="keyword">if</span> (T-&gt;kind == AND)</span><br><span class="line">                    T-&gt;code = merge(<span class="number">3</span>, T-&gt;ptr[<span class="number">0</span>]-&gt;code, genLabel(T-&gt;ptr[<span class="number">0</span>]-&gt;Etrue), T-&gt;ptr[<span class="number">1</span>]-&gt;code);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    T-&gt;code = merge(<span class="number">3</span>, T-&gt;ptr[<span class="number">0</span>]-&gt;code, genLabel(T-&gt;ptr[<span class="number">0</span>]-&gt;Efalse), T-&gt;ptr[<span class="number">1</span>]-&gt;code);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NOT: <span class="comment">/* 交换Efalse与Etrue */</span></span><br><span class="line">                <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Etrue, T-&gt;Efalse);</span><br><span class="line">                <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Efalse, T-&gt;Etrue);</span><br><span class="line">                boolExp(T-&gt;ptr[<span class="number">0</span>]);</span><br><span class="line">                T-&gt;code = T-&gt;ptr[<span class="number">0</span>]-&gt;code;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FUNC_CALL: <span class="comment">/* 函数调用(不支持) */</span></span><br><span class="line">                semantic_error(T-&gt;pos, T-&gt;type_id, <span class="string">&quot;暂时不支持函数调用&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WHILE：WHILE 语句（Exp，Stmt-语句节点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">while_dec</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Etrue, newLabel()); <span class="comment">//子结点继承属性的计算</span></span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Efalse, T-&gt;Snext);</span><br><span class="line">    T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">    boolExp(T-&gt;ptr[<span class="number">0</span>]); <span class="comment">//循环条件,要单独按短路代码处理</span></span><br><span class="line">    T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">1</span>]-&gt;Snext, newLabel());</span><br><span class="line">    semantic_Analysis(T-&gt;ptr[<span class="number">1</span>]); <span class="comment">//while子句-循环体</span></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;width &lt; T-&gt;ptr[<span class="number">1</span>]-&gt;width)</span><br><span class="line">        T-&gt;width = T-&gt;ptr[<span class="number">1</span>]-&gt;width;</span><br><span class="line">    T-&gt;code = merge(<span class="number">5</span>, genLabel(T-&gt;ptr[<span class="number">1</span>]-&gt;Snext), T-&gt;ptr[<span class="number">0</span>]-&gt;code,</span><br><span class="line">                    genLabel(T-&gt;ptr[<span class="number">0</span>]-&gt;Etrue), T-&gt;ptr[<span class="number">1</span>]-&gt;code, genGoto(T-&gt;ptr[<span class="number">1</span>]-&gt;Snext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序会在 “Exp子句” 之前写入一个 <code>LABEL labeln</code></li>
<li>在 “Exp子句” 中会调用一次 <code>genGoto</code>，根据条件跳转到 “while子句”，否则结束 “while语句”</li>
<li>当 “while子句” 结束时会自动跳转到 “Exp子句” 开始新一轮循环</li>
</ul>
<p>FOR：FOR 语句（FOR_DEC，Stmt-语句节点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">for_dec</span><span class="params">(struct node* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Etrue, newLabel()); </span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;Efalse, T-&gt;Snext);</span><br><span class="line">    T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">    semantic_Analysis(T-&gt;ptr[<span class="number">0</span>]); </span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">1</span>]-&gt;Snext, newLabel());</span><br><span class="line">    semantic_Analysis(T-&gt;ptr[<span class="number">1</span>]); </span><br><span class="line">    <span class="keyword">if</span> (T-&gt;width &lt; T-&gt;ptr[<span class="number">1</span>]-&gt;width)</span><br><span class="line">        T-&gt;width = T-&gt;ptr[<span class="number">1</span>]-&gt;width;</span><br><span class="line">    T-&gt;code = merge(<span class="number">7</span>, T-&gt;ptr[<span class="number">0</span>]-&gt;ptr[<span class="number">0</span>]-&gt;code, </span><br><span class="line">                    genLabel(T-&gt;ptr[<span class="number">1</span>]-&gt;Snext), T-&gt;ptr[<span class="number">0</span>]-&gt;ptr[<span class="number">1</span>]-&gt;code,</span><br><span class="line">                    genLabel(T-&gt;ptr[<span class="number">0</span>]-&gt;ptr[<span class="number">1</span>]-&gt;Etrue), T-&gt;ptr[<span class="number">1</span>]-&gt;code, </span><br><span class="line">                    T-&gt;ptr[<span class="number">0</span>]-&gt;ptr[<span class="number">2</span>]-&gt;code, genGoto(T-&gt;ptr[<span class="number">1</span>]-&gt;Snext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>for_dec</code> 调用后，函数 <code>for_list</code> 必被调用</li>
</ul>
<p>ForDec：FOR 语句列表（Exp，Exp，Exp）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">for_list</span><span class="params">(struct node* T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;ptr[<span class="number">0</span>]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;ptr[<span class="number">2</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;ptr[<span class="number">0</span>]-&gt;kind == ASSIGNOP)&#123;</span><br><span class="line">            semantic_Analysis(T-&gt;ptr[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            semantic_error(T-&gt;pos, <span class="string">&quot;&quot;</span>, <span class="string">&quot;for wrong\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;ptr[<span class="number">2</span>]-&gt;kind != ASSIGNOP)&#123;</span><br><span class="line">            semantic_Analysis(T-&gt;ptr[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            semantic_error(T-&gt;pos, <span class="string">&quot;&quot;</span>, <span class="string">&quot;for wrong\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset; </span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">1</span>]-&gt;Etrue, T-&gt;Etrue); </span><br><span class="line">    <span class="built_in">strcpy</span>(T-&gt;ptr[<span class="number">1</span>]-&gt;Efalse, T-&gt;Efalse);</span><br><span class="line">    boolExp(T-&gt;ptr[<span class="number">1</span>]);</span><br><span class="line">    T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width+T-&gt;ptr[<span class="number">1</span>]-&gt;width+T-&gt;ptr[<span class="number">2</span>]-&gt;width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不更新 <code>T-&gt;code</code>，方便交给 <code>for_dec</code> 函数来控制顺序</li>
</ul>
<p><strong>基础运算</strong></p>
<p>加减乘除：PLUS，MINUS，STAR，DIV（Exp，Exp）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">op_exp</span><span class="params">(struct node *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">opn</span> <span class="title">opn1</span>, <span class="title">opn2</span>, <span class="title">result</span>;</span></span><br><span class="line">    T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">    Exp(T-&gt;ptr[<span class="number">0</span>]); <span class="comment">/* 处理第一个表达式 */</span></span><br><span class="line">    T-&gt;ptr[<span class="number">1</span>]-&gt;offset = T-&gt;offset + T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">    Exp(T-&gt;ptr[<span class="number">1</span>]); <span class="comment">/* 处理第二个表达式 */</span></span><br><span class="line">    <span class="comment">/* 判断T-&gt;ptr[0],T-&gt;ptr[1]类型是否正确</span></span><br><span class="line"><span class="comment">    可能根据运算符生成不同形式的代码,给T的type赋值 */</span></span><br><span class="line">    T-&gt;type = INT, T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width + T-&gt;ptr[<span class="number">1</span>]-&gt;width + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    T-&gt;place = temp_add(newTemp(), LEV, T-&gt;type, <span class="string">&#x27;T&#x27;</span>, T-&gt;offset + T-&gt;ptr[<span class="number">0</span>]-&gt;width + T-&gt;ptr[<span class="number">1</span>]-&gt;width);</span><br><span class="line">    opn1.kind = ID;</span><br><span class="line">    <span class="built_in">strcpy</span>(opn1.id, symbolTable.symbols[T-&gt;ptr[<span class="number">0</span>]-&gt;place].alias);</span><br><span class="line">    opn1.type = T-&gt;ptr[<span class="number">0</span>]-&gt;type;</span><br><span class="line">    opn1.offset = symbolTable.symbols[T-&gt;ptr[<span class="number">0</span>]-&gt;place].offset;</span><br><span class="line">    opn2.kind = ID;</span><br><span class="line">    <span class="built_in">strcpy</span>(opn2.id, symbolTable.symbols[T-&gt;ptr[<span class="number">1</span>]-&gt;place].alias);</span><br><span class="line">    opn2.type = T-&gt;ptr[<span class="number">1</span>]-&gt;type;</span><br><span class="line">    opn2.offset = symbolTable.symbols[T-&gt;ptr[<span class="number">1</span>]-&gt;place].offset;</span><br><span class="line">    result.kind = ID;</span><br><span class="line">    <span class="built_in">strcpy</span>(result.id, symbolTable.symbols[T-&gt;place].alias);</span><br><span class="line">    result.type = T-&gt;type;</span><br><span class="line">    result.offset = symbolTable.symbols[T-&gt;place].offset;</span><br><span class="line">    T-&gt;code = merge(<span class="number">3</span>, T-&gt;ptr[<span class="number">0</span>]-&gt;code, T-&gt;ptr[<span class="number">1</span>]-&gt;code, genIR(T-&gt;kind, opn1, opn2, result)); </span><br><span class="line">    T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width + T-&gt;ptr[<span class="number">1</span>]-&gt;width + <span class="number">4</span>;<span class="comment">//INT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>temp_add</code> 生成的临时变量在赋值语句 ASSIGNOP 中才有作用</li>
<li>虽然 <code>T-&gt;code</code> 的次序为 <code>opnstr1 opnstr2 op</code>，但在 <code>print_IR</code> 函数打印时可以调整它的次序</li>
</ul>
<p>加加减减：PPLUS，MMINUS（Exp）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oop_exp</span><span class="params">(struct node *T)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">opn</span> <span class="title">opn1</span>, <span class="title">opn2</span>, <span class="title">result</span>;</span></span><br><span class="line">    T-&gt;ptr[<span class="number">0</span>]-&gt;offset = T-&gt;offset;</span><br><span class="line">    Exp(T-&gt;ptr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    T-&gt;type = INT, T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line"></span><br><span class="line">    opn1.kind = ID;</span><br><span class="line">    <span class="built_in">strcpy</span>(opn1.id, symbolTable.symbols[T-&gt;ptr[<span class="number">0</span>]-&gt;place].alias);</span><br><span class="line">    opn1.type = T-&gt;ptr[<span class="number">0</span>]-&gt;type;</span><br><span class="line">    opn1.offset = symbolTable.symbols[T-&gt;ptr[<span class="number">0</span>]-&gt;place].offset;</span><br><span class="line"></span><br><span class="line">    T-&gt;code = merge(<span class="number">2</span>, T-&gt;ptr[<span class="number">0</span>]-&gt;code, genIR(T-&gt;kind, opn1, opn2, result));</span><br><span class="line">    T-&gt;width = T-&gt;ptr[<span class="number">0</span>]-&gt;width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的完整代码有 1200 多行，就不放出了</p>
<p><strong>编译与结果</strong></p>
<p>编译命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flex lexer.l</span><br><span class="line">bison -d -v parser.y</span><br><span class="line">gcc display.c semantic_analysis.c parser.tab.c lex.yy.c -lfl -o test3</span><br></pre></td></tr></table></figure>
<p>测试文件1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = n;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">		n=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		n=<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fact(n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION fact :</span><br><span class="line">  PARAM var2</span><br><span class="line">  var3 := var2</span><br><span class="line">  temp1 := #<span class="number">1</span></span><br><span class="line">  IF var2 == temp1 GOTO label4</span><br><span class="line">  GOTO label5</span><br><span class="line">LABEL label4 :</span><br><span class="line">  temp2 := #<span class="number">2</span></span><br><span class="line">  var2 := temp2</span><br><span class="line">  GOTO label3</span><br><span class="line">LABEL label5 :</span><br><span class="line">  temp3 := #<span class="number">3</span></span><br><span class="line">  var2 := temp3</span><br><span class="line">LABEL label3 :</span><br><span class="line">  ARG var2</span><br><span class="line">  temp4 := CALL fact</span><br><span class="line">  RETURN var2</span><br><span class="line">LABEL label1 :</span><br></pre></td></tr></table></figure>
<p>测试文件2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c1 = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> c2 = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span> c3 = <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">int</span> c4 = <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span> c5 = <span class="number">9</span>;</span><br><span class="line">	</span><br><span class="line">	c3 = (c1+c2*c3)*(c5-c4);</span><br><span class="line">	c1++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION main :</span><br><span class="line">  PARAM var2</span><br><span class="line">  temp1 := #<span class="number">5</span></span><br><span class="line">  var3 := temp1</span><br><span class="line">  temp2 := #<span class="number">6</span></span><br><span class="line">  var4 := temp2</span><br><span class="line">  temp3 := #<span class="number">7</span></span><br><span class="line">  var5 := temp3</span><br><span class="line">  temp4 := #<span class="number">8</span></span><br><span class="line">  var6 := temp4</span><br><span class="line">  temp5 := #<span class="number">9</span></span><br><span class="line">  var7 := temp5</span><br><span class="line">  temp6 := var4 * var5</span><br><span class="line">  temp7 := var3 + temp6</span><br><span class="line">  temp8 := var7 - var6</span><br><span class="line">  temp9 := temp7 * temp8</span><br><span class="line">  var5 := temp9</span><br><span class="line">  var3 := var3 + <span class="number">1</span></span><br><span class="line">LABEL label1 :</span><br></pre></td></tr></table></figure>
<p>测试文件3：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c1 = <span class="number">5</span>;</span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(c1&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		n = n+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果3：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION main :</span><br><span class="line">  PARAM var3</span><br><span class="line">  temp1 := #<span class="number">5</span></span><br><span class="line">  var4 := temp1</span><br><span class="line">  temp2 := #<span class="number">0</span></span><br><span class="line">  var1 := temp2</span><br><span class="line">LABEL label5 :</span><br><span class="line">  temp3 := #<span class="number">1</span></span><br><span class="line">  IF var4 &gt; temp3 GOTO label4</span><br><span class="line">  GOTO label3</span><br><span class="line">LABEL label4 :</span><br><span class="line">  temp4 := #<span class="number">1</span></span><br><span class="line">  temp5 := var1 + temp4</span><br><span class="line">  var1 := temp5</span><br><span class="line">  GOTO label5</span><br><span class="line">LABEL label3 :</span><br><span class="line">  RETURN var1</span><br><span class="line">LABEL label1 :</span><br></pre></td></tr></table></figure>
<p>测试文件4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">10</span>;i&lt;n;i++)&#123;</span><br><span class="line">		n -= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION main :</span><br><span class="line">  PARAM var2</span><br><span class="line">  temp1 := #<span class="number">8</span></span><br><span class="line">  var3 := temp1</span><br><span class="line">  temp2 := #<span class="number">10</span></span><br><span class="line">  var4 := temp2</span><br><span class="line">LABEL label4 :</span><br><span class="line">  IF var4 &lt; var3 GOTO label3</span><br><span class="line">  GOTO label2</span><br><span class="line">LABEL label3 :</span><br><span class="line">  temp3 := #<span class="number">2</span></span><br><span class="line">  var3 := var3 - temp3</span><br><span class="line">  var4 := var4 + <span class="number">1</span></span><br><span class="line">  GOTO label4</span><br><span class="line">LABEL label2 :</span><br><span class="line">  RETURN var4</span><br><span class="line">LABEL label1 :</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/miscellaneous/" rel="tag"><i class="fa fa-tag"></i> miscellaneous</a>
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/Compilers-Principles/" rel="tag"><i class="fa fa-tag"></i> Compilers Principles</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/19/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lab2/" rel="prev" title="编译原理-Lab2">
      <i class="fa fa-chevron-left"></i> 编译原理-Lab2
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-Lab4/" rel="next" title="编译原理-Lab4">
      编译原理-Lab4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.</span> <span class="nav-text">第一个任务</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">281</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">146</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">3.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">59:28</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
