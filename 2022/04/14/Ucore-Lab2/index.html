<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="项目组成相对与实验一，实验二主要增加和修改的文件如上表所示。主要改动如下：  boot&#x2F;bootasm.S：增加了对计算机系统中物理内存布局的探测功能 kern&#x2F;init&#x2F;entry.S：根据临时段表重新暂时建立好新的段空间，为进行分页做好准备 kern&#x2F;mm&#x2F;default_pmm.[ch]：提供基本的基于链表方法的物理内存管理（分配单位为页，即4096字节） kern&#x2F;mm&#x2F;pmm.[ch]：">
<meta property="og:type" content="article">
<meta property="og:title" content="Ucore-Lab2">
<meta property="og:url" content="http://example.com/2022/04/14/Ucore-Lab2/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="项目组成相对与实验一，实验二主要增加和修改的文件如上表所示。主要改动如下：  boot&#x2F;bootasm.S：增加了对计算机系统中物理内存布局的探测功能 kern&#x2F;init&#x2F;entry.S：根据临时段表重新暂时建立好新的段空间，为进行分页做好准备 kern&#x2F;mm&#x2F;default_pmm.[ch]：提供基本的基于链表方法的物理内存管理（分配单位为页，即4096字节） kern&#x2F;mm&#x2F;pmm.[ch]：">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-14T14:55:28.000Z">
<meta property="article:modified_time" content="2023-03-16T15:42:52.177Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="miscellaneous">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="Kernel">
<meta property="article:tag" content="Ucore">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/04/14/Ucore-Lab2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Ucore-Lab2 | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/14/Ucore-Lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Ucore-Lab2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-14 22:55:28" itemprop="dateCreated datePublished" datetime="2022-04-14T22:55:28+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:42:52" itemprop="dateModified" datetime="2023-03-16T23:42:52+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="项目组成"><a href="#项目组成" class="headerlink" title="项目组成"></a>项目组成</h2><p>相对与实验一，实验二主要增加和修改的文件如上表所示。主要改动如下：</p>
<ul>
<li>boot/bootasm.S：增加了对计算机系统中物理内存布局的探测功能</li>
<li>kern/init/entry.S：根据临时段表重新暂时建立好新的段空间，为进行分页做好准备</li>
<li>kern/mm/default_pmm.[ch]：提供基本的基于链表方法的物理内存管理（分配单位为页，即4096字节）</li>
<li>kern/mm/pmm.[ch]：pmm.h定义物理内存管理类框架struct pmm_manager，基于此通用框架可以实现不同的物理内存管理策略和算法（default_pmm.[ch] 实现了一个基于此框架的简单物理内存管理策略），pmm.c包含了对此物理内存管理类框架的访问，以及与建立、修改、访问页表相关的各种函数实现</li>
<li>kern/sync/sync.h：为确保内存管理修改相关数据时不被中断打断，提供两个功能，一个是保存eflag寄存器中的中断屏蔽位信息并屏蔽中断的功能，另一个是根据保存的中断屏蔽位信息来使能中断的功能（可不用细看）</li>
<li>libs/list.h：定义了通用双向链表结构以及相关的查找、插入等基本操作，这是建立基于链表方法的物理内存管理（以及其他内核功能）的基础，其他有类似双向链表需求的内核功能模块可直接使用list.h中定义的函数</li>
<li>libs/atomic.h：定义了对一个变量进行读写的原子操作，确保相关操作不被中断打断（可不用细看）</li>
<li>tools/kernel.ld：ld形成执行文件的地址所用到的链接脚本，修改了ucore的起始入口和代码段的起始地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  lab2 make qemu</span><br><span class="line">WARNING: Image format was <span class="keyword">not</span> specified <span class="keyword">for</span> <span class="string">&#x27;bin/ucore.img&#x27;</span> <span class="keyword">and</span> probing guessed raw.</span><br><span class="line">         Automatically detecting the format is dangerous <span class="keyword">for</span> raw images, write operations on block <span class="number">0</span> will be restricted.</span><br><span class="line">         Specify the <span class="string">&#x27;raw&#x27;</span> format explicitly to remove the restrictions.</span><br><span class="line">(THU.CST) os is loading ...</span><br><span class="line"></span><br><span class="line">Special kernel symbols:</span><br><span class="line">  entry  <span class="number">0xc0100036</span> (phys)</span><br><span class="line">  etext  <span class="number">0xc0105d24</span> (phys)</span><br><span class="line">  edata  <span class="number">0xc011b000</span> (phys)</span><br><span class="line">  end    <span class="number">0xc011bf28</span> (phys)</span><br><span class="line">Kernel executable memory footprint: <span class="number">112</span>KB</span><br><span class="line">memory management: default_pmm_manager</span><br><span class="line">e820map:</span><br><span class="line">  memory: <span class="number">0009f</span>c00, [<span class="number">00000000</span>, <span class="number">0009f</span>bff], type = <span class="number">1.</span></span><br><span class="line">  memory: <span class="number">00000400</span>, [<span class="number">0009f</span>c00, <span class="number">0009f</span>fff], type = <span class="number">2.</span></span><br><span class="line">  memory: <span class="number">00010000</span>, [<span class="number">000f</span>0000, <span class="number">000f</span>ffff], type = <span class="number">2.</span></span><br><span class="line">  memory: <span class="number">07</span>ee0000, [<span class="number">00100000</span>, <span class="number">07f</span>dffff], type = <span class="number">1.</span></span><br><span class="line">  memory: <span class="number">00020000</span>, [<span class="number">07f</span>e0000, <span class="number">07f</span>fffff], type = <span class="number">2.</span></span><br><span class="line">  memory: <span class="number">00040000</span>, [fffc0000, ffffffff], type = <span class="number">2.</span></span><br><span class="line">kernel panic at kern/mm/default_pmm.c:<span class="number">277</span>:</span><br><span class="line">    assertion failed: (p0 = alloc_page()) == p2 - <span class="number">1</span></span><br><span class="line"><span class="built_in">stack</span> trackback:</span><br><span class="line">Welcome to the kernel debug monitor!!</span><br></pre></td></tr></table></figure>
<h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><p>本次实验主要完成ucore内核对物理内存的管理工作</p>
<ul>
<li>为了完成物理内存管理，这里首先需要 <strong>探测可用的物理内存资源</strong> ，了解到物理内存位于什么地方，有多大之后，就以固定页面大小来划分整个物理内存空间，并准备以此为最小内存分配单位来管理整个物理内存，管理在内核运行过程中每页内存，设定其可用状态（free的，used的，还是reserved的）</li>
<li>接着 ucore kernel 就要建立页表， 启动分页机制，让CPU的MMU把预先建立好的页表中的页表项读入到TLB中，根据页表项描述的虚拟页（Page）与物理页帧（Page Frame）的对应关系完成CPU对内存的读、写和执行操作</li>
</ul>
<h2 id="探测系统物理内存布局"><a href="#探测系统物理内存布局" class="headerlink" title="探测系统物理内存布局"></a>探测系统物理内存布局</h2><p>操作系统需要知道了解整个计算机系统中的物理内存如何分布的，哪些被可用，哪些不可用，其基本方法是通过 BIOS 中断调用来帮助完成的</p>
<p>Linux 有多种办法可以获取内存容量，如果一种方式失效，它就会尝试其他办法</p>
<p>在 Linux 2.6 内核中，是用 detect_memory 函数来获取内存容量的，其函数在本质上是通过调用 BIOS 中断 0x15 实现的，分别是 BIOS 中断 0x15 的3个子功能，子功能号要存放到寄存器 EAX AX 中，如下：</p>
<ul>
<li>EAX=0xE820：遍历主机上全部内存</li>
<li>AX=0xE801：分别检测低 15MB 和 16MB ~ 4GB 的内存，最大支持 4GB</li>
<li>AH=0x88：最多检测出 64MB 内存，如果实际内存超过此容量也按照 64MB 返回 </li>
</ul>
<h2 id="uCore物理页结构"><a href="#uCore物理页结构" class="headerlink" title="uCore物理页结构"></a>uCore物理页结构</h2><p>结构体 Page：用于管理各个内存页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span> <span class="comment">/* list_entry其实是两个指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> <span class="title">list_entry_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment">* struct Page - Page descriptor structures. Each Page describes one</span></span><br><span class="line"><span class="comment">* physical page. In kern/mm/pmm.h, you can find lots of useful functions</span></span><br><span class="line"><span class="comment">* that convert Page to other data types, such as phyical address.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ref;                <span class="comment">// 当前页被引用的次数,与内存共享有关</span></span><br><span class="line">  <span class="keyword">uint32_t</span> flags;         <span class="comment">// 标志位的集合,与eflags寄存器类似</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> property;  <span class="comment">// 空闲的连续page数量,这个成员只会用在连续空闲page中的第一个page</span></span><br><span class="line">  <span class="keyword">list_entry_t</span> page_link; <span class="comment">// 两个分别指向上一个和下一个非连续空闲页的两个指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在lab2中，flags 可以设置的位只有<code>reserved</code>位和<code>Property</code>位<ul>
<li><code>reserved</code>位表示：当前页是否被保留，一旦保留该页，则该页无法用于分配</li>
<li><code>Property</code>位表示：当前页是否已被分配（为1则表示已分配）</li>
</ul>
</li>
</ul>
<h2 id="uCore虚拟页结构"><a href="#uCore虚拟页结构" class="headerlink" title="uCore虚拟页结构"></a>uCore虚拟页结构</h2><p>每个页表项（PTE）都由一个32位整数来存储数据，其结构如下：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      31-12      9-11     8    7    6   5   4      3    2   1   0</span><br><span class="line">+<span class="params">--------------</span>+<span class="params">-------</span>+<span class="params">-----</span>+<span class="params">----</span>+<span class="params">---</span>+<span class="params">---</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">---</span>+<span class="params">---</span>+<span class="params">---</span>+</span><br><span class="line">|     Offset   | Avail | MBZ | PS | D | A | PCD | PWT | U | W | P |</span><br><span class="line">+<span class="params">--------------</span>+<span class="params">-------</span>+<span class="params">-----</span>+<span class="params">----</span>+<span class="params">---</span>+<span class="params">---</span>+<span class="params">-----</span>+<span class="params">-----</span>+<span class="params">---</span>+<span class="params">---</span>+<span class="params">---</span>+</span><br></pre></td></tr></table></figure>
<ul>
<li>0 - <strong>P</strong>resent：表示当前PTE所指向的物理页面是否驻留在内存中</li>
<li>1 - <strong>W</strong>riteable：表示是否允许读写</li>
<li>2 - <strong>U</strong>ser：表示该页的访问所需要的特权级（即User(ring 3)是否允许访问）</li>
<li>3 - <strong>P</strong>ageWriteThough：表示是否使用write through缓存写策略</li>
<li>4 - <strong>P</strong>ageCacheDisable：表示是否 <strong>不对</strong> 该页进行缓存</li>
<li>5 - <strong>A</strong>ccess：表示该页是否已被访问过</li>
<li>6 - <strong>D</strong>irty：表示该页是否已被修改</li>
<li>7 - <strong>P</strong>ageSize：表示该页的大小</li>
<li>8 - <strong>M</strong>ustBeZero：该位必须保留为0</li>
<li>9-11 - <strong>A</strong>vailable：第9-11这三位并没有被内核或中断所使用，可保留给OS使用</li>
<li>12-31 - <strong>O</strong>ffset：目标地址的后20位</li>
</ul>
<h2 id="uCore物理页链表"><a href="#uCore物理页链表" class="headerlink" title="uCore物理页链表"></a>uCore物理页链表</h2><p>结构体 free_area_t：用于定义两个关键的全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* free_area_t - 维护一个双向链表来记录空闲（未使用的）页 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> free_list;         <span class="comment">// 链表头部</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_free;           <span class="comment">// 表示空闲页的数量</span></span><br><span class="line">&#125; <span class="keyword">free_area_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然 ucore 把这两个变量放入了结构体，但是它还是喜欢把它们当做全局变量来用</li>
</ul>
<p>uCore物理页的插链&amp;脱链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">list_entry_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">list_next</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listelm-&gt;next; <span class="comment">/* 指向next */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* list_add是list_add_after的外包装 */</span></span><br><span class="line">list_add(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    <span class="comment">// listelm:	目标链表结点</span></span><br><span class="line">    <span class="comment">// elm: 	将要插入的对象(list_entry_t *elm == NULL)</span></span><br><span class="line">    list_add_after(listelm, elm); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结点-&gt;prev  &lt;--1--&gt;  结点  &lt;--2--&gt;  结点-&gt;next */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* 插入&quot;2&quot;号位置 */</span></span><br><span class="line">list_add_after(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    __list_add(elm, listelm, listelm-&gt;next); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* 插入&quot;1&quot;号位置 */</span></span><br><span class="line">list_add_before(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    __list_add(elm, listelm-&gt;prev, listelm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* 正真执行添加操作的是__list_add */</span></span><br><span class="line">__list_add(<span class="keyword">list_entry_t</span> *elm, <span class="keyword">list_entry_t</span> *prev, <span class="keyword">list_entry_t</span> *next) &#123;</span><br><span class="line">    prev-&gt;next = next-&gt;prev = elm;</span><br><span class="line">    elm-&gt;next = next;</span><br><span class="line">    elm-&gt;prev = prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* list_del是__list_del的外包装 */</span></span><br><span class="line">list_del(<span class="keyword">list_entry_t</span> *listelm) &#123;</span><br><span class="line">    __list_del(listelm-&gt;prev, listelm-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="comment">/* 正真执行脱链操作的是__list_del */</span></span><br><span class="line">__list_del(<span class="keyword">list_entry_t</span> *prev, <span class="keyword">list_entry_t</span> *next) &#123;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="uCore内存管理类"><a href="#uCore内存管理类" class="headerlink" title="uCore内存管理类"></a>uCore内存管理类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;                                 <span class="comment">// 名字</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(<span class="keyword">void</span>);                               <span class="comment">// 初始化             </span></span><br><span class="line">    <span class="keyword">void</span> (*init_memmap)(struct Page *base, <span class="keyword">size_t</span> n); <span class="comment">// 根据初始物理内存空间设置描述和管理数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *(*<span class="title">alloc_pages</span>)(<span class="title">size_t</span> <span class="title">n</span>);</span>            <span class="comment">// 分配页</span></span><br><span class="line">    <span class="keyword">void</span> (*free_pages)(struct Page *base, <span class="keyword">size_t</span> n);  <span class="comment">// 释放页</span></span><br><span class="line">    <span class="keyword">size_t</span> (*nr_free_pages)(<span class="keyword">void</span>);                    <span class="comment">// 返回空闲页数</span></span><br><span class="line">    <span class="keyword">void</span> (*check)(<span class="keyword">void</span>);                              <span class="comment">// 检验管理器的正确性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDXSHIFT        22                     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDX(la) ((((uintptr_t)(la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF) </span></span><br><span class="line"><span class="comment">/* 获取&quot;页目录项PDE&quot;的索引:用来在页目录中定位一个页表 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTXSHIFT        12  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTX(la) ((((uintptr_t)(la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"><span class="comment">/* 获取&quot;页表项PTE&quot;的索引:用来在页表中定位具体的物理页 */</span></span><br></pre></td></tr></table></figure>
<p>还有一些关于内存管理的宏定义：</p>
<ul>
<li>PDX(la)：可以用来获取 Directory，对应页目录项的索引</li>
<li>PTX(la)：可以用来获取 Table，对应表项（物理页）的索引</li>
<li>KADDR(pa)：返回物理地址pa对应的虚拟地址</li>
<li>set_page_ref(page,1)：设置此页被引用一次</li>
<li>page2pa(page)：得到page管理的那一页的物理地址</li>
<li>struct Page * alloc_page()：分配一页出来</li>
<li>memset(void * s, char c, size_t n)：设置s指向地址的前面n个字节为‘c’</li>
<li>PTE_P 0x001 ：表示物理内存页存在</li>
<li>PTE_W 0x002 ：表示物理内存页内容可写</li>
<li>PTE_U 0x004 ：表示可以读取对应地址的物理内存页内容</li>
</ul>
<h2 id="练习0-把-lab1-的内容复制粘贴到-lab2"><a href="#练习0-把-lab1-的内容复制粘贴到-lab2" class="headerlink" title="练习0-把 lab1 的内容复制粘贴到 lab2"></a>练习0-把 lab1 的内容复制粘贴到 lab2</h2><h2 id="练习1-实现-first-fit-连续物理内存分配算法"><a href="#练习1-实现-first-fit-连续物理内存分配算法" class="headerlink" title="练习1-实现 first-fit 连续物理内存分配算法"></a>练习1-实现 first-fit 连续物理内存分配算法</h2><p>分析 ucore 自带的代码：</p>
<p><strong>default_init_memmap：</strong>根据每个物理页帧（一个地址连续的 4K 字节大小单元内存）的情况来建立空闲页链表，且空闲页块应该是根据地址高低形成一个有序链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PageReserved(page)          test_bit(PG_reserved, &amp;((page)-&gt;flags))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">default_init_memmap</span><span class="params">(struct Page *base, <span class="keyword">size_t</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="comment">/* base:基地址,n:表示要初始化n个页 */</span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>); <span class="comment">/* 断言表达式&quot;n&gt;0&quot;成立,否则调用panic来终止程序 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(PageReserved(p)); <span class="comment">/* 进行检查(这里不需要关心) */</span></span><br><span class="line">        p-&gt;flags = p-&gt;property = <span class="number">0</span>; <span class="comment">/* 设置flags &amp; 置空property(只有base page的property才会起作用) */</span></span><br><span class="line">        set_page_ref(p, <span class="number">0</span>); <span class="comment">/* 设置该物理页面的引用次数为0 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;property = n; <span class="comment">/* 在base page中设置空闲的连续page数量 */</span></span><br><span class="line">    SetPageProperty(base); <span class="comment">/* 设置当前页为空闲 */</span></span><br><span class="line">    nr_free += n; <span class="comment">/* nr_free:空闲页的总数 */</span></span><br><span class="line">    list_add(&amp;free_list, &amp;(base-&gt;page_link)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>基于 base 来确定空闲页基地址，根据 n 来获取所需空闲页的数目</li>
<li>只有 base page 的 property 才会起作用，其他 page 的 property 置为0</li>
<li>进行一系列初始化，最后执行 list_add 添加入空闲页链表</li>
</ul>
<p><strong>default_alloc_pages：</strong>分配指定数目的内存页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct Page *</span></span><br><span class="line"><span class="function"><span class="title">default_alloc_pages</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* n:表示要分配n个页 */</span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>); <span class="comment">/* 断言表达式&quot;n&gt;0&quot;成立,否则调用panic来终止程序 */</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* 申请内存页的数目&gt;空闲内存页的数目 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = &amp;free_list; <span class="comment">/* 初始化le为链表头部 */</span></span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123; <span class="comment">/* 实现first-fit算法 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, page_link); <span class="comment">/* 根据链表信息获取该page的位置 */</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;property &gt;= n) &#123; <span class="comment">/* 如果空闲页够用,就进行分配 */</span></span><br><span class="line">            page = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123; <span class="comment">/* 成功获取空闲页 */</span></span><br><span class="line">        list_del(&amp;(page-&gt;page_link)); <span class="comment">/* 脱链操作 */</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;property &gt; n) &#123; <span class="comment">/* 检查是否有剩余 */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page + n; <span class="comment">/* 指向剩下的空闲页 */</span></span><br><span class="line">            p-&gt;property = page-&gt;property - n; <span class="comment">/* 更新base page-&gt;property */</span></span><br><span class="line">            list_add(&amp;free_list, &amp;(p-&gt;page_link)); <span class="comment">/* 重新链回链表 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        nr_free -= n; <span class="comment">/* 更新空闲页的数目 */</span></span><br><span class="line">        ClearPageProperty(page); <span class="comment">/* 将分配出去的内存页标记为非空闲 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page; <span class="comment">/* 返回目标页 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先检查空闲页的总数目和所需数目的关系</li>
<li>然后采用 first-fit 算法来获取合适空闲页</li>
<li>最后检查该空闲块是否剩余，如果剩余直接插到链表头部</li>
</ul>
<p><strong>default_free_pages：</strong>释放目标n个内存页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">default_free_pages</span><span class="params">(struct Page *base, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* base:基地址,n:表示要初始化n个页 */</span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123; <span class="comment">/* 把将要被释放的内存页的各个字段置空 */</span></span><br><span class="line">        assert(!PageReserved(p) &amp;&amp; !PageProperty(p));</span><br><span class="line">        p-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;property = n; <span class="comment">/* 更新base page-&gt;property */</span></span><br><span class="line">    SetPageProperty(base); <span class="comment">/* 设置当前页为空闲 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;free_list);  <span class="comment">/* 初始化le为链表头部 */</span></span><br><span class="line">    <span class="keyword">while</span> (le != &amp;free_list) &#123; <span class="comment">/* 遍历整个链表,找寻是否有相邻的空闲页 */</span></span><br><span class="line">        p = le2page(le, page_link); <span class="comment">/* 根据链表信息获取该page的位置 */</span></span><br><span class="line">        le = list_next(le); </span><br><span class="line">        <span class="keyword">if</span> (base + base-&gt;property == p) &#123; <span class="comment">/* 在base的高地址处有相邻的空闲页 */</span></span><br><span class="line">            base-&gt;property += p-&gt;property; <span class="comment">/* 合并空闲页,更新base page-&gt;property */</span></span><br><span class="line">            ClearPageProperty(p); <span class="comment">/* 将被合并的空闲页标记为不可用 */</span></span><br><span class="line">            list_del(&amp;(p-&gt;page_link)); <span class="comment">/* 脱链 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p + p-&gt;property == base) &#123; <span class="comment">/* 在base的低地址处有相邻的空闲页 */</span></span><br><span class="line">            p-&gt;property += base-&gt;property; </span><br><span class="line">            ClearPageProperty(base); </span><br><span class="line">            base = p; <span class="comment">/* 更新base */</span></span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nr_free += n; <span class="comment">/* 更新空闲页数目 */</span></span><br><span class="line">    list_add(&amp;free_list, &amp;(base-&gt;page_link)); <span class="comment">/* 插入链表头 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先把将要被释放的内存页的各个字段置空</li>
<li>然后遍历整个链表，合并相邻的空闲页</li>
<li>最后更新空闲页数目，并且把合并后的空闲页插入到链表的头部</li>
</ul>
<p>修改 ucore 的代码：</p>
<ul>
<li>问题的关键就在于“剩余空闲页插入链表头”这一过程</li>
<li>first-fit 算法要求将空闲内存块<strong>按照地址从小到大的方式</strong>连起来，那么“插入链表头”的操作想必会影响链表的物理地址次序</li>
<li>所以在 default_alloc_pages 和 default_free_pages 中关于“插入链表头”的操作都要修改</li>
</ul>
<p><strong>default_alloc_pages：</strong>（修改后）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct Page *</span></span><br><span class="line"><span class="function"><span class="title">default_alloc_pages</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, page_link);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;property &gt;= n) &#123;</span><br><span class="line">            page = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;property &gt; n) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page + n;</span><br><span class="line">            p-&gt;property = page-&gt;property - n;</span><br><span class="line">            list_add(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">        list_del(&amp;(page-&gt;page_link)); <span class="comment">/* 注意:这里修改了脱链的位置 */</span></span><br><span class="line">        nr_free -= n;</span><br><span class="line">        ClearPageProperty(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>default_free_pages：</strong>（部分&amp;修改后）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(le = list_next(&amp;free_list); le != &amp;free_list; le = list_next(le))</span><br><span class="line">&#123;</span><br><span class="line">    p = le2page(le, page_link);</span><br><span class="line">    <span class="keyword">if</span> (base + base-&gt;property &lt;= p) &#123;</span><br><span class="line">        assert(base + base-&gt;property != p);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">list_add_before(le, &amp;(base-&gt;page_link));</span><br></pre></td></tr></table></figure>
<h2 id="练习2-实现寻找虚拟地址对应的页表项"><a href="#练习2-实现寻找虚拟地址对应的页表项" class="headerlink" title="练习2- 实现寻找虚拟地址对应的页表项"></a>练习2- 实现寻找虚拟地址对应的页表项</h2><p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系</p>
<p><code>get_pte</code> 函数是设置页表项环节中的一个重要步骤，此函数找到一个虚地址对应的二级页表项的内核虚拟地址，如果此二级页表项不存在，则分配一个包含此项的二级页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> * <span class="comment">/* 获取pte(页表项,页表) */</span></span><br><span class="line">get_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create) &#123;</span><br><span class="line">    <span class="comment">// pgdir:进程自己页表的虚拟地址,将在进程创建页表时为其赋值</span></span><br><span class="line">    <span class="comment">// la:线性地址,虚拟地址</span></span><br><span class="line">    <span class="comment">// create:信息标记位,根据create位判断是否创建这个二级页表</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = <span class="literal">NULL</span>;   </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;         </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>查找页面目录条目</li>
<li>检查输入是否不存在</li>
<li>检查是否需要创建，然后为页表分配页</li>
<li>设置页面参考</li>
<li>获取页面的线性地址</li>
<li>使用 memset 清除页面内容</li>
<li>设置页面目录项的权限</li>
<li>返回页表项</li>
</ul>
<p>接下来就要完善这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> * <span class="comment">/* 获取pte(页表项,页表) */</span></span><br><span class="line">get_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create) &#123;</span><br><span class="line">    <span class="comment">// pgdir:进程自己页表的虚拟地址,将在进程创建页表时为其赋值</span></span><br><span class="line">    <span class="comment">// la:线性地址,虚拟地址</span></span><br><span class="line">    <span class="comment">// create:信息标记位,根据create位判断是否创建这个二级页表</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 </span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = <span class="literal">NULL</span>;   </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;              </span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;          </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = &amp;pgdir[PDX(la)]; </span><br><span class="line">    <span class="comment">/* 根据la(线性地址,虚拟地址)利用PDX获取对应&quot;页目录项PDE的索引&quot; */</span></span><br><span class="line">    <span class="comment">/* 放入pgdir(进程自己一级页表的虚拟地址)中,索引出对应&quot;页目录项PDE的物理地址&quot; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(*pdep &amp; PTE_P)) &#123; <span class="comment">/* 如果这个物理内存页pdep不存在 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!create || (page = alloc_page()) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="comment">/* 检查是否需要创建 || 检查alloc_page()是否分配成功 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set_page_ref(page, <span class="number">1</span>); <span class="comment">// 要查找该页表,则引用次数+1</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = page2pa(page); <span class="comment">// 得到该页的物理地址</span></span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE); <span class="comment">// 利用KADDR转成虚拟地址,并初始化</span></span><br><span class="line">        *pdep = pa | PTE_U | PTE_W | PTE_P; <span class="comment">// 设置页面目录项的权限(存在,可读,可写)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;((<span class="keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</span><br><span class="line">    <span class="comment">// 用KADDR返回二级页表所对应的虚拟地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习3-释放某虚地址所在的物理页并取消对应的二级页表项映射"><a href="#练习3-释放某虚地址所在的物理页并取消对应的二级页表项映射" class="headerlink" title="练习3-释放某虚地址所在的物理页并取消对应的二级页表项映射"></a>练习3-释放某虚地址所在的物理页并取消对应的二级页表项映射</h2><p>当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构 Page 做相关的清除处理，使得此物理内存页成为空闲，另外还需把表示虚地址与物理地址对应关系的二级页表项清除</p>
<p>我们的任务就是补全一下这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;                     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>检查此页表条目是否存在</li>
<li>找到与 pte 对应的页面</li>
<li>减少页面引用</li>
<li>并在页面引用达到0时释放此页面</li>
<li>清除第二页表格条目</li>
<li>齐平 tlb</li>
</ul>
<p>接下来就完善这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> free_page(page) free_pages(page, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">free_pages</span><span class="params">(struct Page *base, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        pmm_manager-&gt;free_pages(base, n);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_ref_dec</span><span class="params">(struct Page *page)</span> </span>&#123;</span><br><span class="line">    page-&gt;ref -= <span class="number">1</span>; <span class="comment">/* page-&gt;ref:当前页被引用的次数,与内存共享有关 */</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pgdir:进程自己页表的虚拟地址,将在进程创建页表时为其赋值</span></span><br><span class="line">    <span class="comment">// la:线性地址,虚拟地址</span></span><br><span class="line">    <span class="comment">// ptep:将要被释放的页表条目(二级页表)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;                      </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123; <span class="comment">/* 检查此页表条目是否存在 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep); <span class="comment">/* 获取该页表条目所对应的物理地址 */</span></span><br><span class="line">        <span class="keyword">if</span> (page_ref_dec(page) == <span class="number">0</span>) &#123; <span class="comment">/* 确保该物理页没有被共享 */</span></span><br><span class="line">            free_page(page); <span class="comment">/* 释放当前物理页 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        *ptep = <span class="number">0</span>; <span class="comment">/* 置空该页表条目 */</span></span><br><span class="line">        tlb_invalidate(pgdir, la); <span class="comment">/* 刷新TLB内的数据 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  lab2 make grade</span><br><span class="line">Check PMM:               (<span class="number">2.2</span>s)</span><br><span class="line">  -check pmm:                                OK</span><br><span class="line">  -check page table:                         OK</span><br><span class="line">  -check ticks:                              OK</span><br><span class="line">Total Score: <span class="number">50</span>/<span class="number">50</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/miscellaneous/" rel="tag"><i class="fa fa-tag"></i> miscellaneous</a>
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/Kernel/" rel="tag"><i class="fa fa-tag"></i> Kernel</a>
              <a href="/tags/Ucore/" rel="tag"><i class="fa fa-tag"></i> Ucore</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/13/%E6%A1%8C%E5%AE%A0%E5%BC%80%E5%8F%91/" rel="prev" title="不务正业系列：桌宠开发（偶尔更新）">
      <i class="fa fa-chevron-left"></i> 不务正业系列：桌宠开发（偶尔更新）
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/15/Ucore-Lab3/" rel="next" title="Ucore-Lab3">
      Ucore-Lab3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%84%E6%88%90"><span class="nav-number">1.</span> <span class="nav-text">项目组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">物理内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A2%E6%B5%8B%E7%B3%BB%E7%BB%9F%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">3.</span> <span class="nav-text">探测系统物理内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uCore%E7%89%A9%E7%90%86%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">uCore物理页结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uCore%E8%99%9A%E6%8B%9F%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">uCore虚拟页结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uCore%E7%89%A9%E7%90%86%E9%A1%B5%E9%93%BE%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">uCore物理页链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uCore%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text">uCore内存管理类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A00-%E6%8A%8A-lab1-%E7%9A%84%E5%86%85%E5%AE%B9%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%88%B0-lab2"><span class="nav-number">8.</span> <span class="nav-text">练习0-把 lab1 的内容复制粘贴到 lab2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01-%E5%AE%9E%E7%8E%B0-first-fit-%E8%BF%9E%E7%BB%AD%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">练习1-实现 first-fit 连续物理内存分配算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02-%E5%AE%9E%E7%8E%B0%E5%AF%BB%E6%89%BE%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%AF%B9%E5%BA%94%E7%9A%84%E9%A1%B5%E8%A1%A8%E9%A1%B9"><span class="nav-number">10.</span> <span class="nav-text">练习2- 实现寻找虚拟地址对应的页表项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A03-%E9%87%8A%E6%94%BE%E6%9F%90%E8%99%9A%E5%9C%B0%E5%9D%80%E6%89%80%E5%9C%A8%E7%9A%84%E7%89%A9%E7%90%86%E9%A1%B5%E5%B9%B6%E5%8F%96%E6%B6%88%E5%AF%B9%E5%BA%94%E7%9A%84%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E9%A1%B9%E6%98%A0%E5%B0%84"><span class="nav-number">11.</span> <span class="nav-text">练习3-释放某虚地址所在的物理页并取消对应的二级页表项映射</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">301</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">155</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">64:18</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
