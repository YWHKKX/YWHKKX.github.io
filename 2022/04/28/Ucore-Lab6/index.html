<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CPU资源的时分复用进程切换：CPU资源的当前占用者切换  保存当前进程在PCB中的执行上下文（CPU状态） 恢复下一个进程的执行上下文  处理机调度：  从就绪队列中挑选下一个占用CPU运行的进程 从多个可用CPU中挑选就绪进程可使用的CPU资源  调度程序：挑选就绪进程的内核函数  调度策略：依据什么原理挑选进程&#x2F;线程 调度时机：什么时候进行调度  内核运行调度程序的条件：  进程从运行状态切">
<meta property="og:type" content="article">
<meta property="og:title" content="Ucore-Lab6">
<meta property="og:url" content="http://example.com/2022/04/28/Ucore-Lab6/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="CPU资源的时分复用进程切换：CPU资源的当前占用者切换  保存当前进程在PCB中的执行上下文（CPU状态） 恢复下一个进程的执行上下文  处理机调度：  从就绪队列中挑选下一个占用CPU运行的进程 从多个可用CPU中挑选就绪进程可使用的CPU资源  调度程序：挑选就绪进程的内核函数  调度策略：依据什么原理挑选进程&#x2F;线程 调度时机：什么时候进行调度  内核运行调度程序的条件：  进程从运行状态切">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-27T16:42:41.000Z">
<meta property="article:modified_time" content="2023-03-16T15:43:08.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="miscellaneous">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="Kernel">
<meta property="article:tag" content="Ucore">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/04/28/Ucore-Lab6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Ucore-Lab6 | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/28/Ucore-Lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Ucore-Lab6
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-28 00:42:41" itemprop="dateCreated datePublished" datetime="2022-04-28T00:42:41+08:00">2022-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:43:08" itemprop="dateModified" datetime="2023-03-16T23:43:08+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="CPU资源的时分复用"><a href="#CPU资源的时分复用" class="headerlink" title="CPU资源的时分复用"></a>CPU资源的时分复用</h2><p>进程切换：CPU资源的当前占用者切换</p>
<ul>
<li>保存当前进程在PCB中的执行上下文（CPU状态）</li>
<li>恢复下一个进程的执行上下文</li>
</ul>
<p>处理机调度：</p>
<ul>
<li>从就绪队列中<strong>挑选</strong>下一个占用CPU运行的进程</li>
<li>从多个可用CPU中<strong>挑选</strong>就绪进程可使用的CPU资源</li>
</ul>
<p>调度程序：挑选就绪进程的内核函数</p>
<ul>
<li>调度策略：依据什么原理挑选进程/线程</li>
<li>调度时机：什么时候进行调度</li>
</ul>
<p>内核运行调度程序的条件：</p>
<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程被终结了</li>
</ul>
<p>非抢占系统：</p>
<ul>
<li>当前进程主动放弃CPU时</li>
</ul>
<p>可抢占系统：</p>
<ul>
<li>中断请求被服务例程响应完成时</li>
<li>当前进程被抢占<ul>
<li>进程的时间片耗尽</li>
<li>进程从等待状态切换到就绪状态</li>
</ul>
</li>
</ul>
<h2 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h2><ul>
<li><p>比较调度算法的准则</p>
<ul>
<li>CPU使用率：CPU处于忙状态的<strong>时间百分比</strong></li>
<li>吞吐量：单位时间内完成的<strong>进程数量</strong></li>
<li>周转时间：进程从初始化到结束（包括等待）的<strong>总时间</strong></li>
<li>等待时间：进程在就绪队列中的<strong>总时间</strong></li>
<li>响应时间：从提交请求到产生响应所花费的<strong>总时间</strong></li>
</ul>
</li>
<li><p>调度策略的目标</p>
<ul>
<li><strong>减少响应时间</strong>：及时处理用户的输入，尽快将输出反馈给用户</li>
<li><strong>减少平均响应时间的波动</strong>：在交互系统中，可预测性比高差异低平均更重要</li>
</ul>
</li>
<li><p>调度策略的吞吐量目标</p>
<ul>
<li>增加吞吐量<ul>
<li>减小开销（例如上下文切换的开销）</li>
<li>系统资源的高效利用（例如CPU和IO设备的并行使用）</li>
</ul>
</li>
<li>减少每个进程的等待时间</li>
<li>保证吞吐量不受用户交互的影响</li>
</ul>
</li>
</ul>
<h2 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h2><ul>
<li>时钟中断是一种硬中断，由时间硬件（系统定时器，一种可编程硬件）产生，CPU处理后交由时间中断处理程序来完成更新系统时间、执行周期性任务等</li>
<li>系结构相关部分被注册到内核中，确保中断产生时能执行，这部分不能有耗时操作，主要是更新时间与调用结构无关部分列程（异步）</li>
<li>已到期的定时器由体系结构无关部分来处理，其它的一些耗时操作，如显示时间的更新也在这一部分</li>
</ul>
<p><strong>内核定时器</strong></p>
<ul>
<li>内核定时器产生的是软中断，软中断是进程相关的，它不会中断CPU的处理</li>
<li>使用定时器时，将软中断注册入内核</li>
<li>在每个时钟中断周期中，系统会检测到期到期定时器，触发软中断，判断时间到期，则执行定时器处理函数，最后清除掉定时器软中断</li>
</ul>
<p><strong>用户定时器</strong></p>
<ul>
<li>用户定时器是线程相关的，定时器产生的消息只会发送给注册线程</li>
<li>定时器消息属于最低优先级的消息，当线程的队列中没有其他消息时，才检索该消息</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>在 SMP（对称多处理器）环境下，<strong>每个 CPU 对应一个 run_queue（可执行队列）</strong></li>
<li>如果一个进程处于 TASK_RUNNING 状态（可执行状态），则它会被加入到其中一个 run_queue（且同一时刻仅会被加入到一个 run_queue），以便让调度程序安排它在这个 run_queue 对应的 CPU 上面运行</li>
<li>一个CPU对应一个 run_queue 这样的设计，其好处是： <ul>
<li>一个持续处于 TASK_RUNNING 状态的进程总是趋于在同一个 CPU 上面运行（其间，这个进程可能被抢占、然后又被调度），这有利于进程的数据被 CPU 所缓存，提高运行效率</li>
<li>各个 CPU 上的调度程序只访问自己的 run_queue，避免了竞争</li>
</ul>
</li>
</ul>
<p>结构体 run_queue 用于描述队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> run_list; <span class="comment">/* 其运行队列的链表结构,可以看作是队列结点(运行队列链表) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> proc_num; <span class="comment">/* 表示其内部的进程总数 */</span></span><br><span class="line">    <span class="keyword">int</span> max_time_slice; <span class="comment">/* 每个进程一轮占用的最多时间片 */</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span> *lab6_run_pool; <span class="comment">/* 优先队列形式的进程容器(只在LAB6中使用) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>进程运行队列（就绪队列）：</p>
<ul>
<li>linux 提供了很多队列，但本实验只涉及到了运行队列（运行队列和就绪队列是同一个东西）</li>
<li>在 ucore 框架中，运行队列存储的是当前可以调度的进程，所以，只有状态为 runnable 的进程才能够进入运行队列，当前正在运行的进程并不会在运行队列中</li>
<li>运行队列通过链表的形式进行组织，链表的每一个节点是一个 list_entry_t，每个 list_entry_t 又对应到了 struct proc_struct *（和前面实验对于链表的操作如出一辙）</li>
</ul>
<h2 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h2><p><strong>RR时间片轮转原理</strong></p>
<ul>
<li>在采用时间片轮转算法中，所有的就绪进程按 FCFS 策略排成一个就绪队列</li>
<li>系统可设置每隔一定时间便产生一次中断，去激活进程调度程序进行调度，把CPU分配给队首进程，并令其执行一个时间片</li>
<li>当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片</li>
<li>这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间</li>
</ul>
<p><strong>多级反馈队列调度机制</strong></p>
<ul>
<li>设置多个就绪队列，在系统中设置多个就绪队列，并为每个队列赋予不同的优先</li>
<li>第一个队列的优先级最高，第二个次之，其余队列的优先级逐个降低</li>
<li>该算法为不同列中的进程所赋予的执行时间片的大小也各不相同，在优先级愈高的队列中，其时间片愈小</li>
<li>每个队列都采用 FCFS 算法，当新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则等待调度<ul>
<li>当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统</li>
<li>否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度</li>
<li>如果它在第二队列中运行个时间片后仍未完成， 再依次将它放入第三队列 … 依此类推</li>
</ul>
</li>
<li>当进程最后被降到第n队列后，在第n队列中便采取按RR方式运行</li>
<li>PS：这里只讨论了最简单的情况，中途没有进程进行“抢占”</li>
</ul>
<h2 id="斜堆-Skew-Heap"><a href="#斜堆-Skew-Heap" class="headerlink" title="斜堆(Skew Heap)"></a>斜堆(Skew Heap)</h2><p>斜堆(Skew heap)也叫自适应堆(self-adjusting heap)，它是左倾堆的一个变种，和左倾堆一样，它通常也用于实现优先队列，它的合并操作的时间复杂度也是 O(lg n) </p>
<p>相比于左倾堆，斜堆的节点没有”零距离”这个属性，除此之外，它们斜堆的合并操作也不同</p>
<p>斜堆的合并操作算法如下： </p>
<ul>
<li>第1步：如果一个空斜堆与一个非空斜堆合并，返回非空斜堆</li>
<li>第2步：如果两个斜堆都非空，那么比较两个根节点，取较小堆的根节点为新的根节点，将 “较小堆的根节点的右孩子” 和 “较大堆” 进行合并</li>
<li>第3步：合并后，交换新堆根节点的左孩子和右孩子</li>
</ul>
<p>第3步是斜堆和左倾堆的合并操作差别的关键所在：</p>
<ul>
<li>如果是左倾堆，则合并后要比较左右孩子的零距离大小</li>
<li>若右孩子的零距离 &gt; 左孩子的零距离，则交换左右孩子</li>
<li>最后设置根的零距离</li>
</ul>
<p><strong>ucore 中和斜堆有关的结构</strong></p>
<ul>
<li>skew_heap_entry：用于记录斜堆各个节点的信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skew_heap_entry</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">skew_heap_entry</span> *<span class="title">parent</span>, *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>compare_f：一个函数指针，指向 <code>proc_stride_comp_f</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*compare_f)</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>ucore 中和斜堆有关的函数</strong></p>
<ul>
<li>proc_stride_comp_f：优先队列的比较函数， <strong>用于测优先级</strong> ，主要思路就是通过步数相减，然后根据其正负比较大小关系（具体的数学原理我真的搞不明白，反正这个函数可以用来测优先级就对了）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">proc_stride_comp_f</span><span class="params">(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool); <span class="comment">// 获取进程a</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool); <span class="comment">// 获取进程b</span></span><br><span class="line">     <span class="keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride; <span class="comment">// 步数相减,通过正负比较大小关系</span></span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* b的优先级高(stride更小) */</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* a的优先级高(stride更小) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>skew_heap_init：初始化斜堆</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">skew_heap_init</span><span class="params">(<span class="keyword">skew_heap_entry_t</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     a-&gt;left = a-&gt;right = a-&gt;parent = <span class="literal">NULL</span>; <span class="comment">/* 置空斜堆的3个索引点 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>skew_heap_insert：将新的进程插入到表示就绪队列的斜堆中，该函数的返回结果是斜堆的新的根</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">skew_heap_entry_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">skew_heap_insert</span><span class="params">(<span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span></span></span><br><span class="line"><span class="params"><span class="function">                 compare_f comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     skew_heap_init(b); <span class="comment">/* 置空斜堆b */</span></span><br><span class="line">     <span class="keyword">return</span> skew_heap_merge(a, b, comp); <span class="comment">/* 合并这两个斜堆,并返回得到的新堆 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>skew_heap_remove：删除斜堆中的指定进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">skew_heap_entry_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">skew_heap_remove</span><span class="params">(<span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span></span></span><br><span class="line"><span class="params"><span class="function">                 compare_f comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">skew_heap_entry_t</span> *p   = b-&gt;parent;</span><br><span class="line">     <span class="keyword">skew_heap_entry_t</span> *rep = skew_heap_merge(b-&gt;left, b-&gt;right, comp); <span class="comment">/* 合并这两个斜堆,并返回得到的新堆 */</span></span><br><span class="line">     <span class="keyword">if</span> (rep) rep-&gt;parent = p;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (p)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span> (p-&gt;left == b)</span><br><span class="line">               p-&gt;left = rep;</span><br><span class="line">          <span class="keyword">else</span> p-&gt;right = rep;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>skew_heap_merge：合并这两个斜堆，并返回得到的新堆（没学对应的数据结构，看不懂）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">skew_heap_entry_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">skew_heap_merge</span><span class="params">(<span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span></span></span><br><span class="line"><span class="params"><span class="function">                compare_f comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (a == <span class="literal">NULL</span>) <span class="keyword">return</span> b;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="literal">NULL</span>) <span class="keyword">return</span> a;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">skew_heap_entry_t</span> *l, *r;</span><br><span class="line">     <span class="keyword">if</span> (comp(a, b) == <span class="number">-1</span>) <span class="comment">/* 执行proc_stride_comp_f: a的优先级更高 */</span></span><br><span class="line">     &#123;</span><br><span class="line">          r = a-&gt;left;</span><br><span class="line">          l = skew_heap_merge(a-&gt;right, b, comp);</span><br><span class="line">          </span><br><span class="line">          a-&gt;left = l;</span><br><span class="line">          a-&gt;right = r;</span><br><span class="line">          <span class="keyword">if</span> (l) l-&gt;parent = a;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="comment">/* 执行proc_stride_comp_f: b的优先级更高 */</span></span><br><span class="line">     &#123;</span><br><span class="line">          r = b-&gt;left;</span><br><span class="line">          l = skew_heap_merge(a, b-&gt;right, comp);</span><br><span class="line">          </span><br><span class="line">          b-&gt;left = l;</span><br><span class="line">          b-&gt;right = r;</span><br><span class="line">          <span class="keyword">if</span> (l) l-&gt;parent = b;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> b;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规律总结：</p>
<ul>
<li>stride 值最小的进程在斜堆的最顶端（优先度更高）</li>
</ul>
<h2 id="练习0-把-lab5-的内容复制粘贴到-lab6"><a href="#练习0-把-lab5-的内容复制粘贴到-lab6" class="headerlink" title="练习0-把 lab5 的内容复制粘贴到 lab6"></a>练习0-把 lab5 的内容复制粘贴到 lab6</h2><p>lab6 的代码有一些不同的地方</p>
<p>在 proc_struct 添加有关 <strong>时钟中断</strong> 的部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>      <span class="comment">// 当前进程的状态</span></span><br><span class="line">    <span class="keyword">int</span> pid;                    <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">int</span> runs;                   <span class="comment">// 当前进程被调度的次数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack;           <span class="comment">// 内核栈</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched; <span class="comment">// 是否需要被调度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span> <span class="comment">// 父进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// 保存的进程上下文,用于进程切换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>       <span class="comment">// 中断帧指针,指向内核栈的某个位置(保存有中断上下文)</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3;                  <span class="comment">// 页目录表的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// 当前进程的相关标志</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];   <span class="comment">// 进程名称(可执行文件名)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;         <span class="comment">// 进程链表 </span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;         <span class="comment">// 进程哈希表 </span></span><br><span class="line">    <span class="keyword">int</span> exit_code;    				 <span class="comment">/* lab5新增:描述线程退出时的原因 */</span> </span><br><span class="line">    <span class="keyword">uint32_t</span> wait_state;			 <span class="comment">/* lab5新增:描述线程进入wait阻塞态的原因 */</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">cptr</span>, *<span class="title">yptr</span>, *<span class="title">optr</span>;</span>    <span class="comment">/* lab5新增:用于组织子进程链表 */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;-- 以下都是lab6新增的部分 --&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>;</span>                       <span class="comment">// 指向运行队列(就绪队列)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> run_link;                      <span class="comment">// 在运行队列中链接的条目</span></span><br><span class="line">    <span class="keyword">int</span> time_slice;                             <span class="comment">// 占用CPU的时间片</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span> lab6_run_pool;            <span class="comment">// 仅适用于LAB6:运行池中的条目</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lab6_stride;                       <span class="comment">// 仅适用于LAB6:流程的当前步幅</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lab6_priority;                     <span class="comment">// 仅适用于LAB6:进程的优先级(由LAB6_set_priority设置)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的 alloc_proc 函数（创建进程控制结构）也要发生变化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;-- 以下都是lab6新增的部分 --&gt; */</span></span><br><span class="line">        </span><br><span class="line">        proc-&gt;rq = <span class="literal">NULL</span>; <span class="comment">/* 把运行队列置空 */</span></span><br><span class="line">        list_init(&amp;(proc-&gt;run_link)); <span class="comment">/* 初始化运行队列中链接的条目 */</span></span><br><span class="line">        proc-&gt;time_slice = <span class="number">0</span>; <span class="comment">/* 初始化占用CPU的时间片 */</span></span><br><span class="line">        proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = proc-&gt;lab6_run_pool.parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;lab6_stride = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_priority = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外在 trap_dispatch 函数中填入 “中断请求-计时器中断” 对应的部分：</p>
<ul>
<li>在 lab6 中，时钟中断的处理逻辑中主动调用了调度器的 proc_tick 函数，使得调度器能感知到时钟中断的产生，并调整调度相关的数据结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 根据trapframe中断帧中的标志位,来执行具体的中断服务历程 */</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> T_PGFLT: <span class="comment">/* 页错误异常(page fault) */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = pgfault_handler(tf)) != <span class="number">0</span>) &#123;</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="comment">/* lab5新增:与进程相关的if判断语句 */</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;handle pgfault failed. ret=%d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (trap_in_kernel(tf)) &#123;</span><br><span class="line">                    panic(<span class="string">&quot;handle pgfault failed in kernel mode. ret=%d\n&quot;</span>, ret);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">&quot;killed by kernel.\n&quot;</span>);</span><br><span class="line">                panic(<span class="string">&quot;handle user mode pgfault failed. ret=%d\n&quot;</span>, ret); </span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SYSCALL: <span class="comment">/* 系统调用(syscall) */</span></span><br><span class="line">        syscall();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*  &lt;---- start ----&gt;  */</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    LAB3 : <span class="function">If some page replacement <span class="title">algorithm</span><span class="params">(such as CLOCK PRA)</span> need tick to change the priority of pages, </span></span><br><span class="line"><span class="function">    then you can add code here. </span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function">        ticks ++</span>;</span><br><span class="line">        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">        sched_class_proc_tick(current); <span class="comment">/* lab6新添:使得调度器能感知到时钟中断的产生,并调整调度相关的数据结构 */</span></span><br><span class="line">        <span class="keyword">break</span>;   </span><br><span class="line">            <span class="comment">/*  &lt;---- end ----&gt;  */</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_COM1: <span class="comment">/* 中断请求-串口中断 */</span></span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;serial [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD: <span class="comment">/* 中断请求-键盘中断 */</span></span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;kbd [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOU: <span class="comment">/* 中断请求-内核到用户空间触发的中断 */</span></span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK: <span class="comment">/* 中断请求-用户空间到内核触发的中断 */</span></span><br><span class="line">        panic(<span class="string">&quot;T_SWITCH_** ??\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE1: <span class="comment">/* 中断请求-IDE通道1中断 */</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE2: <span class="comment">/* 中断请求-IDE通道2中断 */</span></span><br><span class="line">            <span class="comment">/* 本实验不涉及这一部分 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* lab5改动:完善了报错处理 */</span></span><br><span class="line">        print_trapframe(tf); <span class="comment">/* 打印trapframe结构体(中断帧,用于存储执行中断的信息) */</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;unhandled trap.\n&quot;</span>);</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        &#125;</span><br><span class="line">        panic(<span class="string">&quot;unexpected trap in kernel.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched_class_proc_tick</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != idleproc) &#123;</span><br><span class="line">        sched_class-&gt;proc_tick(rq, proc); <span class="comment">/* 处理时钟中断,更新对应的调度参数 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* idleproc处理时钟中断:需要进行调度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习1-使用-Round-Robin-调度算法"><a href="#练习1-使用-Round-Robin-调度算法" class="headerlink" title="练习1-使用 Round Robin 调度算法"></a>练习1-使用 Round Robin 调度算法</h2><ul>
<li>理解并分析 sched_class（调度类，调度器框架）中各个函数指针的用法，并结合 Round Robin 调度算法描 ucore 的调度执行过程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 零,该调度类的名称 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*init)(struct run_queue *rq); <span class="comment">/* 一,初始化运行队列 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc); <span class="comment">/* 二,将proc(进程)放入runqueue(运行队列),必须使用&quot;rq_lock&quot;调用此函数 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc); <span class="comment">/* 三,将proc(进程)移出runqueue(运行队列),必须使用&quot;rq_lock&quot;调用此函数 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span> <span class="comment">/* 四,选择下一个可运行任务 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc); <span class="comment">/* 五,以减小当前运行进程的time-tick(剩余时间片) */</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> =</span> &#123;</span><br><span class="line">    <span class="comment">/* 六,定义一个c语言类的实现,提供调度算法的切换接口(不属于调度类但后续会遇到) */</span></span><br><span class="line">    .name = <span class="string">&quot;RR_scheduler&quot;</span>,</span><br><span class="line">    .init = RR_init,</span><br><span class="line">    .enqueue = RR_enqueue,</span><br><span class="line">    .dequeue = RR_dequeue,</span><br><span class="line">    .pick_next = RR_pick_next,</span><br><span class="line">    .proc_tick = RR_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>RR调度算法的调度思想是让所有 runnable 态的进程分时轮流使用 CPU 时间 </li>
<li>RR调度器维护当前 runnable 进程的有序运行队列</li>
<li>当前进程的时间片用完之后，调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度</li>
</ul>
<p>零，const char *name：指向了当前调度算法的名称字符串 </p>
<p>一，<code>void (*init)(struct run_queue *rq)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list)); <span class="comment">/* 置空链表 */</span></span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>; <span class="comment">/* 进程总数变为&#x27;0&#x27; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于初始化传入的就绪队列，RR算法中只初始化了对应 <code>run_queue</code> 的 <code>run_list</code> 成员</li>
</ul>
<p>二，<code>void (*enqueue)(struct run_queue *rq, struct proc_struct *proc)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link)); <span class="comment">/* 插入结点前 */</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice; <span class="comment">/* 初始化时间片(如果进程在当前的执行时间片已经用完,需要等到下一次有机会运行时才能再执行一段时间) */</span></span><br><span class="line">  &#125;</span><br><span class="line">    proc-&gt;rq = rq; <span class="comment">/* 更新运行队列 */</span></span><br><span class="line">    rq-&gt;proc_num ++; <span class="comment">/* 运行队列中的进程数增加 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于将某个进程添加进传入的队列中</li>
<li>RR算法除了将进程添加进队列中，还重置了相关的时间片</li>
</ul>
<p>三，<code>void (*dequeue)(struct run_queue *rq, struct proc_struct *proc)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link)); <span class="comment">/* 脱链 */</span></span><br><span class="line">    rq-&gt;proc_num --; <span class="comment">/* 运行队列中的进程数减少 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">list_del_init</span><span class="params">(<span class="keyword">list_entry_t</span> *listelm)</span> </span>&#123;</span><br><span class="line">    list_del(listelm);</span><br><span class="line">    list_init(listelm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于将某个进程从传入的队列中移除</li>
</ul>
<p>四，<code>struct proc_struct *(*pick_next)(struct run_queue *rq)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">RR_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123; <span class="comment">/* [首次适配] */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link); <span class="comment">/* 遇到第一个合适的就直接返回了 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于在传入的运行队列中选择出一个最适合运行的进程（选择进程但不将从队列中移除）</li>
<li>在RR算法采用 [首次适配] ，每次都只选择队列最前面那个进程</li>
</ul>
<p>五，<code>void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --; <span class="comment">/* 进行时间片的递减 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 如果用完时间片,那么就使该进程变成可调度状态,等待再次调度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数会在时间中断处理例程中被调用（ <code>sched_class_proc_tick(current)</code> 中的 <code>sched_class-&gt;proc_tick(rq, proc)</code> ），以减小当前运行进程的剩余时间片，若时间片耗尽，则设置当前进程的 <code>need_resched</code> 为 1</li>
</ul>
<p><strong>结合 Round Robin 调度算法描 uCore 的调度执行过程：</strong></p>
<ul>
<li>首先，uCore调用 <code>sched_init</code> 函数用于初始化相关的就绪队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;timer_list); <span class="comment">/* 这个timer_list在之后的实验中会出现 */</span></span><br><span class="line"></span><br><span class="line">    sched_class = &amp;default_sched_class; <span class="comment">/* 提供调度算法的切换接口 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里让我联想到了面向对象中的类与实例:</span></span><br><span class="line"><span class="comment">    sched_class其实就是一组接口,有点类似于一组函数指针</span></span><br><span class="line"><span class="comment">    它起到了和“实例化”差不多的效果,可以任意调用该类中的函数</span></span><br><span class="line"><span class="comment">    没准这就是面向对象的雏形,只不过面向对象更强大,采用了更加高级的数据抽象的形式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    rq = &amp;__rq;</span><br><span class="line">    rq-&gt;max_time_slice = MAX_TIME_SLICE;</span><br><span class="line">    sched_class-&gt;init(rq); <span class="comment">/* 调用RR_init初始化rq运行列表 */</span></span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;sched class: %s\n&quot;</span>, sched_class-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>之后在 <code>proc_init</code> 函数中，建立第一个内核进程，并将其添加至就绪队列中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* 分配一个物理页,作为proc_struct结构体 */</span></span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>; <span class="comment">/* 将空闲进程作为第一个进程,pid为0 */</span></span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE; <span class="comment">/* 设置该空闲进程始终可运行 */</span></span><br><span class="line">    idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack; <span class="comment">/* 设置空闲进程的内核栈 */</span></span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 设置该空闲进程为可调度 */</span></span><br><span class="line">    set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>); <span class="comment">/* 设置该进程的name为&quot;idle&quot; */</span></span><br><span class="line">    nr_process ++; <span class="comment">/* 将全局线程的数目加1 */</span></span><br><span class="line"></span><br><span class="line">    current = idleproc; <span class="comment">/* 设置当前进程为idleproc */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = kernel_thread(init_main, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* 先设置trapframe,最后调用do_fork(详情请参考起前面的实验) */</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123; <span class="comment">/* 内核进程创建失败 */</span></span><br><span class="line">        panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid); <span class="comment">/* 通过pid查找proc_struct,并赋值给initproc */</span></span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>); <span class="comment">/* 设置该进程的name为&quot;init&quot; */</span></span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当所有的初始化完成后，uCore执行 <code>cpu_idle</code> 函数，并在其内部循环执行 <code>schedule</code> 函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">current</span> =</span> <span class="literal">NULL</span>; <span class="comment">/* 指向当前的进程 */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cpu_idle</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched) &#123; <span class="comment">/* 是否需要被调度 */</span></span><br><span class="line">            schedule(); <span class="comment">/* 准备开始调度进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 <code>sched_class_enqueue</code> 将当前进程添加进就绪队列中（因为当前进程要被切换出CPU了）</li>
<li>然后，调用 <code>sched_class_pick_next</code> 获取就绪队列中可被轮换至CPU的进程</li>
<li>如果存在可用的进程，则调用 <code>sched_class_dequeue</code> 函数，将该进程移出就绪队列，并在之后执行 <code>proc_run</code> 函数进行进程上下文切换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 相比与上一个实验要朴实得多,可能做了优化吧 */</span></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">            sched_class_enqueue(current); <span class="comment">/* 将current添加进就绪队列中 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((next = sched_class_pick_next()) != <span class="literal">NULL</span>) &#123; <span class="comment">/* 获取就绪队列中可被轮换至CPU的进程 */</span></span><br><span class="line">            sched_class_dequeue(next); <span class="comment">/* 如果存在可用的进程,将该进程移出就绪队列 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            next = idleproc; <span class="comment">/* 判断将要被调度的进程为空闲进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++; <span class="comment">/* 目标进程被调度的次数增加 */</span></span><br><span class="line">        <span class="keyword">if</span> (next != current) &#123;</span><br><span class="line">            <span class="comment">/* 如果调度进程不是当前进程,则运行proc_run,否则会重新进入空闲进程(循环) */</span></span><br><span class="line">            proc_run(next); <span class="comment">/* 执行进程调度操作(上下文切换) */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sched_class_enqueue 的具体实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched_class_enqueue</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != idleproc) &#123;</span><br><span class="line">        sched_class-&gt;enqueue(rq, proc); <span class="comment">/* RR_enqueue的外包装 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sched_class_pick_next</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">sched_class_pick_next</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sched_class-&gt;pick_next(rq); <span class="comment">/* RR_pick_next的外包装 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sched_class_dequeue</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched_class_dequeue</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    sched_class-&gt;dequeue(rq, proc); <span class="comment">/* RR_dequeue的外包装 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>设计多级反馈队列调度算法</strong></p>
<p>我自己的理解：</p>
<ul>
<li>其实多级反馈队列就是把进程进行了优先级分级，在每一级中的时间片长度不一样（第一级的优先度最高，时间片最短，被 CPU 调度的机会更多）</li>
<li>在同一个优先级的队列内使用时间片轮转算法</li>
<li>CPU 如果一次没有执行完毕目标进程，那么该进程就会降级（降到下一级）</li>
<li>在最后一级中，如果一次还是没有执行完毕目标进程，那么下次就会在这一级中实现 RR 时间片轮转算法</li>
<li>PS：至于为什么要这样搞，这就是数学家用公式算出来的，有关数学公式的理论本人一概不会</li>
</ul>
<p>具体的过程我就随便抄了一个：（其实我也写了一个，就不献丑了）</p>
<ul>
<li>在 proc_struct 中添加总共N个多级反馈队列的入口，每个队列都有着各自的优先级，编号越大的队列优先级约低，并且优先级越低的队列上时间片的长度越大，为其上一个优先级队列的两倍；并且在PCB中记录当前进程所处的队列的优先级</li>
<li>处理调度算法初始化的时候需要同时对N个队列进行初始化</li>
<li>在处理将进程加入到就绪进程集合的时候，观察这个进程的时间片有没有使用完，如果使用完了，就将所在队列的优先级调低，加入到优先级低1级的队列中去，如果没有使用完时间片，则加入到当前优先级的队列中去</li>
<li>在同一个优先级的队列内使用时间片轮转算法</li>
<li>在选择下一个执行的进程的时候，有限考虑高优先级的队列中是否存在任务，如果不存在才转而寻找较低优先级的队列（有可能导致饥饿）</li>
<li>从就绪进程集合中删除某一个进程就只需要在对应队列中删除即可</li>
<li>处理时间中断的函数不需要改变</li>
</ul>
<h2 id="练习2-实现-Stride-Scheduling-调度算法"><a href="#练习2-实现-Stride-Scheduling-调度算法" class="headerlink" title="练习2-实现 Stride Scheduling 调度算法"></a>练习2-实现 Stride Scheduling 调度算法</h2><p>uCore 的 Round-Robin 算法可以保证每个进程得到的 CPU 资源是相等的，但我们希望调度器能够更加智能的为每个进程分配合理的 CPU 资源，让 <strong>每个进程得到的时间资源与它们的优先级成正比关系</strong> ，而 Stride Scheduling 调度算法就是这样的一种典型而简单的算法</p>
<p>其中，该算法的有如下几个特点：</p>
<ul>
<li>可控性：可以证明 Stride Scheduling 对进程的调度次数正比于其优先级</li>
<li>确定性：在不考虑计时器事件的情况下，整个调度机制都是可预知和重现的</li>
</ul>
<p>算法简析：</p>
<p>在实验中使用的 Stride Scheduling 算法是结合时间片的一种优先级调度策略，每一个时间片结束时，选择就绪状态的进程中 Pass 值最小的进程分配一个时间片，在一个时间段中进程所获得的时间片数量和进程的优先级大致成正比</p>
<p>该算法的基本思想如下：</p>
<ul>
<li>为每个 runnable 的进程设置一个当前状态 stride，表示该进程当前的调度权，另外定义其对应的 pass 值，表示对应进程在调度后 stride 需要进行的累加值</li>
<li>每次需要调度时，从当前 runnable 态的进程中选择 stride 最小的进程调度</li>
<li>对于获得调度的进程P，将对应的 stride 加上其对应的步长 pass（只与进程的优先权有关系）</li>
<li>在一段固定的时间之后，重新调度当前 stride 最小的进程（返回步骤二）</li>
</ul>
<p>总之：</p>
<p>其实就是模仿 Round Robin 调度算法来重新写一个 Stride Scheduling，具体的优化策略需要结合一些数学理论，所以我直接抄答案了，并在答案中理解该算法</p>
<p>下面便是具体的实现过程：（有和 Round Robin 的对比）</p>
<p>一，<code>stride_init</code>：进行初始化操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">stride_init</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">     list_init(&amp;(rq-&gt;run_list)); <span class="comment">/* 置空链表 */</span></span><br><span class="line">     rq-&gt;lab6_run_pool = <span class="literal">NULL</span>; <span class="comment">/* 运行池中的条目初始化为空 */</span></span><br><span class="line">     rq-&gt;proc_num = <span class="number">0</span>; <span class="comment">/* 进程总数变为&#x27;0&#x27; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="comment">/* 对比Round Robin */</span></span><br><span class="line">RR_init(struct run_queue *rq) &#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list)); <span class="comment">/* 置空链表 */</span></span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>; <span class="comment">/* 进程总数变为&#x27;0&#x27; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二，<code>stride_enqueue</code>：用于将某个进程添加进传入的队列中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">stride_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">     rq-&gt;lab6_run_pool =</span><br><span class="line">          skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f); </span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">          proc-&gt;time_slice = rq-&gt;max_time_slice; <span class="comment">/* 初始化时间片(如果进程在当前的执行时间片已经用完,需要等到下一次有机会运行时才能再执行一段时间) */</span></span><br><span class="line">     &#125;</span><br><span class="line">     proc-&gt;rq = rq; <span class="comment">/* 更新运行队列 */</span></span><br><span class="line">     rq-&gt;proc_num ++; <span class="comment">/* 运行队列中的进程数增加 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_enqueue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link)); <span class="comment">/* 插入结点前 */</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice; <span class="comment">/* 初始化时间片(如果进程在当前的执行时间片已经用完,需要等到下一次有机会运行时才能再执行一段时间) */</span></span><br><span class="line">  &#125;</span><br><span class="line">    proc-&gt;rq = rq; <span class="comment">/* 更新运行队列 */</span></span><br><span class="line">    rq-&gt;proc_num ++; <span class="comment">/* 运行队列中的进程数增加 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三，<code>stride_dequeue</code>：用于将某个进程从传入的队列中移除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">stride_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">     rq-&gt;lab6_run_pool =</span><br><span class="line">          skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">     rq-&gt;proc_num --; <span class="comment">/* 运行队列中的进程数减少 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_dequeue</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link)); <span class="comment">/* 脱链 */</span></span><br><span class="line">    rq-&gt;proc_num --; <span class="comment">/* 运行队列中的进程数减少 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>四，<code>stride_pick_next</code>：涉及到了选取最小 <code>Stride</code> 值的进程，以及 <code>stride</code> 值的更新</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">stride_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (rq-&gt;lab6_run_pool == <span class="literal">NULL</span>) </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);</span><br><span class="line">     <span class="keyword">if</span> (p-&gt;lab6_priority == <span class="number">0</span>)</span><br><span class="line">          p-&gt;lab6_stride += BIG_STRIDE;</span><br><span class="line">     <span class="keyword">else</span> p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">RR_pick_next</span><span class="params">(struct run_queue *rq)</span> </span>&#123; <span class="comment">/* [首次适配] */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五，<code>stride_proc_tick</code>：和 <code>RR_proc_tick</code> 一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">stride_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --; <span class="comment">/* 进行时间片的递减 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 如果用完时间片,那么就使该进程变成可调度状态,等待再次调度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">RR_proc_tick</span><span class="params">(struct run_queue *rq, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --; <span class="comment">/* 进行时间片的递减 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 如果用完时间片,那么就使该进程变成可调度状态,等待再次调度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/miscellaneous/" rel="tag"><i class="fa fa-tag"></i> miscellaneous</a>
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/Kernel/" rel="tag"><i class="fa fa-tag"></i> Kernel</a>
              <a href="/tags/Ucore/" rel="tag"><i class="fa fa-tag"></i> Ucore</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/28/mrCTF2022/" rel="prev" title="mrCTF2022">
      <i class="fa fa-chevron-left"></i> mrCTF2022
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/29/mybash/" rel="next" title="mybash">
      mybash <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E8%B5%84%E6%BA%90%E7%9A%84%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">CPU资源的时分复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">调度准则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="nav-number">3.</span> <span class="nav-text">时钟中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">4.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">多级反馈队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%9C%E5%A0%86-Skew-Heap"><span class="nav-number">6.</span> <span class="nav-text">斜堆(Skew Heap)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A00-%E6%8A%8A-lab5-%E7%9A%84%E5%86%85%E5%AE%B9%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%88%B0-lab6"><span class="nav-number">7.</span> <span class="nav-text">练习0-把 lab5 的内容复制粘贴到 lab6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01-%E4%BD%BF%E7%94%A8-Round-Robin-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">练习1-使用 Round Robin 调度算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02-%E5%AE%9E%E7%8E%B0-Stride-Scheduling-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">练习2-实现 Stride Scheduling 调度算法</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">332</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:53</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
