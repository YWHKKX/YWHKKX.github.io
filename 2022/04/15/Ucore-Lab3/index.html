<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="vma简析用户进程的虚拟地址空间包含了若干区域，这些区域的分布方式是特定于体系结构的，不过所有的方式都包含下列成分：  可执行文件的二进制代码，也就是程序的代码段 存储全局变量的数据段 用于保存局部变量和实现函数调用的栈 环境变量和命令行参数 程序使用的动态库的代码 用于映射文件内容的区域   由此可以看到进程的虚拟内存空间会被分成不同的若干区域，每个区域都有其相关的属性和用途，一个合法的地址总是">
<meta property="og:type" content="article">
<meta property="og:title" content="Ucore-Lab3">
<meta property="og:url" content="http://example.com/2022/04/15/Ucore-Lab3/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="vma简析用户进程的虚拟地址空间包含了若干区域，这些区域的分布方式是特定于体系结构的，不过所有的方式都包含下列成分：  可执行文件的二进制代码，也就是程序的代码段 存储全局变量的数据段 用于保存局部变量和实现函数调用的栈 环境变量和命令行参数 程序使用的动态库的代码 用于映射文件内容的区域   由此可以看到进程的虚拟内存空间会被分成不同的若干区域，每个区域都有其相关的属性和用途，一个合法的地址总是">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-15T09:46:03.000Z">
<meta property="article:modified_time" content="2023-03-16T15:42:58.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="miscellaneous">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="Kernel">
<meta property="article:tag" content="Ucore">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/04/15/Ucore-Lab3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Ucore-Lab3 | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/15/Ucore-Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Ucore-Lab3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-15 17:46:03" itemprop="dateCreated datePublished" datetime="2022-04-15T17:46:03+08:00">2022-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:42:58" itemprop="dateModified" datetime="2023-03-16T23:42:58+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="vma简析"><a href="#vma简析" class="headerlink" title="vma简析"></a>vma简析</h2><p>用户进程的虚拟地址空间包含了若干区域，这些区域的分布方式是特定于体系结构的，不过所有的方式都包含下列成分：</p>
<ul>
<li>可执行文件的二进制代码，也就是程序的代码段</li>
<li>存储全局变量的数据段</li>
<li>用于保存局部变量和实现函数调用的栈</li>
<li>环境变量和命令行参数</li>
<li>程序使用的动态库的代码</li>
<li>用于映射文件内容的区域 </li>
</ul>
<p>由此可以看到进程的虚拟内存空间会被分成不同的若干区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠</p>
<p>在linux内核中，这样的区域被称之为虚拟内存区域（virtual memory areas，vma），每一个虚拟内存区域都由一个相关的 struct vma_struct 结构来描述，而一个进程往往由许多不同功能的 vma 组成，它们则统一归于 struct mm_struct 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">/* 所属的内存描述符 */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_start;      <span class="comment">/* vma的起始地址 */</span>      </span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_end;        <span class="comment">/* vma的结束地址 */</span>  </span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags;       <span class="comment">/* 标识集 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;  <span class="comment">/* 按vma的起始地址排序的线性列表链接 */</span></span><br><span class="line">    <span class="comment">/* 后续实验还会增加: */</span></span><br><span class="line">    <span class="comment">// mm_count(共享mm的进程数)</span></span><br><span class="line">    <span class="comment">// mm_lock(关于锁的标记) </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;          <span class="comment">/* vma链表的起始地址 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span>   <span class="comment">/* 当前访问的vma，用于速度目的 */</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                    <span class="comment">/* 这些vma的PDT(页目录表) */</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                   <span class="comment">/* 这些vma的计数 */</span></span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                   <span class="comment">/* 用于指向swap manager的某个链表 */</span></span><br><span class="line">    <span class="comment">/* 在FIFO算法中,该双向链表用于将可交换的已分配物理页串起来 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>每一个进程都有一个 mm_struct 来管理虚拟内存和物理内存</li>
<li>内核会把这一整片内存给划分为不同功能的 vma，每个 vma 用一个 vma_struct 来管理</li>
<li>按 vma 的起始地址排序，可以把一个进程中所有的 vma 组成一个链表</li>
<li>而 mm_struct-&gt;mmap_list 指向该 vma 链表的起始地址</li>
</ul>
<p>下面是与 vma 有关的函数：</p>
<ul>
<li>find_vma：找寻合适的 vma 地址（vma-&gt;vm_start &lt;= addr &lt;= vma_vm_end）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">/* 所属的内存描述符 */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_start;      <span class="comment">/* vma的起始地址 */</span>      </span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_end;        <span class="comment">/* vma的结束地址 */</span>  </span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags;       <span class="comment">/* 标识集 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;  <span class="comment">/* 按vma的起始地址排序的线性列表链接 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct vma_struct * </span></span><br><span class="line"><span class="function"><span class="title">find_vma</span><span class="params">(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr)</span> </span>&#123; <span class="comment">/* 我没有看出来这个addr有什么用 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        vma = mm-&gt;mmap_cache; <span class="comment">/* 尝试直接获取当前访问的vma,若没有找到才遍历链表 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma != <span class="literal">NULL</span> &amp;&amp; vma-&gt;vm_start &lt;= addr &amp;&amp; vma-&gt;vm_end &gt; addr)) &#123;</span><br><span class="line">                <span class="keyword">bool</span> found = <span class="number">0</span>; <span class="comment">/* 标记未找到 */</span></span><br><span class="line">                <span class="keyword">list_entry_t</span> *<span class="built_in">list</span> = &amp;(mm-&gt;mmap_list), *le = <span class="built_in">list</span>;</span><br><span class="line">                <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123; <span class="comment">/* 遍历vma链表 */</span></span><br><span class="line">                    vma = le2vma(le, list_link); <span class="comment">/* 通过链表信息获取vma首地址 */</span></span><br><span class="line">                    <span class="keyword">if</span> (vma-&gt;vm_start&lt;=addr &amp;&amp; addr &lt; vma-&gt;vm_end) &#123;</span><br><span class="line">                        found = <span class="number">1</span>; <span class="comment">/* 标记找到 */</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">                    vma = <span class="literal">NULL</span>; <span class="comment">/* 若没有找到,返回NULL */</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vma != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mm-&gt;mmap_cache = vma; <span class="comment">/* 若找到,更新mmap_cache条目(方便下次找到) */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>vma_create：新建vma，并进行初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct vma_struct *</span></span><br><span class="line"><span class="function"><span class="title">vma_create</span><span class="params">(<span class="keyword">uintptr_t</span> vm_start, <span class="keyword">uintptr_t</span> vm_end, <span class="keyword">uint32_t</span> vm_flags)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct vma_struct)); <span class="comment">/* 分配一片空间用于存储vma */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vma != <span class="literal">NULL</span>) &#123; <span class="comment">/* 初始化各个条目 */</span></span><br><span class="line">        vma-&gt;vm_start = vm_start;</span><br><span class="line">        vma-&gt;vm_end = vm_end;</span><br><span class="line">        vma-&gt;vm_flags = vm_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>insert_vma_struct：把新申请的vma插入vma链表（mmap_list为该链表的起始地址）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">insert_vma_struct</span><span class="params">(struct mm_struct *mm, struct vma_struct *vma)</span> </span>&#123;</span><br><span class="line">    assert(vma-&gt;vm_start &lt; vma-&gt;vm_end);</span><br><span class="line">    <span class="keyword">list_entry_t</span> *<span class="built_in">list</span> = &amp;(mm-&gt;mmap_list); <span class="comment">/* 目标进程的获取vma链表首地址 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le_prev = <span class="built_in">list</span>, *le_next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123; <span class="comment">/* 遍历vma链表 */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_prev</span> =</span> le2vma(le, list_link);</span><br><span class="line">            <span class="keyword">if</span> (mmap_prev-&gt;vm_start &gt; vma-&gt;vm_start) &#123;</span><br><span class="line">                <span class="comment">/* 注意:vma链表是按vma起始地址的排序进行链接的 */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            le_prev = le;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    le_next = list_next(le_prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查是否覆盖 */</span></span><br><span class="line">    <span class="keyword">if</span> (le_prev != <span class="built_in">list</span>) &#123;</span><br><span class="line">        check_vma_overlap(le2vma(le_prev, list_link), vma);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (le_next != <span class="built_in">list</span>) &#123;</span><br><span class="line">        check_vma_overlap(vma, le2vma(le_next, list_link));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_mm = mm; <span class="comment">/* 更新vm_mm条目(用于记录该vma所属的mm_struct内存描述符) */</span></span><br><span class="line">    list_add_after(le_prev, &amp;(vma-&gt;list_link)); <span class="comment">/* 插链 */</span></span><br><span class="line"></span><br><span class="line">    mm-&gt;map_count ++; <span class="comment">/* vma的计数增加 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">check_vma_overlap</span><span class="params">(struct vma_struct *prev, struct vma_struct *next)</span> </span>&#123;</span><br><span class="line">    assert(prev-&gt;vm_start &lt; prev-&gt;vm_end);</span><br><span class="line">    assert(prev-&gt;vm_end &lt;= next-&gt;vm_start);</span><br><span class="line">    assert(next-&gt;vm_start &lt; next-&gt;vm_end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mm_map：构建新的vma（包含find_vma，vma_create，insert_vma_struct，并形成逻辑）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERBASE            0x00200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERTOP             0xB0000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_ACCESS(start, end) \ <span class="comment">/* 检查该start和end是否符合条件 */</span></span></span><br><span class="line">(USERBASE &lt;= (start) &amp;&amp; (start) &lt; (end) &amp;&amp; (end) &lt;= USERTOP)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mm_map</span><span class="params">(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> vm_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">       struct vma_struct **vma_store)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mm:当前进程的mm_struct结构体</span></span><br><span class="line">    <span class="comment">// addr(ph-&gt;p_va):映射段的虚拟地址</span></span><br><span class="line">    <span class="comment">// len(ph-&gt;p_memsz):该段在内存中的大小</span></span><br><span class="line">    <span class="comment">// vm_flags:标志位</span></span><br><span class="line">    <span class="comment">// vma_store:NULL</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uintptr_t</span> start = ROUNDDOWN(addr, PGSIZE), end = ROUNDUP(addr + len, PGSIZE);</span><br><span class="line">    <span class="comment">/* 实现内存页对齐,建立合法的start(目标段起始地址),end地址(目标段结束地址) */</span></span><br><span class="line">    <span class="keyword">if</span> (!USER_ACCESS(start, end)) &#123; <span class="comment">/* 确保该start和end在一定的范围内 */</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(mm != <span class="literal">NULL</span>); <span class="comment">/* 断言mm不为空 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL; <span class="comment">/* 标记异常返回 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((vma = find_vma(mm, start)) != <span class="literal">NULL</span> &amp;&amp; end &gt; vma-&gt;vm_start) &#123;</span><br><span class="line">        <span class="comment">/* 找寻合适的vma地址(通过mmap_cache获取vma链表) */</span></span><br><span class="line">     <span class="comment">// insert_vma_struct(mm, vma); </span></span><br><span class="line">     <span class="comment">// ret = 0;</span></span><br><span class="line">        <span class="keyword">goto</span> out; <span class="comment">/* 找寻成功则立刻返回 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里我感觉有点<span class="doctag">BUG:</span></span></span><br><span class="line"><span class="comment">    如果find_vma找到了vma(vma就不为空),应该把它送入insert_vma_struct才对</span></span><br><span class="line"><span class="comment">    按照程序的逻辑,不管&quot;end&gt;vma-&gt;vm_star&quot;t是否成立,找寻到的vma都无法再利用</span></span><br><span class="line"><span class="comment">    条件成立:执行&quot;goto out&quot;返回一个错误代码</span></span><br><span class="line"><span class="comment">    条件不成立:后续的vma_create会覆盖原来的vma,就相当于白找了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    ret = -E_NO_MEM; <span class="comment">/* 标记异常返回 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((vma = vma_create(start, end, vm_flags)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* 新建vma,并进行初始化 */</span></span><br><span class="line">        <span class="keyword">goto</span> out; <span class="comment">/* 新建失败则立刻返回(NULL) */</span></span><br><span class="line">    &#125;</span><br><span class="line">    insert_vma_struct(mm, vma); <span class="comment">/* 使新分配的vma插入vma链表 */</span></span><br><span class="line">    <span class="keyword">if</span> (vma_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *vma_store = vma;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>; <span class="comment">/* 标记正常返回 */</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 mm 有关的函数只有两个：（因为涉及到锁和共享内存，所以在后续的实验中进行分析）</p>
<ul>
<li>mm_create：创建一片虚拟内存，完成各个条目的初始化</li>
<li>mm_destroy：遍历并释放 vma 链表中的所有 vma，最后释放 mm</li>
</ul>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存是CPU可以看到的“内存”</p>
<ul>
<li>虚拟内存所对应的实际物理内存单元可能不存在</li>
<li>虚拟内存的地址和对应物理内存的地址可能不一致</li>
<li>通过操作系统所实现的某种内存映射机制，可以达到访问的虚拟内存地址转换为物理内存地址的目的</li>
</ul>
<p>虚拟内存的异常：</p>
<ul>
<li>写入一个存在物理页的虚拟页 —- 写时复制</li>
<li>读写一个不存在物理页的虚拟页 —- 缺页</li>
<li>不满足访问权限</li>
</ul>
<p><strong>虚拟页结构</strong></p>
<p>lab3 的虚拟页结构和 lab2 有所不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                    <span class="comment">// 当前页被引用的次数,与内存共享有关</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;             <span class="comment">// 标志位的集合,与eflags寄存器类似</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;      <span class="comment">// 空闲的连续page数量,这个成员只会用在连续空闲page中的第一个page</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;     <span class="comment">// 两个分别指向上一个和下一个非连续空闲页的两个指针</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> pra_page_link; <span class="comment">// 用于连接上一个和下一个&quot;可交换已分配&quot;的物理页</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> pra_vaddr;        <span class="comment">// 用于保存该物理页所对应的虚拟地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新增了 <code>pra_page_link</code> 和 <code>pra_vaddr</code> ，它们将在页面替换算法（page replace algorithm，pra）中起作用（ <code>pra_page_link</code> 类似于 <code>page_link</code> ，用于链接执行“页面替换算法”的链表）</p>
<h2 id="uCore页面置换-amp-物理页控制"><a href="#uCore页面置换-amp-物理页控制" class="headerlink" title="uCore页面置换&amp;物理页控制"></a>uCore页面置换&amp;物理页控制</h2><p><strong>swap_manager</strong> 与 pmm_manager 类似，都设置了一个用于管理某个功能的模块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">     <span class="keyword">int</span> (*init)            (<span class="keyword">void</span>); </span><br><span class="line">    <span class="comment">/* 交换管理器的全局初始化 */</span></span><br><span class="line">     <span class="keyword">int</span> (*init_mm)         (struct mm_struct *mm); </span><br><span class="line">    <span class="comment">/* 初始化mm_结构中的priv数据 */</span></span><br><span class="line">     <span class="keyword">int</span> (*tick_event)      (struct mm_struct *mm); </span><br><span class="line">    <span class="comment">/* 发生时钟中断时调用 */</span></span><br><span class="line">     <span class="keyword">int</span> (*map_swappable)   (struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in); </span><br><span class="line">    <span class="comment">/* 将可交换页面映射到mm_结构时调用 */</span></span><br><span class="line">     <span class="keyword">int</span> (*set_unswappable) (struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr);</span><br><span class="line">    <span class="comment">/* 当页面被标记为共享时，调用此例程(从交换管理器中删除addr条目) */</span></span><br><span class="line">     <span class="keyword">int</span> (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, <span class="keyword">int</span> in_tick);</span><br><span class="line">    <span class="comment">/* 试着换掉一页，然后返回victim */</span></span><br><span class="line">     <span class="keyword">int</span> (*check_swap)(<span class="keyword">void</span>);     </span><br><span class="line">    <span class="comment">/* 检查页面重新定距算法 */</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">/* 结构体swap_manager中:定义了一大堆的函数指针 */</span></span><br></pre></td></tr></table></figure>
<p><strong>pgdir_alloc_page</strong>：分配一块物理页（作为页表），设置页表项（对应物理地址la），插入页表目录（pgdir）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct Page *</span></span><br><span class="line"><span class="function"><span class="title">pgdir_alloc_page</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">uint32_t</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> alloc_page(); <span class="comment">/* 分配一张物理页 */</span></span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (page_insert(pgdir, page, la, perm) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 将该物理页与对应的虚拟地址关联,同时设置页表 */</span></span><br><span class="line">            free_page(page); <span class="comment">/* 释放页 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (swap_init_ok)&#123;</span><br><span class="line">            swap_map_swappable(check_mm_struct, la, page, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">/* 设置当前页为可swap */</span></span><br><span class="line">            page-&gt;pra_vaddr=la;</span><br><span class="line">            assert(page_ref(page) == <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>page_insert</strong>：将该物理页与对应的虚拟地址关联，同时设置页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct Page *page, <span class="keyword">uintptr_t</span> la, <span class="keyword">uint32_t</span> perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pgdir:页目录表PDT的内核虚拟基址</span></span><br><span class="line">    <span class="comment">// page:需要映射的物理页</span></span><br><span class="line">    <span class="comment">// la:需要映射的线性地址</span></span><br><span class="line">    <span class="comment">// perm:在相关pte中设置的该页面的权限</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pte_t</span> *ptep = get_pte(pgdir, la, <span class="number">1</span>); <span class="comment">/* 获取线性地址la对应二级页表项的虚拟地址 */</span></span><br><span class="line">    <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    page_ref_inc(page); <span class="comment">/* 引用次数+1 */</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123; <span class="comment">/* 表示物理内存页存在 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> pte2page(*ptep); <span class="comment">/* 获取该物理页 */</span></span><br><span class="line">        <span class="keyword">if</span> (p == page) &#123;</span><br><span class="line">            page_ref_dec(page); <span class="comment">/* 引用次数-1 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            page_remove_pte(pgdir, la, ptep); <span class="comment">/* 释放某虚地址所在的物理页并取消对应的二级页表项映射 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptep = page2pa(page) | PTE_P | perm; <span class="comment">/* 获取物理页page的物理地址后进行设置 */</span></span><br><span class="line">    <span class="comment">/* ptep为对应二级页表项的虚拟地址,页表项里面也应该装物理地址 */</span></span><br><span class="line">    tlb_invalidate(pgdir, la); <span class="comment">/* 用于使虚拟地址la对应的tlb表项失效 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* page-&gt;ref:当前页被引用的次数,与内存共享有关 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_ref_inc</span><span class="params">(struct Page *page)</span> </span>&#123; </span><br><span class="line">    page-&gt;ref += <span class="number">1</span>; <span class="comment">/* 引用次数+1 */</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_ref_dec</span><span class="params">(struct Page *page)</span> </span>&#123;</span><br><span class="line">    page-&gt;ref -= <span class="number">1</span>; <span class="comment">/* 引用次数-1 */</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>page_remove_pte</strong>：释放某虚地址所在的物理页并取消对应的二级页表项映射（已经实现）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pgdir:页目录表PDT的内核虚拟基址</span></span><br><span class="line">    <span class="comment">// la:需要映射的线性地址</span></span><br><span class="line">    <span class="comment">// ptep:二级页表项的虚拟地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 <span class="comment">/* 模板 */</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;                     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* 实现 */</span></span></span><br><span class="line">    <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep); <span class="comment">/* 获取对应的物理页 */</span></span><br><span class="line">        <span class="keyword">if</span> (page_ref_dec(page) == <span class="number">0</span>) &#123; <span class="comment">/* &quot;引用次数-1&quot;后,确保该页没有被引用 */</span></span><br><span class="line">            free_page(page); <span class="comment">/* 释放目标页 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        *ptep = <span class="number">0</span>;</span><br><span class="line">        tlb_invalidate(pgdir, la); <span class="comment">/* 用于使虚拟地址la对应的tlb表项失效 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>swap_in</strong>：只会将目标物理页加载进内存中，而不会修改页表条目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">swap_in</span><span class="params">(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page **ptr_result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mm:指定地址对应的&quot;所属的内存描述符&quot;</span></span><br><span class="line">    <span class="comment">// addr:指定的虚拟地址</span></span><br><span class="line">    <span class="comment">// ptr_result:最终需要返回的物理页(利用alloc_page进行分配)</span></span><br><span class="line">    </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">result</span> =</span> alloc_page(); <span class="comment">/* 分配一张物理页 */</span></span><br><span class="line">     assert(result!=<span class="literal">NULL</span>); <span class="comment">/* assert断言分配成功 */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">/* 找到一个虚地址对应的二级页表项的虚拟地址,如果此二级页表项不存在,则分配一个包含此项的二级页表 */</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">int</span> r;</span><br><span class="line">     <span class="keyword">if</span> ((r = swapfs_read((*ptep), result)) != <span class="number">0</span>)</span><br><span class="line">         <span class="comment">/* 尝试将硬盘中的内容换入到新的page中 */</span></span><br><span class="line">     &#123;</span><br><span class="line">        assert(r!=<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     cprintf(<span class="string">&quot;swap_in: load disk swap entry %d with swap_page in vadr 0x%x\n&quot;</span>, (*ptep)&gt;&gt;<span class="number">8</span>, addr);</span><br><span class="line">     *ptr_result=result;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>swapfs_read</strong>：尝试将硬盘中的内容换入到新的 page 中 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">swapfs_read</span><span class="params">(<span class="keyword">swap_entry_t</span> entry, struct Page *page)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ide_read_secs(SWAP_DEV_NO, swap_offset(entry) * PAGE_NSECT, page2kva(page), PAGE_NSECT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">ide_read_secs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> ideno, <span class="keyword">uint32_t</span> secno, <span class="keyword">void</span> *dst, <span class="keyword">size_t</span> nsecs)</span> </span>&#123;</span><br><span class="line">    assert(nsecs &lt;= MAX_NSECS &amp;&amp; VALID_IDE(ideno));</span><br><span class="line">    assert(secno &lt; MAX_DISK_NSECS &amp;&amp; secno + nsecs &lt;= MAX_DISK_NSECS);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> iobase = IO_BASE(ideno), ioctrl = IO_CTRL(ideno);</span><br><span class="line"></span><br><span class="line">    ide_wait_ready(iobase, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate interrupt</span></span><br><span class="line">    outb(ioctrl + ISA_CTRL, <span class="number">0</span>);</span><br><span class="line">    outb(iobase + ISA_SECCNT, nsecs);</span><br><span class="line">    outb(iobase + ISA_SECTOR, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_CYL_LO, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_CYL_HI, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_SDH, <span class="number">0xE0</span> | ((ideno &amp; <span class="number">1</span>) &lt;&lt; <span class="number">4</span>) | ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>));</span><br><span class="line">    outb(iobase + ISA_COMMAND, IDE_CMD_READ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; nsecs &gt; <span class="number">0</span>; nsecs --, dst += SECTSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = ide_wait_ready(iobase, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        insl(iobase, dst, SECTSIZE / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>swap_map_swappable</strong>：将该物理页加入到 mm_struct-&gt;sm_priv 指针所指向的双向链表中，换入和换出操作都会操作该链表（插入/移除 <strong>可交换的已分配</strong> 物理页） </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">swap_map_swappable</span><span class="params">(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sm-&gt;map_swappable(mm, addr, page, swap_in); <span class="comment">/* 发生时钟中断时调用 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="uCore缺页异常处理"><a href="#uCore缺页异常处理" class="headerlink" title="uCore缺页异常处理"></a>uCore缺页异常处理</h2><p>页缺失（Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等），是指当软件试图访问已映射在虚拟地址空间中， <strong>但是并未被加载在物理内存中的一个分页时</strong> ，由中央处理器的内存管理单元所发出的中断（读写一个不存在物理页的虚拟页）</p>
<p>通常情况下，用于处理此中断的程序是操作系统的一部分</p>
<ul>
<li>如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存</li>
<li>而如果访问是不被允许的，那么操作系统通常会结束相关的进程</li>
</ul>
<p>产生页访问异常的原因主要有：</p>
<ul>
<li>目标页帧不存在（页表项全为 0，即该线性地址与物理地址尚未建立映射或者已经撤销）</li>
<li>相应的物理页帧不在内存中（页表项非空，但 Present 标志位=0，比如在 swap 分区或磁盘文件上)</li>
<li>不满足访问权限（此时页表项 P 标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面）</li>
</ul>
<p>异常处理的过程：</p>
<p>产生页访问异常后，CPU 硬件和软件都会做一些事情来应对此事</p>
<ul>
<li>首先页访问异常也是一种异常，所以针对一般异常的硬件处理操作是必须要做的，即 CPU 在当前内核栈保存当前被打断的程序现场，即依次压入当前被打断程序使用的 EFLAGS，CS，EIP，errorCode</li>
<li>由于页访问异常的中断号是 0xE，CPU 把异常中断号 0xE 对应的中断服务例程的地址加载到 CS 和 EIP 寄存器中，开始执行中断服务例程</li>
<li>这时 ucore 开始处理异常中断，首先需要保存硬件没有保存的寄存器，在 vectors.S 中的标号 vector14 处先把中断号压入内核栈，然后再在 trapentry.S 中的标号__alltraps 处把 DS、ES 和其他通用寄存器都压栈</li>
<li>自此，被打断的程序执行现场（context）被保存在内核栈中</li>
<li>接下来，在 trap.c 的 trap 函数开始了中断服务例程的处理流程，大致调用关系为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap--&gt;trap_dispatch--&gt;pgfault_handler--&gt;do_pgfault</span><br></pre></td></tr></table></figure>
<p>其中的 <code>do_pgfault</code> 就是该异常处理的核心部分</p>
<h2 id="练习0-把-lab2-的内容复制粘贴到-lab3"><a href="#练习0-把-lab2-的内容复制粘贴到-lab3" class="headerlink" title="练习0-把 lab2 的内容复制粘贴到 lab3"></a>练习0-把 lab2 的内容复制粘贴到 lab3</h2><h2 id="练习1-给未被映射的地址映射上物理页"><a href="#练习1-给未被映射的地址映射上物理页" class="headerlink" title="练习1-给未被映射的地址映射上物理页"></a>练习1-给未被映射的地址映射上物理页</h2><p>完成 <code>do_pgfault</code> 函数（mm/vmm.c），给未被映射的地址映射上物理页，设置访问权限的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表</p>
<ul>
<li>触发 do_pgfault 有两种情况：<ul>
<li>如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存</li>
<li>如果访问是不被允许的，那么操作系统通常会结束相关的进程</li>
</ul>
</li>
<li>第二种情况程序已经替我们实现了，所以我们需要“将相关的分页从硬盘上的虚拟内存文件中调入内存”</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_pgfault</span><span class="params">(struct mm_struct *mm, <span class="keyword">uint32_t</span> error_code, <span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mm:指定地址对应的&quot;所属的内存描述符&quot;</span></span><br><span class="line">    <span class="comment">// error_code:错误代码</span></span><br><span class="line">    <span class="comment">// addr:发生Page Fault的虚拟地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL;</span><br><span class="line">    <span class="comment">/* 根据mm找到一个vma(virtual memory areas) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">/* vma未找到 || 如果addr(虚拟地址)不在mm的vma范围内 */</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检测到错误代码,根据错误代码输出错误信息 */</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* error code flag : default is 3 ( W/R=1, P=1): write, present */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">/* error code flag : (W/R=1, P=0): write, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* error code flag : (W/R=0, P=1): read, present */</span></span><br><span class="line">        cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* error code flag : (W/R=0, P=0): read, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> perm = PTE_U; <span class="comment">/* 设置页表条目所对应的权限:可以读取对应物理页的内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE); <span class="comment">/* 将addr与PGSIZE对齐 */</span></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">pte_t</span> *ptep=<span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 <span class="comment">/* 需要在这里实现:将相关的分页从硬盘上的虚拟内存文件中调入内存 */</span></span></span><br><span class="line">    ptep = ???        </span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">            struct Page *page=<span class="literal">NULL</span>;               </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>尝试查找 pte，如果 pte 的PT（页面表）不存在，则创建一个PT</li>
<li>如果 phy addr 不存在，则分配一个页面并将 phy addr 映射为逻辑 addr</li>
<li>根据 mm 和 addr，尝试加载右磁盘页面的内容</li>
<li>根据 mm、addr 和 page，设置 phy addr 的映射</li>
<li>使页面可交换</li>
</ul>
<p>具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_pgfault</span><span class="params">(struct mm_struct *mm, <span class="keyword">uint32_t</span> error_code, <span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mm:指定地址对应的&quot;所属的内存描述符&quot;</span></span><br><span class="line">    <span class="comment">// error_code:错误代码</span></span><br><span class="line">    <span class="comment">// addr:发生Page Fault的虚拟地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL;</span><br><span class="line">    <span class="comment">/* 根据mm找到一个vma(virtual memory areas) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">/* vma未找到 || 如果addr(虚拟地址)不在mm的vma范围内 */</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 检测错误代码,这里的检测不涉及特权判断 */</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* error code flag : default is 3 ( W/R=1, P=1): write, present */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">/* error code flag : (W/R=1, P=0): write, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* error code flag : (W/R=0, P=1): read, present */</span></span><br><span class="line">        cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* error code flag : (W/R=0, P=0): read, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> perm = PTE_U; <span class="comment">/* 设置页表条目所对应的权限:可以读取对应物理页的内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE); <span class="comment">/* 将addr与PGSIZE对齐 */</span></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">pte_t</span> *ptep=<span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 <span class="comment">/* 模板 */</span></span></span><br><span class="line">    ptep = ???         </span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">            struct Page *page=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>); <span class="comment">/* 获取当前虚拟地址所对应的页表项 */</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123; <span class="comment">/* 该页表项对应的物理页不存在 */</span></span><br><span class="line">        <span class="keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* 分配一块物理页，并设置页表项 */</span></span><br><span class="line">            cprintf(<span class="string">&quot;pgdir_alloc_page in do_pgfault failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 该页表项对应的物理页存在 */</span></span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123; <span class="comment">/* 如果swap已经初始化完成 */</span></span><br><span class="line">            struct Page *page=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* 只会将目标物理页加载进内存中，而不会修改页表条目 */</span></span><br><span class="line">                cprintf(<span class="string">&quot;swap_in in do_pgfault failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            &#125;    </span><br><span class="line">            page_insert(mm-&gt;pgdir, page, addr, perm);</span><br><span class="line">            <span class="comment">/* 将该物理页与对应的虚拟地址关联,同时设置页表 */</span></span><br><span class="line">            swap_map_swappable(mm, addr, page, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">/* 设置当前页为可swap */</span></span><br><span class="line">            page-&gt;pra_vaddr = addr;</span><br><span class="line">            <span class="comment">/* page-&gt;pra_vaddr:用于保存该物理页所对应的虚拟地址 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习2-补充完成基于FIFO的页面替换算法"><a href="#练习2-补充完成基于FIFO的页面替换算法" class="headerlink" title="练习2-补充完成基于FIFO的页面替换算法"></a>练习2-补充完成基于FIFO的页面替换算法</h2><p>FIFO 中，当新加入一个物理页时，我们只需将该物理页加入至链表首部即可，当需要换出某个物理页时，选择链表末尾的物理页即可</p>
<p>先看看 FIFO 初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list_entry_t</span> pra_list_head; <span class="comment">/* swap manager中:&quot;可交换已分配&quot;链表的链表头 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_init_mm(struct mm_struct *mm)</span><br><span class="line">&#123;     </span><br><span class="line">     list_init(&amp;pra_list_head);</span><br><span class="line">     mm-&gt;sm_priv = &amp;pra_list_head;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">list_init</span><span class="params">(<span class="keyword">list_entry_t</span> *elm)</span> </span>&#123;</span><br><span class="line">    elm-&gt;prev = elm-&gt;next = elm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>让 mm-&gt;sm_priv 指向 pra_list_head 的地址</li>
<li>现在，我们可以从内存控制结构体 mm_struct 访问 FIFO PRA（FIFO页面替换算法）</li>
</ul>
<p>接下来就是需要我们进行完善的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="comment">/* 执行目标页加入队列的操作(插入目标页头部即可) */</span></span><br><span class="line">_fifo_map_swappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in) </span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv; <span class="comment">/* 获取pra_list_head */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);</span><br><span class="line"> 	<span class="comment">/* 获取用于连接上一个和下一个&quot;可交换已分配&quot;的物理页 */</span></span><br><span class="line">    </span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>); <span class="comment">/* 断言获取成功 */</span></span><br><span class="line">    <span class="comment">//record the page access situlation</span></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span> </span><br><span class="line">    <span class="comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="comment">/* 执行换出队列的操作(把链表尾部的page脱链即可) */</span></span><br><span class="line">_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick)</span><br><span class="line">&#123; </span><br><span class="line">     <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv; <span class="comment">/* 获取pra_list_head */</span></span><br><span class="line">         assert(head != <span class="literal">NULL</span>);</span><br><span class="line">     assert(in_tick==<span class="number">0</span>);</span><br><span class="line">     <span class="comment">/* Select the victim */</span></span><br><span class="line">     <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span> </span><br><span class="line">     <span class="comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span></span><br><span class="line">     <span class="comment">//(2)  assign the value of *ptr_page to the addr of this page</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体实现特别简单：（参考 CSapp 中的 malloc lab）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="comment">/* 执行目标页加入队列的操作(插入目标页头部即可) */</span></span><br><span class="line">_fifo_map_swappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// mm:指定地址对应的&quot;所属的内存描述符&quot;</span></span><br><span class="line">    <span class="comment">// addr:发生目标虚拟地址</span></span><br><span class="line">    <span class="comment">// page:将要被插入的物理页</span></span><br><span class="line">    <span class="comment">// swap_in:swap_manager中的函数指针(将可交换页面映射到mm_结构时调用)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv; <span class="comment">/* 获取pra_list_head */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link); <span class="comment">/* page-&gt;pra_page_link==NULL */</span></span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 结点-&gt;prev  &lt;--1--&gt;  结点(pra_list_head)  &lt;--2--&gt;  结点-&gt;next */</span></span><br><span class="line">    </span><br><span class="line">    list_add(head, entry); <span class="comment">/* 直接插入头部(&quot;2&quot;号位置) */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="comment">/* 执行换出队列的操作(把链表尾部的page脱链即可) */</span> </span><br><span class="line">_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// mm:指定地址对应的&quot;所属的内存描述符&quot;</span></span><br><span class="line">    <span class="comment">// ptr_page:将要被换出的物理页(会被返回出来)</span></span><br><span class="line">    <span class="comment">// in_tick:信息表示位</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv; <span class="comment">/* 获取pra_list_head */</span></span><br><span class="line">         assert(head != <span class="literal">NULL</span>);</span><br><span class="line">     assert(in_tick==<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">list_entry_t</span> *le = head-&gt;prev; <span class="comment">/* 获取pra_list_head-&gt;prev(链表尾) */</span></span><br><span class="line">     assert(head!=le);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> le2page(le, pra_page_link); <span class="comment">/* 根据链表信息获取该page的位置 */</span></span><br><span class="line">     list_del(le); <span class="comment">/* 脱链操作 */</span></span><br><span class="line">     assert(p !=<span class="literal">NULL</span>);</span><br><span class="line">     *ptr_page = p;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  lab3 make grade</span><br><span class="line">Check SWAP:              (<span class="number">1.2</span>s)</span><br><span class="line">  -check pmm:                                OK</span><br><span class="line">  -check page table:                         OK</span><br><span class="line">  -check vmm:                                WRONG</span><br><span class="line">   -e !! error: missing <span class="string">&#x27;page fault at 0x00000100: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;check_pgfault() succeeded!&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;check_vmm() succeeded.&#x27;</span></span><br><span class="line"></span><br><span class="line">  -check swap page fault:                    WRONG</span><br><span class="line">   -e !! error: missing <span class="string">&#x27;page fault at 0x00001000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00002000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00003000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00004000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;write Virt Page e in fifo_check_swap&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00005000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00001000: K/W [no page found]&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00002000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00003000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;page fault at 0x00004000: K/W [no page found].&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;check_swap() succeeded!&#x27;</span></span><br><span class="line"></span><br><span class="line">  -check ticks:                              WRONG</span><br><span class="line">   -e !! error: missing <span class="string">&#x27;++ setup timer interrupts&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;100 ticks&#x27;</span></span><br><span class="line">   !! error: missing <span class="string">&#x27;End of Test.&#x27;</span></span><br><span class="line"></span><br><span class="line">Total Score: <span class="number">10</span>/<span class="number">45</span></span><br><span class="line">make: *** [Makefile:<span class="number">260</span>：grade] 错误 <span class="number">1</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/miscellaneous/" rel="tag"><i class="fa fa-tag"></i> miscellaneous</a>
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/Kernel/" rel="tag"><i class="fa fa-tag"></i> Kernel</a>
              <a href="/tags/Ucore/" rel="tag"><i class="fa fa-tag"></i> Ucore</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/14/Ucore-Lab2/" rel="prev" title="Ucore-Lab2">
      <i class="fa fa-chevron-left"></i> Ucore-Lab2
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/19/StarCTF2022/" rel="next" title="StarCTF2022">
      StarCTF2022 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#vma%E7%AE%80%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">vma简析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">2.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uCore%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2-amp-%E7%89%A9%E7%90%86%E9%A1%B5%E6%8E%A7%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">uCore页面置换&amp;物理页控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uCore%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">uCore缺页异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A00-%E6%8A%8A-lab2-%E7%9A%84%E5%86%85%E5%AE%B9%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%88%B0-lab3"><span class="nav-number">5.</span> <span class="nav-text">练习0-把 lab2 的内容复制粘贴到 lab3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01-%E7%BB%99%E6%9C%AA%E8%A2%AB%E6%98%A0%E5%B0%84%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8A%E7%89%A9%E7%90%86%E9%A1%B5"><span class="nav-number">6.</span> <span class="nav-text">练习1-给未被映射的地址映射上物理页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02-%E8%A1%A5%E5%85%85%E5%AE%8C%E6%88%90%E5%9F%BA%E4%BA%8EFIFO%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">练习2-补充完成基于FIFO的页面替换算法</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">332</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:53</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
