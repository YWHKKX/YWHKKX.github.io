<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="进程状态进程的生命周期通常有6种情况：进程创建、进程执行、进程等待、进程抢占、进程唤醒、进程结束 对应了一下几种进程状态：  创建状态： 这是一个进程刚刚建立，但还未将它送人就绪队列时的状态  指的是为程序分配合适的pcb格式，然后放入内存 如果由于内存不足，暂未放入主存，创建工作并未完成，进程不能被调用，则被成为创建状态   就绪状态： 指进程得到了除CPU以外所有必要资源就等CPU开始发动了">
<meta property="og:type" content="article">
<meta property="og:title" content="Ucore-Lab4">
<meta property="og:url" content="http://example.com/2022/04/19/Ucore-Lab4/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="进程状态进程的生命周期通常有6种情况：进程创建、进程执行、进程等待、进程抢占、进程唤醒、进程结束 对应了一下几种进程状态：  创建状态： 这是一个进程刚刚建立，但还未将它送人就绪队列时的状态  指的是为程序分配合适的pcb格式，然后放入内存 如果由于内存不足，暂未放入主存，创建工作并未完成，进程不能被调用，则被成为创建状态   就绪状态： 指进程得到了除CPU以外所有必要资源就等CPU开始发动了">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/04/19/Ucore-Lab4/1650201734801-1651324459312.png">
<meta property="og:image" content="http://example.com/2022/04/19/Ucore-Lab4/1650201455136-1651324459313.png">
<meta property="article:published_time" content="2022-04-19T10:46:54.000Z">
<meta property="article:modified_time" content="2023-03-16T15:43:02.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="miscellaneous">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="Kernel">
<meta property="article:tag" content="Ucore">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/19/Ucore-Lab4/1650201734801-1651324459312.png">

<link rel="canonical" href="http://example.com/2022/04/19/Ucore-Lab4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Ucore-Lab4 | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/19/Ucore-Lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Ucore-Lab4
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-19 18:46:54" itemprop="dateCreated datePublished" datetime="2022-04-19T18:46:54+08:00">2022-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:43:02" itemprop="dateModified" datetime="2023-03-16T23:43:02+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>15 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>进程的生命周期通常有6种情况：进程创建、进程执行、进程等待、进程抢占、进程唤醒、进程结束</p>
<p>对应了一下几种进程状态：</p>
<ul>
<li>创建状态：<ul>
<li>这是一个进程刚刚建立，但还未将它送人就绪队列时的状态 </li>
<li>指的是为程序分配合适的pcb格式，然后放入内存</li>
<li>如果由于内存不足，暂未放入主存，创建工作并未完成，进程不能被调用，则被成为创建状态</li>
</ul>
</li>
<li>就绪状态：<ul>
<li>指进程得到了除CPU以外所有必要资源就等CPU开始发动了</li>
<li>通常把处于就绪状态的进程排成一个或多个队列，称其为就绪队列</li>
</ul>
</li>
<li>执行状态：<ul>
<li>指进程已获得处理机，其程序正在执行 </li>
<li>得到调度被分配到CPU，就会从就绪状态转换为执行状态，单CPU只能执行单进程，多CPU可以进行多进程</li>
</ul>
</li>
<li>阻塞状态：<ul>
<li>进程因等待某事件（如：等待I/O操作结束、等待通信信息、等待申请缓存空间）而暂停执行时的状态</li>
<li>指执行状态受到I/O的影响变为阻塞状态，等I/O完成后又变为就绪状态</li>
<li>通常将处于阻塞状态的进程排成一个队列，称为阻塞队列，在有的系统中，按阻塞原因的不同而将处于阻塞状态的进程排成多个队列</li>
</ul>
</li>
<li>唤醒状态：<ul>
<li>唤醒进程的原因：<ul>
<li>被阻塞进程需要的资源可被满足</li>
<li>被阻塞进程等待的事件到达</li>
<li>将该进程的PCB插入到就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>终止状态（僵尸状态）：<ul>
<li>当一个进程已经正常结束或异常结束，OS已将它从就绪队列中移出，但尚未将它撤消时的状态（父进程尚未使用 <code>wait</code> 函数族等来收尸，即等待父进程销毁它）</li>
<li>自然或非正常结束进程，将进入终止状态，先等待os处理，然后将其pcb清零，将pcb空间返还系统</li>
</ul>
</li>
</ul>
<h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><p>在Unix中，进程通过系统调用 <code>fork</code> 和 <code>exec</code> 来创建一个进程</p>
<ul>
<li><code>fork</code>：把一个进程复制成两个除PID以外完全相同的进程<ul>
<li>fork 函数创建一个继承的子进程：<ul>
<li>该子进程复制父进程的所有变量和内存，以及父进程的所有CPU寄存器（除了某个特殊寄存器，以区分是子进程还是父进程） </li>
</ul>
</li>
<li>fork 函数一次调用，返回两个值：<ul>
<li>父进程中返回子进程的PID</li>
<li>子进程中返回 0</li>
</ul>
</li>
<li>fork 函数的开销十分昂贵，其实现开销来源于：<ul>
<li>对子进程分配内存</li>
<li>复制父进程的内存和寄存器到子进程中</li>
</ul>
</li>
<li>在大多数情况下，调用 <code>fork</code> 函数后就紧接着调用 <code>exec</code> ，此时 <code>fork</code> 中的内存复制操作是无用的，因此，<code>fork</code> 函数中使用 <strong>写时复制技术</strong>（Copy on Write， COW）</li>
</ul>
</li>
<li><code>exec</code>：用新进程来重写当前进程，PID没有改变</li>
</ul>
<p><strong>空闲进程的创建</strong></p>
<p>空闲进程主要工作是完成内核中各个子系统的初始化，并最后用于调度其他进程，该进程最终会一直在 <code>cpu_idle</code> 函数中判断当前是否可调度（循环语句）</p>
<ul>
<li>简单来说，虽然这叫做“系统空闲进程”，但这其实并不是一个真正的进程</li>
<li>由于该进程是为了调度进程而创建的，所以其 <code>need_resched</code> 成员初始时为1（需要被调度）</li>
<li>空闲进程在 <code>proc_init</code> 函数中被创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        <span class="comment">/* 分配一个物理页,作为proc_struct结构体 */</span></span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>; <span class="comment">/* 将空闲进程作为第一个进程,pid为0 */</span></span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE; <span class="comment">/* 设置该空闲进程始终可运行 */</span></span><br><span class="line">    idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack; <span class="comment">/* 设置空闲进程的内核栈 */</span></span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>; <span class="comment">/* 设置该空闲进程为可调度 */</span></span><br><span class="line">    set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>); <span class="comment">/* 设置该进程的name为&quot;idle&quot; */</span></span><br><span class="line">    nr_process ++; <span class="comment">/* 将全局线程的数目加1 */</span></span><br><span class="line"></span><br><span class="line">    current = idleproc; <span class="comment">/* 设置当前进程为idleproc */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &lt;-------- 第一个内核进程的创建 --------&gt; */</span></span><br><span class="line">    <span class="keyword">int</span> pid = kernel_thread(init_main, <span class="string">&quot;Hello world!!&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid);</span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一个内核进程的创建</strong></p>
<p>第一个内核进程是未来所有新进程的父进程或祖先进程</p>
<ul>
<li>在 <code>proc_init</code> 函数中完成创建工作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &lt;-------- 第一个内核进程的创建 --------&gt; */</span></span><br><span class="line"><span class="keyword">int</span> pid = kernel_thread(init_main, <span class="string">&quot;Hello world!!&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123; <span class="comment">/* 内核进程创建失败 */</span></span><br><span class="line">    panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initproc = find_proc(pid); <span class="comment">/* 通过pid查找proc_struct,并赋值给initproc */</span></span><br><span class="line">set_proc_name(initproc, <span class="string">&quot;init&quot;</span>); <span class="comment">/* 设置该进程的name为&quot;init&quot; */</span></span><br><span class="line"></span><br><span class="line">assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>kernel_thread</code>中<ul>
<li>程序先设置 <code>trapframe</code> 结构，最后调用 <code>do_fork</code> 函数</li>
<li>注意：该 <code>trapframe</code> 部分寄存器 <code>ebx、edx、eip</code> 被分别设置为“目标函数地址”、“参数地址”以及“kernel_thread_entry地址”</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">init_main</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123; <span class="comment">/* 打印函数 */</span></span><br><span class="line">    cprintf(<span class="string">&quot;this initproc, pid = %d, name = \&quot;%s\&quot;\n&quot;</span>, current-&gt;pid, get_proc_name(current));</span><br><span class="line">    cprintf(<span class="string">&quot;To U: \&quot;%s\&quot;.\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)arg);</span><br><span class="line">    cprintf(<span class="string">&quot;To U: \&quot;en.., Bye, Bye. :)\&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fn:某个打印函数</span></span><br><span class="line">    <span class="comment">// arg:某个字符串</span></span><br><span class="line">    <span class="comment">// clone_flags:标志位</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe)); <span class="comment">/* 设置trapframe结构 */</span></span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;</span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">    tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf); <span class="comment">/* 调用do_fork */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>do_fork</code> 就是后续实验需要实现的函数</li>
</ul>
<h2 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h2><p>将处于挂起状态的进程映像在磁盘上，目的是减少进程占用的内存</p>
<p>挂起状态，它既可以是我们客户主动使得进程挂起，也可以是操作系统因为某些原因使得进程挂起，总而言之引入挂起状态的原因有以下几种：</p>
<ul>
<li>用户的请求：可能是在程序运行期间发现了可疑的问题，需要暂停进程</li>
<li>父进程的请求：考察，协调，或修改子进程</li>
<li>操作系统的需要：对运行中资源的使用情况进行检查和记账</li>
<li>负载调节的需要：有一些实时的任务非常重要，需要得到充足的内存空间，这个时候我们需</li>
<li>把非实时的任务进行挂起，优先使得实时任务执行</li>
<li>定时任务：一个进程可能会周期性的执行某个任务，那么在一次执行完毕后挂起而不是阻塞，这样可以节省内存</li>
<li>安全：系统有时可能会出现故障或者某些功能受到破坏，这是就需要将系统中正在进行的进程进行挂起，当系统故障消除以后，对进程的状态进行恢复</li>
</ul>
<p>挂起（Suspend）：把一个进程从内存转到外存 </p>
<ul>
<li>等待到等待挂起：没有进程处于就绪状态或就绪进程要求更多内存资源</li>
<li>就绪到就绪挂起：当有高优先级进程处于等待状态（系统认为很快会就绪的），低优先级就绪进程会挂起，为高优先级进程提供更大的内存空间</li>
<li>运行到就绪挂起：当有高优先级等待进程因事件出现而进入就绪挂起</li>
<li>等待挂起到就绪挂起：当有等待挂起进程因相关事件出现而转换状</li>
</ul>
<p>激活（Activate）：把一个进程从外存转到内存</p>
<ul>
<li>就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程</li>
<li>等待挂起到等待：当一个进程释放足够内存，并有高优先级等待挂起进程</li>
</ul>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p><strong>过程简述</strong></p>
<ul>
<li>暂停当前进程，保存上下文，并从运行状态变成其他状态</li>
<li>调度另一个进程，恢复其上下文并从就绪状态转为运行状态</li>
</ul>
<p><strong>进程控制块</strong>（Process Control Block，PCB）</p>
<ul>
<li>进程控制块是 <strong>操作系统管理控制进程运行所用的信息集合</strong> ，操作系统用PCB来描述 <strong>进程的基本情况以及运行变化的过程</strong></li>
<li><strong>PCB是进程存在的唯一标志</strong> ，每个进程都在操作系统中有一个对应的PCB（内核为每个进程维护了对应的进程控制块PCB）</li>
<li>进程控制块可以通过某个数据结构组织起来（例如链表），同一状态进程的 PCB 连接成一个链表，多个状态对应多个不同的链表，各状态的进程形成不同的链表：就绪联链表，阻塞链表等等</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span></span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// 未初始化的     -- alloc_proc</span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// 等待状态       -- try_free_pages, do_wait, do_sleep</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// 就绪/运行状态  -- proc_init, wakeup_proc,</span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// 僵死状态       -- do_exit</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>      <span class="comment">// 当前进程的状态</span></span><br><span class="line">    <span class="keyword">int</span> pid;                    <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">int</span> runs;                   <span class="comment">// 当前进程被调度的次数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack;           <span class="comment">// 内核栈</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched; <span class="comment">// 是否需要被调度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span> <span class="comment">// 父进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// 保存的进程上下文,用于进程切换</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>       <span class="comment">// 中断帧指针,指向内核栈的某个位置(保存有中断上下文)</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3;                  <span class="comment">// 页目录表的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// 当前进程的相关标志</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];   <span class="comment">// 进程名称(可执行文件名)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;         <span class="comment">// 进程链表 </span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;         <span class="comment">// 进程哈希表 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>struct context context</code>：<ul>
<li>需要注意的是，与 <code>trapframe</code> 所保存的用户态上下文不同，context 保存的是线程的 <strong>当前</strong> 上下文</li>
<li>这个上下文可能是执行用户代码时的上下文，也可能是执行内核代码时的上下文</li>
</ul>
</li>
<li><code>struct trapframe* tf</code>：<ul>
<li>无论是用户程序在用户态通过系统调用进入内核态，还是线程在内核态中被创建，内核态中的线程返回用户态所加载的上下文就是 <code>struct trapframe* tf</code></li>
<li>所以当一个线程在内核态中建立，则该新线程就必须“伪造”一个 <code>trapframe</code> 来返回用户态</li>
</ul>
</li>
<li>两者关系：<ul>
<li>以 <code>kernel_thread</code> 函数为例，尽管该函数设置了 <code>proc-&gt;trapframe</code> ，但在 <code>fork</code> 函数中的 <code>copy_thread</code> 函数里，程序还会设置 <code>proc-&gt;context</code> </li>
<li>“两个上下文”看上去好像冗余，但实际上两者所分的工是不一样的</li>
<li>进程之间通过进程调度来切换控制权，当某个 <code>fork</code> 出的新进程获取到了控制流后，首当其中执行的代码是 <code>current-&gt;context-&gt;eip</code> 所指向的代码，此时新进程仍处于内核态，但实际上我们想在用户态中执行代码，所以我们需要从内核态切换回用户态，也就是中断返回，此时会遇上两个问题：<ul>
<li>新进程如何执行中断返回？：这就是 <code>proc-&gt;context.eip = (uintptr_t)forkret</code> 的用处， <code>forkret</code> 会使新进程正确的从中断处理例程中返回</li>
<li>新进程中断返回至用户代码时的上下文为？：这就是 <code>proc_struct-&gt;tf</code> 的用处，中断返回时，新进程会恢复保存的 <code>trapframe</code> 信息至各个寄存器中，然后开始执行用户代码</li>
</ul>
</li>
</ul>
</li>
<li>由于进程数量可能较大，倘若从头向后遍历查找符合某个状态的PCB，则效率会十分低下，因此使用了哈希表作为遍历所用的数据结构</li>
</ul>
<p><strong>详细流程</strong></p>
<ul>
<li>uCore中，内核的第一个进程 <code>idleproc</code>（空闲进程）会执行 <code>cpu_idle</code> 函数，并从中调用 <code>schedule</code> 函数，准备开始调度进程：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">current</span> =</span> <span class="literal">NULL</span>; <span class="comment">/* 指向当前的进程 */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cpu_idle</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched) &#123; <span class="comment">/* 是否需要被调度 */</span></span><br><span class="line">            schedule(); <span class="comment">/* 准备开始调度进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>schedule</code> 函数会先清除调度标志，并从当前进程在链表中的位置开始，遍历进程控制块，直到找出处于 <strong>就绪状态</strong> 的进程：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list_entry_t</span> proc_list; <span class="comment">/* 进程链表的起始地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">idleproc</span> =</span> <span class="literal">NULL</span>; <span class="comment">/* 内核的第一个进程 */</span></span><br><span class="line"><span class="comment">/* 内核的第一个进程(空闲进程):其主要工作是完成内核中各个子系统的初始化,并最后用于调度其他进程 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le2proc(le, member)         \</span></span><br><span class="line"><span class="meta">    to_struct((le), struct proc_struct, member)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_struct(ptr, type, member)                               \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le, *last;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>; <span class="comment">/* 清除调度标志 */</span></span><br><span class="line">        last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link);</span><br><span class="line">        <span class="comment">/* 第一次执行时:当前进程肯定是第一个进程(空闲进程) */</span></span><br><span class="line">        <span class="comment">/* 后续执行时:current可能是第一个进程(空闲进程),也可能不是 */</span></span><br><span class="line">        </span><br><span class="line">        le = last; <span class="comment">/* 初始化le为当前进程在链表中的位置 */</span></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">/* 遍历整个进程链表,直到找出处于就绪状态的进程(准备将其调度) */</span></span><br><span class="line">            <span class="keyword">if</span> ((le = list_next(le)) != &amp;proc_list) &#123;</span><br><span class="line">                next = le2proc(le, list_link); <span class="comment">/* 根据链表信息获取该进程的物理地址 */</span></span><br><span class="line">                <span class="keyword">if</span> (next-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">                    <span class="comment">/* 如果是&quot;就绪/运行状态&quot;直接break,进入后续操作 */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (le != last);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span> || next-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            next = idleproc; <span class="comment">/* 判断将要被调度的进程为空闲进程 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++; <span class="comment">/* 目标进程被调度的次数增加 */</span></span><br><span class="line">        <span class="keyword">if</span> (next != current) &#123; </span><br><span class="line">            <span class="comment">/* 如果调度进程不是当前进程,则运行proc_run,否则会重新进入空闲进程(循环) */</span></span><br><span class="line">            proc_run(next); <span class="comment">/* 执行进程调度操作 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>proc_run</code> 函数会设置TSS中ring0的内核栈地址，同时还会加载页目录表的地址，等到这些前置操作完成后，最后执行上下文切换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123; <span class="comment">/* 再次检查(调度进程,不能等于当前进程) */</span></span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = proc; <span class="comment">/* 设置当前执行的进程 */</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE); <span class="comment">/* 设置ring0的内核栈地址 */</span></span><br><span class="line">            lcr3(next-&gt;cr3); <span class="comment">/* 加载页目录表 */</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context)); <span class="comment">/* 切换上下文(汇编) */</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>PS：线程控制块</strong>（Thread Control Block，TCB）</p>
<ul>
<li>线程控制块（TCB）是与进程的控制块（PCB）相似的子控制块，只是TCB中所保存的线程状态比PCB中保存少而已</li>
</ul>
<img src="/2022/04/19/Ucore-Lab4/1650201734801-1651324459312.png" class width="1650201734801"> 
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p><strong>有序终止</strong>：进程结束时调用 <code>exit()</code>，完成进程资源回收</p>
<ul>
<li><code>exit</code> 函数调用的功能：<ul>
<li>将调用参数作为进程的“结果”</li>
<li>关闭所有打开的文件等占用资源</li>
<li>释放内存</li>
<li>释放大部分进程相关的内核数据结构</li>
<li>检查父进程是否存活<ul>
<li>如果存活，则保留结果的值，直到父进程使用，同时当前进程进入僵尸状态</li>
<li>如果没有，它将释放所有的数据结构，进程结束</li>
</ul>
</li>
<li>清理所有等待的僵尸进程（僵尸状态，终止状态）</li>
</ul>
</li>
</ul>
<h2 id="进程机制"><a href="#进程机制" class="headerlink" title="进程机制"></a>进程机制</h2><p>这里我将简述一下 ucore 的进程是什么实现的：（涉及多进程原理）</p>
<ul>
<li>内核的第一个进程 <code>idleproc</code>（空闲进程）会执行 <code>cpu_idle</code>函数，在这个函数中循环执行 <code>schedule</code> 用于空闲进程的调度，这个函数是永远不会停止的</li>
<li>其他的进程都会因为<code>schedule</code> 而被调度，又会因为各种原因被中断，然后再次调度</li>
<li>CPU 会把自己的资源依靠某种算法给分配到这些进程上，每次对于一个进程只执行一小会儿（用定时器timer实现），然后去执行其他的进程</li>
<li>从用户的视角来看，就好像这些进程是“同步运行”的一样，这就是操作系统提供的“抽象”</li>
</ul>
<h2 id="中断帧"><a href="#中断帧" class="headerlink" title="中断帧"></a>中断帧</h2><p>中断发生时：内核将进程的所有寄存器的值放到了进程的 trapframe 结构中</p>
<p>trapframe 保存的都是一些系统关键的寄存器，这里我们只需要特别关注4个寄存器（涉及到程序执行的控制流问题）：</p>
<ul>
<li>EFLAGS：状态寄存器（本实验暂时用不到）</li>
<li>EIP：Instruction Pointer，当前执行的汇编指令的地址</li>
<li>ESP：当前的栈顶</li>
<li>EBP：当前的栈底，当前过程的帧在栈中的开始地址(高地址) </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<h2 id="用户线程与内核线程"><a href="#用户线程与内核线程" class="headerlink" title="用户线程与内核线程"></a>用户线程与内核线程</h2><p>线程有三种实现方式</p>
<ul>
<li>用户线程：在用户空间实现（POSIX Pthread）<ul>
<li>用户线程的定义：<ul>
<li>用户线程是由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等</li>
</ul>
</li>
<li>用户线程的特征：<ul>
<li>不依赖于操作系统内核，在用户空间实现线程机制<ul>
<li>可用于不支持线程的多进程操作系统</li>
<li>线程控制模块（TCB）由线程库函数内部维护</li>
</ul>
</li>
<li>同一个进程内的用户线程切换速度块，无需用户态/核心态切换</li>
<li>允许每个进程拥有自己的线程调度算法</li>
</ul>
</li>
<li>用户进程的缺点：<ul>
<li>线程发起系统调用而阻塞时，整个进程都会进入等待状态</li>
<li>不支持基于线程的处理机抢占</li>
<li>只能按进程分配CPU时间</li>
</ul>
</li>
</ul>
</li>
<li>内核线程：在内核中实现（Windows，Linux）<ul>
<li>内核线程的定义：<ul>
<li>内核线程是由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理</li>
</ul>
</li>
<li>内核线程的特征：<ul>
<li>由内核自己维护PCB和TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建、终止和切换消耗相对较大</li>
<li>以线程为单位进行CPU时间分配，其中多线程进程可以获得更多的CPU时间</li>
</ul>
</li>
</ul>
</li>
<li>轻权进程：轻权进程是操作系统内核支持的用户线程<ul>
<li>轻权进程的特点：<ul>
<li>用户线程可以自定义调度算法，但存在部分缺点</li>
<li>而内核线程不存在用户线程的各种缺点</li>
<li>所以轻权进程是用户线程与内核线程的结合产物</li>
</ul>
</li>
<li>轻权进程的模型图：</li>
</ul>
</li>
</ul>
<img src="/2022/04/19/Ucore-Lab4/1650201455136-1651324459313.png" class width="1650201455136"> 
<h2 id="练习0-把-lab3-的内容复制粘贴到-lab4"><a href="#练习0-把-lab3-的内容复制粘贴到-lab4" class="headerlink" title="练习0-把 lab3 的内容复制粘贴到 lab4"></a>练习0-把 lab3 的内容复制粘贴到 lab4</h2><h2 id="练习1-分配并初始化一个进程控制块"><a href="#练习1-分配并初始化一个进程控制块" class="headerlink" title="练习1-分配并初始化一个进程控制块"></a>练习1-分配并初始化一个进程控制块</h2><p>alloc_proc 函数负责分配并返回一个新的 struct proc_struct 结构，用于存储新建立的内核线程的管理信息，ucore 需要对这个结构进行最基本的初始化，你需要完成这个初始化过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE1 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * below fields in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment">     *       enum proc_state state;	       // Process state</span></span><br><span class="line"><span class="comment">     *       int pid;                      // Process ID</span></span><br><span class="line"><span class="comment">     *       int runs;                     // the running times of Proces</span></span><br><span class="line"><span class="comment">     *       uintptr_t kstack;             // Process kernel stack</span></span><br><span class="line"><span class="comment">     *       volatile bool need_resched;   // bool value: need to be rescheduled to release CPU?</span></span><br><span class="line"><span class="comment">     *       struct proc_struct *parent;   // the parent process</span></span><br><span class="line"><span class="comment">     *       struct mm_struct *mm;         // Process&#x27;s memory management field</span></span><br><span class="line"><span class="comment">     *       struct context context;       // Switch here to run process</span></span><br><span class="line"><span class="comment">     *       struct trapframe *tf;         // Trap frame for current interrupt</span></span><br><span class="line"><span class="comment">     *       uintptr_t cr3;                // CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line"><span class="comment">     *       uint32_t flags;               // Process flag</span></span><br><span class="line"><span class="comment">     *       char name[PROC_NAME_LEN + 1]; // Process name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的关键就是初始化一个 proc_struct 结构体：</p>
<ul>
<li>首先需要知道 proc_struct 结构体的内容</li>
<li>然后需要明白它的各个条目该初始化为什么</li>
</ul>
<p>下面是实现的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;			<span class="comment">// 进程所处状态-未初始化的</span></span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;					   <span class="comment">// 进程的PID为&quot;-1&quot;</span></span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;					   <span class="comment">// 进程的运行时间为0</span></span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;			    <span class="comment">// 该进程不需要被CPU调度</span></span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;			    <span class="comment">// 页目录为内核页目录表的基址</span></span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，具体的操作流程需要看后续的代码是怎么安排的，我为了省事就直接抄答案了</p>
<ul>
<li><code>context</code>是进程的上下文：用于进程的上下文切换</li>
<li><code>*tf</code> 是中断帧指针：总是指向内核栈的某个位置 <ul>
<li>当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态</li>
<li>当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值</li>
<li><code>trapframe</code> 包含了 <code>context</code> 的信息</li>
</ul>
</li>
</ul>
<h2 id="练习2-为新创建的内核线程分配资源"><a href="#练习2-为新创建的内核线程分配资源" class="headerlink" title="练习2-为新创建的内核线程分配资源"></a>练习2-为新创建的内核线程分配资源</h2><p><code>do_fork</code> 的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同，在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">/* &lt;-------- start --------&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;-------- end --------&gt; */</span> </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ul>
<li>调用 alloc_proc 来分配一个 proc_struct</li>
<li>调用 setup_kstack 为子进程分配内核堆栈</li>
<li>根据 clone_flag 调用 copy_mm 或 share mm</li>
<li>调用 copy_thread 在 proc_struct 中设置中断帧指针和上下文</li>
<li>将 proc_struct 插入 hash_list和proc_list</li>
<li>调用 wakeup_proc 使新的子进程可以运行</li>
<li>使用子进程的 pid 设置 ret vaule</li>
</ul>
<p>我们可用的函数：</p>
<ul>
<li>alloc_proc：分配一张物理页</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="comment">/* kmalloc:分配连续的物理地址,用于小内存分配 */</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123; <span class="comment">/* 初始化各个参数(和“练习1”的代码一样) */</span></span><br><span class="line">        proc-&gt;state = PROC_UNINIT; </span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setup_kstack：将大小为 KSTACKPAGE 的页面作为进程内核堆栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTACKPAGE          2                           </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">setup_kstack</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> alloc_pages(KSTACKPAGE); <span class="comment">/* 分配两张物理页 */</span></span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;kstack = (<span class="keyword">uintptr_t</span>)(page); <span class="comment">/* proc_struct-&gt;kstack:内核栈 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>copy_mm：把所有的虚拟页数据复制到新的进程（本实验中没有任何作用）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copy_mm</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(current-&gt;mm == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* do nothing in this project */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>copy_thread：在进程的内核堆栈顶部设置 trapframe，并设置进程的内核入口点和堆栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">copy_thread</span><span class="params">(struct proc_struct *proc, <span class="keyword">uintptr_t</span> esp, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br><span class="line">    *(proc-&gt;tf) = *tf;</span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp;</span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line">    proc-&gt;context.eip = (<span class="keyword">uintptr_t</span>)forkret;</span><br><span class="line">    proc-&gt;context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>hash_proc：将 proc 添加到进程哈希链表中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH_SHIFT          10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid_hashfn(x)       (hash32(x, HASH_SHIFT))</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> hash_list[HASH_LIST_SIZE]; <span class="comment">/* 进程哈希链表的入口地址 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">hash_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    list_add(hash_list + pid_hashfn(proc-&gt;pid), &amp;(proc-&gt;hash_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>get_pid：为进程分配唯一的PID</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PROCESS                 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PID                     (MAX_PROCESS * 2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">get_pid</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *<span class="built_in">list</span> = &amp;proc_list, *le; <span class="comment">/* 设置*prev和*next */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    <span class="keyword">if</span> (++ last_pid &gt;= MAX_PID) &#123; </span><br><span class="line">        last_pid = <span class="number">1</span>; <span class="comment">/* 讲真没有看懂这里有啥意义 */</span></span><br><span class="line">        <span class="keyword">goto</span> inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = <span class="built_in">list</span>; <span class="comment">/* 初始le为哈希进程链表入口 */</span></span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123; <span class="comment">/* 遍历哈希进程链表 */</span></span><br><span class="line">            proc = le2proc(le, list_link); <span class="comment">/* 根据链表信息获取进程地址 */</span></span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    <span class="keyword">goto</span> repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_pid; <span class="comment">/* 返回一个不重复的pid */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wakeup_proc：设置 proc-&gt;state = PROC_RUNNABLE（程序可运行）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE &amp;&amp; proc-&gt;state != PROC_RUNNABLE);</span><br><span class="line">    proc-&gt;state = PROC_RUNNABLE; <span class="comment">/* 程序可运行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_NO_FREE_PROC      5   <span class="comment">// 尝试创建一个新的process beyond</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTACKPAGE          2     </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;-------- start --------&gt; */</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 分配一个物理页,作为proc_struct */</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proc-&gt;parent = current; <span class="comment">/* 设置父进程为当前进程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123; <span class="comment">/* 分配内核栈 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123; <span class="comment">/* 将所有虚拟页数据复制过去 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf); <span class="comment">/* 复制线程的状态,包括寄存器上下文等等 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid(); <span class="comment">/* 为进程分配唯一的PID */</span></span><br><span class="line">        hash_proc(proc); <span class="comment">/* 将proc添加到进程哈希链表中 */</span></span><br><span class="line">        list_add(&amp;proc_list, &amp;(proc-&gt;list_link)); <span class="comment">/* 将proc添加到进程链表中 */</span></span><br><span class="line">        nr_process ++; <span class="comment">/* 将全局线程的数目加1 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    wakeup_proc(proc); <span class="comment">/* 设置新的子进程可执行 */</span></span><br><span class="line">    ret = proc-&gt;pid; <span class="comment">/* 设置返回值为pid */</span></span><br><span class="line">    <span class="comment">/* &lt;-------- end --------&gt; */</span> </span><br><span class="line">    </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习3-理解proc-run函数和它调用的函数如何完成进程切换的"><a href="#练习3-理解proc-run函数和它调用的函数如何完成进程切换的" class="headerlink" title="练习3-理解proc_run函数和它调用的函数如何完成进程切换的"></a>练习3-理解proc_run函数和它调用的函数如何完成进程切换的</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123; <span class="comment">/* 再次检查(调度进程,不能等于当前进程) */</span></span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = proc; <span class="comment">/* 设置当前执行的进程 */</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE); <span class="comment">/* 设置ring0的内核栈地址 */</span></span><br><span class="line">            lcr3(next-&gt;cr3); <span class="comment">/* 加载页目录表 */</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context)); <span class="comment">/* 切换上下文(汇编) */</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个在前面已经提过了</p>
<p>PS：“local_intr_save”和“local_intr_restore”用于实现“原子操作”，使得某些关键的代码不会被打断，从而避免引起一些未预料到的错误，避免条件竞争 </p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/miscellaneous/" rel="tag"><i class="fa fa-tag"></i> miscellaneous</a>
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/Kernel/" rel="tag"><i class="fa fa-tag"></i> Kernel</a>
              <a href="/tags/Ucore/" rel="tag"><i class="fa fa-tag"></i> Ucore</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/19/StarCTF2022/" rel="prev" title="StarCTF2022">
      <i class="fa fa-chevron-left"></i> StarCTF2022
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/20/Ptmalloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Afree/" rel="next" title="Ptmalloc源码分析：free">
      Ptmalloc源码分析：free <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">2.</span> <span class="nav-text">进程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8C%82%E8%B5%B7"><span class="nav-number">3.</span> <span class="nav-text">进程挂起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-number">4.</span> <span class="nav-text">进程切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">5.</span> <span class="nav-text">进程终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">进程机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%B8%A7"><span class="nav-number">7.</span> <span class="nav-text">中断帧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">用户线程与内核线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A00-%E6%8A%8A-lab3-%E7%9A%84%E5%86%85%E5%AE%B9%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%88%B0-lab4"><span class="nav-number">9.</span> <span class="nav-text">练习0-把 lab3 的内容复制粘贴到 lab4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01-%E5%88%86%E9%85%8D%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">10.</span> <span class="nav-text">练习1-分配并初始化一个进程控制块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02-%E4%B8%BA%E6%96%B0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90"><span class="nav-number">11.</span> <span class="nav-text">练习2-为新创建的内核线程分配资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A03-%E7%90%86%E8%A7%A3proc-run%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%83%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84"><span class="nav-number">12.</span> <span class="nav-text">练习3-理解proc_run函数和它调用的函数如何完成进程切换的</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">332</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:53</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
