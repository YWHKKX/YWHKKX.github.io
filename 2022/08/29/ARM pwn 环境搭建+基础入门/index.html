<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ARM 架构简述ARM 架构，过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作艾康精简指令集机器， Acorn RISC Machine），是一个精简指令集（RISC）处理器架构家族，其广泛地使用在许多嵌入式系统设计  ARM程序，指在ARM系统中正在执行的程序，而非保存在ROM中的bin文件 ARM 和 x86 之间的更多区别是：  在 ARM 中，大多数指令都可">
<meta property="og:type" content="article">
<meta property="og:title" content="ARM pwn 环境搭建+基础入门">
<meta property="og:url" content="http://example.com/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="ARM 架构简述ARM 架构，过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作艾康精简指令集机器， Acorn RISC Machine），是一个精简指令集（RISC）处理器架构家族，其广泛地使用在许多嵌入式系统设计  ARM程序，指在ARM系统中正在执行的程序，而非保存在ROM中的bin文件 ARM 和 x86 之间的更多区别是：  在 ARM 中，大多数指令都可">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1661655283051-1682921718235.png">
<meta property="og:image" content="http://example.com/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1661586815885-1682921718235.png">
<meta property="article:published_time" content="2022-08-29T11:51:41.000Z">
<meta property="article:modified_time" content="2023-05-01T06:15:20.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="ARM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1661655283051-1682921718235.png">

<link rel="canonical" href="http://example.com/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ARM pwn 环境搭建+基础入门 | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ARM pwn 环境搭建+基础入门
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-29 19:51:41" itemprop="dateCreated datePublished" datetime="2022-08-29T19:51:41+08:00">2022-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-01 14:15:20" itemprop="dateModified" datetime="2023-05-01T14:15:20+08:00">2023-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Technology/" itemprop="url" rel="index"><span itemprop="name">Technology</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="ARM-架构简述"><a href="#ARM-架构简述" class="headerlink" title="ARM 架构简述"></a>ARM 架构简述</h2><p>ARM 架构，过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作艾康精简指令集机器， Acorn RISC Machine），是一个精简指令集（RISC）处理器架构家族，其广泛地使用在许多嵌入式系统设计 </p>
<p>ARM程序，指在ARM系统中正在执行的程序，而非保存在ROM中的bin文件</p>
<p>ARM 和 x86 之间的更多区别是：</p>
<ul>
<li>在 ARM 中，大多数指令都可用于条件执行。</li>
<li>英特尔 x86 和 x86-64 系列处理器使用小端格式</li>
<li>ARM 架构在低版本是小端的，之后，ARM 处理器成为 <strong>BL端</strong>（有允许可切换字节序的设置，由程序状态寄存器 CPSR 的位9 (E位) 控制）</li>
</ul>
<p>一个ARM程序包含3部分：</p>
<ul>
<li>RO段（只读）：RO是程序中的指令和常量</li>
<li>RW段（可读写）：RW是程序中已初始化的变量</li>
<li>ZI段（可读写）：ZI是程序中未初始化的变量</li>
</ul>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>安装 qemu-user：（用于开启虚拟机）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu-user</span><br><span class="line">sudo apt-get install qemu-use-binfmt qemu-user-binfmt:i386</span><br></pre></td></tr></table></figure>
<p>安装交叉编译工具 aarch64-linux-gnu-gcc：（推荐）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>
<p>安装交叉编译工具链 arm-linux-gcc-4.3.3：（不推荐）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fshare%2Finit%3Fsurl%3DbpEq2Mr">arm-linux-gcc-4.4.3.tar.gz</a></li>
<li>百度云盘，密码：1gtt</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/local/arm_4.4.3</span><br><span class="line">sudo cp -r ./opt/FriendlyARM/toolschain/4.4.3/* /usr/local/arm_4.4.3</span><br><span class="line">gedit ~/.zshrc</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/arm_4.4.3/bin</span><br></pre></td></tr></table></figure>
<p>安装 qemu 内核：（最好不要 <code>apt-get</code> 直接安装，因为没有 <code>qemu-system-aarch64</code>）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-6.2.0.tar.xz</span><br><span class="line">tar xvJf qemu-6.2.0.tar.xz</span><br><span class="line">cd qemu-6.2.0</span><br><span class="line">./configure --target-list=aarch64-softmmu</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>获取 ubuntu-18.04-server-arm64.iso：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://old-releases.ubuntu.com/releases/18.04.3/">http://old-releases.ubuntu.com/releases/18.04.3/</a> </li>
</ul>
<p>下载对应架构（aarch64）的 UEFI 固件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://releases.linaro.org/components/kernel/uefi-linaro/16.02/release/qemu64/QEMU_EFI.fd</span><br></pre></td></tr></table></figure>
<p>创建虚拟机硬盘：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create ubuntuimg.img 40G</span><br></pre></td></tr></table></figure>
<p>创建虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -nographic -drive if=none,file=ubuntu-18.04-server-arm64.iso,id=cdrom,media=cdrom -device virtio-scsi-device -device scsi-cd,drive=cdrom -drive if=none,file=ubuntuimg.img,id=hd0 -device virtio-blk-device,drive=hd0</span><br></pre></td></tr></table></figure>
<p>直接回车选择安装 Ubuntu Server：</p>
<p><img src="/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1661655283051-1682921718235.png" alt="1661655283051"> </p>
<p>安装成功后，就可以通过如下命令开启 ARM 程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -L /usr/aarch64-linux-gnu -g 1234 ./[pwn] </span><br><span class="line">qemu-aarch64 -L /usr/aarch64-linux-gnu -g 1234 ./[pwn]</span><br></pre></td></tr></table></figure>
<p>最后介绍一下调试方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch [pwn] </span><br><span class="line">set architecture [Arch-name] # aarch64 or arm</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51760563/article/details/119935101">使用qemu搭建ARM64架构虚拟机</a> </li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38406667/article/details/107367971">Ubuntu下arm-linux-gdb的安装</a> </li>
</ul>
<h2 id="数据类型和寄存器"><a href="#数据类型和寄存器" class="headerlink" title="数据类型和寄存器"></a>数据类型和寄存器</h2><p>与高级语言类似，ARM 支持对不同数据类型的操作</p>
<p>我们可以加载（或存储）的数据类型可以是有符号和无符号单词，半字或字节，这些数据类型的扩展名是：</p>
<ul>
<li>-h 或 -sh 表示半字</li>
<li>-b 或 -sb 表示一字节</li>
<li>没有扩展名表示一字</li>
</ul>
<p>有符号数据类型和无符号数据类型之间的区别在于：</p>
<ul>
<li>有符号数据类型 (+s) 可以同时包含正值和负值，因此范围较小</li>
<li>无符号数据类型 (+0) 可以保存较大的正值（包括“零”），但不能保存负值，因此范围更广</li>
</ul>
<p>以下是如何将这些数据类型与加载和存储说明一起使用的一些示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ldr = Load Word</span><br><span class="line">ldrh = Load unsigned Half Word</span><br><span class="line">ldrsh = Load signed Half Word</span><br><span class="line">ldrb = Load unsigned Byte</span><br><span class="line">ldrsb = Load signed Bytes</span><br><span class="line"></span><br><span class="line">str = Store Word</span><br><span class="line">strh = Store unsigned Half Word</span><br><span class="line">strsh = Store signed Half Word</span><br><span class="line">strb = Store unsigned Byte</span><br><span class="line">strsb = Store signed Byte</span><br></pre></td></tr></table></figure>
<p>寄存器的数量取决于ARM版本</p>
<p>根据ARM参考手册，除了基于 <code>ARMv6-M</code> 和 <code>ARMv7-M</code> 的处理器外，都有30个通用的32位寄存器，其中的 <code>r0-r15</code> 作用如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>32位</th>
<th>64位</th>
<th>别名</th>
<th style="text-align:left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>R0-R6</td>
<td>X0-X7</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td></td>
<td>X8</td>
<td>–</td>
<td style="text-align:left">保存子程序返回值</td>
</tr>
<tr>
<td>R7</td>
<td></td>
<td>–</td>
<td style="text-align:left">持有系统调用号</td>
</tr>
<tr>
<td></td>
<td>X9-X15</td>
<td>临时寄存器</td>
<td style="text-align:left">子程序使用时不需要保存</td>
</tr>
<tr>
<td>R8-R10</td>
<td>X19-X28</td>
<td>临时寄存器</td>
<td style="text-align:left">子程序使用时必须保存</td>
</tr>
<tr>
<td></td>
<td>X18</td>
<td>–</td>
<td style="text-align:left">记录平台信息</td>
</tr>
<tr>
<td>R11</td>
<td>X29</td>
<td>FP</td>
<td style="text-align:left">帧指针</td>
</tr>
<tr>
<td>R12</td>
<td>X16-X17</td>
<td>IP</td>
<td style="text-align:left">程序内呼叫</td>
</tr>
<tr>
<td>R13</td>
<td>X31</td>
<td>SP</td>
<td style="text-align:left">栈指针</td>
</tr>
<tr>
<td>R14</td>
<td>X30</td>
<td>LR</td>
<td style="text-align:left">链接注册</td>
</tr>
<tr>
<td>R15</td>
<td></td>
<td>PC</td>
<td style="text-align:left">程序计数器</td>
</tr>
<tr>
<td>CPSR</td>
<td>CPSR</td>
<td>–</td>
<td style="text-align:left">当前程序状态寄存器</td>
</tr>
<tr>
<td>SPSR</td>
<td>SPSR</td>
<td>–</td>
<td style="text-align:left">程序状态保存寄存器</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>R0-R12：</strong>可在常见操作期间用于存储临时值、指针（到内存的位置）等<ul>
<li>R0 在算术运算期间可以称为累加器，或者用于存储以前调用的函数的结果</li>
<li>R7 在使用系统调用时变得很有用，因为它存储了 syscall 编号</li>
<li>R11 帮助我们跟踪栈上的边界，作为帧指针（稍后将介绍）</li>
<li>R0-R3：ARM 上的函数调用约定指定函数的前四个参数存储在寄存器 r0-r3 中</li>
</ul>
</li>
<li><strong>R13：SP</strong>（栈指针）栈指针指向栈的顶部<ul>
<li>栈是用于特定于函数的存储的内存区域，当函数返回时，将回收该内存区域</li>
<li>因此，栈指针用于分配栈上的空间，方法是从栈指针中减去我们要分配的值（以字节为单位），换句话说，如果我们想分配一个32位值，我们从栈指针中减去“4”</li>
</ul>
</li>
<li><strong>R14：LR</strong>（链路寄存器）进行函数调用时，链接寄存器将使用内存地址进行更新，该内存地址引用从中启动函数的下一条指令<ul>
<li>这样做允许程序返回到在“子”函数完成后启动“子”函数调用的“父”函数</li>
</ul>
</li>
<li><strong>R15：PC</strong>（程序计数器）程序计数器按执行的指令的大小自动递增<ul>
<li>此大小在 <code>ARM</code> 状态下始终为4个字节，在 <code>THUMB</code> 模式下始终为2个字节</li>
<li>当执行分支指令时，PC保存目标地址，在执行过程中，PC 将当前指令加 8（两条 ARM 指令）的地址存储在 <code>ARM</code> 状态，将当前指令加 4（两条拇指指令）的地址存储在 <code>Thumb(v1)</code> 状态</li>
<li>PS：这与x86不同，在x86中，PC 始终指向要执行的下一条指令</li>
</ul>
</li>
</ul>
<p><strong>CPSR：</strong>显示当前程序状态寄存器（CPSR）的值</p>
<ul>
<li>在此值下，您可以看到标志 &gt;&gt; <code>thumb, fast, interrupt, overflow, carry, zero, and negative</code></li>
<li>这些标志表示 CPSR 寄存器中的某些位，并根据 CPSR 的值进行设置，并在激活时变为 <strong>粗体</strong></li>
<li>N、Z、C 和 V 位与 x86 上 EFLAG 寄存器中的 SF、ZF、CF 和 OF 位相同，它们将用于支持程序集级别的条件和循环中的条件执行：<ul>
<li><strong>N</strong> – 当操作结果为负时设置</li>
<li><strong>Z</strong> – 当操作结果为零时设置</li>
<li><strong>C</strong> – 判断无符号数是否溢出</li>
<li><strong>V</strong> – 判断带符号数是否溢出</li>
</ul>
</li>
</ul>
<p><img src="/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1661586815885-1682921718235.png" alt="1661586815885"> </p>
<p>下表展示了 CPSR 中各个位的具体作用：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Flag</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">N<br>(Negative)</td>
<td style="text-align:left">如果指令结果产生负数，则启用</td>
</tr>
<tr>
<td style="text-align:left">Z<br>(Zero)</td>
<td style="text-align:left">如果指令的结果产生零值，则启用</td>
</tr>
<tr>
<td style="text-align:left">C<br>(Carry)</td>
<td style="text-align:left">如果指令的结果产生一个需要完全表示第 33 位的值，则启用该值</td>
</tr>
<tr>
<td style="text-align:left">V<br>(Overflow)</td>
<td style="text-align:left">如果指令的结果产生的值不能用 32 位 2 的补码表示，则启用此选项</td>
</tr>
<tr>
<td style="text-align:left">E<br>(Endian-bit)</td>
<td style="text-align:left">ARM可以在小端序或大端中进行切换，对于小字节序，此位设置为“0”，对于大字节序模式，此位设置为“1”</td>
</tr>
<tr>
<td style="text-align:left">T<br>(Thumb-bit)</td>
<td style="text-align:left">如果您处于 Thumb 状态，则设置此位，并在您处于 ARM 状态时被禁用</td>
</tr>
<tr>
<td style="text-align:left">M<br>(Mode-bits)</td>
<td style="text-align:left">这些位指定当前权限模式（USR、SVC 等）</td>
</tr>
<tr>
<td style="text-align:left">J<br>(Jazelle)</td>
<td style="text-align:left">第三个执行状态，允许某些 ARM 处理器在硬件中执行 Java 字节码</td>
</tr>
</tbody>
</table>
</div>
<h2 id="ARM-amp-THUMB"><a href="#ARM-amp-THUMB" class="headerlink" title="ARM &amp; THUMB"></a>ARM &amp; THUMB</h2><p>ARM 处理器有两种主要状态，它们可以在其中运行（这里不算Jazelle）：ARM 和 Thumb</p>
<ul>
<li>Thumb 是 ARM 体系结构中一种 <strong>16位的指令集</strong></li>
<li>Thumb 指令集可以看作是 ARM 指令压缩形式的子集，它是为减小代码量而提出，具有16bit的代码密度</li>
</ul>
<p>这些状态与权限级别无关，例如，在 SVC 模式下运行的代码可以是 ARM 或 Thumb，这两种状态之间的主要区别在于指令集，其中 ARM 状态下的指令始终为32位，而 Thumb 状态的指令为16位（但可以是32位）</p>
<p>了解何时以及如何使用 Thumb 对于我们的 ARM 漏洞利用开发目的尤为重要，在编写 ARM 外壳代码时，我们需要删除 NULL 字节，并使用 16 位 Thumb 指令而不是 32 位 ARM 指令来降低拥有它们的机会</p>
<p>如前所述，有不同的 Thumb 版本，不同的命名只是为了将它们彼此区分开来：（处理器本身将始终将其称为 Thumb）</p>
<ul>
<li>Thumb-1（16 位指令）：用于 ARMv6 和早期架构</li>
<li>Thumb-2（16 位和 32 位指令）：通过添加更多指令并允许它们为 16 位或 32 位宽（ARMv6T2、ARMv7）来扩展 Thumb-1</li>
<li>ThumbEE：包括一些针对动态生成的代码（在执行前或执行期间在设备上编译的代码）的一些更改和添加</li>
</ul>
<p>ARM 和 Thumb 之间的区别：</p>
<ul>
<li>条件执行：<ul>
<li>ARM 状态下的所有指令都支持条件执行，某些 ARM 处理器版本允许使用 IT 指令在 Thumb 中执行条件（条件执行导致更高的代码密度，因为它减少了要执行的指令数量，并减少了昂贵的分支指令的数量）</li>
</ul>
</li>
<li>32 位 ARM 和 Thumb 指令：<ul>
<li>32 位 Thumb 指令具有 .w 后缀</li>
<li>32 位 ARM 指令没有</li>
</ul>
</li>
<li>桶形移位器：<ul>
<li>是另一个独特的 ARM 模式功能，它可用于将多个指令缩小为一个</li>
</ul>
</li>
</ul>
<p>要切换处理器执行的状态，必须满足以下两个条件之一：</p>
<ul>
<li>我们可以使用分支指令BX（分支和交换）或BLX（分支，链路和交换），并将目标寄存器的最低有效位设置为1<ul>
<li>这可以通过将1添加到偏移量（如0x5530 + 1）来实现</li>
<li>您可能会认为这会导致对齐问题，因为指令是 2 字节或 4 字节对齐的</li>
<li>不够都这不是问题，因为处理器将忽略最低有效位</li>
</ul>
</li>
<li>我们知道，如果当前程序状态寄存器中的 T 位已设置，则处于 Thumb 模式</li>
</ul>
<h2 id="ARM-指令集"><a href="#ARM-指令集" class="headerlink" title="ARM 指令集"></a>ARM 指令集</h2><p>汇编语言由指令组成，这些指令是主要的构建块，ARM 指令后面通常跟一个或两个操作数，通常使用以下模板： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MNEMONIC&#123;S&#125;&#123;condition&#125; &#123;Rd&#125;, Operand1, Operand2</span><br></pre></td></tr></table></figure>
<p>由于 ARM 指令集的灵活性，并非所有指令都使用模板中提供的所有字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MNEMONIC - 指令的简称(助记符)</span><br><span class="line">&#123;S&#125; - 可选后缀,如果指定了S,则条件标志会根据操作结果更新</span><br><span class="line">&#123;condition&#125; - 执行指令需要满足的条件</span><br><span class="line">&#123;Rd&#125; - 用于存储指令结果的寄存器(目标)</span><br><span class="line">Operand1 - 第一个操作数,寄存器或立即数</span><br><span class="line">Operand2 - 第二个(灵活的)操作数,可以是立即数(数字)或带有可选移位的寄存器</span><br></pre></td></tr></table></figure>
<p>虽然 MNEMONIC、S、Rd 和 Operand1 字段是直截了当的，但条件和 Operand2 字段需要进一步澄清：</p>
<ul>
<li>条件字段与 CPSR 寄存器的值紧密相关，或者更确切地说，与寄存器中特定位的值紧密相关</li>
<li>Operand2 被称为灵活的操作数，因为我们可以以各种形式使用它：<ul>
<li>作为即时值（具有有限的值集）</li>
<li>寄存器</li>
<li>以移位寄存器</li>
</ul>
</li>
<li>例如，我们可以将这些表达式用作操作数 2：  </li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#123 - 立即值(具有有限的一组值)</span></span><br><span class="line"><span class="attribute">Rx</span> - 寄存器 x(如 R<span class="number">1</span>、R<span class="number">2</span>、R<span class="number">3</span> ...)</span><br><span class="line"><span class="attribute">Rx</span>, ASR n - 寄存器 x 算术右移 n 位 (<span class="number">1</span> = n = <span class="number">32</span>)</span><br><span class="line"><span class="attribute">Rx</span>, LSL n - 寄存器 x 逻辑左移 n 位 (<span class="number">0</span> = n = <span class="number">31</span>)</span><br><span class="line"><span class="attribute">Rx</span>, LSR n - 寄存器 x 逻辑右移 n 位 (<span class="number">1</span> = n = <span class="number">32</span>)</span><br><span class="line"><span class="attribute">Rx</span>, ROR n - 寄存器 x 右移 n 位 (<span class="number">1</span> = n = <span class="number">31</span>)</span><br><span class="line"><span class="attribute">Rx</span>, RRX - 寄存器 x 右移一位,扩展</span><br></pre></td></tr></table></figure>
<ul>
<li>作为不同类型说明的快速示例，让我们看一下以下列表：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ADD</span> R<span class="number">0</span>, R<span class="number">1</span>, R<span class="number">2</span> - 将 R<span class="number">1</span> (Operand<span class="number">1</span>) 和 R<span class="number">2</span> (Operand<span class="number">2</span> 的寄存器形式) 的内容相加并将结果存储到 R<span class="number">0</span> (Rd)</span><br><span class="line"><span class="attribute">ADD</span> R<span class="number">0</span>, R<span class="number">1</span>, #<span class="number">2</span> - 将 R<span class="number">1</span> (Operand<span class="number">1</span>) 的内容与值 <span class="number">2</span> (Operand<span class="number">2</span> 的立即数形式) 相加并将结果存储到 R<span class="number">0</span> (Rd)</span><br><span class="line"><span class="attribute">MOVLE</span> R<span class="number">0</span>, #<span class="number">5</span> - 仅当满足条件 LE (小于或等于)时,将数字 <span class="number">5</span> (操作数 <span class="number">2</span>,因为编译器将其视为 MOVLE R<span class="number">0</span>, R<span class="number">0</span>, #<span class="number">5</span>) 移动到 R<span class="number">0</span>(Rd)</span><br><span class="line"><span class="attribute">MOV</span> R<span class="number">0</span>, R<span class="number">1</span>, LSL #<span class="number">1</span> - 将 R<span class="number">1</span> 的内容(操作数 <span class="number">2</span> 采用逻辑左移的寄存器形式)左移一位到 R<span class="number">0</span>(Rd),因此,如果 R<span class="number">1</span> 的值为 <span class="number">2</span>,它会左移一位并变为 <span class="number">4</span>,然后将 <span class="number">4</span> 移至 R<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>作为快速摘要，让我们看一下我们将在以后的示例中使用的最常见的说明</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MOV</td>
<td style="text-align:left">Move data</td>
<td style="text-align:center">EOR</td>
<td style="text-align:left">Bitwise XOR</td>
</tr>
<tr>
<td style="text-align:center">MVN</td>
<td style="text-align:left">Move and negate</td>
<td style="text-align:center">LDR</td>
<td style="text-align:left">Load</td>
</tr>
<tr>
<td style="text-align:center">ADD</td>
<td style="text-align:left">Addition</td>
<td style="text-align:center">STR</td>
<td style="text-align:left">Store</td>
</tr>
<tr>
<td style="text-align:center">SUB</td>
<td style="text-align:left">Subtraction</td>
<td style="text-align:center">LDM</td>
<td style="text-align:left">Load Multiple</td>
</tr>
<tr>
<td style="text-align:center">MUL</td>
<td style="text-align:left">Multiplication</td>
<td style="text-align:center">STM</td>
<td style="text-align:left">Store Multiple</td>
</tr>
<tr>
<td style="text-align:center">LSL</td>
<td style="text-align:left">Logical Shift Left</td>
<td style="text-align:center">PUSH</td>
<td style="text-align:left">Push on Stack</td>
</tr>
<tr>
<td style="text-align:center">LSR</td>
<td style="text-align:left">Logical Shift Right</td>
<td style="text-align:center">POP</td>
<td style="text-align:left">Pop off Stack</td>
</tr>
<tr>
<td style="text-align:center">ASR</td>
<td style="text-align:left">Arithmetic Shift Right</td>
<td style="text-align:center">B</td>
<td style="text-align:left">Branch</td>
</tr>
<tr>
<td style="text-align:center">ROR</td>
<td style="text-align:left">Rotate Right</td>
<td style="text-align:center">BL</td>
<td style="text-align:left">Branch with Link</td>
</tr>
<tr>
<td style="text-align:center">CMP</td>
<td style="text-align:left">Compare</td>
<td style="text-align:center">BX</td>
<td style="text-align:left">Branch and eXchange</td>
</tr>
<tr>
<td style="text-align:center">AND</td>
<td style="text-align:left">Bitwise AND</td>
<td style="text-align:center">BLX</td>
<td style="text-align:left">Branch with Link and eXchange</td>
</tr>
<tr>
<td style="text-align:center">ORR</td>
<td style="text-align:left">Bitwise OR</td>
<td style="text-align:center">SWI/SVC</td>
<td style="text-align:left">System Call</td>
</tr>
</tbody>
</table>
</div>
<h2 id="加载和存储"><a href="#加载和存储" class="headerlink" title="加载和存储"></a>加载和存储</h2><p>ARM 使用 load-store 模型进行内存访问，这意味着只有 load/store（LDR 和 STR）指令才能访问内存，虽然在x86上允许大多数指令直接对内存中的数据进行操作，但在ARM上，<strong>数据必须在操作之前从内存移动到寄存器中</strong></p>
<p>这意味着在 ARM 上的特定内存地址递增 32 位值需要三种类型的指令（加载、递增和存储），首先将特定地址的值加载到寄存器中，在寄存器中递增，然后将其从寄存器存储回存储器</p>
<p>通常，<code>LDR</code> 用于将某些内容从内存加载到寄存器中，而 <code>STR</code> 用于将某些内容从寄存器存储到内存地址</p>
<p><strong>常规操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R2, [R0] 	@ [R0]:原始地址是在 R0 中找到的值</span><br><span class="line">STR R2, [R1] 	@ [R1]:目标地址是在 R1 中找到的值</span><br></pre></td></tr></table></figure>
<ul>
<li>LDR 操作：将 R0 中找到的地址处的值加载到目标寄存器 R2</li>
<li>STR 操作：将 R2 中找到的值存储到 R1 中找到的内存地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STR    Ra, [Rb, imm]</span><br><span class="line">LDR    Ra, [Rc, imm]</span><br></pre></td></tr></table></figure>
<ul>
<li>偏移形式为：使用立即（整数）作为偏移量</li>
<li><strong>偏移地址模式</strong>：先从基本寄存器 Ra 中添加或减去此值，然后再使用已知的偏移量访问数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STR    Ra, [Rb, Rc]</span><br><span class="line">LDR    Ra, [Rb, Rc]</span><br></pre></td></tr></table></figure>
<ul>
<li>偏移形式为：使用寄存器作为偏移（偏移地址模式）<ul>
<li>Rb 是基寄存器</li>
<li>Rc 是偏移</li>
</ul>
</li>
<li>使用场景：当您的代码想要访问在运行时计算索引的数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR    Ra, [Rb, Rc, &lt;shifter&gt;]</span><br><span class="line">STR    Ra, [Rb, Rc, &lt;shifter&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>偏移形式为：具有缩放寄存器作为偏移（偏移地址模式）<ul>
<li>Rb 是基寄存器</li>
<li>Rc 是左/右移位（&lt; shifter &gt;）的即时偏移（或包含即时值的寄存器），以缩放即时偏移（这意味着桶形移位器用于缩放偏移）</li>
</ul>
</li>
<li>使用场景：循环以循环访问数组</li>
</ul>
<p><strong>特殊操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR r3, [r1], #offset</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>索引后地址模式</strong>：这意味着基寄存器（R1）用作最终地址，然后使用 R1 + 4 计算的失调进行更新</li>
<li>换句话说，它采用在 R1（不是 R1+4）中找到的值并将其加载到 R3 中，然后将 R1 更新为 R1 + offset</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADR r0, words+12             /* address of words[3] -&gt; r0 */</span><br></pre></td></tr></table></figure>
<ul>
<li>我们使用 ADR 指令（懒惰方法）来获取 <code>word[3]</code> 的地址放入 R0</li>
<li>PS：其实这两个都是伪指令<ul>
<li>ADR 是小范围的地址读取伪指令</li>
<li>LDR 是大范围的读取地址伪指令</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR r1, array_buff_bridge    /* address of array_buff[0] -&gt; r1 */</span><br><span class="line">LDR r2, array_buff_bridge+4  /* address of array_buff[2] -&gt; r2 */</span><br></pre></td></tr></table></figure>
<ul>
<li>执行上述两条指令后，R1 和 R2 包含 <code>array_buff[0]</code> 和 <code>array_buff[2]</code> 的地址</li>
<li>PS：对于数组，可以采用这种这种写法</li>
</ul>
<p><strong>同时处理多个值</strong></p>
<p>有时，一次加载（或存储）多个值会更有效，为此，我们使用 LDM（加载多个）和 STM（存储多个）指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDM r0, &#123;r4,r5&#125;              /* words[3] -&gt; r4 = 0x03; words[4] -&gt; r5 = 0x04 */</span><br></pre></td></tr></table></figure>
<ul>
<li>R0 中装有 <code>word[3]</code> </li>
<li>我们使用一个命令加载了多个（2个数据块），该命令将：<ul>
<li><code>R4 = 0x00000003</code> </li>
<li><code>R5 = 0x00000004</code></li>
</ul>
</li>
<li>PS：注意在合适的位置打上花括号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stm r1, &#123;r4,r5&#125;              /* r4 -&gt; array_buff[0] = 0x03; r5 -&gt; array_buff[1] = 0x04 */</span><br></pre></td></tr></table></figure>
<ul>
<li>R1 中装有 <code>array_buff[0]</code> </li>
<li>我们使用一个命令存储了多个（2个数据块），该命令将：<ul>
<li><code>array_buff[0] = 0x00000003</code></li>
<li><code>array_buff[1] = 0x00000004</code></li>
</ul>
</li>
</ul>
<h2 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h2><p>CPSR 中的 N、Z、C 和 V 位与 x86 上 EFLAG 寄存器中的 SF、ZF、CF 和 OF 位相同，它们将用于支持程序集级别的条件和循环中的条件执行</p>
<p>下表列出了可用的条件代码、其含义以及测试的标志的状态：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Condition Code</th>
<th style="text-align:center">Meaning (for cmp or subs)</th>
<th style="text-align:center">Status of Flags</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">EQ</td>
<td style="text-align:center">相等</td>
<td style="text-align:center">Z==1</td>
</tr>
<tr>
<td style="text-align:center">NE</td>
<td style="text-align:center">不相等</td>
<td style="text-align:center">Z==0</td>
</tr>
<tr>
<td style="text-align:center">GT</td>
<td style="text-align:center">大于（有符号）</td>
<td style="text-align:center">(Z==0) &amp;&amp; (N==V)</td>
</tr>
<tr>
<td style="text-align:center">LT</td>
<td style="text-align:center">小于（有符号）</td>
<td style="text-align:center">N!=V</td>
</tr>
<tr>
<td style="text-align:center">GE</td>
<td style="text-align:center">大于等于（有符号）</td>
<td style="text-align:center">N==V</td>
</tr>
<tr>
<td style="text-align:center">LE</td>
<td style="text-align:center">小于等于（有符号）</td>
<td style="text-align:center">(Z==1) \</td>
<td>\</td>
<td>(N!=V)</td>
</tr>
<tr>
<td style="text-align:center">CS or HS</td>
<td style="text-align:center">大于等于（无符号）</td>
<td style="text-align:center">C==1</td>
</tr>
<tr>
<td style="text-align:center">CC or LO</td>
<td style="text-align:center">小于（无符号）</td>
<td style="text-align:center">C==0</td>
</tr>
<tr>
<td style="text-align:center">HI</td>
<td style="text-align:center">大于（无符号）</td>
<td style="text-align:center">(C==1) &amp;&amp; (Z==0)</td>
</tr>
<tr>
<td style="text-align:center">LS</td>
<td style="text-align:center">小于等于（无符号）</td>
<td style="text-align:center">(C==0) \</td>
<td>\</td>
<td>(Z==0)</td>
</tr>
<tr>
<td style="text-align:center">MI</td>
<td style="text-align:center">负数</td>
<td style="text-align:center">N==1</td>
</tr>
<tr>
<td style="text-align:center">PL</td>
<td style="text-align:center">正数或零</td>
<td style="text-align:center">N==0</td>
</tr>
<tr>
<td style="text-align:center">AL</td>
<td style="text-align:center">True</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">NV</td>
<td style="text-align:center">False</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">VS</td>
<td style="text-align:center">有符号溢出</td>
<td style="text-align:center">V==1</td>
</tr>
<tr>
<td style="text-align:center">VC</td>
<td style="text-align:center">无符号溢出</td>
<td style="text-align:center">V==0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Thumb 条件执行</strong></p>
<p>ARM 存在多种允许条件执行的 Thumb 版本，某些 ARM 处理器版本支持“IT”指令，该指令允许在 Thumb 状态下有条件地执行最多 4 条指令 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IT&#123;x&#123;y&#123;z&#125;&#125;&#125; cond</span><br></pre></td></tr></table></figure>
<ul>
<li><em>cond</em> 指定 IT 块中第<strong>一</strong>条指令的条件</li>
<li><em>x</em> 指定 IT 块中第<strong>二</strong>条指令的条件开关</li>
<li><em>y</em> 指定 IT 块中第<strong>三</strong>条指令的条件开关</li>
<li><em>z</em> 指定 IT 块中第<strong>四</strong>条指令的条件开关</li>
</ul>
<p>IT 指令的结构是 “IF-Then-(Else)”，语法是两个字母 T 和 E 的构造：</p>
<ul>
<li>IT 指的是 If-Then（下一个指令是有条件的）</li>
<li>ITT 指的是 If-Then-Then（接下来的2条指令是有条件的）</li>
<li>ITE 指的是 If-Then-Else（接下来的2条指令是有条件的）</li>
<li>ITTE 指的是 If-Then-Then-Else（接下来的3个指令是有条件的）</li>
<li>ITTEE 指的是 If-Then-Then-Else-Else（接下来的4个指令是有条件的）</li>
</ul>
<p>IT 块内的每条指令都必须指定一个相同或逻辑相反的条件后缀：</p>
<ul>
<li>如果使用 ITE，则第一条和第二条指令 (If-Then) 必须具有相同的条件后缀，第三条指令 (Else) 必须具有前两条指令的逻辑反比</li>
<li>以下是 ARM 参考手册中的一些示例，其中说明了此逻辑： </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ITTE   NE           ; Next 3 instructions are conditional</span><br><span class="line">ANDNE  R0, R0, R1   ; ANDNE does not update condition flags</span><br><span class="line">ADDSNE R2, R2, #1   ; ADDSNE updates condition flags</span><br><span class="line">MOVEQ  R2, R3       ; Conditional move</span><br><span class="line"></span><br><span class="line">ITE    GT           ; Next 2 instructions are conditional</span><br><span class="line">ADDGT  R1, R0, #55  ; Conditional addition in case the GT is true</span><br><span class="line">ADDLE  R1, R0, #48  ; Conditional addition in case the GT is not true</span><br><span class="line"></span><br><span class="line">ITTEE  EQ           ; Next 4 instructions are conditional</span><br><span class="line">MOVEQ  R0, R1       ; Conditional MOV</span><br><span class="line">ADDEQ  R2, R2, #10  ; Conditional ADD</span><br><span class="line">ANDNE  R3, R3, #1   ; Conditional AND</span><br><span class="line">BNE.W  dloop        ; Branch instruction can only be used in the last instruction of an IT block</span><br></pre></td></tr></table></figure>
<p><strong>跳转&amp;分支</strong></p>
<p>分支（又名Jumps）允许我们跳转到另一个代码段，当我们需要跳过（或重复）代码块或跳转到特定函数时，这很有用</p>
<ul>
<li>这种用例的最佳示例是 IF 和 Loop</li>
</ul>
<p>有三种类型的分支指令：</p>
<ul>
<li>分支（B）<ul>
<li>简单跳转到函数</li>
</ul>
</li>
<li>分支链接（BL）<ul>
<li>在 LR 中保存 （PC+4） 并跳转到功能</li>
</ul>
</li>
<li>分支交换（BX）和分支链路交换（BLX）<ul>
<li>与 B/BL 交换指令集相同（ARM &lt;-&gt; Thumb）</li>
<li>需要寄存器作为第一个操作数：BX/BLX [reg]</li>
</ul>
</li>
<li>BX/BLX 用于将指令集从 ARM 交换到 Thumb，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">     .code 32         @ ARM mode</span><br><span class="line">     add r2, pc, #1   @ put PC+1 into R2</span><br><span class="line">     bx r2            @ branch + exchange to R2</span><br><span class="line"></span><br><span class="line">    .code 16          @ Thumb mode</span><br><span class="line">     mov r0, #1</span><br></pre></td></tr></table></figure>
<ul>
<li>这里的诀窍是获取实际 PC 的当前值，将其增加“1”，将结果存储到寄存器，然后执行 <code>BX/BLX [reg]</code></li>
<li><code>add r2, pc, #1</code>：简单地获取有效的PC地址（即当前PC寄存器的值+8 -&gt; 0x805C）并为其添加“1”（0x805C + 1 = 0x805D） </li>
</ul>
<h2 id="栈和函数"><a href="#栈和函数" class="headerlink" title="栈和函数"></a>栈和函数</h2><p><strong>栈</strong> </p>
<p>一般来说，堆栈是程序/进程中的内存区域，这部分内存是在创建进程时分配的</p>
<ul>
<li>我们使用 Stack 来存储临时数据，例如某些函数的局部变量，帮助我们在函数之间转换的环境变量等</li>
<li>我们使用 PUSH 和 POP 指令与堆栈进行交互，如 PUSH 和 POP（这是其他一些内存相关指令的别名，而不是实际指令，但出于简单起见，我们使用 PUSH 和 POP）</li>
</ul>
<p>首先，当我们说 Stack 增长时，我们的意思是一个项目（32位数据）被放在 Stack 上，堆栈可以 <strong>向上</strong> 增长（当堆栈以降序方式实现时）或 <strong>向下</strong> 增长（当堆栈以上升方式实现时），下一条（32位）信息的实际位置由堆栈指针定义，或者确切地说，由存储在SP寄存器中的内存地址定义</p>
<p>栈地址的增长方向：</p>
<ul>
<li>向高地址增长的栈称为 <strong>递增栈</strong>（Descendent Stack）</li>
<li>向低地址增长的栈称为 <strong>递减栈</strong>（Acendant Stack） </li>
</ul>
<p>作为不同 Stack 实现的摘要，我们可以使用下表，其中描述了在不同情况下使用哪些存储多个/加载多个指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">堆栈类型</th>
<th style="text-align:left">Store</th>
<th style="text-align:left">Load</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">完全降序</td>
<td style="text-align:left">STMFD （STMDB，Decrement Before）</td>
<td style="text-align:left">LDMFD（LDM，Increment after）</td>
</tr>
<tr>
<td style="text-align:center">完全升序</td>
<td style="text-align:left">STMFA （STMIB，Increment Before）</td>
<td style="text-align:left">LDMFA （LDMDA，Decrement After）</td>
</tr>
<tr>
<td style="text-align:center">空降序</td>
<td style="text-align:left">STMED （STMDA，Decrement After）</td>
<td style="text-align:left">LDMED （LDMIB，Increment Before）</td>
</tr>
<tr>
<td style="text-align:center">空升序</td>
<td style="text-align:left">STMEA（STM，Increment after）</td>
<td style="text-align:left">LDMEA （LDMDB，Decrement Before）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>函数</strong></p>
<p>要理解 ARM 中的函数，我们首先需要熟悉函数的结构部分，它们是：</p>
<ol>
<li>Prologue（序幕）</li>
<li>Body（主体）</li>
<li>Epilogue（结语）</li>
</ol>
<p><strong>Prologue（序幕）</strong>的目的是保存程序的先前状态（通过将 LR 和 R11 的值存储到堆栈上），并为函数的局部变量设置堆栈（虽然序言的实现可能因使用的编译器而异，但通常这是通过使用 PUSH / ADD / SUB 指令来完成的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push &#123;r11, lr&#125; 		/* 序幕的开始,将帧指针和LR保存到堆栈 */</span><br><span class="line">add r11, sp, #0 	/* 设置栈底帧 */</span><br><span class="line">sub sp, sp, #16 	/* 序幕结束,在堆栈上分配一些缓冲区(这也为堆栈帧分配空间) */</span><br></pre></td></tr></table></figure>
<p><strong>Body（主体）</strong> 部分通常负责某种独特而特定的任务，这部分函数可能包含各种指令，分支（跳转）到其他函数等，函数的 body 部分的示例可以像以下几条指令一样简单： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov r0, #1 			/* 设置局部变量 (a=1)。 这也用作设置函数 max */ 的第一个参数</span><br><span class="line">mov r1, #2 			/* 设置局部变量 (b=2)。 这也用作设置函数 max */ 的第二个参数</span><br><span class="line">bl max 				/* 调用/分支到函数 max */</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的示例代码显示了一个函数的片段，该函数设置局部变量，然后分支到另一个函数</li>
<li>这段代码还向我们展示了函数的参数（在本例中为函数 max）是通过寄存器传递的</li>
<li>在某些情况下，当有超过4个参数要传递时，我们会另外使用 Stack 来存储剩余的参数</li>
<li>还值得一提的是，函数的结果通过寄存器 R0 返回，因此，无论函数（max）的结果是什么，我们应该能够在从函数返回后立即从寄存器 R0 中获取它</li>
<li>需要指出的另一件事是，在某些情况下，结果的长度可能是64位（超过32位寄存器的大小） </li>
</ul>
<p>函数的最后一部分，即 <strong>Epilogue（结语）</strong>，用于将程序的状态恢复到其初始状态（在函数调用之前），以便它可以从它离开的位置继续，为此，我们需要重新调整堆栈指针（这是通过使用帧指针寄存器 R11 作为参考并执行添加或子操作来完成的）</p>
<p>重新调整堆栈指针后，通过将以前（在序幕中）保存的寄存器值从堆栈中弹出到相应的寄存器中来恢复它们，根据函数类型，POP 指令可能是 Epilogue 的最终指令（但是，可能是在恢复寄存器值后，我们使用 BX 指令离开函数），Epilogue 的示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub sp, r11, #0 		/* 结尾的开始,重新调整堆栈指针 */</span><br><span class="line">pop &#123;r11, pc&#125; 			/* 结尾,从堆栈中恢复帧指针,通过直接加载到PC中跳转到以前保存的LR,函数的堆栈帧最终在这一步被销毁 */</span><br></pre></td></tr></table></figure>
<p>所以现在我们知道：</p>
<ol>
<li>Prologue（序幕）为功能设置环境</li>
<li>Body（主体）实现函数的逻辑并将结果存储到 R0</li>
<li>Epilogue（结语）还原状态，以便程序可以从调用函数之前离开的位置恢复</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://azeria-labs.com/writing-arm-assembly-part-1/">编写 ARM 程序集|阿泽里亚实验室</a> </p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/ARM/" rel="tag"><i class="fa fa-tag"></i> ARM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/26/dl_runtime_resolve%20attack/" rel="prev" title="dl_runtime_resolve attack">
      <i class="fa fa-chevron-left"></i> dl_runtime_resolve attack
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/30/ARM%20pwn+ret2csu/" rel="next" title="ARM pwn+ret2csu">
      ARM pwn+ret2csu <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM-%E6%9E%B6%E6%9E%84%E7%AE%80%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">ARM 架构简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83"><span class="nav-number">2.</span> <span class="nav-text">搭建环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">数据类型和寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM-amp-THUMB"><span class="nav-number">4.</span> <span class="nav-text">ARM &amp; THUMB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM-%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-number">5.</span> <span class="nav-text">ARM 指令集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%98%E5%82%A8"><span class="nav-number">6.</span> <span class="nav-text">加载和存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C"><span class="nav-number">7.</span> <span class="nav-text">条件执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">栈和函数</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">329</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:32</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
