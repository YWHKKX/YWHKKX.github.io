<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Linux 内核简述Linux 的内核虽然是基于单内核的，但是经过这么多年的发展，也具备微内核的一些特征（体现了 Linux 实用至上的原则） 主要有以下特征：  使用 GNU C 库（和标准C库有一定的区别） 支持动态加载内核模块 支持对称多处理（SMP） 内核可以抢占（preemptive），允许内核运行的任务有优先执行的能力 不区分线程和进程  Linux 内核源码的结构    目录 说明">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核学习笔记（持续更新）">
<meta property="og:url" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="Linux 内核简述Linux 的内核虽然是基于单内核的，但是经过这么多年的发展，也具备微内核的一些特征（体现了 Linux 实用至上的原则） 主要有以下特征：  使用 GNU C 库（和标准C库有一定的区别） 支持动态加载内核模块 支持对称多处理（SMP） 内核可以抢占（preemptive），允许内核运行的任务有优先执行的能力 不区分线程和进程  Linux 内核源码的结构    目录 说明">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1662381646423-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660827734080-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660832270823-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660832773428-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660834074319-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660834323260-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660836387459-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1655523602992-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660878766425-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660879056533-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660882969270-1666871176497.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1663685252415-1666871176498.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660900515527-1666871176498.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661421650964-1666871176498.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661432738679-1666871176498.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661438949794-1666871176498.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661472333928-1666871176498.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661508765929-1666871176498.png">
<meta property="og:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661852969399-1666871176498.png">
<meta property="article:published_time" content="2022-08-18T15:38:46.000Z">
<meta property="article:modified_time" content="2023-04-02T08:52:18.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="Kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1662381646423-1666871176497.png">

<link rel="canonical" href="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux内核学习笔记（持续更新） | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux内核学习笔记（持续更新）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-18 23:38:46" itemprop="dateCreated datePublished" datetime="2022-08-18T23:38:46+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-02 16:52:18" itemprop="dateModified" datetime="2023-04-02T16:52:18+08:00">2023-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>87k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1:19</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Linux-内核简述"><a href="#Linux-内核简述" class="headerlink" title="Linux 内核简述"></a>Linux 内核简述</h2><p>Linux 的内核虽然是基于单内核的，但是经过这么多年的发展，也具备微内核的一些特征（体现了 Linux 实用至上的原则）</p>
<p>主要有以下特征：</p>
<ul>
<li>使用 GNU C 库（和标准C库有一定的区别）</li>
<li>支持动态加载内核模块</li>
<li>支持对称多处理（SMP）</li>
<li>内核可以抢占（preemptive），允许内核运行的任务有优先执行的能力</li>
<li>不区分线程和进程</li>
</ul>
<h2 id="Linux-内核源码的结构"><a href="#Linux-内核源码的结构" class="headerlink" title="Linux 内核源码的结构"></a>Linux 内核源码的结构</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>arch</td>
<td>特定体系结构的代码</td>
</tr>
<tr>
<td>block</td>
<td>块设备I/O层</td>
</tr>
<tr>
<td>crypo</td>
<td>加密API</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核源码文档</td>
</tr>
<tr>
<td>drivers</td>
<td>设备驱动程序</td>
</tr>
<tr>
<td>firmware</td>
<td>使用某些驱动程序而需要的设备固件</td>
</tr>
<tr>
<td>fs</td>
<td>VFS和各种文件系统</td>
</tr>
<tr>
<td>include</td>
<td>内核头文件</td>
</tr>
<tr>
<td>init</td>
<td>内核引导和初始化</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>像调度程序这样的核心子系统</td>
</tr>
<tr>
<td>lib</td>
<td>同样内核函数</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理子系统和VM</td>
</tr>
<tr>
<td>net</td>
<td>网络子系统</td>
</tr>
<tr>
<td>samples</td>
<td>示例，示范代码</td>
</tr>
<tr>
<td>scripts</td>
<td>编译内核所用的脚本</td>
</tr>
<tr>
<td>security</td>
<td>Linux 安全模块</td>
</tr>
<tr>
<td>sound</td>
<td>语音子系统</td>
</tr>
<tr>
<td>usr</td>
<td>早期用户空间代码（所谓的initramfs）</td>
</tr>
<tr>
<td>tools</td>
<td>在Linux开发中有用的工具</td>
</tr>
<tr>
<td>virt</td>
<td>虚拟化基础结构</td>
</tr>
</tbody>
</table>
</div>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程就是处于执行期的程序，包括：可执行代码，打开的文件，挂起的信号，内核内部的数据，处理器状态，一个或者多个具有内存映射的空间，一个或者多个执行线程，还有存放全局变量的代码段</p>
<p>内核把进程表列存放在叫做 <strong>任务队列(task_list)</strong> 的双向循环链表中，链表中的每个类型都是 <code>task_struct</code>（该结构体相对较大，包含一个具体进程的所有信息，通常存放在该进程内核栈的末尾）</p>
<ul>
<li>Windows：开启的一个程序就是一个线程，它只是一个容器，用于装载系统资源，它并不执行代码，它是系统资源分配的最小单元，而在进程中执行代码的是线程，是代码执行的最小单位</li>
<li>Linux：Linux 中的进程于 Windows 相比是很轻量级的，而且不严格区分进程和线程，Linux 的进程就是 Windows 中的线程，线程就是轻量级的进程</li>
</ul>
<p><strong>Linux 中的第一个进程</strong></p>
<p>Linux 内核在系统启动的最后阶段会启动 init 进程，该进程会读取系统的初始化脚本，并执行其他相关程序，最终启动系统</p>
<p>所有其他进程都是 PID 为“1”的 init 进程的后代</p>
<p><strong>Linux 进程的状态</strong></p>
<ul>
<li>TASK_RUNNING（运行）：正在运行，或者在运行队列中等待运行</li>
<li>TASK_INTERRUPTIBLE（可中断）：正在睡眠（被阻塞），可以接受信号而被唤醒</li>
<li>TASK_UNINTERRUPTIBLE（不可中断）：正在睡眠（被阻塞），不能被唤醒</li>
<li>TASK_TRACED（被追踪）：被其他进程跟踪（例如：通过 ptrace 对调试程序进行跟踪）<ul>
<li>强大的调试工具 <code>gdb</code> 和 Linux 系统调用和信号跟踪工具 <code>strace</code>，都是用 ptrace 实现的</li>
<li>ptrace 是一个系统调用，它提供了一种方法来让‘父’进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器，主要用来实现断点调试和系统调用跟踪  </li>
</ul>
</li>
<li>TASK_STOPPED（停止）：即将停止，然后被回收</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1662381646423-1666871176497.png" class width="1662381646423"> 
<p><strong>Linux 进程的创建</strong></p>
<p>Linux 中创建进程与其他系统有个主要区别，Linux 中创建进程分2步：fork() 和 exec() </p>
<ul>
<li>fork：通过拷贝当前进程创建一个子进程</li>
<li>exec：读取可执行文件，将其载入到内存中运行</li>
</ul>
<p>Copy On Write，写时复制：</p>
<ul>
<li>如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会获取指向相同资源的指针</li>
<li>直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变 </li>
</ul>
<p>也就是说，在一份共享资源，被多个调用者共同消费时，若出现修改资源的操作，我们并不直接对资源进行修改，而是对将资源修改操作划分为三个步骤：</p>
<ul>
<li>第一：先将资源以 [页为单位] 进行复制，复制出一个新的资源备份</li>
<li>第二：往这个资源备份里面添加新的数据</li>
<li>第三：将原先资源地址指向资源备份的地址</li>
</ul>
<p>Copy On Write 对 fork 的优化：</p>
<ul>
<li>减少分配和复制大量资源时带来的瞬间延时</li>
<li>fork 并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制</li>
</ul>
<p>Copy On Write 的原理：</p>
<ul>
<li>fork() 之后，kernel 把父进程中所有的内存页的权限都设为 read-only，然后子进程的地址空间指向父进程</li>
<li>当父子进程都只读内存时，相安无事，当其中某个进程写内存时，CPU硬件检测到内存页是 read-only 的，于是触发页异常中断（page-fault），陷入 kernel 的一个中断例程</li>
<li>中断例程中，kernel 就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份</li>
</ul>
<p>创建的流程： </p>
<ul>
<li>系统调用 clone 的底层会调用 fork()，它的又底层是 _do_fork()，在其中会调用 copy_process()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">		 child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE); <span class="comment">/* task_struct *p */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用 dup_task_struct() 为新进程分配内核栈，task_struct 等，其中的内容与父进程相同</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = dup_task_struct(current, node); <span class="comment">/* task_struct *p */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>check 新进程（进程数目是否超出上限等）</li>
<li>清理新进程的信息（比如 PID 置0等），使之与父进程区别开</li>
<li>新进程状态置为 TASK_UNINTERRUPTIBLE</li>
<li>更新 task_struct 的 flags 成员</li>
<li>执行调度程序相关设置，将此任务分配给 CPU，然后调用 copy 系列函数复制所有进程信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">shm_init_task(p);</span><br><span class="line">retval = security_task_alloc(p, clone_flags);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_audit;</span><br><span class="line">retval = copy_semundo(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_security;</span><br><span class="line">retval = copy_files(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_semundo;</span><br><span class="line">retval = copy_fs(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_files;</span><br><span class="line">retval = copy_sighand(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">retval = copy_signal(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_sighand;</span><br><span class="line">retval = copy_mm(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_signal;</span><br><span class="line">retval = copy_namespaces(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_mm;</span><br><span class="line">retval = copy_io(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_namespaces;</span><br><span class="line">retval = copy_thread_tls(clone_flags, stack_start, stack_size, p, tls);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_io;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 alloc_pid() 为新进程分配一个有效的PID（copy_process() 返回）</li>
<li>根据 clone() 的参数标志 clone_flags，拷贝或共享相应的信息</li>
<li>做一些扫尾工作并返回新进程指针</li>
</ul>
<p>用户态创建进程的 fork() 函数实际上最终是调用 clone() 系统调用，创建线程和进程的步骤一样，只是最终传给 clone() 的参数不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ea1f3d</span> &lt;fork+<span class="number">77</span>&gt;    syscall  &lt;SYS_clone&gt;</span><br><span class="line">       fn: <span class="number">0x1200011</span></span><br><span class="line">       child_stack: <span class="number">0x0</span></span><br><span class="line">       flags: <span class="number">0x0</span></span><br><span class="line">       arg: <span class="number">0x7ffff7fb2810</span> ◂— <span class="number">0x0</span></span><br><span class="line">       vararg: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>在内核中创建的内核线程与普通的进程之间还有个主要区别在于：</p>
<ul>
<li>内核线程没有独立的地址空间，它们只能在内核空间运行</li>
<li>这与之前提到的 Linux 内核是个单内核有关</li>
</ul>
<p>fork 的变种：vfork</p>
<ul>
<li>除了不拷贝父进程的页表项以外，vfork 和 fork 的功能相同，子进程作为父进程的一个单独线程，并在父进程的地址空间里运行</li>
<li>创建的子进程会执行完后，才到父进程执行</li>
</ul>
<p><strong>Linux 线程的创建</strong></p>
<p>在 Linux 中，线程被视为一个与其他进程共享某些资源的进程，每个线程会单独占有一个 task_struct 结构体</p>
<p>Linux 线程和进程的底层都是系统调用 clone（上文已经介绍了 clone 的实现），就是传入的参数不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND , <span class="number">0</span>); <span class="comment">/* 创建线程 */</span></span><br><span class="line">clone(SIGCHLD , <span class="number">0</span>); <span class="comment">/* fork */</span></span><br><span class="line">clone(CLONE_VFORK | CLONE_VM | SIGCHLD, <span class="number">0</span>); <span class="comment">/* vfork */</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数标志</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLONE_SETTID</td>
<td>将TID回写至用户空间</td>
</tr>
<tr>
<td>CLONE_SETTLS</td>
<td>为子进程创建新的TLS</td>
</tr>
<tr>
<td>CLONE_SIGHAND</td>
<td>父子进程共享信号处理函数以及被阻断的信号</td>
</tr>
<tr>
<td>CLONE_FILES</td>
<td>父子进程共享打开的文件</td>
</tr>
<tr>
<td>CLONE_FS</td>
<td>父子进程共享文件系统信息</td>
</tr>
<tr>
<td>CLONE_SYSVSEM</td>
<td>父子进程共享System V SEM_UNDO语义</td>
</tr>
<tr>
<td>CLONE_THREAD</td>
<td>父子进程放入相同的线程组</td>
</tr>
<tr>
<td>CLONE_VFORK</td>
<td>调用<code>vfork</code>，父进程准备睡眠等待子进程将其唤醒</td>
</tr>
<tr>
<td>CLONE_NEWNS</td>
<td>为子进程创建新的命名空间</td>
</tr>
<tr>
<td>CLONE_STOP</td>
<td>以TASK_STOPPED状态开始进程</td>
</tr>
<tr>
<td>CLONE_VM</td>
<td>父子进程共享地址空间</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Linux 进程的终止</strong></p>
<p>进程的终止一般是显示地调用 exit，或者隐式地从某个主函数中返回，和创建进程一样，终结一个进程同样有很多步骤：</p>
<p>子进程上的操作：（do_exit）</p>
<ul>
<li>设置 task_struct 中的标识成员设置为 PF_EXITING</li>
<li>调用 del_timer_sync() 删除内核定时器, 确保没有定时器在排队和运行</li>
<li>调用 exit_mm() 释放进程占用的 mm_struct</li>
<li>调用 sem__exit() ，使进程离开等待 IPC 信号的队列</li>
<li>调用 exit_files() 和 exit_fs()，释放进程占用的文件描述符和文件系统资源</li>
<li>把 task_struct 的 exit_code 设置为进程的返回值</li>
<li>调用 exit_notify() 向父进程发送信号，并把自己的状态设为 EXIT_ZOMBIE</li>
<li>切换到新进程继续执行</li>
</ul>
<p>子进程进入 EXIT_ZOMBIE 之后，虽然永远不会被调度，关联的资源也释放掉了，但是它本身占用的内存还没有释放（比如：创建时分配的内核栈，task_struct 结构等），这些由父进程来释放</p>
<p>父进程上的操作：（release_task）</p>
<ul>
<li>父进程受到子进程发送的 exit_notify() 信号后，将该子进程的进程描述符和所有进程独享的资源全部删除</li>
</ul>
<p>从上面的步骤可以看出，必须要确保每个子进程都有父进程，如果父进程在子进程结束之前就已经结束了会怎么样呢？</p>
<ul>
<li>子进程在调用 exit_notify() 时已经考虑到了这点</li>
<li>如果子进程的父进程已经退出了，那么子进程在退出时，exit_notify() 函数会先调用 forget_original_parent() ，然后再调用 find_new_reaper() 来寻找新的父进程</li>
<li>find_new_reaper() 函数先在当前线程组中找一个线程作为父亲，如果找不到，就让 init 做父进程（init 进程是在 linux 启动时就一直存在的）</li>
</ul>
<h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><p>现在的操作系统都是 <strong>抢占式多任务</strong> 的，为了能让更多的任务能同时在系统上更好的运行，需要一个管理程序来管理计算机上同时运行的各个任务（也就是进程）</p>
<ul>
<li>抢占式多任务：由调度模式来决定什么时候停止一个进程的运行，以便其他进程可以得到运行机会（这个强制挂起的动作就是抢占）</li>
<li>非抢占式多任务：除非进程自己主动停止运行，否则它会一直执行（这个主动挂起的操作就是让步）</li>
</ul>
<p>这个管理程序就是调度程序，它的功能说起来很简单：</p>
<ul>
<li>决定哪些进程运行，哪些进程等待</li>
<li>决定每个进程运行多长时间</li>
</ul>
<p>总之，调度是一个平衡的过程：</p>
<ul>
<li>一方面，它要保证各个运行的进程能够最大限度的使用CPU（即尽量少的切换进程，进程切换过多，CPU的时间会浪费在切换上）</li>
<li>另一方面，保证各个进程能公平的使用CPU（即防止一个进程长时间独占CPU的情况）</li>
</ul>
<p><strong>IO消耗型进程&amp;CPU消耗型进程</strong></p>
<p>IO消耗型进程：用大部分时间来提交/等待 IO 请求，这种进程经常处于可运行状态，但通常都是运行短短的一会儿</p>
<p>CPU消耗型进程：把大部分时间用在执行代码上，除非被抢占，否则它们通常都一直在不停地运行，因为它们对 IO 的需求很小</p>
<p>进程调度策略往往要在这两个矛盾中间寻找平衡：</p>
<ul>
<li>进程响应迅速</li>
<li>最大系统利用率</li>
</ul>
<p><strong>时间片</strong></p>
<p>决定哪个进程运行以及运行多长时间都和进程的优先级有关，但是对于调度程序来说，并不是运行一次就结束了，还必须知道间隔多久进行下次调度</p>
<p>为了确定一个进程到底能持续运行多长时间，调度中还引入了时间片的概念，也可以认为是进程在下次调度发生前运行的时间（除非进程主动放弃CPU，或者有实时进程来抢占CPU）</p>
<p>时间片的大小设置并不简单：</p>
<ul>
<li>设大了，系统响应变慢（调度周期长）</li>
<li>设小了，进程频繁切换带来的处理器消耗</li>
<li>默认的时间片一般是10ms</li>
</ul>
<p>通常来说：</p>
<ul>
<li>IO消耗型进程不需要太长的时间片</li>
<li>CPU消耗型进程则希望时间片越长越好</li>
</ul>
<p><strong>完全公平调度器 CFS</strong></p>
<p>前面说过，调度功能就是决定哪个进程运行以及进程运行多长时间</p>
<p>进程的优先级有2种度量方法，一种是 nice 值，一种是实时优先级：（实时优先级 &gt; nice 值）</p>
<ul>
<li>nice 值的范围是 -20～19，值越大优先级越低，也就是说 nice 值为 -20 的进程优先级最大</li>
<li>实时优先级的范围是 0～99，与 nice 值的定义相反，实时优先级是值越大优先级越高</li>
</ul>
<p>实时进程都是一些对响应时间要求比较高的进程，因此系统中有实时优先级高的进程处于运行队列的话，它们会抢占一般的进程的运行时间</p>
<p>介绍下 CFS：</p>
<ul>
<li>CFS 使用红黑树结构，来存储要调度的任务队列</li>
<li>每个节点代表了一个要调度的任务，节点的 key 即为虚拟时间（vruntime），虚拟时间由这个人物的运行时间计算而来（CFS 不再有时间片的概念，取而代之的是 vruntime）</li>
<li>key 越小，也就是 vruntime 越小的话，红黑树对应的节点就越靠左</li>
<li>CFS scheduler 每次都挑选最左边的节点作为下一个要运行的任务，这个节点是“缓存的”，由一个特殊的指针指向，不需要进行 <code>O(logn)</code> 遍历来查找，也因此，CFS 搜索的时间是 <code>O(1)</code></li>
</ul>
<p>vruntime(key) 的计算公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime += 实际运行时间(time process run) * <span class="number">1024</span> / 进程权重(load weight of <span class="keyword">this</span> process)</span><br></pre></td></tr></table></figure>
<ul>
<li>实际运行时间：该程序已经运行了多久 </li>
<li>进程权重：根据任务的 nice 值进行索引</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>相当于 nice 和 weight 是等价的，但是不同 nice 值的任务权重差别变大了</li>
</ul>
<p>例子：现在我们有一个刚来的进程 [time=0，nice=0，priority=1024]：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime += <span class="number">0</span> * <span class="number">1024</span> / <span class="number">1024</span> = <span class="number">10</span> <span class="comment">/* vruntime有一个最小值min_vruntime */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>vruntime 并不是无限小的，有一个最小值来限定 min_vruntime </li>
<li>假如新进程的 vruntime 初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的</li>
</ul>
<p>CFS 是这样做的：每个CPU的运行队列 cfs_rq 都维护一个 min_vruntime 字段，记录该运行队列中所有进程的 vruntime 最小值，新进程的初始 vruntime 值就以它所在运行队列的 min_vruntime 为基础来设置，与老进程保持在合理的差距范围内</p>
<p>对于新任务来说，vruntime = 0（任务：用于完成某个操作的一组 [进程,线程]，用 <code>task_struct</code> 结构体来描述）</p>
<p><strong>调度器入口</strong></p>
<p>进程调度器的主要入口是函数 schedule()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __sched <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line"></span><br><span class="line">	sched_submit_work(tsk);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		preempt_disable();</span><br><span class="line">		__schedule(<span class="literal">false</span>);</span><br><span class="line">		sched_preempt_enable_no_resched();</span><br><span class="line">	&#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(schedule);</span><br></pre></td></tr></table></figure>
<ul>
<li>schedule() 函数只是个外层的封装，实际调用的还是 __schedule() 函数 </li>
<li>__schedule() 接受一个参数，该参数为 bool 型，false 表示非抢占，自愿调度，而 true 则相反</li>
<li>__schedule() 的实现大概可以分为四个部分：<ul>
<li>针对当前进程的处理</li>
<li>选择下一个需要执行的进程</li>
<li>执行切换工作</li>
<li>收尾工作</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __sched notrace __schedule(<span class="keyword">bool</span> preempt)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *switch_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	cpu = smp_processor_id();</span><br><span class="line">	rq = cpu_rq(cpu);</span><br><span class="line">	prev = rq-&gt;curr;</span><br><span class="line"></span><br><span class="line">	schedule_debug(prev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sched_feat(HRTICK))</span><br><span class="line">		hrtick_clear(rq);</span><br><span class="line"></span><br><span class="line">	local_irq_disable(); <span class="comment">/* 禁止本地中断，防止与中断的竞争行为 */</span></span><br><span class="line">	rcu_note_context_switch(preempt);</span><br><span class="line"></span><br><span class="line">	rq_lock(rq, &amp;rf);</span><br><span class="line">	smp_mb__after_spinlock();</span><br><span class="line"></span><br><span class="line">	rq-&gt;clock_update_flags &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	update_rq_clock(rq); <span class="comment">/* 更新本地runqueue的clock和clock_task变量，这两个变量代表runqueue的时间 */</span></span><br><span class="line"></span><br><span class="line">	switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line">	<span class="keyword">if</span> (!preempt &amp;&amp; prev-&gt;state) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(prev-&gt;state, prev))) &#123;</span><br><span class="line">			prev-&gt;state = TASK_RUNNING;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);</span><br><span class="line">			prev-&gt;on_rq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;in_iowait) &#123;</span><br><span class="line">				atomic_inc(&amp;rq-&gt;nr_iowait);</span><br><span class="line">				delayacct_blkio_start();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (prev-&gt;flags &amp; PF_WQ_WORKER) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">to_wakeup</span>;</span></span><br><span class="line"></span><br><span class="line">				to_wakeup = wq_worker_sleeping(prev);</span><br><span class="line">				<span class="keyword">if</span> (to_wakeup)</span><br><span class="line">					try_to_wake_up_local(to_wakeup, &amp;rf);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">	&#125;</span><br><span class="line">	next = pick_next_task(rq, prev, &amp;rf); <span class="comment">/* 检查并选择调度类 */</span></span><br><span class="line">	clear_tsk_need_resched(prev);</span><br><span class="line">	clear_preempt_need_resched();</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">		rq-&gt;nr_switches++;</span><br><span class="line">		rq-&gt;curr = next;</span><br><span class="line">		++*switch_count;</span><br><span class="line">		trace_sched_switch(preempt, prev, next);</span><br><span class="line">		rq = context_switch(rq, prev, next, &amp;rf);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line">		rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">	&#125;</span><br><span class="line">	balance_callback(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>__schedule() 通常都需要和一个具体的调度类相关联，所以它会找到一个最高优先级的调度类（拥有自己的运行队列）</li>
<li>而 __schedule() 调用的 pick_next_task() 函数就实现了这个过程，它会以优先级为序，依次检查每一个调用类，选择最高优先级的进程</li>
</ul>
<p><strong>调度策略</strong></p>
<p>Linux 的调度器是以模块的方式提供的，这种模块化的结构被称为 <strong>调度器类</strong>，它允许多种不同的可动态添加的调度算法共存</p>
<ul>
<li>每个调度器都有一个优先级，程序会根据优先级遍历调度类，最高优先优先级的调度器类胜出，然后再根据调度器自身的算法去选择下一个将要执行的程序</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SCHED_NORMAL</td>
<td>普通的分时进程，使用的 fair_sched_class 调度类（完全公平调度器）</td>
</tr>
<tr>
<td>SCHED_FIFO</td>
<td>先进先出的实时进程，当调用程序把CPU分配给进程的时候，它把该进程描述符保留在运行队列链表的当前位置，此调度策略的进程一旦使用CPU则一直运行，如果没有其他可运行的更高优先级实时进程，进程就继续使用CPU，想用多久就用多久，即使还有其他具有相同优先级的实时进程处于可运行状态，使用的是 rt_sched_class 调度类</td>
</tr>
<tr>
<td>SCHED_RR</td>
<td>时间片轮转的实时进程，当调度程序把CPU分配给进程的时候，它把该进程的描述符放在运行队列链表的末尾，这种策略保证对所有具有相同优先级的 SCHED_RR 实时进程进行公平分配CPU时间，使用的 rt_sched_class 调度类</td>
</tr>
<tr>
<td>SCHED_BATCH</td>
<td>是 SCHED_NORMAL 的分化版本，采用分时策略，根据动态优先级，分配CPU资源，在有实时进程的时候，实时进程优先调度，但针对吞吐量优化，除了不能抢占外与常规进程一样，允许任务运行更长时间，更好使用高速缓存，适合于成批处理的工作，使用的 fair_shed_class 调度类</td>
</tr>
<tr>
<td>SCHED_IDLE</td>
<td>优先级最低，在系统空闲时运行，使用的是 idle_sched_class 调度类，给0号进程使用</td>
</tr>
<tr>
<td>SCHED_DEADLINE</td>
<td>新支持的实时进程调度策略，针对突发型计算，并且对延迟和完成时间敏感的任务使用，基于 EDF（earliest deadline first），使用的是 dl_sched_class 调度类</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>SCHED_FIFO：实现了一种简单的先入先出的调度算法，它不使用时间片，处于 SCHED_FIFO 级的进程会比任何 SCHED_NORMAL 级的进程都要优先执行调度</li>
<li>SCHED_RR：SCHED_RR 和 SCHED_FIFO 大体上相同，只是 SCHED_RR 带有时间片，如果一个 SCHED_RR 任务耗尽了它的时间片，在同一优先级的其他实时进程会被轮流调度</li>
<li>PS：SCHED_FIFO 和 SCHED_RR 都是采用静态优先级</li>
</ul>
<p><strong>上下文切换&amp;抢占</strong></p>
<p>上下文切换：一个可执行进程切换到另一个可执行进程的过程（由 <code>context_switch</code> 函数进行处理）</p>
<ul>
<li><code>context_switch</code> 函数完成了两项基本工作：<ul>
<li>调用 <code>switch_mm</code>，把虚拟内存从上一个进程映射切换到新进程中</li>
<li>调用 <code>switch_to</code>，把进程处理器状态从上一个进程切换到新进程中</li>
</ul>
</li>
</ul>
<p>用户抢占：内核从系统调用或中断处理程序即将返回用户空间的时候，如果 <code>need resched</code> 标志被设置，会导致 <code>schedule</code>，此时就会发生用用户抢占</p>
<ul>
<li>用户抢占的发生场景：<ul>
<li>从系统调用返回用户空间</li>
<li>从中断处理程序返回用户空间</li>
</ul>
</li>
</ul>
<p>内核抢占：Linux 支持内核抢占（对于不支持内核抢占的程序，内核代码会一直执行，直到它完成为止），内核会检查 <code>need resched</code> 和 <code>preempt_count</code> 的值</p>
<ul>
<li>内核抢占的发生场景：<ul>
<li>中断处理程序正在执行，且返回内核空间之前</li>
<li>内核代码再一次具有可抢占性</li>
<li>内核中的任务显式地调用 <code>schedule</code> </li>
<li>内核中的任务阻塞（这同样也会调用 <code>schedule</code>）</li>
</ul>
</li>
<li><code>preempt_count</code> 简述：<ul>
<li><code>preempt_count</code> 初始化为“0”，每当使用锁时数值加“1”，释放锁时数值减“1”</li>
<li>当 <code>preempt_count</code> 为“0”时，说明有一个更为重要的任务需要执行并且可以抢占</li>
<li>当 <code>preempt_count</code> 不为“0”时，说明内核不能安全抢占该进程</li>
</ul>
</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>简单来说，系统调用就是用户程序和硬件设备之间的桥梁，用户程序在需要的时候，通过系统调用来使用硬件设备</p>
<p>系统调用的存在，有以下重要的意义：</p>
<ul>
<li>用户程序通过系统调用来使用硬件，而不用关心具体的硬件设备，这样大大简化了用户程序的开发 </li>
<li>系统调用使得用户程序有更好的可移植性</li>
<li>系统调用使得内核能更好的管理用户程序，增强了系统的稳定性 </li>
<li>系统调用有效的分离了用户程序和内核的开发</li>
</ul>
<p>用户程序，系统调用，内核，硬件设备的调用关系如下图： </p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660827734080-1666871176497.png" class width="1660827734080"> 
<p>要想实现系统调用，主要实现以下几个方面：</p>
<ul>
<li>通知内核调用一个哪个系统调用（系统调用号）</li>
<li>用户程序把系统调用的参数传递给内核（前5个参数放在 [ebx,ecx,edx,esi,edi] 中，如果参数多的话，还需要用个单独的寄存器存放指向所有参数在用户空间地址的指针）</li>
<li>用户程序获取内核返回的系统调用返回值（获取系统调用的返回值也是通过寄存器，在x86系统上，返回值放在 [eax] 中）</li>
</ul>
<p><strong>Linux 系统调用的实现</strong></p>
<p>Linux 采用 <code>SYSCALL_DEFINEx</code> 来定义一个系统调用（“x”代表该系统调用的参数个数）</p>
<ul>
<li>例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pipe()系统调用底层 */</span></span><br><span class="line">SYSCALL_DEFINE1(pipe, <span class="keyword">int</span> __user *, fildes) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_pipe2(fildes, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>源码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE_MAXARGS	6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)				\</span></span><br><span class="line"><span class="meta">	SYSCALL_METADATA(sname, x, __VA_ARGS__)			\</span></span><br><span class="line"><span class="meta">	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SYSCALL_DEFINEx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)					\</span></span><br><span class="line"><span class="meta">	__diag_push();							\</span></span><br><span class="line"><span class="meta">	__diag_ignore(GCC, 8, <span class="meta-string">&quot;-Wattribute-alias&quot;</span>,			\</span></span><br><span class="line"><span class="meta">		      <span class="meta-string">&quot;Type aliasing is used to sanitize syscall arguments&quot;</span>);\</span></span><br><span class="line"><span class="meta">	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))	\</span></span><br><span class="line"><span class="meta">		__attribute__((alias(__stringify(__se_sys##name))));	\</span></span><br><span class="line"><span class="meta">	ALLOW_ERROR_INJECTION(sys##name, ERRNO);			\</span></span><br><span class="line"><span class="meta">	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span></span><br><span class="line"><span class="meta">	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));	\</span></span><br><span class="line"><span class="meta">	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))	\</span></span><br><span class="line"><span class="meta">	&#123;								\</span></span><br><span class="line"><span class="meta">		long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span></span><br><span class="line"><span class="meta">		__MAP(x,__SC_TEST,__VA_ARGS__);				\</span></span><br><span class="line"><span class="meta">		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\</span></span><br><span class="line"><span class="meta">		return ret;						\</span></span><br><span class="line"><span class="meta">	&#125;								\</span></span><br><span class="line"><span class="meta">	__diag_pop();							\</span></span><br><span class="line"><span class="meta">	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SYSCALL_DEFINEx */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个宏定义真是天书，给个博客参考一下：<a target="_blank" rel="noopener" href="https://www.e-learn.cn/topic/3281736#:~:text=显然SYSCALL_DEFINE1是系统调用的入口，其中1表示函数参数的个数，name表示系统调用函数的名字，同理下面的2%2C3%2C4%2C5%2C6表示参数个数。 其具体定义位于linux-4.13.16includelinuxsyscalls.h中，具体定义如下：,%23define SYSCALL_DEFINE1(name%2C...">SYSCALL_DEFINEx宏源码解析</a>) </li>
<li>最后还要把新定义的系统调用添加到系统调用表里面</li>
</ul>
<p><strong>系统调用参数传递</strong></p>
<p>x86-32 系统：</p>
<ul>
<li>不超过6个：ebx，ecx，edx，esi，edi，ebp 按照顺序存放前6个参数</li>
<li>超过6个：全部参数应该依次放在一块连续的内存区域里，同时在寄存器 ebx 中保存指向该内存区域的指针</li>
</ul>
<p>x86-64 系统：</p>
<ul>
<li>RDI、RSI、RDX、RCX、R8、R9 这6个寄存器依次对应第1参数到第6个参数</li>
</ul>
<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><p>Linux 中4个基本的内核数据结构：链表，队列，映射，红黑树</p>
<p><strong>链表</strong></p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660832270823-1666871176497.png" class width="1660832270823"> 
<ul>
<li>有个单独的头节点（head）</li>
<li>每个节点（node）除了包含必要的数据之外，还有2个指针（pre,next）</li>
<li>pre 指针指向前一个节点（node），next 指针指向后一个节点（node）</li>
<li>头节点（head）的 pre 指针指向链表的最后一个节点</li>
<li>最后一个节点的 next 指针指向头节点（head）</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660832773428-1666871176497.png" class width="1660832773428"> 
<ul>
<li>其实就是把数据放在前面了而已</li>
</ul>
<p>单向链表&amp;双向链表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span>&#123;</span></span><br><span class="line">	<span class="keyword">void</span> *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环形链表：</p>
<ul>
<li>环形链表的节点和双向链表相同，但是最后一个元素指向第一个元素</li>
<li>有一个特殊的指针（头指针）始终指向头节点，利用该指针可以快速查找链表的“起始端”</li>
<li>Linux 内核的标准链表就是采用的环形链表</li>
</ul>
<p><strong>Linux 中链表的实现</strong></p>
<p>Linux 不是将数据结构塞入链表，而是将链表节点塞入数据结构</p>
<p>其数据结构很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内核中添加链表的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *_new, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// @new:要添加的新条目</span></span><br><span class="line">    <span class="comment">// @head:目标结点(将new添加到它之前)</span></span><br><span class="line">	__list_add(_new, head-&gt;prev, head); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(struct list_head *_new, struct list_head *prev,</span><br><span class="line">			      struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">	next-&gt;prev = _new;</span><br><span class="line">	_new-&gt;next = next;</span><br><span class="line">	_new-&gt;prev = prev;</span><br><span class="line">	prev-&gt;next = _new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为 <code>list_add_tail</code> 只接收 <code>list_head</code> 为参数，链表也只能查找到 <code>list_head</code> 的地址</li>
<li>所以需要一个宏定义来通过 <code>list_head</code> 快速定位父类型结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member)                                        \</span></span><br><span class="line"><span class="meta">	(&#123;                                                                     \</span></span><br><span class="line"><span class="meta">		const typeof(((type *)0)-&gt;member) *__mptr = (ptr);             \</span></span><br><span class="line"><span class="meta">		(type *)((char *)__mptr - offsetof(type, member));             \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>container_of</code> 宏，我们可以定义一个简单的宏函数来返回包含 <code>list_head</code> 的父类型结构体的起始地址：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) container_of(ptr, type, member)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp; ((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>依靠 <code>list_entry</code> ，内核提供了创建，操作以及其他链表管理的各种例程（所有这些方法都不需要考虑 <code>list_head</code> 在父类型结构体中的位置）</li>
<li>通过 <code>offsetof</code> ，内核可以快速查看某个结构条目在该父类型结构体中的偏移</li>
<li>PS：对于 <code>container_of</code> 的计算过程可以参考一下这篇博客 =&gt; <a target="_blank" rel="noopener" href="https://blog.csdn.net/s2603898260/article/details/79371024">container of()函数简介</a> </li>
</ul>
<p>Linux 中对链表的其他操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *_new, struct list_head *head)</span> <span class="comment">/* 插链(将new添加到head之前) */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span> <span class="comment">/* 脱链(直接把entry脱链) */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>队列</strong></p>
<p>内核中的队列是以字节形式保存数据的，所以获取数据的时候，需要知道数据的大小，如果从队列中取得数据时指定的大小不对的话，取得数据会不完整或过大</p>
<ul>
<li>队列是限制在两端进行插入操作和删除操作的线性表，允许进行存入操作的一端称为“队尾”，允许进行删除操作的一端称为“队头”</li>
<li>当线性表中没有元素时，称为“空队”</li>
<li>特点：先进先出（FIFO）</li>
</ul>
<p>常规的队列有如下两种：</p>
<ul>
<li>顺序队列：建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理<ul>
<li>队头指针 front，它指向队头元素</li>
<li>队尾指针 rear，它指向下一个入队元素的存储位置 </li>
</ul>
</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660834074319-1666871176497.png" class width="1660834074319"> 
<ul>
<li>链式队列：一个链队列显然需要两个分别指示队头和队尾的指针（分别成为头指针和尾指针）才能唯一确定<ul>
<li>空的链队列的判决条件为头指针和尾指针均指向头节点</li>
</ul>
</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660834323260-1666871176497.png" class width="1660834323260"> 
<p><strong>Linux 中队列的实现</strong></p>
<p>Linux 中的通用队列被称为 kfifo，提供了两个主要操作：enqueue（入队列）和 dequeue（出队列）</p>
<p>用于管理 kfifo 的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">kfifo</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	in; <span class="comment">/* 队列入口(写位置的“逻辑偏移量”) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	out; <span class="comment">/* 队列出口(读位置的“逻辑偏移量”) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	mask; <span class="comment">/* 为了后续优化 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	esize; <span class="comment">/* 队列中每个元素所占用的字节数 */</span></span><br><span class="line">	<span class="keyword">void</span>		*data; <span class="comment">/* 指向数据的指针 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建队列 <code>kfifo_alloc</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kfifo_alloc(fifo, size, gfp_mask) \</span></span><br><span class="line"><span class="meta">__kfifo_int_must_check_helper( \</span></span><br><span class="line"><span class="meta">(&#123; \</span></span><br><span class="line"><span class="meta">	typeof((fifo) + 1) __tmp = (fifo); \</span></span><br><span class="line"><span class="meta">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span></span><br><span class="line"><span class="meta">	__is_kfifo_ptr(__tmp) ? \</span></span><br><span class="line"><span class="meta">	__kfifo_alloc(__kfifo, size, sizeof(*__tmp-&gt;type), gfp_mask) : \</span></span><br><span class="line"><span class="meta">	-EINVAL; \</span></span><br><span class="line"><span class="meta">&#125;) \</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>该函数创建并初始化一个大小为 size 的 kfifo（内核使用 gfp_mask 来标识分配队列）</li>
<li>该函数的核心还是调用 <code>__kfifo_alloc</code>，在其中会自动分配 buffer</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __kfifo_alloc(struct __kfifo *fifo, <span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span><br><span class="line">		<span class="keyword">size_t</span> esize, <span class="keyword">gfp_t</span> gfp_mask)</span><br><span class="line">&#123;</span><br><span class="line">	size = roundup_pow_of_two(size);</span><br><span class="line">	fifo-&gt;in = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;esize = esize;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		fifo-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">		fifo-&gt;mask = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;data = kmalloc_array(esize, size, gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fifo-&gt;data) &#123;</span><br><span class="line">		fifo-&gt;mask = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;mask = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kfifo_alloc);</span><br></pre></td></tr></table></figure>
<p>创建队列 <code>kfifo_init</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kfifo_init(fifo, buffer, size) \</span></span><br><span class="line"><span class="meta">(&#123; \</span></span><br><span class="line"><span class="meta">	typeof((fifo) + 1) __tmp = (fifo); \</span></span><br><span class="line"><span class="meta">	struct __kfifo *__kfifo = &amp;__tmp-&gt;kfifo; \</span></span><br><span class="line"><span class="meta">	__is_kfifo_ptr(__tmp) ? \</span></span><br><span class="line"><span class="meta">	__kfifo_init(__kfifo, buffer, size, sizeof(*__tmp-&gt;type)) : \</span></span><br><span class="line"><span class="meta">	-EINVAL; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>该函数创建并初始化一个 kfifo 对象，它将使用由指针 buffer 指向的 size 字节大小的内存</li>
<li>该函数的核心还是调用 <code>__kfifo_init</code>，并为该 buffer 初始化 <code>__kfifo</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __kfifo_init(struct __kfifo *fifo, <span class="keyword">void</span> *buffer,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">size_t</span> esize)</span><br><span class="line">&#123;</span><br><span class="line">	size /= esize;</span><br><span class="line">	size = roundup_pow_of_two(size);</span><br><span class="line"></span><br><span class="line">	fifo-&gt;in = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;out = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;esize = esize;</span><br><span class="line">	fifo-&gt;data = buffer;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		fifo-&gt;mask = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;mask = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Linux 中对队列的其他操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	kfifo_in(fifo, buf, n) <span class="comment">/* 向队列fifo中推入n字节的buf */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	kfifo_out(fifo, buf, n) <span class="comment">/* 向队列fifo中摘取n字节的buf */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kfifo_size(fifo) <span class="comment">/* 获取队列长度(使用__kfifo-&gt;mask) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kfifo_reset(fifo) <span class="comment">/* 重置fifo(放弃该fifo中的所有数据) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kfifo_free(fifo) <span class="comment">/* 释放一个使用kfifo_alloc分配的队列(对于使用kfifo_init生成的队列,需要手动释放自己提供的buffer) */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>映射</strong></p>
<p>映射（也称为关联数组）是实现（key，value）绑定的一种数据结构（有点像其他语言中的字典类型），每个唯一的ID对应一个自定义的数据结构</p>
<p>映射需要至少支持三个操作：</p>
<ul>
<li>Add（key，value）</li>
<li>Remove（key）</li>
<li>value = Lookup（key）</li>
</ul>
<p>在 Linux 中的映射的目的是绑定一个标识数（UID）到一个指针，使用计算就是整数ID管理机制（IDR）</p>
<ul>
<li>IDR 是用于将 uid 和一个数据地址进行绑定的一种映射</li>
<li>IDR 把每一个ID分级数据进行管理，每一级维护着ID的5位数据，这样就可以把IDR分为7级进行管理</li>
<li>IDR 底层使用了 redix 树 </li>
</ul>
<p>IDR 怎么对于数据ID管理呢？传统上我们对于未使用的ID进行管理的时候可以使用位图进行管理，也可以使用数组进行管理，也可以使用链表进行ID管理，三个个各有优缺点：</p>
<ul>
<li>使用位图进行管理：使用空间少，但是对于位图对应的数据结构支持不太友好</li>
<li>使用数组进行管理：寻址快速，但是只能管理比较少量的ID数目</li>
<li>使用链表进行管理：可以支持大量的数据ID，但是通过链表的指针寻址比较慢</li>
</ul>
<p>而 IDR 管理可以集合以上3者的优点：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660836387459-1666871176497.png" class width="1660836387459"> 
<p><strong>Linux 中映射的实现</strong></p>
<p>以下结构体用于映射用户空间的 UID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span>	<span class="title">idr_rt</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		idr_base;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		idr_next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct radix_tree_root *</span></span><br><span class="line"><span class="function"><span class="title">xfs_dquot_tree</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	struct xfs_quotainfo	*qi,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span>			type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">	<span class="keyword">case</span> XFS_DQ_USER:</span><br><span class="line">		<span class="keyword">return</span> &amp;qi-&gt;qi_uquota_tree;</span><br><span class="line">	<span class="keyword">case</span> XFS_DQ_GROUP:</span><br><span class="line">		<span class="keyword">return</span> &amp;qi-&gt;qi_gquota_tree;</span><br><span class="line">	<span class="keyword">case</span> XFS_DQ_PROJ:</span><br><span class="line">		<span class="keyword">return</span> &amp;qi-&gt;qi_pquota_tree;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ASSERT(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>struct idr</code> 类于 <code>list_head</code>，用于管理 IDR 整个树的信息</li>
<li>其中最关键的是 <code>radix_tree_root</code>，它是 Linux 内核 Radix Tree 的基础数据结构</li>
<li>Linux 整数ID管理机制（IDR）的底层算法就是 Radix Tree，每个 <code>idr</code> 都是被 Radix Tree 组织起来的一个个单元，通过 Radix Tree 可以快速查找到各个 <code>idr</code></li>
</ul>
<p>初始化一个 <code>idr</code>：（需要提前定义静态的 <code>idr</code> 结构）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idr_init</span><span class="params">(struct idr *idr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	idr_init_base(idr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idr_init_base</span><span class="params">(struct idr *idr, <span class="keyword">int</span> base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INIT_RADIX_TREE(&amp;idr-&gt;idr_rt, IDR_RT_MARKER);</span><br><span class="line">	idr-&gt;idr_base = base;</span><br><span class="line">	idr-&gt;idr_next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配一个 <code>idr</code>：（把一个 UID 分配给目标 <code>idr</code>，需要两个步骤）</p>
<ul>
<li>调整后备树的大小：（为下一次调用 <code>idr_alloc()</code> 预分配内存）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idr_preload</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (__radix_tree_preload(gfp_mask, IDR_PRELOAD_SIZE))</span><br><span class="line">		preempt_disable();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(idr_preload);</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>@start</code> 和 <code>@end</code> 指定的范围内分配一个未使用的ID：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">idr_alloc</span><span class="params">(struct idr *idr, <span class="keyword">void</span> *ptr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">gfp_t</span> gfp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @idr: IDR句柄</span></span><br><span class="line"><span class="comment">     * @ptr: 与新ID关联的指针</span></span><br><span class="line"><span class="comment">     * @start: 最小ID</span></span><br><span class="line"><span class="comment">     * @end: 最大ID</span></span><br><span class="line"><span class="comment">     * @gfp: 内存分配标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	u32 id = start;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(start &lt; <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	ret = idr_alloc_u32(idr, ptr, &amp;id, end &gt; <span class="number">0</span> ? end - <span class="number">1</span> : INT_MAX, gfp);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(idr_alloc);</span><br></pre></td></tr></table></figure>
<p>查找一个 <code>idr</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">idr_find</span><span class="params">(<span class="keyword">const</span> struct idr *idr, <span class="keyword">unsigned</span> <span class="keyword">long</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> radix_tree_lookup(&amp;idr-&gt;idr_rt, id - idr-&gt;idr_base);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(idr_find);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">radix_tree_lookup</span><span class="params">(<span class="keyword">const</span> struct radix_tree_root *root, <span class="keyword">unsigned</span> <span class="keyword">long</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __radix_tree_lookup(root, index, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_lookup);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__radix_tree_lookup(<span class="keyword">const</span> struct radix_tree_root *root,</span><br><span class="line">			  <span class="keyword">unsigned</span> <span class="keyword">long</span> index, struct radix_tree_node **nodep,</span><br><span class="line">			  <span class="keyword">void</span> __rcu ***slotp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *	@root:	基数树根</span></span><br><span class="line"><span class="comment">     *	@index:	索引键</span></span><br><span class="line"><span class="comment">     *	@nodep:	返回节点</span></span><br><span class="line"><span class="comment">     *	@slotp:	返回插槽</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">node</span>, *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> maxindex;</span><br><span class="line">	<span class="keyword">void</span> __rcu **slot;</span><br><span class="line"></span><br><span class="line"> restart:</span><br><span class="line">	parent = <span class="literal">NULL</span>;</span><br><span class="line">	slot = (<span class="keyword">void</span> __rcu **)&amp;root-&gt;xa_head;</span><br><span class="line">	radix_tree_load_root(root, &amp;node, &amp;maxindex);</span><br><span class="line">	<span class="keyword">if</span> (index &gt; maxindex)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (radix_tree_is_internal_node(node)) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> offset;</span><br><span class="line"></span><br><span class="line">		parent = entry_to_node(node);</span><br><span class="line">		offset = radix_tree_descend(parent, &amp;node, index);</span><br><span class="line">		slot = parent-&gt;slots + offset;</span><br><span class="line">		<span class="keyword">if</span> (node == RADIX_TREE_RETRY)</span><br><span class="line">			<span class="keyword">goto</span> restart;</span><br><span class="line">		<span class="keyword">if</span> (parent-&gt;shift == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodep)</span><br><span class="line">		*nodep = parent;</span><br><span class="line">	<span class="keyword">if</span> (slotp)</span><br><span class="line">		*slotp = slot;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果该函数调用成功，则返回 ID 关联的指针</li>
<li>如果报错，则返回 NULL</li>
</ul>
<p>删除一个 <code>idr</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">idr_remove</span><span class="params">(struct idr *idr, <span class="keyword">unsigned</span> <span class="keyword">long</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> radix_tree_delete_item(&amp;idr-&gt;idr_rt, id - idr-&gt;idr_base, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">radix_tree_delete_item</span><span class="params">(struct radix_tree_root *root,</span></span></span><br><span class="line"><span class="params"><span class="function">			     <span class="keyword">unsigned</span> <span class="keyword">long</span> index, <span class="keyword">void</span> *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">node</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> __rcu **slot = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> *entry;</span><br><span class="line"></span><br><span class="line">	entry = __radix_tree_lookup(root, index, &amp;node, &amp;slot);</span><br><span class="line">	<span class="keyword">if</span> (!slot)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (!entry &amp;&amp; (!is_idr(root) || node_tag_get(root, node, IDR_FREE,</span><br><span class="line">						get_slot_offset(node, slot))))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (item &amp;&amp; entry != item)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	__radix_tree_delete(root, node, slot);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(radix_tree_delete_item);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>idr_remove</code> 调用成功，则将 ID 关联的指针一起从映射中删除</li>
<li>返回被删除的条目，如果不存在则返回 NULL</li>
</ul>
<p>撤销一个 <code>idr</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idr_destroy</span><span class="params">(struct idr *idr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_node</span> *<span class="title">node</span> =</span> rcu_dereference_raw(idr-&gt;idr_rt.xa_head);</span><br><span class="line">	<span class="keyword">if</span> (radix_tree_is_internal_node(node))</span><br><span class="line">		radix_tree_free_nodes(node);</span><br><span class="line">	idr-&gt;idr_rt.xa_head = <span class="literal">NULL</span>;</span><br><span class="line">	root_tag_set(&amp;idr-&gt;idr_rt, IDR_FREE);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(idr_destroy);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>idr_destroy</code> 调用成功，则只释放 <code>idr</code> 中未使用的内存，并不会释放当前已经分配给 UID 使用的内存</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1432802">linux内核IDR机制详解</a> </p>
<p><strong>红黑树</strong></p>
<p>红黑树是对概念模型2-3-4树的一种实现，由于直接进行不同节点间的转化会造成较大的开销，所以选择以二叉树为基础，在二叉树的属性中加入一个 <strong>颜色属性</strong> 来表示2-3-4树中不同的节点</p>
<p>红黑规则：</p>
<ul>
<li>节点不是黑色，就是红色（非黑即红）</li>
<li>根节点为黑色，叶节点为黑色（叶节点是指末梢的空节点 <code>Nil</code>或<code>Null</code>）</li>
<li>一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）</li>
<li>每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）</li>
</ul>
<p>在插链的过程中，可能会破坏这些规则，这就需要一些机制来恢复平衡：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1655523602992-1666871176497.png" class width="1655523602992"> 
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>为了提高CPU和外围硬件（硬盘，键盘，鼠标等等）之间协同工作的性能，引入了中断的机制，中断是一种电信号，由硬件设备产生，并直接送入中断控制器的输入引脚中，中断机制是硬件在需要的时候向CPU发出信号，CPU暂时停止正在进行的工作来处理硬件请求</p>
<ul>
<li>异步中断（一般由硬件引起）：CPU 处理中断的时间过长，所以先将硬件复位，使硬件可以继续自己的工作，然后在适当时候处理中断请求中耗时的部分</li>
<li>同步中断：CPU 处理完中断请求的所有工作后才反馈硬件</li>
</ul>
<p><strong>硬中断</strong></p>
<p>由与系统相连的外设（比如网卡、硬盘）自动产生的，主要是用来通知操作系统系统外设状态的变化（比如当网卡收到数据包的时候，就会发出一个硬中断）</p>
<p>为了在中断执行时间尽可能短和中断处理需完成大量工作之间找到一个平衡点，Linux 将中断处理程序分解为两个半部：上半部（top half）和下半部（bottom half）：</p>
<ul>
<li>顶半部完成尽可能少的比较紧急的功能，它往往只是 <strong>简单地读取寄存器中的中断状态并清除中断标志后就进行“登记中断”的工作</strong><ul>
<li>“登记中断”：将底半部处理程序挂到该设备的执行队列中去</li>
</ul>
</li>
<li><strong>底半部负责执行中断处理程序</strong>，它来完成中断事件的绝大多数任务，而且可以被新的中断打断</li>
<li>顶半部往往被设计成不可中断，底半部则相对来说并不是非常紧急的，而且相对比较耗时，不在硬件中断服务程序中执行，所以可以打断</li>
</ul>
<p>简单来说就是：</p>
<ul>
<li>上半部：登记中断，把底半部处理程序挂到该设备的执行队列中，不可中断必须立刻完成</li>
<li>下半部：负责中断处理程序的具体实现，可中断（可以稍后完成）</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660878766425-1666871176497.png" class width="1660878766425"> 
<p>上半部由硬中断完成，实现下半部的方法很多，目前使用最多的是以下3中方法：</p>
<ul>
<li>softirq 软中断</li>
<li>tasklet 小片任务</li>
<li>工作队列</li>
</ul>
<p><strong>硬中断和软中断的区别</strong> </p>
<ul>
<li>软中断是执行中断指令产生的，而硬中断是由外设引发的</li>
<li>硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器</li>
<li>硬中断是可屏蔽的，软中断不可屏蔽</li>
<li>硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为 <strong>[上半部]</strong></li>
<li>软中断处理硬中断未完成的工作，是一种推后执行的机制，属于 <strong>[下半部]</strong></li>
</ul>
<p><strong>softirq 软中断</strong></p>
<p>软中断的流程如下： </p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660879056533-1666871176497.png" class width="1660879056533"> 
<p>软中断是在编译期间静态分配的，它不像 tasklet 那样能被动态地注册或注销，软中断由 <code>softirq_action</code> 结构体表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">void</span>	(*action)(struct softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个结构体的字段是个函数指针，字段名称是 action</li>
<li>函数指针的参数是 <code>struct softirq_action</code> 的地址，其实就是指向 <code>softirq_vec</code> 中的某一项：<ul>
<li>如果 <code>open_softirq</code> 是这样调用的：<code>open_softirq(NET_TX_SOFTIRQ, my_tx_action)</code></li>
<li>那么 <code>my_tx_action</code> 的参数就是：<code>softirq_vec[NET_TX_SOFTIRQ]</code> 的地址</li>
</ul>
</li>
</ul>
<p>注册软中断的函数 open_softirq：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_softirq</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> (*action)(struct softirq_action *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// nr: 软中断类型</span></span><br><span class="line">    <span class="comment">// (*action)(struct softirq_action *: 软中断处理程序的函数指针</span></span><br><span class="line">    softirq_vec[nr].action = action; <span class="comment">/* softirq_vec是个softirq_action类型的数组 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将软中断类型和软中断处理函数加入到软中断序列中</li>
</ul>
<p>触发软中断的函数 raise_softirq：（属于上半部）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span> <span class="comment">/* 被触发的中断类型 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags); <span class="comment">/* 保存寄存器 */</span></span><br><span class="line">    raise_softirq_irqoff(nr); <span class="comment">/* 触发软中断 */</span></span><br><span class="line">    local_irq_restore(flags); <span class="comment">/* 恢复寄存器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">raise_softirq_irqoff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__raise_softirq_irqoff(nr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!in_interrupt())</span><br><span class="line">		wakeup_softirqd(); <span class="comment">/* 唤醒ksoftirqd(内核线程),用于辅助处理软中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于 <code>ksoftirqd</code> 机制，后文会介绍</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> or_softirq_pending(x)  (S390_lowcore.softirq_pending |= (x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __raise_softirq_irqoff(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span><br><span class="line">&#123;</span><br><span class="line">	trace_softirq_raise(nr);</span><br><span class="line">	or_softirq_pending(<span class="number">1UL</span> &lt;&lt; nr); <span class="comment">/* 操作触发&#x27;软中断类型&#x27;的bit位为1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>raise_softirq</code> 通过把 [软中断类型位图] 的对应为置为“1”来传递 [被触发的中断类型]</li>
</ul>
<p>执行软中断的函数 do_softirq：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> <span class="title">do_softirq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_interrupt()) <span class="comment">/* 判断是否在中断处理中，如果正在中断处理，就直接返回 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags); <span class="comment">/* 保存当前寄存器的值 */</span></span><br><span class="line">    pending = local_softirq_pending(); <span class="comment">/* 取得获取软中断类型位图 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pending) <span class="comment">/* 循环处理所有已注册的软中断 */</span></span><br><span class="line">        __do_softirq();</span><br><span class="line"></span><br><span class="line">    local_irq_restore(flags); <span class="comment">/* 恢复寄存器的值到中断处理前 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只要软中断类型位图 softirq pending 有一位不为“0”，就证明至少有一种软中断需要被处理，然后就会调用 <code>__do_softirq</code></li>
</ul>
<p><strong>tasklet 小片任务</strong></p>
<p>tasklet 也是利用软中断来实现的</p>
<ul>
<li>tasklet 提供了比软中断更好用的接口（其实就是基于软中断又封装了一下）</li>
<li>tasklet 支持动态地注册或注销</li>
</ul>
<p>所以除了对性能要求特别高的情况，一般建议使用 tasklet 来实现自己的中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span> <span class="comment">/* 链表中的下一个tasklet */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state;         <span class="comment">/* tasklet状态 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;              <span class="comment">/* 引用计数器 */</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>); <span class="comment">/* tasklet处理函数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data;          <span class="comment">/* tasklet处理函数的参数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>已经注册了的 tasklet 由两个数据结构来组织：（两个都是 <code>tasklet_struct</code> 链表）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> **<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct tasklet_head, tasklet_vec)</span></span>; <span class="comment">/* 普通 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_PER_CPU</span><span class="params">(struct tasklet_head, tasklet_hi_vec)</span></span>; <span class="comment">/* 优先 */</span></span><br></pre></td></tr></table></figure>
<p>分别由 <code>tasklet_schedule</code> 和 <code>tasklet_hi_schedule</code> 函数进行调度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __tasklet_schedule(struct tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">	__tasklet_schedule_common(t, &amp;tasklet_vec,</span><br><span class="line">				  TASKLET_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__tasklet_schedule);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __tasklet_hi_schedule(struct tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">	__tasklet_schedule_common(t, &amp;tasklet_hi_vec,</span><br><span class="line">				  HI_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__tasklet_hi_schedule);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __tasklet_schedule_common(struct tasklet_struct *t,</span><br><span class="line">				      struct tasklet_head __percpu *headp,</span><br><span class="line">				      <span class="keyword">unsigned</span> <span class="keyword">int</span> softirq_nr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags); <span class="comment">/* 关闭本地cpu中断 */</span></span><br><span class="line">	head = this_cpu_ptr(headp); <span class="comment">/* 获取对应的tasklet_struct链表头 */</span></span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">	*head-&gt;tail = t; <span class="comment">/* 把新的tasklet_struct插入链表尾 */</span></span><br><span class="line">	head-&gt;tail = &amp;(t-&gt;next);</span><br><span class="line">	raise_softirq_irqoff(softirq_nr); <span class="comment">/* 调用对应的软中断 */</span></span><br><span class="line">	local_irq_restore(flags); <span class="comment">/* 恢复本地中断传递到给定的状态 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>所有的 tasklet 都通过重复调用 <code>TASKLET_SOFTIRQ</code> 和 <code>HI_SOFTIRQ</code> 两个软中断来实现</li>
<li>当一个 tasklet 被调度时，内核会唤起这两个软中断中的一个，然后执行特定的函数，执行所有已调度的 tasklet</li>
</ul>
<p>静态创建一个 tasklet（直接引用）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_TASKLET(name, func, data)                                      \</span></span><br><span class="line"><span class="meta">	struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(0), func, data &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_TASKLET_DISABLED(name, func, data)                             \</span></span><br><span class="line"><span class="meta">	struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(1), func, data &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这两个宏都能根据给定的名称静态地创建一个 <code>tasklet_struct</code> 结构</li>
<li>两个宏的区别在于：<ul>
<li>DECLARE_TASKLET 设置引用计数器为“0”，该 tasklet 处于激活状态</li>
<li>DECLARE_TASKLET_DISABLED 设置引用计数器为“1”，该 tasklet 处于禁止状态</li>
</ul>
</li>
</ul>
<p>动态创建一个 tasklet（间接引用）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_init</span><span class="params">(struct tasklet_struct *t,</span></span></span><br><span class="line"><span class="params"><span class="function">		  <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>), <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	t-&gt;state = <span class="number">0</span>;</span><br><span class="line">	atomic_set(&amp;t-&gt;count, <span class="number">0</span>); <span class="comment">/* 设置原子变量的值(引用计数器设置为&quot;0&quot;) */</span></span><br><span class="line">	t-&gt;func = func;</span><br><span class="line">	t-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tasklet_init);</span><br></pre></td></tr></table></figure>
<ul>
<li>其作用就是初始化一个 <code>tasklet_struct</code></li>
</ul>
<p>禁止一个 tasklet（暂缓）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_disable</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tasklet_disable_nosync(t);</span><br><span class="line">	tasklet_unlock_wait(t); <span class="comment">/* 等待正在执行的tasklet执行完成 */</span></span><br><span class="line">	smp_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果该 tasklet 正在执行，这个函数就会等到它执行完毕后再返回</li>
</ul>
<p>禁止一个 tasklet（立刻）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_disable_nosync</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	atomic_inc(&amp;t-&gt;count);</span><br><span class="line">	smp_mb__after_atomic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果该 tasklet 正在执行，这个函数也会立刻终止该 tasklet（这样做会丧失许多安全性）</li>
</ul>
<p>启用一个禁止的 tasklet：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_enable</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	smp_mb__before_atomic();</span><br><span class="line">	atomic_dec(&amp;t-&gt;count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除一个 tasklet：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_kill</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (in_interrupt())</span><br><span class="line">		pr_notice(<span class="string">&quot;Attempt to kill tasklet from interrupt\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			yield();</span><br><span class="line">		&#125; <span class="keyword">while</span> (test_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state));</span><br><span class="line">	&#125;</span><br><span class="line">	tasklet_unlock_wait(t); <span class="comment">/* 等待正在执行的tasklet执行完成 */</span></span><br><span class="line">	clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tasklet_kill);</span><br></pre></td></tr></table></figure>
<p><strong>ksoftirqd 对 softirq 和 tasklet 的优化</strong></p>
<p>当大量软中断出现时（tasklet 底层也是软中断），内核会唤醒一组内核线程来处理这些软中断，这些线程的名称都是 <code>ksoftirqd/n</code></p>
<p>一旦这些线程初始化，就会执行类似于以下代码的死循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!softirq_pending(cpu)) <span class="comment">/* 没有发现软中断,则重新调度 */</span></span><br><span class="line">        schedule();</span><br><span class="line">    </span><br><span class="line">    set_current_state(TASK_RUNNING);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(softirq_pending(cpu))&#123; <span class="comment">/* 发现软中断,则执行do_softirq处理软中断 */</span></span><br><span class="line">        do_softirq();</span><br><span class="line">        <span class="keyword">if</span>(need_resched())</span><br><span class="line">            schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>工作队列</strong></p>
<p>工作队列子系统是一个 <strong>用于创建内核线程的接口</strong>，通过它可以创建一个“工作者线程”来专门处理中断的下半部工作（这些工作者线程就叫做 <code>events/n</code>），它在进程的上下文中运行，可以重新调度和睡眠</p>
<ul>
<li>工作队列和 tasklet 不一样，不是基于软中断来实现的</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660882969270-1666871176497.png" class width="1660882969270"> 
<p>工作队列主要用到下面几个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在include/linux/workqueue.h文件中定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> data;             <span class="comment">/* 这个并不是处理函数的参数,而是表示此work是否pending等状态的flag */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span>         <span class="comment">/* 中断下半部处理函数的链表 */</span></span><br><span class="line">    <span class="keyword">work_func_t</span> func;               <span class="comment">/* 处理中断下半部工作的函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 也是在kernel/workqueue.c文件中定义的</span></span><br><span class="line"><span class="comment"> * 每个workqueue_struct表示一种工作者类型,系统默认的就是events工作者类型</span></span><br><span class="line"><span class="comment"> * 每个工作者类型一般对应n个工作者线程,n就是处理器的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs</span>;</span>		<span class="comment">/* WR: all pwqs of this wq */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span>		<span class="comment">/* PR: list of all workqueues */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">mutex</span>;</span>		<span class="comment">/* protects this wq */</span></span><br><span class="line">	<span class="keyword">int</span>			work_color;	<span class="comment">/* WQ: current work color */</span></span><br><span class="line">	<span class="keyword">int</span>			flush_color;	<span class="comment">/* WQ: current flush color */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		nr_pwqs_to_flush; <span class="comment">/* flush in progress */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span>	*<span class="title">first_flusher</span>;</span>	<span class="comment">/* WQ: first flusher */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_queue</span>;</span>	<span class="comment">/* WQ: flush waiters */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_overflow</span>;</span> <span class="comment">/* WQ: flush overflow list */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">maydays</span>;</span>	<span class="comment">/* MD: pwqs requesting rescue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span>		*<span class="title">rescuer</span>;</span>	<span class="comment">/* I: rescue worker */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			nr_drainers;	<span class="comment">/* WQ: drain in progress */</span></span><br><span class="line">	<span class="keyword">int</span>			saved_max_active; <span class="comment">/* WQ: saved pwq max_active */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span>	*<span class="title">unbound_attrs</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span>	*<span class="title">dfl_pwq</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_device</span>	*<span class="title">wq_dev</span>;</span>	<span class="comment">/* I: for sysfs interface */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">char</span>			name[WQ_NAME_LEN]; <span class="comment">/* I: workqueue name */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* hot fields used during command issue, aligned to cacheline */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags ____cacheline_aligned; <span class="comment">/* WQ: WQ_* flags */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">percpu</span> *<span class="title">cpu_pwqs</span>;</span> <span class="comment">/* I: per-cpu pwqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">rcu</span> *<span class="title">numa_pwq_tbl</span>[];</span> <span class="comment">/* PWR: unbound pwqs indexed by node */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>worker_thread</code> - 工作线程的处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 工作线程函数,所有工人都属于一个工人池,要么是每cpu的,要么是动态的未绑定的</span></span><br><span class="line"><span class="comment">   这些工作人员处理所有工作项,而不考虑其特定的目标工作队列</span></span><br><span class="line"><span class="comment">   唯一的例外是属于&quot;救援人员&quot;的工作队列的工作项,定义在rescuer_thread()中 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span> *__worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> __worker;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tell the scheduler that this is a workqueue worker */</span></span><br><span class="line">	set_pf_worker(<span class="literal">true</span>);</span><br><span class="line">woke_up:</span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* am I supposed to die? */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">		spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">		set_pf_worker(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		set_task_comm(worker-&gt;task, <span class="string">&quot;kworker/dying&quot;</span>); <span class="comment">/* 设置worker-&gt;task的值 */</span></span><br><span class="line">		ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">		worker_detach_from_pool(worker);</span><br><span class="line">		kfree(worker);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	worker_leave_idle(worker); <span class="comment">/* 清除WORKER_IDLE标志位,并退出idle状态链表 */</span></span><br><span class="line">recheck:</span><br><span class="line">	<span class="comment">/* no more worker necessary? */</span></span><br><span class="line">	<span class="keyword">if</span> (!need_more_worker(pool)) <span class="comment">/* 如果当前worker_pool-&gt;worklist中有pending任务,但是当前pool中没有正在运行的线程,need_more_worker()返回true */</span></span><br><span class="line">		<span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do we need to manage? */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker)) <span class="comment">/* manage_worker()创建新工作线程之后,还需要跳转到recheck标签处再检查一遍,有可能在创建工作线程过程中整个线程池发生了变化 */</span></span><br><span class="line">		<span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;scheduled list can only be filled while a worker is</span></span><br><span class="line"><span class="comment">	 * preparing to process a work or actually processing it.</span></span><br><span class="line"><span class="comment">	 * Make sure nobody diddled with it while I was sleeping.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled)); <span class="comment">/* scheduled链表表示:工作线程准备处理一个work或者正在执行一个work时,才会有work添加到该链表中 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Finish PREP stage.  We&#x27;re guaranteed to have at least one idle</span></span><br><span class="line"><span class="comment">	 * worker or that someone else has already assumed the manager</span></span><br><span class="line"><span class="comment">	 * role.  This is where @worker starts participating in concurrency</span></span><br><span class="line"><span class="comment">	 * management if applicable and concurrency management is restored</span></span><br><span class="line"><span class="comment">	 * after being rebound.  See rebind_workers() for details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123; <span class="comment">/* 遍历当前worker_pool-&gt;worklist中的工作,调用process_one_work()进行处理 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line">			list_first_entry(&amp;pool-&gt;worklist,</span><br><span class="line">					 struct work_struct, entry);</span><br><span class="line"></span><br><span class="line">		pool-&gt;watchdog_ts = jiffies;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) &#123;</span><br><span class="line">			<span class="comment">/* optimization path, not strictly necessary */</span></span><br><span class="line">			process_one_work(worker, work); <span class="comment">/* 处理一个工作 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">				process_scheduled_works(worker); <span class="comment">/* 就是循环对worker中scheduled链表中的work执行处理,具体处理方式就是调用process_one_work() */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">			process_scheduled_works(worker);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">	worker_set_flags(worker, WORKER_PREP); </span><br><span class="line">sleep:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock is held and there&#x27;s no work to process and no need to</span></span><br><span class="line"><span class="comment">	 * manage, sleep.  Workers are woken up only while holding</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock or from local cpu, so setting the current state</span></span><br><span class="line"><span class="comment">	 * before releasing pool-&gt;lock is enough to prevent losing any</span></span><br><span class="line"><span class="comment">	 * event.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_enter_idle(worker);</span><br><span class="line">	__set_current_state(TASK_IDLE);</span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>工作队列的实现比较复杂，我这里还没有完全看明白，以后有需要在专门学习一下</li>
</ul>
<p>其实工作队列的核心思想就是：内核启动时创建并维护一个工作队列，该队列由内核线程实现，没有任务执行时就陷入睡眠，在用户调用 schedule_work 时，将 work 挂到该工作队列的链表或者队列中，唤醒该内核线程并执行该 work（用户也可以自己创建一个 workqueue 来使用）</p>
<h2 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h2><p>存在共享资源（共享一个文件，一块内存等等）的时候，为了防止并发访问时共享资源的数据不一致，引入了同步机制</p>
<p>所谓同步，其实防止在临界区中形成竞争条件：</p>
<ul>
<li>临界区 - 也称为临界段，就是访问和操作共享数据的代码段</li>
<li>竞争条件 - 2个或2个以上线程在临界区里同时执行的时候，就构成了竞争条件</li>
</ul>
<p>内核同步常见方法如下：</p>
<p><strong>原子操作</strong></p>
<p>原子操作是由编译器来保证的，保证一个线程对数据的操作不会被其他线程打断</p>
<ul>
<li>所谓原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch</li>
<li>原子操作只能针对 <code>atomic_t</code> 类型的数据进行处理：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic64_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>相关的原子操作如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_read(v)	READ_ONCE((v)-&gt;counter) <span class="comment">/* 原子读 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic64_read(v)	READ_ONCE((v)-&gt;counter)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_set(v,i)	WRITE_ONCE(((v)-&gt;counter), (i)) <span class="comment">/* 原子写 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic64_set(v,i)	WRITE_ONCE((v)-&gt;counter, (i))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_bit(nr,p)		ATOMIC_BITOP(set_bit,nr,p) <span class="comment">/* 设置第nr位(置&quot;1&quot;) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_bit(nr,p)		ATOMIC_BITOP(clear_bit,nr,p) <span class="comment">/* 清空第nr位(置&quot;0&quot;) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> change_bit(nr,p)	ATOMIC_BITOP(change_bit,nr,p) <span class="comment">/* 改变第nr位(异或) */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>锁</strong></p>
<p>为了给临界区加锁，保证临界区数据的同步，首先了解一下内核中哪些情况下会产生并发</p>
<p>内核中造成竞争条件的原因：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>竞争原因</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>中断随时会发生，也就会随时打断当前执行的代码，如果中断和被打断的代码在相同的临界区，就产生了竞争条件</td>
</tr>
<tr>
<td>软中断和tasklet</td>
<td>软中断和 tasklet 也会随时被内核唤醒执行，也会像中断一样打断正在执行的代码</td>
</tr>
<tr>
<td>内核抢占</td>
<td>内核具有抢占性，发生抢占时，如果抢占的线程和被抢占的线程在相同的临界区，就产生了竞争条件</td>
</tr>
<tr>
<td>睡眠及用户空间的同步</td>
<td>用户进程睡眠后，调度程序会唤醒一个新的用户进程，新的用户进程和睡眠的进程可能在同一个临界区中</td>
</tr>
<tr>
<td>对称多处理</td>
<td>2个或多个处理器可以同时执行相同的代码</td>
</tr>
</tbody>
</table>
</div>
<p>加锁后多线程的执行流程：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1663685252415-1666871176498.png" class width="1663685252415"> 
<p>常见的锁有以下几类：</p>
<p>自旋锁：当一个线程获取了锁之后，其他试图获取这个锁的线程一直在循环等待获取这个锁，直至锁重新可用</p>
<ul>
<li>由于线程实在一直循环的获取这个锁，所以会造成CPU处理时间的浪费，因此最好将自旋锁用于能很快处理完的临界区</li>
<li>自旋锁常用于中断处理程序中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(lock); <span class="comment">/* 初始化自旋锁lock */</span></span><br><span class="line">spin_trylock(lock); <span class="comment">/* 尝试获取指定的锁(如果获取,则返回&quot;0&quot;,否则返回非&quot;0&quot;) */</span></span><br><span class="line">spin_is_locked(lock); <span class="comment">/* 如果指定的锁当前正在被获取,则返回非&quot;0&quot;,否则返回&quot;0&quot; */</span></span><br><span class="line"></span><br><span class="line">spin_lock(&amp;lock); <span class="comment">/* 获取指定的锁 */</span></span><br><span class="line">spin_lock_irq(&amp;lock); <span class="comment">/* 禁止本地中断,获取指定的锁 */</span></span><br><span class="line">spin_lock_irqsave(&amp;lock, flags); <span class="comment">/* 保存中断的当前状态,禁止本地中断,获取指定的锁 */</span></span><br><span class="line"></span><br><span class="line">spin_unlock(&amp;lock); <span class="comment">/* 对指定的锁进行解锁 */</span></span><br><span class="line">spin_unlock_irq(&amp;lock); <span class="comment">/* 对指定的锁进行解锁,恢复本地中断 */</span></span><br><span class="line">spin_unlock_irqrestore(&amp;lock, flags); <span class="comment">/* 对指定的锁进行解锁,并恢复到加锁之前的状态 */</span></span><br></pre></td></tr></table></figure>
<p>读写锁：读写锁实际是一种特殊的自旋锁</p>
<ul>
<li>它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作 </li>
<li>其实还是一种锁，是给一段临界区代码加锁，读写之间是互斥的：读的时候写阻塞，写的时候读阻塞，而且读和写在竞争锁的时候，写会优先得到锁</li>
<li>一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_RWLOCK(lock); <span class="comment">/* 初始化读写锁 */</span></span><br><span class="line"></span><br><span class="line">read_lock(&amp;lock); <span class="comment">/* 获取读锁 */</span></span><br><span class="line">read_lock_irq(&amp;lock); <span class="comment">/* 禁止本地中断,获取读锁 */</span></span><br><span class="line">read_lock_irqsave(&amp;lock); <span class="comment">/* 保存中断的当前状态,禁止本地中断,获取读锁 */</span></span><br><span class="line">read_unlock(&amp;lock); <span class="comment">/* 释放读锁 */</span></span><br><span class="line">read_unlock_irq(&amp;lock); <span class="comment">/* 释放读锁,恢复本地中断 */</span></span><br><span class="line">read_unlock_irqrestore(&amp;lock); <span class="comment">/* 释放读锁,并恢复到加锁之前的状态 */</span></span><br><span class="line"></span><br><span class="line">write_lock(&amp;lock); <span class="comment">/* 获取写锁 */</span></span><br><span class="line">write_lock_irq(&amp;lock); <span class="comment">/* 禁止本地中断,获取写锁 */</span></span><br><span class="line">write_lock_irqsave(&amp;lock); <span class="comment">/* 保存中断的当前状态,禁止本地中断,获取写锁 */</span></span><br><span class="line">write_unlock(&amp;lock); <span class="comment">/* 释放写锁 */</span></span><br><span class="line">write_unlock_irq(&amp;lock); <span class="comment">/* 释放写锁,恢复本地中断 */</span></span><br><span class="line">write_unlock_irqrestore(&amp;lock); <span class="comment">/* 释放写锁,并恢复到加锁之前的状态 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>PS：这里的[读锁]和[写锁]指的都是 <code>lock</code>，它们是同一个锁，只是为了区分[读者]和[写者]和分开命名</li>
</ul>
<p>顺序锁：顺序锁其实就对读写锁的一种优化</p>
<ul>
<li>对某一个共享数据读取的时候不加锁，写的时候加锁</li>
<li>在读写锁的基础上，读锁被获取的情况下，写锁仍然可以被获取（顺序锁为写者赋予了较高的优先级，即使在读者正在读的时候，也允许写着继续运行）</li>
<li>可以实现同时读写，但是同时写不被允许</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SEQLOCK(x) <span class="comment">/* 初始化seq锁(顺序锁) */</span></span></span><br><span class="line"></span><br><span class="line">read_seqlock_excl(&amp;lock); <span class="comment">/* 获取读锁 */</span></span><br><span class="line">read_seqlock_excl_bh(&amp;lock); <span class="comment">/* 获取读锁,禁止当前处理器的软中断 */</span></span><br><span class="line">read_seqlock_excl_irq(&amp;lock); <span class="comment">/* 获取读锁,禁止当前处理器的硬中断 */</span></span><br><span class="line">read_seqlock_excl_irqsave(&amp;lock); <span class="comment">/* 获取读锁,保存中断的当前状态,禁止当前处理器的硬中断 */</span></span><br><span class="line"></span><br><span class="line">read_sequnlock_excl(&amp;lock); <span class="comment">/* 释放读锁 */</span></span><br><span class="line">read_sequnlock_excl_irq(&amp;lock); <span class="comment">/* 内核中只有定义,不使用 */</span></span><br><span class="line"></span><br><span class="line">write_seqlock(&amp;lock); <span class="comment">/* 获取写锁 */</span></span><br><span class="line">write_seqlock_bh(&amp;lock); <span class="comment">/* 获取写锁,禁止当前处理器的软中断 */</span></span><br><span class="line">write_seqlock_irq(&amp;lock); <span class="comment">/* 获取写锁,禁止当前处理器的硬中断 */</span></span><br><span class="line">write_seqlock_irqsave(&amp;lock); <span class="comment">/* 获取写锁,禁止当前处理器的硬中断,保存中断的当前状态 */</span></span><br><span class="line"></span><br><span class="line">write_unseqlock(&amp;lock); <span class="comment">/* 释放写锁 */</span></span><br><span class="line">write_sequnlock_irq(&amp;lock); <span class="comment">/* 释放写锁,恢复被禁止的硬中断 */</span></span><br><span class="line">write_sequnlock_irqrestore(&amp;lock); <span class="comment">/* 释放写锁,恢复被禁止的硬中断,恢复中断的状态 */</span></span><br></pre></td></tr></table></figure>
<p>互斥锁：互斥锁也是一种可以睡眠的锁（互斥锁不属于自旋锁，而是属于信号量）</p>
<ul>
<li>其实相当于二值信号量，只是内核提供了单独的API，使用的场景也更严格一些</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;mutex); <span class="comment">/* 动态初始化该互斥锁 */</span></span><br><span class="line">mutex_lock(&amp;mutex); <span class="comment">/* 互斥锁加锁 */</span></span><br><span class="line">mutex_unlock(&amp;mutex); <span class="comment">/* 互斥锁解锁 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>必须在同一个上下文中加锁或解锁</li>
<li>不能在中断中使用</li>
</ul>
<p><strong>信号量</strong></p>
<p>信号量也是一种锁，和自旋锁不同的是，进程获取不到信号量的时候，不会像自旋锁一样循环的去试图获取锁，而是进入睡眠（进入等待队列），直至有信号量释放出来时，才会唤醒睡眠的进程，进入临界区执行</p>
<p>信号量结构体具体如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        count; <span class="comment">/* 信号量计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span> <span class="comment">/* 等待队列 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实信号量就相当于一个 [常数] 加上一个 [等待队列]：</p>
<ul>
<li>[常数] &gt; 0：代表了当前临界区可以容纳的进程个数</li>
<li>[常数] = 0：争用信号量的进程会进入睡眠（进入等待队列）</li>
<li>[常数] &lt; 0：在等待队列中的进程数目</li>
</ul>
<p>当一个进程进入临界区时，会先检查该临界区的 <code>semaphore-&gt;count</code>：</p>
<ul>
<li>如果大于“0”就进入该临界区，同时 <code>semaphore-&gt;count--</code></li>
<li>如果小于等于“0”就进入 <code>semaphore-&gt;wait_list</code>，同时 <code>semaphore-&gt;count--</code></li>
</ul>
<p>当一个进程离开临界区时，也会检查该临界区的 <code>semaphore-&gt;count</code>：</p>
<ul>
<li>如果小于“0”就把 <code>semaphore-&gt;wait_list</code> 中的一个进程放入临界区，同时 <code>semaphore-&gt;count++</code></li>
<li>如果大于等于“0”，只执行 <code>semaphore-&gt;count++</code> 就可以了</li>
</ul>
<p>常规信号量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_init</span><span class="params">(struct semaphore *sem, <span class="keyword">int</span> val)</span></span>; <span class="comment">/* 初始化信号量,将信号量的计数器值设置为&#x27;val&#x27; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore *sem)</span></span>; <span class="comment">/* 获取信号量,成功后信号量计数器将减&#x27;1&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_interruptible</span><span class="params">(struct semaphore *sem)</span></span>; <span class="comment">/* 用来获取信号量,将信号量sem的计数器值减&#x27;1&#x27;,但它是可被信号中断的 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_trylock</span><span class="params">(struct semaphore *sem)</span></span>; <span class="comment">/* 尝试获取信号量sem(若该sem已经被占用,则返回非&#x27;0&#x27;,否则返回&#x27;0&#x27;,并且获取该sem) */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore *sem)</span></span>; <span class="comment">/* 释放信号量,成功后信号量计数器将减&#x27;1&#x27; */</span></span><br></pre></td></tr></table></figure>
<p>读写信号量：和读写锁一样，只是底层用的是信号量而已</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_rwsem(sem) <span class="comment">/* 初始化读写信号量,将信号量的count字段设置为&#x27;0&#x27;, wait_lock自旋锁设置为未锁,将等待进程的链表wait_list置为空链表 */</span>	</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">down_read</span><span class="params">(struct rw_semaphore *sem)</span></span>; <span class="comment">/* 读者获取信号量sem,如果该信号量在被写者所持有,则对该函数的调用会导致调用者的睡眠 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __sched <span class="title">down_write</span><span class="params">(struct rw_semaphore *sem)</span></span>; <span class="comment">/* 写者获取信号量sem,如果该信号量被读者或写者所持有,则对该函数的调用会导致调用者的睡眠 */</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_read</span><span class="params">(struct rw_semaphore *sem)</span></span>; <span class="comment">/* 读者释放读写信号量 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_write</span><span class="params">(struct rw_semaphore *sem)</span></span>; <span class="comment">/* 写者释放读写信号量 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>[读者]拿到[读锁]时，其他的[读者]想要拿锁是不会阻塞的，而[写者]则会阻塞</li>
<li>[写者]拿到[写锁]时，不管是[读者]还是[写者]都会阻塞（比读写锁更严格）</li>
</ul>
<p><strong>完成变量</strong></p>
<p>完成变量的机制类似于信号量，比如一个线程A进入临界区之后，另一个线程B会在完成变量上等待，线程A完成了任务出了临界区之后，使用完成变量来唤醒线程B</p>
<ul>
<li>如果在内核中一个任务需要发出信号通知另一任务发生了某个特定事件，利用完成变量（completion variable）是使两个任务得以同步的简单方法</li>
<li>如果一个任务要执行一些工作时，另一个任务就会在完成变量上等待</li>
</ul>
<p>案例：<code>vfork</code> 函数会使用完成变量去唤醒父进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_completion</span><span class="params">(struct completion *c)</span></span>; <span class="comment">/* 创建并初始化完成变量 */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_completion</span><span class="params">(struct completion *c)</span></span>; <span class="comment">/* 命令当前任务等待特定的事件 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(struct completion *c)</span></span>; <span class="comment">/* 唤醒等待的内核任务 */</span></span><br></pre></td></tr></table></figure>
<p><strong>禁止抢占</strong></p>
<p>内核是抢占性的，内核中的进程在任何时候都可以停止，使另一个优先度更高的进程运行，如果一个进程和被它抢占的进程在同一个临界区运行，那么就可能会出现安全问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进程A对未添加保护的变量buf进行访问</span><br><span class="line">进程A被进程B抢占</span><br><span class="line">进程B也操作变量buf</span><br><span class="line">进程B结束</span><br><span class="line">进程A重新调度</span><br><span class="line">进程A出现安全问题</span><br></pre></td></tr></table></figure>
<p>内核抢占代码使用自旋锁作为非抢占区域的标记（如果一个自旋锁被持有，内核便不能进行抢占），对于独立变量而言，没有必要设置自旋锁（会浪费系统资源），因此需要使用 <code>preempt_disable</code> 来禁止内核抢占</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preempt_enable() <span class="comment">/* 允许内核抢占,并使preempt_count减&#x27;1&#x27;  */</span></span><br><span class="line">preempt_disable() <span class="comment">/* 禁止内核抢占,并使preempt_count加&#x27;1&#x27; */</span></span><br></pre></td></tr></table></figure>
<p><strong>顺序与屏障</strong></p>
<p>CPU 可能需要按照写数据的顺序来读数据（类似于 FIFO），但编译器和处理器为了提高效率，常常会对读写的顺序进行“重新排布”</p>
<p>有一些机械指令可以示意 CPU 不要对周围的数据进行重新排序，这些指令就叫做“屏障”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rmb() <span class="comment">/* 读屏障:阻止屏障两边的&quot;载入指令&quot;发生重排序 */</span></span><br><span class="line">wmb() <span class="comment">/* 写屏障:阻止屏障两边的&quot;存储指令&quot;发生重排序 */</span></span><br><span class="line">mb() <span class="comment">/* 阻止屏障两边的&quot;载入指令/存储指令&quot;发生重排序 */</span></span><br><span class="line">smp_rmb() <span class="comment">/* 在SMP(多核处理器)上提供rmb功能,在UP(单核处理器)提供barrier功能 */</span></span><br><span class="line">smp_wmb() <span class="comment">/* 在SMP(多核处理器)上提供wmb功能,在UP(单核处理器)提供barrier功能 */</span></span><br><span class="line">smp_mb() <span class="comment">/* 在SMP(多核处理器)上提供mb功能,在UP(单核处理器)提供barrier功能 */</span></span><br><span class="line">barrier() <span class="comment">/* 阻止编译器跨屏障对&quot;载入指令/存储指令&quot;进行优化 */</span></span><br></pre></td></tr></table></figure>
<p><strong>同步方法选择</strong></p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660900515527-1666871176498.png" class width="1660900515527"> 
<h2 id="系统时间"><a href="#系统时间" class="headerlink" title="系统时间"></a>系统时间</h2><p>系统时间管理在内核中有相当重要的地位，内核中有大量函数都是基于时间驱动的</p>
<p>系统中管理的时间有2种：实际时间和定时器</p>
<ul>
<li>实际时间：现实中钟表上显示的时间，其实内核中并不常用这个时间，主要是用户空间的程序有时需要获取当前时间，所以内核中也管理着这个时间</li>
<li>定时器：内核中主要使用的时间管理方法，通过定时器，可以有效的调度程序的执行 </li>
</ul>
<p><strong>定时器</strong></p>
<p>定时器在内核中用一个链表来保存的，链表的每个节点都是一个定时器 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">entry</span>;</span> <span class="comment">/* 定时器链表的入口 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		expires; <span class="comment">/* 以jiffies为单位的&quot;超时时间&quot; */</span></span><br><span class="line">	<span class="keyword">void</span>			(*function)(struct timer_list *); <span class="comment">/* 定时器处理函数 */</span></span><br><span class="line">	u32			flags; <span class="comment">/* 传给处理函数的长整形参数 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定时器的使用中，下面2个概念非常重要：</p>
<ul>
<li>HZ：节拍率(HZ)是时钟中断的频率，表示的一秒内时钟中断的次数 </li>
<li>jiffies：jiffies 用来记录自系统启动以来产生的总节拍数，比如系统启动了 N 秒，那么 jiffies 就为 N×HZ </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> jiffies	raid6_jiffies()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">raid6_jiffies</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">	gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> tv.tv_sec*<span class="number">1000</span> + tv.tv_usec/<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个动态定时器的生命周期中，一般会经过下面的几个步骤： </p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661421650964-1666871176498.png" class width="1661421650964"> 
<p>相关的 API 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> timer_setup(timer, callback, flags)			\</span></span><br><span class="line"><span class="meta">	__init_timer((timer), (callback), (flags)) <span class="comment">/* 初始化定时器结构的内部值 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(struct timer_list *timer)</span></span>; <span class="comment">/* 激活目标定时器 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_timer</span><span class="params">(struct timer_list *timer, <span class="keyword">unsigned</span> <span class="keyword">long</span> expires)</span></span>; <span class="comment">/* 更改超时时间 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_timer</span><span class="params">(struct timer_list * timer)</span></span>; <span class="comment">/* 停止目标定时器 */</span></span><br></pre></td></tr></table></figure>
<p><strong>时间中断</strong></p>
<p>时钟中断处理程序作为系统定时器而注册到内核中，体系结构的不同，可能时钟中断处理程序中处理的内容不同，介绍如下：</p>
<ul>
<li>时钟中断是一种硬中断，由时间硬件（系统定时器，一种可编程硬件）产生，CPU处理后交由时间中断处理程序来完成更新系统时间、执行周期性任务等</li>
<li>系结构相关部分被注册到内核中，确保中断产生时能执行，这部分不能有耗时操作，主要是更新时间与调用结构无关部分列程（异步）</li>
<li>已到期的定时器由体系结构无关部分来处理，其它的一些耗时操作，如显示时间的更新也在这一部分</li>
</ul>
<p>但是以下这些基本的工作都会执行：</p>
<ul>
<li>获得 xtime_lock 锁（一种顺序锁），以便对访问 jiffies_64 和墙上时间 xtime 进行保护</li>
<li>需要时应答或重新设置系统时钟</li>
<li>周期性的使用墙上时间更新实时时钟</li>
<li>调用 <code>tick_periodic()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tick_periodic</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tick_do_timer_cpu == cpu) &#123;</span><br><span class="line">		write_seqlock(&amp;jiffies_lock);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 记录下一个节拍事件 */</span></span><br><span class="line">		tick_next_period = ktime_add(tick_next_period, tick_period);</span><br><span class="line"></span><br><span class="line">		do_timer(<span class="number">1</span>);</span><br><span class="line">		write_sequnlock(&amp;jiffies_lock);</span><br><span class="line">		update_wall_time();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	update_process_times(user_mode(get_irq_regs())); <span class="comment">/* 更新所耗费的各种节拍数 */</span></span><br><span class="line">	profile_tick(CPU_PROFILING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ticks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	jiffies_64 += ticks;</span><br><span class="line">	calc_global_load(ticks); <span class="comment">/* 更新时钟 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_process_times</span><span class="params">(<span class="keyword">int</span> user_tick)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> current;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注意:这个定时器中断上下文也必须考虑在内 */</span></span><br><span class="line">	account_process_tick(p, user_tick);</span><br><span class="line">	run_local_timers(); <span class="comment">/* 标记了一个软中段,去处理所有到期的定时器 */</span></span><br><span class="line">	rcu_check_callbacks(user_tick);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IRQ_WORK</span></span><br><span class="line">	<span class="keyword">if</span> (in_irq())</span><br><span class="line">		irq_work_tick();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	scheduler_tick(); <span class="comment">/* 负责减少当前运行进程的时间片计数值,必要时设置need_resched */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_POSIX_TIMERS))</span><br><span class="line">		run_posix_cpu_timers(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述场景中，写锁必须要优先于读锁（因为 <strong>xtime</strong> 必须及时更新），而且写锁的使用者很少（一般只有系统定期更新 <strong>xtime</strong> 的线程需要持有这个锁）</li>
<li>这正是 [顺序锁] 的应用场景</li>
</ul>
<p><strong>延迟运行</strong></p>
<p>除了使用定时器和下半部机制以外，还需要其他方法来推迟执行任务：</p>
<ul>
<li>忙等待：最简单的延迟方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 延迟100个jiffies */</span> </span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> delay = jiffies + <span class="number">100</span>; </span><br><span class="line"> <span class="keyword">while</span> (time_before(jiffies, delay))</span><br><span class="line">     cond_resched(); <span class="comment">/* 运行内核重新调度执行其他任务(只有在设置need_resched标准后才会生效) */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 延迟2s */</span> </span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> delay = jiffies + <span class="number">2</span>*HZ; </span><br><span class="line"> <span class="keyword">while</span> (time_before(jiffies, delay))</span><br><span class="line">     cond_resched();</span><br></pre></td></tr></table></figure>
<ul>
<li>短延迟：短暂的延迟，而且还要求延迟的时间很精确</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udelay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> usecs)</span></span>; <span class="comment">/* 单位-us */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ndelay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> nsecs)</span></span>; <span class="comment">/* 单位-ns */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mdelay(n)	udelay((n) * 1000) <span class="comment">/* 单位-ms */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>schedule_timeout()：让需要延迟运行的任务睡眠到指定时间后，再运行（底层还是定时器）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">long</span> __sched <span class="title">schedule_timeout</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">long</span> timeout)</span></span>; <span class="comment">/* 单位-jiffies */</span></span><br></pre></td></tr></table></figure>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>页</strong></p>
<p>内存最基本的管理单元是页，同时按照内存地址的大小，大致分为3个区，页的大小与体系结构有关，在 x86 结构中一般是 4KB 或者 8KB</p>
<p>可以通过 <code>getconf</code> 命令来查看系统的 page 的大小： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 getconf -a | grep -i <span class="string">&#x27;page&#x27;</span></span><br><span class="line">PAGESIZE                           <span class="number">4096</span></span><br><span class="line">PAGE_SIZE                          <span class="number">4096</span></span><br><span class="line">_AVPHYS_PAGES                      <span class="number">514073</span></span><br><span class="line">_PHYS_PAGES                        <span class="number">995803</span></span><br></pre></td></tr></table></figure>
<p>用于描述页的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;    <span class="comment">/* 存放页的状态 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> _count;        <span class="comment">/* 页的引用计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">atomic_t</span> _mapcount;    <span class="comment">/* 已经映射到mms的pte的个数 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* 用于slab层 */</span></span><br><span class="line">            u16 inuse;</span><br><span class="line">            u16 objects;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;        <span class="comment">/* 此page作为私有数据时,指向私有数据 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>    <span class="comment">/* 此page作为页缓存时,指向关联的address_space */</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span>    <span class="comment">/* 指向slab层 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">first_page</span>;</span>    <span class="comment">/* 尾部复合页中的第一个页 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">pgoff_t</span> index;        <span class="comment">/* Our offset within mapping */</span></span><br><span class="line">        <span class="keyword">void</span> *freelist;        <span class="comment">/* SLUB: freelist req slab lock */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>    <span class="comment">/* 将页关联起来的链表项 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">virtual</span>;            <span class="comment">/* 页的虚拟地址 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WANT_PAGE_DEBUG_FLAGS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> debug_flags;    <span class="comment">/* Use atomic bitops on this */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kmemcheck wants to track the status of each byte in a page; this</span></span><br><span class="line"><span class="comment">     * is a pointer to such a status block. NULL if not tracked</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* 存放页的状态 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 页面缓存和匿名页面 */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">			<span class="keyword">pgoff_t</span> index;	</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* slab, slob and slub */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 私有pages */</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">					<span class="keyword">int</span> pages;	<span class="comment">/* Nr of pages left */</span></span><br><span class="line">					<span class="keyword">int</span> pobjects;	<span class="comment">/* Approximate count */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line">			<span class="comment">/* Double-word boundary */</span></span><br><span class="line">			<span class="keyword">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="keyword">void</span> *s_mem;	<span class="comment">/* slab: first object */</span></span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;		<span class="comment">/* SLUB */</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">/* SLUB */</span></span><br><span class="line">					<span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 复合页尾页 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head;	<span class="comment">/* Bit zero is set */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* First tail page only */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">char</span> compound_dtor;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">char</span> compound_order;</span><br><span class="line">			<span class="keyword">atomic_t</span> compound_mapcount;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 复合页第二尾页 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _compound_pad_1;	<span class="comment">/* compound_head */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _compound_pad_2;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 页面表页面 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_1;	<span class="comment">/* compound_head */</span></span><br><span class="line">			<span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_2;	<span class="comment">/* mapping */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> <span class="comment">/* x86 pgds only */</span></span><br><span class="line">				<span class="keyword">atomic_t</span> pt_frag_refcount; <span class="comment">/* powerpc */</span></span><br><span class="line">			&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">			<span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span> <span class="comment">/* 指向主机设备页面映射 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> hmm_data;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _zd_pad_1;	<span class="comment">/* uses mapping */</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span> <span class="comment">/* 使用它通过RCU释放页面 */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span>		<span class="comment">/* This union is 4 bytes in size. */</span></span><br><span class="line">		<span class="keyword">atomic_t</span> _mapcount; <span class="comment">/* 如果页面可以映射到用户空间,则编码页面表引用此页面的次数 */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> page_type; <span class="comment">/* 如果页面既不是PageSlab,也不可映射到用户空间,则此处存储的值可能有助于确定此页面的用途 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> active;		<span class="comment">/* SLAB */</span></span><br><span class="line">		<span class="keyword">int</span> units;			<span class="comment">/* SLOB */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> _refcount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">	 * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">	 * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">	 * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">	 * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">	 * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">virtual</span>;			<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">					   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">	<span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; _struct_page_alignment;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>为每个物理页都要分配一个这样的结构</li>
</ul>
<p><strong>区</strong></p>
<p>页是内存管理的最小单元，内核将内存按地址的顺序分成了不同的区</p>
<ul>
<li>有的硬件只能访问有专门的区，其实一般主要关注的区只有3个：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>区</strong></th>
<th><strong>描述</strong></th>
<th><strong>物理内存</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ZONE_DMA</td>
<td>DMA使用的页</td>
<td>&lt; 16MB</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>正常可寻址的页</td>
<td>16MB～896MB</td>
</tr>
<tr>
<td>ZONE_HIGHMEM</td>
<td>动态映射的页</td>
<td>&gt; 896MB 某些硬件只能直接访问内存地址，不支持内存映射，对于这些硬件内核会分配 ZONE_DMA 区的内存。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>某些硬件的内存寻址范围很广，比虚拟寻址范围还要大的多，那么就会用到 ZONE_HIGHMEM 区的内存</li>
<li>而 ZONE_DMA 用于I/O设备直接存储器访问（网卡就会使用 DMA 技术）</li>
<li>对于大部分的内存申请，只要用 ZONE_NORMAL 区的内存即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	我们不知道我们要分配的内存是否将是freeable的或者它最终将被释放</span></span><br><span class="line"><span class="comment">	因此为了避免完全浪费几GB的RAM,我们必须保留一些较低区域的内存(否则我们冒着在较低区域上运行OOM的风险,尽管在较高区域上有大量的可用RAM)</span></span><br><span class="line"><span class="comment">	如果sysctl_lowmem_reserve_ratio sysctl发生更改,则会在运行时重新计算此数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*pageblock_flags; <span class="comment">/* pageblock_nr_pages块的标志 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">	 * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">	 * is calculated as:</span></span><br><span class="line"><span class="comment">	 *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">	 * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">	 * bootmem allocator):</span></span><br><span class="line"><span class="comment">	 *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">	 * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">	 * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">	 * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">	 * and thresholds.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Locking rules:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">	 * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">	 * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">	 * quite infrequently.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">	 * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">	 * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">	 * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">	 * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Read access to managed_pages should be safe because it&#x27;s unsigned</span></span><br><span class="line"><span class="comment">	 * long. Write access to zone-&gt;managed_pages and totalram_pages are</span></span><br><span class="line"><span class="comment">	 * protected by managed_page_count_lock at runtime. Idealy only</span></span><br><span class="line"><span class="comment">	 * adjust_managed_page_count() should be used instead of directly</span></span><br><span class="line"><span class="comment">	 * touching zone-&gt;managed_pages and totalram_pages.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		managed_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name; <span class="comment">/* 表示该区的名称 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_isolate_pageblock; <span class="comment">/* 隔离页面块的数量,它用于解决由于检索页面块迁移类型错误,而导致的不正确的free页计数问题 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">	<span class="keyword">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> initialized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free areas of different sizes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone flags, see below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock; <span class="comment">/* 自旋锁,主要保护free_area */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark; <span class="comment">/* 当可用页面低于此点时,在读取可用页面数时会采取其他步骤,以避免每cpu计数器漂移导致水印被破坏 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_free_pfn;</span><br><span class="line">	<span class="comment">/* pfn where async and sync compaction migration scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_migrate_pfn[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">	 * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">	 * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_considered;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_defer_shift;</span><br><span class="line">	<span class="keyword">int</span>			compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">	<span class="keyword">bool</span>			compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			contiguous;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad3_)</span><br><span class="line">	<span class="comment">/* Zone statistics */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
<ul>
<li>分配 ZONE_NORMAL 区的内存的方法如下：</li>
</ul>
<p><strong>按页获取内存</strong>：最原始的方法，用于底层获取内存的方式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc_page(gfp_mask)</td>
<td>只分配一页，返回指向页结构的指针</td>
</tr>
<tr>
<td>alloc_pages(gfp_mask, order)</td>
<td>分配 2^order 个页，返回指向第一页页结构的指针</td>
</tr>
<tr>
<td>__get_free_page(gfp_mask)</td>
<td>只分配一页，返回指向其逻辑地址的指针</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask, order)</td>
<td>分配 2^order 个页，返回指向第一页逻辑地址的指针</td>
</tr>
<tr>
<td>get_zeroed_page(gfp_mask)</td>
<td>只分配一页，让其内容填充为“0”，返回指向其逻辑地址的指针</td>
</tr>
</tbody>
</table>
</div>
<p><strong>按字节获取内存</strong>：使用最多的获取方法</p>
<p>有两种方式进行该种类型的分配：</p>
<ul>
<li>kmalloc：分配的内存物理地址是连续的，虚拟地址也是连续的</li>
<li>vmalloc：分配的内存物理地址是不连续的，虚拟地址是连续的</li>
</ul>
<p>因此在使用中，用的较多的还是 kmalloc：</p>
<ul>
<li>kmalloc 的性能较好</li>
<li>kmalloc 的物理地址和虚拟地址之间的映射比较简单，只需要将物理地址的第一页和虚拟地址第一页关联起来即可</li>
<li>vmalloc 由于物理地址是不连续的，所以要将物理地址的每一页都和虚拟地址关联起来才行</li>
</ul>
<p>PS：其实 kmalloc() 底层也是基于 SLAB 分配器的，只不过它所需要的管理结构头已经按照 2^n 的大小排列事先准备好了而已，这个管理结构体数组是 <code>struct cache_sizes malloc_sizes[]</code></p>
<p><strong>Slab 层获取</strong>：效率最高的获取方法</p>
<p>linux 中的高速缓存是用所谓 slab 层来实现的，slab 层即内核中管理高速缓存的机制，整个 slab 层的原理如下：</p>
<ul>
<li>可以在内存中建立各种对象的高速缓存（比如进程描述相关的结构 task_struct 的高速缓存）</li>
<li>除了针对特定对象的高速缓存以外，也有通用对象的高速缓存</li>
<li>每个高速缓存中包含多个 slab，slab 用于管理缓存的对象</li>
<li>slab 中包含多个缓存的对象，物理上由一页或多个连续的页组成</li>
</ul>
<p>高速缓存 -&gt; slab -&gt; 缓存对象之间的关系如下图：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661432738679-1666871176498.png" class width="1661432738679"> 
<p>用于管理 slab 的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>   <span class="comment">/* 存放缓存对象，这个链表有 满，部分满，空 3种状态  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff; <span class="comment">/* slab 着色的偏移量 */</span></span><br><span class="line">    <span class="keyword">void</span> *s_mem;             <span class="comment">/* 在 slab 中的第一个对象 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;      <span class="comment">/* slab 中已分配的对象数 */</span></span><br><span class="line">    <span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;      <span class="comment">/* 第一个空闲对象(如果有的话) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;   <span class="comment">/* 应该是在 NUMA 环境下使用 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>低级内核页分配：（当高速缓存中没有空闲的 slab 时才会调用 <strong>kmem_getpages</strong> 函数来分配页）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">kmem_getpages</span><span class="params">(struct kmem_cache *cachep, <span class="keyword">gfp_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">								<span class="keyword">int</span> nodeid)</span></span></span><br></pre></td></tr></table></figure>
<p>高速缓存内核页分配：</p>
<p>高速缓存的创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *</span></span><br><span class="line"><span class="function"><span class="title">kmem_cache_create</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> align,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *))</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>name：一个字符串，存放着高速缓存的名字</li>
<li>size：高速缓存中每个元素的大小</li>
<li>align：slab 内第一个对象的偏移</li>
<li>flags：标志位，用于控制高速缓存的行为</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>flag</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td>SLAB_HWCACHE_ALIGN - 0x00002000U</td>
<td>命令 slab 层把一个 slab 内的所有对象按照高速缓存行进行对齐</td>
</tr>
<tr>
<td>SLAB_POISON - 0x00000800U</td>
<td>使 slab 层用已知的值（a5a5a5a5）填充 slab，有利于对未初始化内存的访问</td>
</tr>
<tr>
<td>SLAB_RED_ZONE -  0x00000400U</td>
<td>使 slab 层在已经分配的内存周围插入“红色警戒区”，用于探测缓冲越界</td>
</tr>
<tr>
<td>SLAB_PANIC - 0x00040000U</td>
<td>当分配失败时提醒 slab 层</td>
</tr>
<tr>
<td>SLAB_CACHE_DMA - 0x00004000U</td>
<td>命令 slab 层分配可以执行 DMA 的内存空间给各个 slab（只有分配对象用于 DMA 时才会使用）</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>*ctor：高速缓存的构造函数（只有在新的页追加到高速缓存时，构造函数才会被调用），因为 Linux 内核的高速缓存不使用构造函数，所以这里常常被赋值为 NULL</li>
<li>return：指向高速缓存指针 <code>*cachep</code></li>
</ul>
<p>从高速缓存中分配对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmem_cache_alloc</span><span class="params">(struct kmem_cache *cachep, <span class="keyword">gfp_t</span> flags)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>cachep：指向高速缓存指针</p>
<ul>
<li>flags：之前讨论的 gfp_mask 标志，只有在高速缓存中所有 slab 都没有空闲对象，并且需要申请新的空间时，这个标志才会起作用</li>
<li>return：指向对象的指针</li>
</ul>
</li>
</ul>
<p>向高速缓存释放对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_free</span><span class="params">(struct kmem_cache *cachep, <span class="keyword">void</span> *objp)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>cachep：指向高速缓存指针</p>
<ul>
<li>objp：要释放的对象的指针</li>
</ul>
</li>
</ul>
<p>高速缓存的销毁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_destroy</span><span class="params">(struct kmem_cache *cachep)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>cachep：指向高速缓存指针 </li>
</ul>
<p><strong>高端内存获取</strong></p>
<p>高端内存就是之前提到的 ZONE_HIGHMEM 区的内存，用于满足 “物理地址空间大于虚拟地址空间” 的一些设备的访问需求</p>
<p>在x86体系结构中，这个区的内存不能映射到内核地址空间上（因为 <strong>没有逻辑地址</strong>），为了使用 ZONE_HIGHMEM 区的内存，内核提供了永久映射和临时映射2种手段：</p>
<ul>
<li>永久映射：永久映射的函数是可以睡眠的，所以只能用在进程上下文中（永久映射的数量有限）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">kmap</span><span class="params">(struct page *page)</span> <span class="comment">/* 将ZONE_HIGHMEM区的一个page永久的映射到内核地址空间,返回值即为这个page对应的逻辑地址 */</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kunmap</span><span class="params">(struct page *page)</span> <span class="comment">/* 允许永久映射的数量是有限的,所以不需要高端内存时,应该及时的解除映射 */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>临时映射：临时映射不会阻塞，也禁止了内核抢占，所以可以用在中断上下文和其他不能重新调度的地方</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">kmap_atomic</span><span class="params">(struct page *page, <span class="keyword">enum</span> km_type idx)</span> <span class="comment">/* 将ZONE_HIGHMEM区的一个page临时映射到内核地址空间,其中的km_type表示映射的目的(新版kernel不设置这个参数) */</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kunmap_atomic(addr, idx)    do &#123; pagefault_enable(); &#125; while (0) <span class="comment">/* 相应的解除映射是个宏 */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>虚拟文件系统（VFS）是 linux 内核和具体 I/O 设备之间的封装的一层共通访问接口，通过这层接口 Linux 内核可以以同一的方式访问各种 I/O 设备，它提供了一个通用的文件系统模型，该模型囊括了任何文件系统的常用功能和行为</p>
<ul>
<li>PS：其实不仅是硬件设备，许多软件机制也会构造 VFS 对象，使用户层可以通过操作文件的形式来操作它们（Linux 中一切皆文件，在这里可以体现）</li>
</ul>
<p>主要有以下好处：</p>
<ul>
<li>简化了应用程序的开发：应用通过统一的系统调用访问各种存储介质</li>
<li>简化了新文件系统加入内核的过程：新文件系统只要实现VFS的各个接口即可，不需要修改内核部分</li>
</ul>
<p>虚拟文件系统本身是 linux 内核的一部分，是纯软件的东西，并不需要任何硬件的支持，其核心就是4个主要对象：</p>
<ul>
<li>超级块：代表一个具体的已安装文件系统</li>
<li>索引结点：代表一个具体的文件</li>
<li>目录项：代表一个目录项，是路径的一个组成部分</li>
<li>文件：代表由进程打开的文件</li>
</ul>
<p><strong>超级块</strong></p>
<p>超级块（super_block）主要存储文件系统相关的信息，这是个针对文件系统级别的概念</p>
<ul>
<li>超级块一般存储在磁盘的特定扇区中</li>
<li>但是对于那些基于内存的文件系统（比如 proc，sysfs），超级块是在使用时创建在内存中的</li>
</ul>
<p>描述超级块的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 超级块结构中定义的字段非常多</span></span><br><span class="line"><span class="comment"> * 这里只介绍一些重要的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_list</span>;</span>               <span class="comment">/* 指向所有超级块的链表 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>    *<span class="title">s_op</span>;</span> <span class="comment">/* 超级块方法 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>        *<span class="title">s_root</span>;</span>           <span class="comment">/* 目录挂载点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">s_lock</span>;</span>            <span class="comment">/* 超级块信号量 */</span></span><br><span class="line">    <span class="keyword">int</span>            s_count;                   <span class="comment">/* 超级块引用计数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_inodes</span>;</span>           <span class="comment">/* inode链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>        *<span class="title">s_mtd</span>;</span>            <span class="comment">/* 存储磁盘信息 */</span></span><br><span class="line">    <span class="keyword">fmode_t</span>            s_mode;                <span class="comment">/* 安装权限 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其中的 s_op 中定义了超级块的操作方法</span></span><br><span class="line"><span class="comment"> * 这里只介绍一些相对重要的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span> <span class="comment">/* 创建和初始化一个索引节点对象 */</span></span><br><span class="line">    <span class="keyword">void</span> (*destroy_inode)(struct inode *);                <span class="comment">/* 释放给定的索引节点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*dirty_inode) (struct inode *);                 <span class="comment">/* VFS在索引节点被修改时会调用这个函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write_inode) (struct inode *, <span class="keyword">int</span>);             <span class="comment">/* 将索引节点写入磁盘,wait表示写操作是否需要同步 */</span></span><br><span class="line">    <span class="keyword">void</span> (*drop_inode) (struct inode *);                  <span class="comment">/* 最后一个指向索引节点的引用被删除后,VFS会调用这个函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*delete_inode) (struct inode *);                <span class="comment">/* 从磁盘上删除指定的索引节点 */</span></span><br><span class="line">    <span class="keyword">void</span> (*put_super) (struct super_block *);             <span class="comment">/* 卸载文件系统时由VFS调用,用来释放超级块 */</span></span><br><span class="line">    <span class="keyword">void</span> (*write_super) (struct super_block *);           <span class="comment">/* 用给定的超级块更新磁盘上的超级块 */</span></span><br><span class="line">    <span class="keyword">int</span> (*sync_fs)(struct super_block *sb, <span class="keyword">int</span> wait);     <span class="comment">/* 使文件系统中的数据与磁盘上的数据同步 */</span></span><br><span class="line">    <span class="keyword">int</span> (*statfs) (struct dentry *, struct kstatfs *);    <span class="comment">/* VFS调用该函数获取文件系统状态 */</span></span><br><span class="line">    <span class="keyword">int</span> (*remount_fs) (struct super_block *, <span class="keyword">int</span> *, <span class="keyword">char</span> *); <span class="comment">/* 指定新的安装选项重新安装文件系统时,VFS会调用该函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*clear_inode) (struct inode *);                 <span class="comment">/* VFS调用该函数释放索引节点,并清空包含相关数据的所有页面 */</span></span><br><span class="line">    <span class="keyword">void</span> (*umount_begin) (struct super_block *);          <span class="comment">/* VFS调用该函数中断安装操作 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>超级块对象通过 <code>alloc_super()</code> 函数创建并初始化（从磁盘读取文件系统超级块，并将信息填充到内存中的超级块对象中）</li>
</ul>
<p><strong>索引节点</strong></p>
<p>索引节点是 VFS 中的核心概念，它包含内核在操作文件或目录时需要的全部信息</p>
<ul>
<li>一个索引节点代表文件系统中的一个文件（Linux 一切皆文件）</li>
<li>Linux 系统为每一个文件都分配了一个 inode 编号，这个编号中记录了文件相关的一些元信息，通过这些元信息可以用来唯一标识一个文件（操作系统上的 inode 并非无穷无尽，通常在你安装操作系统后，系统上的 inode 数量就已经确定了下来）</li>
<li>索引节点和超级块一样是实际存储在磁盘上的，当被应用程序访问到时才会在内存中创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 索引节点结构中定义的字段非常多(这里只介绍一些重要的属性) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">i_hash</span>;</span>     <span class="comment">/* 散列表，用于快速查找inode */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_list</span>;</span>        <span class="comment">/* 索引节点链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span>  <span class="comment">/* 超级块链表超级块  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_dentry</span>;</span>   <span class="comment">/* 目录项链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        i_ino;      <span class="comment">/* 节点号 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        i_count;        <span class="comment">/* 引用计数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_nlink;    <span class="comment">/* 硬链接数 */</span></span><br><span class="line">    <span class="keyword">uid_t</span>            i_uid;          <span class="comment">/* 使用者id */</span></span><br><span class="line">    <span class="keyword">gid_t</span>            i_gid;          <span class="comment">/* 使用组id */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_atime</span>;</span>    <span class="comment">/* 最后访问时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_mtime</span>;</span>    <span class="comment">/* 最后修改时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_ctime</span>;</span>    <span class="comment">/* 最后改变时间 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>    *<span class="title">i_op</span>;</span>  <span class="comment">/* 索引节点操作函数 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span>    <span class="comment">/* 缺省的索引节点操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>    *<span class="title">i_sb</span>;</span>              <span class="comment">/* 相关的超级块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span>     <span class="comment">/* 相关的地址映射 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span>         <span class="comment">/* 设备地址映射 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_flags;            <span class="comment">/* 文件系统标志 */</span></span><br><span class="line">    <span class="keyword">void</span>            *i_private;             <span class="comment">/* fs 私有指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其中的i_op中定义了索引节点的操作方法(这里只介绍一些相对重要的函数) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 为dentry对象创造一个新的索引节点 */</span></span><br><span class="line">    <span class="keyword">int</span> (*create) (struct inode *,struct dentry *,<span class="keyword">int</span>, struct nameidata *);</span><br><span class="line">    <span class="comment">/* 在特定文件夹中寻找索引节点,该索引节点要对应于dentry中给出的文件名 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="keyword">struct</span> <span class="title">nameidata</span> *);</span></span><br><span class="line">    <span class="comment">/* 创建硬链接 */</span></span><br><span class="line">    <span class="keyword">int</span> (*link) (struct dentry *,struct inode *,struct dentry *);</span><br><span class="line">    <span class="comment">/* 从一个符号链接查找它指向的索引节点 */</span></span><br><span class="line">    <span class="keyword">void</span> * (*follow_link) (struct dentry *, struct nameidata *);</span><br><span class="line">    <span class="comment">/* 在follow_link调用之后,该函数由VFS调用进行清除工作 */</span></span><br><span class="line">    <span class="keyword">void</span> (*put_link) (struct dentry *, struct nameidata *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="comment">/* 该函数由VFS调用,用于修改文件的大小 */</span></span><br><span class="line">    <span class="keyword">void</span> (*truncate) (struct inode *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来看看几种类型的索引节点：</p>
<ul>
<li>磁盘索引节点：保存在硬盘中的索引节点</li>
<li>内存索引节点：保存在内存中的索引节点</li>
<li>文件节点：用于指向磁盘索引节点的节点（有助于硬链接的实现）</li>
</ul>
<p>不管是文件还是目录，[磁盘索引节点] 都需要与 [内存索引节点] 进行“绑定”，这样才可以操控磁盘上的数据，文件被打开时，[磁盘索引节点] 被复制到 [内存索引节点]，以便于使用</p>
<p>相关 API 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_create</span><span class="params">(struct inode *dir, struct dentry *dentry, <span class="keyword">umode_t</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">bool</span> excl)</span> <span class="comment">/* 为dentry对象创建一个新的inode,在创建时使用mode指定模式 */</span></span></span><br><span class="line"><span class="function">struct dentry *<span class="title">ext4_lookup</span><span class="params">(struct inode *dir, struct dentry *dentry, </span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>; <span class="comment">/* 在特定目录中查找inode */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_link</span><span class="params">(struct dentry *old_dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		     struct inode *dir, struct dentry *dentry)</span></span>; <span class="comment">/* 创建硬链接(链接名称由dentry参数指定),链接对象是dir目录中的old_dentry目录项所代表的文件 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_symlink</span><span class="params">(struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct dentry *dentry, <span class="keyword">const</span> <span class="keyword">char</span> *symname)</span></span>; <span class="comment">/* 创建符号链接,符号名称由symname指定,链接对象是dir目录中的dentry目录项所代表的文件 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_mkdir</span><span class="params">(struct inode *dir, </span></span></span><br><span class="line"><span class="params"><span class="function">                      struct dentry *dentry, <span class="keyword">umode_t</span> mode)</span></span>; <span class="comment">/* 创建一个新的目录,使用mode指定模式 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_mknod</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> rdev)</span></span>; <span class="comment">/* 创建特殊文件,要创建的文件放在dir目录中,其目录项为dentry,关联的设备为rdev,初始权限由mode指定 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ext4_rename</span><span class="params">(struct inode *old_dir, struct dentry *old_dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		       struct inode *new_dir, struct dentry *new_dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		       <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>; <span class="comment">/* 用于移动文件,文件源路径在old_dir目录中,源文件由old_dentry目录项指定,目标路径在new_dir目录中,目标文件由new_dentry指定 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ext4_setattr</span><span class="params">(struct dentry *dentry, struct iattr *attr)</span></span>; <span class="comment">/* 在修改了索引结点后,通知发生了&quot;改变事件&quot; */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ext4_getattr</span><span class="params">(<span class="keyword">const</span> struct path *path, struct kstat *stat,</span></span></span><br><span class="line"><span class="params"><span class="function">		 u32 request_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> query_flags)</span></span>; <span class="comment">/* 当收到&quot;改变事件&quot;的通知后,调用此函数进行处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_setxattr</span><span class="params">(struct dentry *dentry, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">void</span> *value,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span>; <span class="comment">/* 给dentry指定的文件设置扩展属性,属性名为name,值为value */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vfs_getxattr</span><span class="params">(struct dentry *dentry, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">void</span> *value, <span class="keyword">size_t</span> size)</span> <span class="comment">/* 检索扩展的属性值,属性名为name */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>目录项</strong></p>
<p>目录项不是目录，而是目录的组成部分</p>
<p>目录项是描述文件的逻辑属性，只存在于内存中，并不是实际存在于磁盘上，更确切的说是存在于内存的目录项缓存，为了提高查找性能而设计：</p>
<ul>
<li>在使用的时候在内存中创建目录项对象，其实通过索引节点已经可以定位到指定的文件</li>
<li>但是索引节点对象的属性非常多，在查找，比较文件时，直接用索引节点效率不高，所以引入了目录项的概念</li>
</ul>
<p>路径中的每个部分都是一个目录项</p>
<ul>
<li>比如路径：<code>/mnt/cdrom/foo/bar</code> </li>
<li>其中包含5个目录项：<code>/ mnt cdrom foo bar</code></li>
</ul>
<p>每个目录项对象都有3种状态：</p>
<ul>
<li>被使用：对应一个有效的索引节点，并且该对象由一个或多个使用者</li>
<li>未使用：对应一个有效的索引节点，但是VFS当前并没有使用这个目录项</li>
<li>负状态：没有对应的有效索引节点（可能索引节点被删除或者路径不存在了）</li>
</ul>
<p>描述目录项的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 目录项对象结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> d_count;       <span class="comment">/* 使用计数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;   <span class="comment">/* 目录项标识 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> d_lock;        <span class="comment">/* 单目录项锁 */</span></span><br><span class="line">    <span class="keyword">int</span> d_mounted;          <span class="comment">/* 是否登录点的目录项 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span>    <span class="comment">/* 相关联的索引节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_hash</span>;</span>    <span class="comment">/* 散列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span>    <span class="comment">/* 父目录的目录项对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>         <span class="comment">/* 目录项名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span>        <span class="comment">/* 未使用的链表 */</span></span><br><span class="line">    <span class="comment">/* d_child and d_rcu can share memory */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>    <span class="comment">/* child of parent list */</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">    &#125; d_u;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span>    <span class="comment">/* 子目录链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_alias</span>;</span>    <span class="comment">/* 索引节点别名链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;        <span class="comment">/* 重置时间 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span> <span class="comment">/* 目录项操作相关函数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>    <span class="comment">/* 文件的超级块 */</span></span><br><span class="line">    <span class="keyword">void</span> *d_fsdata;            <span class="comment">/* 文件系统特有数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN_MIN];    <span class="comment">/* 短文件名 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目录项相关操作函数 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 该函数判断目录项对象是否有效,VFS准备从dcache中使用一个目录项时会调用这个函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_revalidate)(struct dentry *, struct nameidata *);</span><br><span class="line">    <span class="comment">/* 为目录项对象生成hash值 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_hash) (struct dentry *, struct qstr *);</span><br><span class="line">    <span class="comment">/* 比较 qstr 类型的2个文件名 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_compare) (struct dentry *, struct qstr *, struct qstr *);</span><br><span class="line">    <span class="comment">/* 当目录项对象的 d_count 为0时,VFS调用这个函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_delete)(struct dentry *);</span><br><span class="line">    <span class="comment">/* 当目录项对象将要被释放时,VFS调用该函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*d_release)(struct dentry *);</span><br><span class="line">    <span class="comment">/* 当目录项对象丢失其索引节点时（也就是磁盘索引节点被删除了）,VFS会调用该函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*d_iput)(struct dentry *, struct inode *);</span><br><span class="line">    <span class="keyword">char</span> *(*d_dname)(struct dentry *, <span class="keyword">char</span> *, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>文件</strong></p>
<p>文件对象表示进程已打开的文件，从用户角度来看，我们在代码中操作的就是一个文件对象，它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息，它的作用范围是某一具体进程</p>
<ul>
<li>文件对象反过来指向一个目录项对象（目录项反过来指向一个索引节点）</li>
</ul>
<p>其实只有目录项对象才表示一个已打开的实际文件，虽然一个文件对应的文件对象不是唯一的，但其对应的索引节点和目录项对象却是唯一的</p>
<p>下面是用于描述文件的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span> <span class="comment">/* 文件对象链表 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span> <span class="comment">/* 释放之后的RCU链表 */</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span> <span class="comment">/* 包含的目录项 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span> <span class="comment">/* 索引结点 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span> <span class="comment">/* 指向操作file的回调函数集 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span>		f_lock; <span class="comment">/* 保护文件的自旋锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> 		f_flags; <span class="comment">/* 文件标志:O_RDONLY,O_NONBLOCK,O_SYNC */</span></span><br><span class="line">	<span class="keyword">fmode_t</span>			f_mode; <span class="comment">/* 文件读/写模式:FMODE_READ,FMODE_WRITE */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span>			f_pos; <span class="comment">/* 当前读写位置 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="keyword">void</span>			*private_data; <span class="comment">/* 文件私有数据 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span> <span class="comment">/* 指向该页所在地址空间描述结构的指针 */</span></span><br><span class="line">	<span class="keyword">errseq_t</span>		f_wb_err;</span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file_operations中定义了文件对象的操作方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 用于更新偏移量指针,由系统调用lleek()调用它 */</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">/* 由系统调用read()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="comment">/* 由系统调用write()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="comment">/* 由系统调用aio_read()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">    <span class="comment">/* 由系统调用aio_write()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">    <span class="comment">/* 将给定文件映射到指定的地址空间上,由系统调用mmap调用它 */</span></span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="comment">/* 创建一个新的文件对象,并将它和相应的索引节点对象关联起来 */</span></span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="comment">/* 当已打开文件的引用计数减少时,VFS调用该函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>file_operations</code> 用于实现对于“特定文件系统”的系统调用</li>
<li>这里有点面向对象的味道，也是 VFS 可以兼容多种文件系统的原因</li>
</ul>
<p>四个对象之间关系图：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661438949794-1666871176498.png" class width="1661438949794"> 
<p>除了 VFS 以外，内核必须提供 <code>file_system_type</code> 结构体来描述每种文件系统的功能和行为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* 文件系统名称 */</span></span><br><span class="line">	<span class="keyword">int</span> fs_flags; <span class="comment">/* 文件系统类型标志 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_REQUIRES_DEV		1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_BINARY_MOUNTDATA	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_HAS_SUBTYPE		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_MOUNT		8	<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_RENAME_DOES_D_MOVE	32768	<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">		       <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">	<span class="keyword">void</span> (*kill_sb) (struct super_block *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> <span class="comment">/* 文件系统模块 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span> <span class="comment">/* 链表中下一个文件系统类型 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span> <span class="comment">/* 超级块对象链表 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>每种文件系统，不管是有多少个实例安装到系统上，还是根本就没有安装，都只能有一个 <code>file_system_type</code> 结构体</li>
</ul>
<p>当文件系统被实际安装时，将会有一个 <code>vfsmount</code> 结构体在安装点被创建，用来表示每个文件系统的实例：（代表一个安装点）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span>	<span class="comment">/* root of the mounted tree */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span>	<span class="comment">/* pointer to superblock */</span></span><br><span class="line">	<span class="keyword">int</span> mnt_flags;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<h2 id="块I-O层"><a href="#块I-O层" class="headerlink" title="块I/O层"></a>块I/O层</h2><p>I/O设备主要有2类：</p>
<ul>
<li>字符设备：只能顺序读写设备中的内容（比如：串口设备，键盘）</li>
<li>块设备：能够随机读写设备中的内容（比如：硬盘，U盘）</li>
</ul>
<p>字符设备由于只能顺序访问，因此应用场景也不多，块设备是随机访问的，所以块设备在不同的应用场景中存在很大的优化空间：</p>
<ul>
<li>块设备的最小寻址单元就是扇区，扇区的大小是2的整数倍，一般是512字节</li>
<li>扇区是物理上的最小寻址单元，而逻辑上的最小寻址单元是块</li>
<li>为了便于文件系统管理，块的大小一般是扇区的整数倍，并且小于等于页的大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面  sudo fdisk -l</span><br><span class="line">[sudo] yhellow 的密码： </span><br><span class="line">Disk /dev/loop0：<span class="number">4</span> KiB，<span class="number">4096</span> 字节，<span class="number">8</span> 个扇区</span><br><span class="line">单元：扇区 / <span class="number">1</span> * <span class="number">512</span> = <span class="number">512</span> 字节</span><br><span class="line">扇区大小(逻辑/物理)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br><span class="line">I/O 大小(最小/最佳)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br></pre></td></tr></table></figure>
<p>块是文件系统的一种抽象：</p>
<ul>
<li>只能基于块来访问文件系统</li>
<li>磁盘的物理寻址是按照扇区进行的，但内核执行的所有磁盘操作都是按块进行的</li>
</ul>
<p><strong>内核访问块设备</strong></p>
<p>内核通过文件系统访问块设备时，需要先把块读入到内存中，所以文件系统为了管理块设备，必须管理[块]和内存页之间的映射</p>
<p>内核中有2种方法来管理 [<strong>块</strong>] 和内存页之间的映射：</p>
<p>一，缓冲区和缓冲区头：</p>
<ul>
<li>每个 [<strong>块</strong>] 都是一个缓冲区，同时对每个 [<strong>块</strong>] 都定义一个缓冲区头来描述它</li>
<li>由于 [<strong>块</strong>] 的大小是小于内存页的大小的，所以每个内存页会包含一个或者多个 [<strong>块</strong>]</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b_state;            <span class="comment">/* 表示缓冲区状态 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span>  <span class="comment">/* 当前页中缓冲区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span>              <span class="comment">/* 当前缓冲区所在内存页 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">sector_t</span> b_blocknr;       <span class="comment">/* 起始块号 */</span></span><br><span class="line">    <span class="keyword">size_t</span> b_size;            <span class="comment">/* buffer在内存中的大小 */</span></span><br><span class="line">    <span class="keyword">char</span> *b_data;             <span class="comment">/* 块映射在内存页中的数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span>  	 <span class="comment">/* 关联的块设备 */</span></span><br><span class="line">    <span class="keyword">bh_end_io_t</span> *b_end_io;       	 <span class="comment">/* I/O完成方法 */</span></span><br><span class="line">     <span class="keyword">void</span> *b_private;            	 <span class="comment">/* 保留的 I/O 完成方法 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span>     <span class="comment">/* 关联的其他缓冲区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span>    <span class="comment">/* 相关的地址空间 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> b_count;                     <span class="comment">/* 引用计数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>b_state</code>：表示缓冲区的状态，合法的标志存放在 <code>bh_state_bits</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bh_state_bits</span> &#123;</span></span><br><span class="line">	BH_Uptodate,	<span class="comment">/* 包含可用数据 */</span></span><br><span class="line">	BH_Dirty,	<span class="comment">/* 脏的 */</span></span><br><span class="line">	BH_Lock,	<span class="comment">/* 正在被IO操作使用(被锁定) */</span></span><br><span class="line">	BH_Req,		<span class="comment">/* 有IO请求 */</span></span><br><span class="line">	BH_Uptodate_Lock,<span class="comment">/* Used by the first bh in a page, to serialise IO completion of other buffers in the page */</span></span><br><span class="line"></span><br><span class="line">	BH_Mapped,	<span class="comment">/* 映射磁盘块 */</span></span><br><span class="line">	BH_New,		<span class="comment">/* 刚刚通过get_block映射,尚且不能访问 */</span></span><br><span class="line">	BH_Async_Read,	<span class="comment">/* 通过end_buffer_async_read,被异步IO读操作使用 */</span></span><br><span class="line">	BH_Async_Write,	<span class="comment">/* 通过end_buffer_async_write,被异步IO写操作使用 */</span></span><br><span class="line">	BH_Delay,		<span class="comment">/* 尚未和磁盘块关联 */</span></span><br><span class="line">	BH_Boundary,	<span class="comment">/* 处于连续区的边界(下一个块不再连续) */</span></span><br><span class="line">	BH_Write_EIO,	<span class="comment">/* 在写时遇到IO错误 */</span></span><br><span class="line">	BH_Unwritten,	<span class="comment">/* 在磁盘上的空间已经被申请但是没有数据写入 */</span></span><br><span class="line">	BH_Quiet,	<span class="comment">/* 禁止错误 */</span></span><br><span class="line">	BH_Meta,	<span class="comment">/* Buffer contains metadata */</span></span><br><span class="line">	BH_Prio,	<span class="comment">/* Buffer should be submitted with REQ_PRIO */</span></span><br><span class="line">	BH_Defer_Completion, <span class="comment">/* Defer AIO completion to workqueue */</span></span><br><span class="line"></span><br><span class="line">	BH_PrivateStart,	<span class="comment">/* 不是可用状态位,其目的是为了表明起始位 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>b_count</code>：表示缓冲区的使用计数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_bh</span><span class="params">(struct buffer_head *bh)</span> <span class="comment">/* 增加引用计数 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        atomic_inc(&amp;bh-&gt;b_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_bh</span><span class="params">(struct buffer_head *bh)</span> <span class="comment">/* 减少引用计数 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        smp_mb__before_atomic();</span><br><span class="line">        atomic_dec(&amp;bh-&gt;b_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：在 2.6 版本的 Linux 内核中，许多 IO 操作都不依靠 <code>buffer_head</code>，而是直接对页面或地址空间进行操作来完成，并引入了一种更灵活且轻量级的容器 <code>bio</code> 结构体</p>
<p>二，bio 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I/O操作的主要单元,针对I/O块和更低级的层(ie drivers and stacking drivers)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">    <span class="keyword">sector_t</span>        bi_sector;   	    <span class="comment">/* 磁盘上相关扇区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span>        *<span class="title">bi_next</span>;</span>  	  	<span class="comment">/* 请求列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>    *<span class="title">bi_bdev</span>;</span> 	<span class="comment">/* 相关的块设备 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        bi_flags;   	<span class="comment">/* 状态和命令标志 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        bi_rw;      	<span class="comment">/* 读还是写 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>        bi_vcnt;    	<span class="comment">/* bio_vecs的数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>        bi_idx;       <span class="comment">/* bio_io_vect的当前索引 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 结合后的片段数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_phys_segments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_size;    	<span class="comment">/* 剩余 I/O 计数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 第一个和最后一个可合并的段的大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_seg_front_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_seg_back_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_max_vecs;    <span class="comment">/* bio_vecs数目上限 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_comp_cpu;    <span class="comment">/* 结束CPU */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">atomic_t</span>        bi_cnt;        		<span class="comment">/* 使用计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>        *<span class="title">bi_io_vec</span>;</span>   <span class="comment">/* bio_vec 链表 */</span></span><br><span class="line">    <span class="keyword">bio_end_io_t</span>        *bi_end_io; 	<span class="comment">/* I/O 完成方法 */</span></span><br><span class="line">    <span class="keyword">void</span>            *bi_private;    	<span class="comment">/* bio结构体创建者的私有方法 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span>  <span class="comment">/* data integrity */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">bio_destructor_t</span>    *bi_destructor;    <span class="comment">/* bio撤销方法 */</span></span><br><span class="line">    <span class="comment">/* 内嵌在结构体末尾的bio向量,主要为了防止出现二次申请少量的bio_vecs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>        <span class="title">bi_inline_vecs</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>bio 结构体：表示正在执行的 I/O 操作相关的信息</li>
<li>bi_io_vec 链表：表示当前 I/O 操作涉及到的内存页（每个 bio_vec 都是对应一个页面 page，从而保证内核能够方便高效的完成 I/O 操作）</li>
<li>bio_vec 结构体：表示 I/O 操作使用的片段</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span>	*<span class="title">bv_page</span>;</span>		<span class="comment">/* 指向这个缓冲区所驻留的物理页 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	bv_len;		<span class="comment">/* 这个缓冲区以字节为单位的大小 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	bv_offset;	<span class="comment">/* 缓冲区所驻留的页中以字节为单位的偏移量 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>bi_vcnt：表示 bi_io_vec 链表中 bi_vec 的个数</li>
<li>bi_idx：表示当前的 bi_vec 片段的索引</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661472333928-1666871176498.png" class width="1661472333928"> 
<p><strong>请求队列</strong></p>
<p>块设备将它们挂起的块 IO 请求保存在请求队列 <code>request_queue</code> 中</p>
<p>队列中的请求由结构体 <code>request</code> 表示，一个请求可以由多个 <code>bio</code> 结构体组成</p>
<p><strong>内核I/O调度</strong></p>
<p>内核 I/O 调度程序通过两种方式来减少磁盘寻址时间：合并与排序</p>
<p>常见的内核 I/O 调度策略如下：</p>
<ul>
<li>Linus 电梯：<ul>
<li>为了保证磁盘寻址的效率，一般会尽量让磁头向一个方向移动，等到头了再反过来移动，这样可以缩短所有请求的磁盘寻址总时间</li>
<li>磁头的移动有点类似于电梯，所以这个 I/O 调度算法也叫电梯调度</li>
</ul>
</li>
<li>最终期限I/O调度：<ul>
<li>最终期限I/O调度算法类似于 Linus 电梯，但是给每个请求设置了超时时间，默认情况下，读请求的超时时间500ms，写请求的超时时间是5s</li>
</ul>
</li>
<li>预测I/O调度：<ul>
<li>基于最终期限I/O调度算法，新的读请求提交后，并不立即进行请求处理，而是有意等待片刻(默认是6ms)</li>
<li>等待期间如果有其他对磁盘相邻位置进行读操作的读请求加入，会立刻处理这些读请求</li>
<li>等待期间如果没有其他读请求加入，那么等待时间相当于浪费掉</li>
</ul>
</li>
<li>完全公正的排队I/O调度：<ul>
<li>完全公正的排队（Complete Fair Queuing，CFQ）I/O调度，是为专有工作负荷设计的，它和之前提到的I/O调度有根本的不同</li>
<li>CFQ I/O调度算法中，每个进程都有自己的I/O队列</li>
<li>CFQ I/O调度程序以时间片轮转调度队列，从每个队列中选取一定的请求数（默认4个），然后进行下一轮调度</li>
</ul>
</li>
<li>空操作的I/O调度：<ul>
<li>空操作I/O调度几乎不做什么事情，这也是它这样命名的原因</li>
<li>空操作I/O调度只做一件事情，当有新的请求到来时，把它与任一相邻的请求合并</li>
</ul>
</li>
</ul>
<p>Linux 内核中内置了上面4种I/O调度，可以在启动时通过命令行选项 <code>elevator=xxx</code> 来启用任何一种</p>
<p>elevator 选项参数如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>I/O调度程序</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>as</td>
<td>预测</td>
</tr>
<tr>
<td>cfq</td>
<td>完全公正排队</td>
</tr>
<tr>
<td>deadline</td>
<td>最终期限</td>
</tr>
<tr>
<td>noop</td>
<td>空操作</td>
</tr>
</tbody>
</table>
</div>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p><strong>地址空间</strong></p>
<p>进程地址空间也就是每个进程所使用的内存（就是每个进程所能访问的虚拟内存地址范围），内核对进程地址空间的管理，也就是对用户态程序的内存管理</p>
<ul>
<li>现代的操作系统中进程都是在保护模式下运行的，地址空间其实是操作系统给进程用的一段连续的虚拟内存空间</li>
<li>地址空间最终会通过页表映射到物理内存上，因为内核操作的是物理内存</li>
</ul>
<p>虽然地址空间的范围很大，但是进程也不一定有权限访问全部的地址空间（一般都是只能访问地址空间中的一些地址区间），进程能够访问的那些地址区间也称为 [内存区域]，进程如果访问了有效内存区域以外的内容就会报 “段错误” 信息</p>
<ul>
<li>[内存区域]：进程能够访问的那些 [地址区间]</li>
</ul>
<p>内存区域中主要包含以下信息：</p>
<ul>
<li>代码段 (text section)，即可执行文件代码的内存映射</li>
<li>数据段 (data section)，即可执行文件的已初始化全局变量的内存映射</li>
<li>bss 段的零页 (页面信息全是“0”值)，即未初始化全局变量的内存映射</li>
<li>进程用户空间栈的零页内存映射</li>
<li>进程使用的C库或者动态链接库等共享库的代码段，数据段和bss段的内存映射</li>
<li>任何内存映射文件</li>
<li>任何共享内存段</li>
<li>任何匿名内存映射，比如由 malloc() 分配的内存</li>
</ul>
<p>linux 中的地址空间是用 mm_struct 来表示的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>        <span class="comment">/* [内存区域]单链表组织 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>                <span class="comment">/* [内存区域]红黑树组织 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span>  <span class="comment">/* 最近一次访问的[内存区域] */</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;  <span class="comment">/* 获取指定区间内一个还未映射的地址，出错时返回错误码 */</span></span><br><span class="line">    <span class="keyword">void</span> (*unmap_area) (struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr);  <span class="comment">/* 取消地址 addr 的映射 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;        <span class="comment">/* 地址空间中可以用来映射的首地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;        <span class="comment">/* 进程的虚拟地址空间大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cached_hole_size;     <span class="comment">/* 如果不空的话，就是 free_area_cache 后最大的空洞 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_area_cache;      <span class="comment">/* 地址空间的第一个空洞 */</span></span><br><span class="line">    <span class="keyword">pgd_t</span> * pgd;                        <span class="comment">/* 页全局目录 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_users;            <span class="comment">/* 使用地址空间的用户数 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_count;            <span class="comment">/* 实际使用地址空间的计数， (users count as 1) */</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                <span class="comment">/* [内存区域]个数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span>   	<span class="comment">/* 内存区域信号量 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> page_table_lock;         <span class="comment">/* 页表锁 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>       		<span class="comment">/* 所有地址空间形成的链表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Special counters, in some configurations protected by the</span></span><br><span class="line"><span class="comment">     * page_table_lock, in other configurations by being atomic.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">mm_counter_t</span> _file_rss;</span><br><span class="line">    <span class="keyword">mm_counter_t</span> _anon_rss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_rss;   	 <span class="comment">/* High-watermark of RSS usage */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_vm;   	 <span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm, locked_vm, shared_vm, exec_vm;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data; <span class="comment">/* 代码段,数据段的开始和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack; <span class="comment">/* 堆的首地址,尾地址,进程栈首地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end; <span class="comment">/* 命令行参数,环境变量首地址,尾地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">cpumask_t</span> cpu_vm_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="keyword">mm_context_t</span> context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap token stuff */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Last value of global fault stamp as seen by this process.</span></span><br><span class="line"><span class="comment">     * In other words, this value gives an indication of how long</span></span><br><span class="line"><span class="comment">     * it has been since this task got the token.</span></span><br><span class="line"><span class="comment">     * Look at mm/thrash.c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> faultstamp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> token_priority;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> last_interval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">core_state</span>;</span> <span class="comment">/* coredumping support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AIO</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        ioctx_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    <span class="title">ioctx_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MM_OWNER</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;owner&quot; points to a task that is regarded as the canonical</span></span><br><span class="line"><span class="comment">     * user/owner of this mm. All of the following must be true in</span></span><br><span class="line"><span class="comment">     * order for it to be changed:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * current == mm-&gt;owner</span></span><br><span class="line"><span class="comment">     * current-&gt;mm != mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;mm == mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;alloc_lock is held</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exe_file</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_exe_file_vmas;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_mm</span> *<span class="title">mmu_notifier_mm</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>mm_users：就是 mm_struct 被用户空间进程(线程)引用的次数 </li>
<li>mm_count：其实它记录就是 mm_struct 实际的引用计数 <ul>
<li>当 mm_users=0 时，并不一定能释放此 mm_struct，只有当 mm_count=0 时，才可以确定释放此 mm_struct</li>
<li>如果只有1个进程使用 mm_struct，那么 mm_users=1，mm_count也是 1</li>
<li>如果有9个线程在使用 mm_struct，那么 mm_users=9，而 mm_count 仍然为 1</li>
</ul>
</li>
</ul>
<p><strong>虚拟内存区域(VMA)</strong></p>
<p>[内存区域]（进程能够访问的那些 [地址区间]）在 linux 中也被称为 [虚拟内存区域]（VMA），它其实就是进程地址空间上一段连续的内存范围</p>
<p>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span>    <span class="comment">/* 相关的 mm_struct 结构体 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;      <span class="comment">/* 内存区域首地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;        <span class="comment">/* 内存区域尾地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span>  <span class="comment">/* VMA链表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;        <span class="comment">/* 访问控制权限 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;       <span class="comment">/* 标志 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span>         <span class="comment">/* 树上的VMA节点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">     * linkage into the address_space-&gt;i_mmap prio tree, or</span></span><br><span class="line"><span class="comment">     * linkage to the list of like vmas hanging off its node, or</span></span><br><span class="line"><span class="comment">     * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">            <span class="keyword">void</span> *parent;    <span class="comment">/* aligns with prio_tree_node parent */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">        &#125; vm_set;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">     * list, after a COW of one of the file pages.    A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">     * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span>    <span class="comment">/* 匿名vma对象链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>    	   <span class="comment">/* 匿名vma对象 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span>	<span class="comment">/* 相关的操作表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Information about our backing store: */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;       		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">                       units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>        		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="keyword">void</span> * vm_private_data;       		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_truncate_count;	<span class="comment">/* truncate_count or restart_addr */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>    	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>    	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虚拟内存区域（VMA）对应的操作表如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*open)(struct vm_area_struct * area); <span class="comment">/* 把指定vma与一个地址空间绑定 */</span></span><br><span class="line">	<span class="keyword">void</span> (*close)(struct vm_area_struct * area); <span class="comment">/* 把指定vma的地址空间删除 */</span></span><br><span class="line">	<span class="keyword">int</span> (*split)(struct vm_area_struct * area, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr);</span><br><span class="line">	<span class="keyword">int</span> (*mremap)(struct vm_area_struct * area);</span><br><span class="line">	<span class="keyword">vm_fault_t</span> (*fault)(struct vm_fault *vmf); </span><br><span class="line">	<span class="keyword">vm_fault_t</span> (*huge_fault)(struct vm_fault *vmf,</span><br><span class="line">			<span class="keyword">enum</span> page_entry_size pe_size);</span><br><span class="line">	<span class="keyword">void</span> (*map_pages)(struct vm_fault *vmf,</span><br><span class="line">			<span class="keyword">pgoff_t</span> start_pgoff, <span class="keyword">pgoff_t</span> end_pgoff);</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*pagesize)</span><span class="params">(struct vm_area_struct * area)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* notification that a previously read-only page is about to become</span></span><br><span class="line"><span class="comment">	 * writable, if an error is returned it will cause a SIGBUS */</span></span><br><span class="line">	<span class="keyword">vm_fault_t</span> (*page_mkwrite)(struct vm_fault *vmf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* same as page_mkwrite when using VM_PFNMAP|VM_MIXEDMAP */</span></span><br><span class="line">	<span class="keyword">vm_fault_t</span> (*pfn_mkwrite)(struct vm_fault *vmf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* called by access_process_vm when get_user_pages() fails, typically</span></span><br><span class="line"><span class="comment">	 * for use by special VMAs that can switch between memory and hardware</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*access)(struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span><br><span class="line">		      <span class="keyword">void</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> write);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Called by the /proc/PID/maps code to ask the vma whether it</span></span><br><span class="line"><span class="comment">	 * has a special name.  Returning non-NULL will also cause this</span></span><br><span class="line"><span class="comment">	 * vma to be dumped unconditionally. */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *(*name)(struct vm_area_struct *vma);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * set_policy() op must add a reference to any non-NULL @new mempolicy</span></span><br><span class="line"><span class="comment">	 * to hold the policy upon return.  Caller should pass NULL @new to</span></span><br><span class="line"><span class="comment">	 * remove a policy and fall back to surrounding context--i.e. do not</span></span><br><span class="line"><span class="comment">	 * install a MPOL_DEFAULT policy, nor the task or system default</span></span><br><span class="line"><span class="comment">	 * mempolicy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> (*set_policy)(struct vm_area_struct *vma, struct mempolicy *<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * get_policy() op must add reference [mpol_get()] to any policy at</span></span><br><span class="line"><span class="comment">	 * (vma,addr) marked as MPOL_SHARED.  The shared policy infrastructure</span></span><br><span class="line"><span class="comment">	 * in mm/mempolicy.c will do this automatically.</span></span><br><span class="line"><span class="comment">	 * get_policy() must NOT add a ref if the policy at (vma,addr) is not</span></span><br><span class="line"><span class="comment">	 * marked as MPOL_SHARED. vma policies are protected by the mmap_sem.</span></span><br><span class="line"><span class="comment">	 * If no [shared/vma] mempolicy exists at the addr, get_policy() op</span></span><br><span class="line"><span class="comment">	 * must return NULL--i.e., do not &quot;fallback&quot; to task or system default</span></span><br><span class="line"><span class="comment">	 * policy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *(*<span class="title">get_policy</span>)(<span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>,</span></span><br><span class="line"><span class="class">					<span class="title">unsigned</span> <span class="title">long</span> <span class="title">addr</span>);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Called by vm_normal_page() for special PTEs to find the</span></span><br><span class="line"><span class="comment">	 * page for @addr.  This is useful if the default behavior</span></span><br><span class="line"><span class="comment">	 * (using pte_page()) would not find the correct page.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *(*<span class="title">find_special_page</span>)(<span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>,</span></span><br><span class="line"><span class="class">					  <span class="title">unsigned</span> <span class="title">long</span> <span class="title">addr</span>);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>地址空间和页表</strong></p>
<p>地址空间中的地址都是虚拟内存中的地址，而CPU需要操作的是物理内存（内核操作的也是物理内存），所以需要一个将虚拟地址映射到物理地址的机制</p>
<p>这个机制就是页表，linux 中使用3级页面来完成虚拟地址到物理地址的转换</p>
<ul>
<li>PGD - 全局页目录，包含一个 pgd_t 类型数组，多数体系结构中 pgd_t 类型就是一个无符号长整型</li>
<li>PMD - 中间页目录，它是个 pmd_t 类型数组</li>
<li>PTE - 简称页表，包含一个 pte_t 类型的页表项，该页表项指向物理页面</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661508765929-1666871176498.png" class width="1661508765929"> 
<p><strong>翻译后缓存器-translate lookaside buffer-TLB</strong></p>
<p>搜索物理地址的速度很有限，因此为了加快搜索，TLB 机制诞生了</p>
<ul>
<li>TLB 其实就是一块高速缓存 </li>
<li>当请求访问一个虚拟地址时，处理器会先检查 TLB 中是否缓存了该虚拟地址到物理地址的映射</li>
</ul>
<h2 id="页高速缓存-amp-页回写"><a href="#页高速缓存-amp-页回写" class="headerlink" title="页高速缓存&amp;页回写"></a>页高速缓存&amp;页回写</h2><p>为了提高 I/O 性能，也引入了缓存机制，即将一部分磁盘上的数据缓存到内存中 </p>
<p>之所以通过缓存能提高 I/O 性能是基于以下2个重要的原理：</p>
<ul>
<li>CPU访问内存的速度远远大于访问磁盘的速度（访问速度差距不是一般的大，差好几个数量级）</li>
<li>数据一旦被访问，就有可能在短期内再次被访问（临时局部原理）</li>
</ul>
<p><strong>页高速缓存</strong></p>
<p>页缓存和硬件 cache 的原理基本相同，将容量大而低速设备中的部分数据存放到容量小而快速的设备中，这样速度快的设备将作为低速设备的缓存，当访问低速设备中的数据时，可以直接从缓存中获取数据而不需再访问低速设备，从而节省了整体的访问时间</p>
<ul>
<li>页高速缓存缓存的是具体的物理页面，与前面章节中提到的虚拟内存空间 vm_area_struct 不同</li>
<li>假设有进程创建了多个 vm_area_struct 都指向同一个文件，那么这个 vm_area_struct 对应的页高速缓存只有一份</li>
<li>也就是磁盘上的文件缓存到内存后，它的虚拟内存地址可以有多个，但是物理内存地址却只能有一个</li>
</ul>
<p>为了有效提高 I/O 性能，页高速缓存要需要满足以下条件：</p>
<ul>
<li>能够快速检索需要的内存页是否存在</li>
<li>能够快速定位脏页面（也就是被写过，但还没有同步到磁盘上的数据）</li>
<li>页高速缓存被并发访问时，尽量减少并发锁带来的性能损失</li>
</ul>
<p>实现页高速缓存的最重要的结构体要算是 address_space：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">host</span>;</span>        		<span class="comment">/* 拥有此address_space的inode对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span>    <span class="title">page_tree</span>;</span>    <span class="comment">/* 包含全部页面的radix树 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        tree_lock;   		    <span class="comment">/* 保护radix树的自旋锁 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_mmap_writable;	<span class="comment">/* VM_SHARED计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prio_tree_root</span>    <span class="title">i_mmap</span>;</span>        <span class="comment">/* 私有映射链表的树 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_mmap_nonlinear</span>;</span>	<span class="comment">/* VM_NONLINEAR链表 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        i_mmap_lock;   	    <span class="comment">/* 保护i_map的自旋锁 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        truncate_count;     <span class="comment">/* 截断计数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        nrpages;    		<span class="comment">/* 总页数 */</span></span><br><span class="line">    <span class="keyword">pgoff_t</span>            writeback_index;		<span class="comment">/* 回写的起始偏移 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span>;</span>    <span class="comment">/* address_space的操作表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        flags;        				<span class="comment">/* gfp_mask掩码与错误标识 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span> 		 <span class="comment">/* 预读信息 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        private_lock;   		 <span class="comment">/* 私有address_space自旋锁 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">private_list</span>;</span>   	 <span class="comment">/* 私有address_space链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">assoc_mapping</span>;</span>  <span class="comment">/* 缓冲 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">unmap_mutex</span>;</span>    	 <span class="comment">/* 保护未映射页的mutux锁 */</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br></pre></td></tr></table></figure>
<p>这里的 Radix 树（基数树）就是页高速缓存的底层算法</p>
<p><strong>页回写</strong></p>
<p>由于页高速缓存的作用，写操作实际上会被延迟，当页高速缓存中的数据更新，但是后台存储的数据还没有更新时，该数据就被称为脏数据</p>
<ul>
<li>在内存中累积起来的脏页最终必须被写回磁盘</li>
<li>而写回磁盘的操作就被称为页回写</li>
</ul>
<p>Linux 页高速缓存页中的回写是由内核中的 <code>flusher</code> 线程来完成的，<code>flusher</code> 线程在以下3种情况发生时，触发回写操作：</p>
<ul>
<li>一，当空闲内存低于一个阀值时：<ul>
<li>空闲内存不足时，需要释放一部分缓存</li>
<li>由于只有不脏的页面才能被释放，所以要把脏页面都回写到磁盘，使其变成干净的页面</li>
</ul>
</li>
<li>二，当脏页在内存中驻留时间超过一个阀值时：<ul>
<li>确保脏页面不会无限期的驻留在内存中，从而减少了数据丢失的风险</li>
</ul>
</li>
<li>三，当用户进程调用 <code>sync()</code> 和 <code>fsync()</code> 系统调用时：<ul>
<li>给用户提供一种强制回写的方法，应对回写要求严格的场景</li>
</ul>
</li>
</ul>
<p>但页回写的条件满足时，内核便会调用 <code>wakeup_flusher_threads</code> 来唤醒一个或者多个 <code>flusher</code> 线程，然后 <code>flusher</code> 线程会将脏页写回磁盘</p>
<h2 id="设备-amp-模块"><a href="#设备-amp-模块" class="headerlink" title="设备&amp;模块"></a>设备&amp;模块</h2><p><strong>设备类型</strong></p>
<p>Linux 中主要由3种类型的设备，分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>设备类型</strong></th>
<th style="text-align:left"><strong>代表设备</strong></th>
<th style="text-align:left"><strong>特点</strong></th>
<th style="text-align:left"><strong>访问方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">块设备</td>
<td style="text-align:left">硬盘，光盘</td>
<td style="text-align:left">随机访问设备中的内容</td>
<td style="text-align:left">一般都是把设备挂载为文件系统后再访问</td>
</tr>
<tr>
<td style="text-align:left">字符设备</td>
<td style="text-align:left">键盘，打印机</td>
<td style="text-align:left">只能顺序访问（一个一个字符或者一个一个字节）</td>
<td style="text-align:left">一般不挂载，直接和设备交互</td>
</tr>
<tr>
<td style="text-align:left">网络设备</td>
<td style="text-align:left">网卡</td>
<td style="text-align:left">打破了Unix “所有东西都是文件” 的设计原则</td>
<td style="text-align:left">通过套接字API来访问</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>除了以上3种典型的设备之外，其实Linux中还有一些其他的设备类型，其中见的较多的应该算是”伪设备”</li>
<li>所谓”伪设备”，其实就是一些虚拟的设备，仅提供访问内核功能而已，没有物理设备与之关联</li>
<li>典型的”伪设备”就是 /dev/random(内核随机数发生器)， /dev/null(空设备)， /dev/zero(零设备)， /dev/full(满设备)</li>
</ul>
<p><strong>设备结构体</strong></p>
<p>用于描述一个字符设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="keyword">dev_t</span> dev;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于不同的文件系统，<code>file_operations</code> 的内容不同</li>
<li>内核对象 <code>kobj</code> 用于统一设备模型</li>
</ul>
<p><strong>内核模块</strong></p>
<p>Linux 内核是模块化组成的，内核中的模块可以按需加载，从而保证内核启动时不用加载所有的模块，即减少了内核的大小，也提高了效率</p>
<ul>
<li>通过编写内核模块来给内核增加功能或者接口是个很好的方式（既不用重新编译内核，也方便调试和删除）</li>
</ul>
<p>带参数的内核模块的示例：（我在网上抄了个示例，打 kernel pwn 的时候可能会用到）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_student</span><span class="params">(struct student*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stu_id = <span class="number">0</span>;  <span class="comment">// 默认id</span></span><br><span class="line">module_param(stu_id, <span class="keyword">int</span>, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(stu_id, <span class="string">&quot;学生ID，默认为 0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* stu_name_in = <span class="string">&quot;default name&quot;</span>; <span class="comment">// 默认名字</span></span><br><span class="line">module_param_named(stu_name_out, stu_name_in ,charp, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(stu_name, <span class="string">&quot;学生姓名，默认为 default name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARR_LEN 5</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr_len;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr_in[MAX_ARR_LEN];</span><br><span class="line">module_param_array_named(arr_out, arr_in, <span class="keyword">int</span>, &amp;arr_len, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(arr_in, <span class="string">&quot;数组参数，默认为空&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_paramed_km_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span>* <span class="title">stu1</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 进入内核模块 */</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;test_paramed_km is inited!\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据参数生成 struct student 信息</span></span><br><span class="line">    <span class="comment">// 如果没有参数就用默认参数</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;alloc one student....\n&quot;</span>);</span><br><span class="line">    stu1 = kmalloc(<span class="keyword">sizeof</span>(*stu1), GFP_KERNEL);</span><br><span class="line">    stu1-&gt;id = stu_id;</span><br><span class="line">    stu1-&gt;name = stu_name_in;</span><br><span class="line">    print_student(stu1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr_len; ++i) &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;arr_value[%d]: %d\n&quot;</span>, i, arr_in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_paramed_km_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 退出内核模块 */</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;test_paramed_km is exited!\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;\n\n\n\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_student</span><span class="params">(struct student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stu != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;**********student info***********\n&quot;</span>);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;student id   is: %d\n&quot;</span>, stu-&gt;id);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;student name is: %s\n&quot;</span>, stu-&gt;name);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;*********************************\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;the student info is null!!\n&quot;</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(test_paramed_km_init);</span><br><span class="line">module_exit(test_paramed_km_exit);</span><br></pre></td></tr></table></figure>
<p>上面的示例对应的 Makefile 如下： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> must complile on customize kernel</span></span><br><span class="line">obj-m += paramed_km.o</span><br><span class="line">paramed_km-objs := test_paramed_km.o</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">generate the path</span></span><br><span class="line">CURRENT_PATH:=$(shell pwd)</span><br><span class="line"><span class="meta">#</span><span class="bash">the current kernel version number</span></span><br><span class="line">LINUX_KERNEL:=$(shell uname -r)</span><br><span class="line"><span class="meta">#</span><span class="bash">the absolute path</span></span><br><span class="line">LINUX_KERNEL_PATH:=/usr/src/kernels/$(LINUX_KERNEL)</span><br><span class="line"><span class="meta">#</span><span class="bash">complie object</span></span><br><span class="line">all:</span><br><span class="line">    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules</span><br><span class="line">    rm -rf modules.order Module.symvers .*.cmd *.o *.mod.c .tmp_versions *.unsigned</span><br><span class="line"><span class="meta">#</span><span class="bash">clean</span></span><br><span class="line">clean:</span><br><span class="line">    rm -rf modules.order Module.symvers .*.cmd *.o *.mod.c *.ko .tmp_versions *.unsigned</span><br></pre></td></tr></table></figure>
<p>内核模块运行方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@vbox chap17]# ll   &lt;-- 编译内核后,多了paramed_km.ko文件</span><br><span class="line">total 124</span><br><span class="line">-rw-r--r-- 1 root root    538 Dec  1 19:37 Makefile</span><br><span class="line">-rw-r--r-- 1 root root 118352 Dec  1 19:37 paramed_km.ko</span><br><span class="line">-rw-r--r-- 1 root root   2155 Dec  1 19:37 test_paramed_km.c</span><br><span class="line"></span><br><span class="line">&lt;-- 通过 modinfo 命令可以查看对内核模块参数的注释</span><br><span class="line">[root@vbox chap17]# modinfo  paramed_km.ko</span><br><span class="line">filename:       paramed_km.ko</span><br><span class="line">license:        Dual BSD/GPL</span><br><span class="line">srcversion:     C52F97687B033738742800D</span><br><span class="line">depends:</span><br><span class="line">vermagic:       2.6.32-279.el6.x86_64 SMP mod_unload modversions</span><br><span class="line">parm:           stu_id:学生ID，默认为 0 (int)</span><br><span class="line">parm:           stu_name_out:charp</span><br><span class="line">parm:           stu_name_in:学生姓名，默认为 default name</span><br><span class="line">parm:           arr_out:array of int</span><br><span class="line">parm:           arr_in:数组参数，默认为空</span><br><span class="line"></span><br><span class="line">&lt;-- 3 个参数都是默认的</span><br><span class="line">[root@vbox chap17]# insmod paramed_km.ko</span><br><span class="line">[root@vbox chap17]# rmmod paramed_km.ko</span><br><span class="line">[root@vbox chap17]# dmesg | tail -16  &lt;-- 结果中显示2个默认参数,第3个数组参数默认为空,所以不显示</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is inited!</span><br><span class="line">*************************</span><br><span class="line">alloc one student....</span><br><span class="line">**********student info***********</span><br><span class="line">student id   is: 0</span><br><span class="line">student name is: default name</span><br><span class="line">*********************************</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is exited!</span><br><span class="line">*************************</span><br><span class="line"></span><br><span class="line">&lt;-- 3 个参数都被设置</span><br><span class="line">[root@vbox chap17]# insmod paramed_km.ko stu_id=100 stu_name_out=myname arr_out=1,2,3,4,5</span><br><span class="line">[root@vbox chap17]# rmmod paramed_km.ko</span><br><span class="line">[root@vbox chap17]# dmesg | tail -21</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is inited!</span><br><span class="line">*************************</span><br><span class="line">alloc one student....</span><br><span class="line">**********student info***********</span><br><span class="line">student id   is: 100</span><br><span class="line">student name is: myname</span><br><span class="line">*********************************</span><br><span class="line">arr_value[0]: 1</span><br><span class="line">arr_value[1]: 2</span><br><span class="line">arr_value[2]: 3</span><br><span class="line">arr_value[3]: 4</span><br><span class="line">arr_value[4]: 5</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is exited!</span><br><span class="line">*************************</span><br></pre></td></tr></table></figure>
<p><strong>内核对象</strong></p>
<p>Linux-2.6-kernel 中增加了一个引人注目的新特性：统一设备模型(device model)</p>
<ul>
<li>统一设备模型的最初动机是为了实现智能的电源管理，linux 内核为了实现智能电源管理，需要建立表示系统中所有设备拓扑关系的树结构</li>
<li>这样在关闭电源时，可以从树的节点开始关闭</li>
</ul>
<p>实现了统一设备模型之后，还给内核带来了如下的好处:</p>
<ul>
<li>代码重复最小化（统一处理的东西多了）</li>
<li>可以列举系统中所有设备，观察它们的状态，并查看它们连接的总线</li>
<li>可以将系统中的全部设备以树的形式完整，有效的展示出来—包括所有总线和内部连接</li>
<li>可以将设备和其对应的驱动联系起来，反之亦然</li>
<li>可以将设备按照类型加以归类，无需理解物理设备的拓扑结构</li>
<li>可以沿设备树的叶子向其根的反向依次遍历，以保证能以正确的顺序关闭设备电源</li>
</ul>
<p>kobject：</p>
<p>统一设备模型的核心部分就是 kobject，通过下面对 kobject 结构体的介绍，可以大致了解它是如何使得各个物理设备能够以树结构的形式组织起来的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;                   <span class="comment">/* kobject 名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span>               <span class="comment">/* kobject 链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>        *<span class="title">parent</span>;</span>             <span class="comment">/* kobject 的父对象，说明kobject是有层次结构的 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>        *<span class="title">kset</span>;</span>                   <span class="comment">/* kobject 的集合，接下来有详细介绍 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>    *<span class="title">ktype</span>;</span>              <span class="comment">/* kobject 的类型，接下来有详细介绍 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span>    *<span class="title">sd</span>;</span>                 <span class="comment">/* 在sysfs中，这个结构体表示kobject的一个inode结构体，sysfs之后也会介绍 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>        <span class="title">kref</span>;</span>                    <span class="comment">/* 提供 kobject 的引用计数 */</span></span><br><span class="line">    <span class="comment">/* 一些标志位  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;       </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>kobject 本身不代表什么实际的内容，一般都是嵌在其他数据结构中来发挥作用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>    <span class="comment">/* 表示kset中所有kobject的链表 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;     <span class="comment">/* 用于保护 list 的自旋锁*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>      <span class="comment">/* kset中嵌入的一个kobject，使得kset也可以表现的像一样kobject一样*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span>  <span class="comment">/* 处理kset中kobject的热插拔事件 提供了与用户空间热插拔进行通信的机制 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>cdev 中嵌入了 kobject 之后，就可以通过 cdev-&gt;kboj.parent 建立 cdev 之间的层次关系，通过 cdev-&gt;kobj.entry 获取关联的所有 cdev 设备等 </li>
<li>总之，嵌入了 kobject 之后，cdev 设备之间就有了树结构关系，cdev 设备和其他设备之间也有可层次关系 </li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661852969399-1666871176498.png" class width="1661852969399"> 
<p><strong>sysfs文件系统</strong></p>
<p>sysfs 文件系统是一个处于内存中的虚拟文件系统，它为我们提供 kobject 对象层次结构的视图，帮助用户可以以一个简单文件系统的方式来观察各种设备的拓扑结构：</p>
<ul>
<li>sysfs 代替了先前处于 proc 下的设备文件</li>
<li>sysfs 就被挂载在 sys 目录中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  labs git:(master) ✗ ls /sys</span><br><span class="line">block  class  devices   fs          kernel  power</span><br><span class="line">bus    dev    firmware  hypervisor  module</span><br></pre></td></tr></table></figure>
<ul>
<li>block：每个子目录对应一个系统中已经注册的块设备</li>
<li>bus：提供了一个系统的总线视图</li>
<li>class：包含了以高层功能逻辑组织起来的系统设备视图</li>
<li>dev：已经注册的设备结点视图</li>
<li>devices：系统中设备拓扑结构视图（该目录将设备模型导出到用户空间）</li>
<li>firmware：包含一些诸如 ACPI EDD EFI 等底层子系统的特殊树</li>
<li>fs：已注册文件系统的视图</li>
<li>kernel：包含内核配置项和状态信息</li>
<li>module：包含系统已加载模块的信息</li>
<li>power：包含系统范围的电源管理数据</li>
</ul>
<h2 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h2><p><strong>printk</strong></p>
<p>内核提供的打印函数 <code>printk</code> 和C语言提供的 <code>printf</code> 功能几乎相同：</p>
<ul>
<li><code>printk</code> 的弹性极佳，可以在任何时候进行调用</li>
<li><code>printk</code> 和 <code>printf</code> 的区别就在于，前者可以提供一个日志等级</li>
<li>内核会根据其日志等级来判断是否在终端上打印消息</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>日志等级</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>KERN_EMERG</td>
<td>一个紧急情况</td>
</tr>
<tr>
<td>KERN_ALERT</td>
<td>一个需要被立刻注意到的错误</td>
</tr>
<tr>
<td>KERN_CRIT</td>
<td>一个临界情况</td>
</tr>
<tr>
<td>KERN_ERR</td>
<td>一个错误</td>
</tr>
<tr>
<td>KERN_WARNING</td>
<td>一个警告</td>
</tr>
<tr>
<td>KERN_NOTICE</td>
<td>一个普通情况</td>
</tr>
<tr>
<td>KERN_INFO</td>
<td>一条非正式的消息</td>
</tr>
<tr>
<td>KERN_DEBUG</td>
<td>一条调试消息</td>
</tr>
</tbody>
</table>
</div>
<p><strong>oops</strong></p>
<p>oops 是内核通知用户有错误发生的最常用方式，这个过程包括：</p>
<ul>
<li>向终端上输出错误信息</li>
<li>输出寄存器中保存的信息</li>
<li>输出可供跟踪的回溯线索</li>
</ul>
<p>下面是一个 oops 的实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">➜  5-oops-mod git:(master) ✗ dmesg | tail -64</span><br><span class="line">[  139.812510] before init</span><br><span class="line">[  139.812512] BUG: kernel NULL pointer dereference, address: 0000000000000000</span><br><span class="line">[  139.812515] #PF: supervisor write access in kernel mode</span><br><span class="line">[  139.812516] #PF: error_code(0x0002) - not-present page</span><br><span class="line">[  139.812517] PGD 0 P4D 0 </span><br><span class="line">[  139.812519] Oops: 0002 [#1] SMP NOPTI</span><br><span class="line">[  139.812521] CPU: 1 PID: 3543 Comm: insmod Tainted: G           OE     5.15.0-48-generic #54~20.04.1-Ubuntu</span><br><span class="line">[  139.812523] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 11/12/2020</span><br><span class="line">[  139.812524] RIP: 0010:my_oops_init+0x15/0x31 [oops_mod]</span><br><span class="line">[  139.812528] Code: Unable to access opcode bytes at RIP 0xffffffffc0b1bfeb.</span><br><span class="line">[  139.812528] RSP: 0018:ffffb1bb85c6bb98 EFLAGS: 00010246</span><br><span class="line">[  139.812530] RAX: 000000000000000b RBX: 0000000000000000 RCX: 0000000000000027</span><br><span class="line">[  139.812530] RDX: 0000000000000000 RSI: ffffb1bb85c6b9e0 RDI: ffff942775e60588</span><br><span class="line">[  139.812531] RBP: ffffb1bb85c6bb98 R08: ffff942775e60580 R09: 0000000000000001</span><br><span class="line">[  139.812532] R10: 0000000000000001 R11: 000000000000000f R12: ffffffffc0b1c000</span><br><span class="line">[  139.812533] R13: ffff942695cb5ac0 R14: ffffffffc0b1e000 R15: 0000000000000000</span><br><span class="line">[  139.812534] FS:  00007f0f977db740(0000) GS:ffff942775e40000(0000) knlGS:0000000000000000</span><br><span class="line">[  139.812535] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[  139.812536] CR2: ffffffffc0b1bfeb CR3: 00000001a9510003 CR4: 0000000000770ee0</span><br><span class="line">[  139.812557] PKRU: 55555554</span><br><span class="line">[  139.812558] Call Trace:</span><br><span class="line">[  139.812559]  &lt;TASK&gt;</span><br><span class="line">[  139.812561]  do_one_initcall+0x46/0x1e0</span><br><span class="line">[  139.812565]  ? __cond_resched+0x19/0x40</span><br><span class="line">[  139.812568]  ? kmem_cache_alloc_trace+0x15a/0x420</span><br><span class="line">[  139.812571]  do_init_module+0x52/0x230</span><br><span class="line">[  139.812574]  load_module+0x1376/0x1600</span><br><span class="line">[  139.812576]  __do_sys_finit_module+0xbf/0x120</span><br><span class="line">[  139.812578]  ? __do_sys_finit_module+0xbf/0x120</span><br><span class="line">[  139.812579]  __x64_sys_finit_module+0x1a/0x20</span><br><span class="line">[  139.812581]  do_syscall_64+0x59/0xc0</span><br><span class="line">[  139.812583]  ? fput+0x13/0x20</span><br><span class="line">[  139.812584]  ? ksys_mmap_pgoff+0x14b/0x2a0</span><br><span class="line">[  139.812586]  ? exit_to_user_mode_prepare+0x3d/0x1c0</span><br><span class="line">[  139.812588]  ? exit_to_user_mode_prepare+0x3d/0x1c0</span><br><span class="line">[  139.812589]  ? syscall_exit_to_user_mode+0x27/0x50</span><br><span class="line">[  139.812591]  ? __x64_sys_mmap+0x33/0x50</span><br><span class="line">[  139.812592]  ? do_syscall_64+0x69/0xc0</span><br><span class="line">[  139.812593]  ? do_syscall_64+0x69/0xc0</span><br><span class="line">[  139.812594]  entry_SYSCALL_64_after_hwframe+0x61/0xcb</span><br><span class="line">[  139.812596] RIP: 0033:0x7f0f9792173d</span><br><span class="line">[  139.812598] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 8b 0d 23 37 0d 00 f7 d8 64 89 01 48</span><br><span class="line">[  139.812599] RSP: 002b:00007ffdee07d0f8 EFLAGS: 00000246 ORIG_RAX: 0000000000000139</span><br><span class="line">[  139.812600] RAX: ffffffffffffffda RBX: 000055e6a61767c0 RCX: 00007f0f9792173d</span><br><span class="line">[  139.812601] RDX: 0000000000000000 RSI: 000055e6a5c91358 RDI: 0000000000000003</span><br><span class="line">[  139.812602] RBP: 0000000000000000 R08: 0000000000000000 R09: 00007f0f979f8580</span><br><span class="line">[  139.812602] R10: 0000000000000003 R11: 0000000000000246 R12: 000055e6a5c91358</span><br><span class="line">[  139.812603] R13: 0000000000000000 R14: 000055e6a6176760 R15: 0000000000000000</span><br><span class="line">[  139.812604]  &lt;/TASK&gt;</span><br><span class="line">[  139.812605] Modules linked in: oops_mod(OE+) isofs xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xfrm_user xfrm_algo xt_addrtype iptable_filter iptable_nat nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 libcrc32c bpfilter br_netfilter bridge stp llc rfcomm aufs overlay bnep vsock_loopback vmw_vsock_virtio_transport_common vmw_vsock_vmci_transport vsock binfmt_misc nls_iso8859_1 intel_rapl_msr intel_rapl_common kvm_intel kvm crct10dif_pclmul ghash_clmulni_intel aesni_intel crypto_simd vmw_balloon cryptd btusb input_leds btrtl btbcm btintel bluetooth joydev serio_raw ecdh_generic ecc vmw_vmci mac_hid sch_fq_codel vmwgfx ttm drm_kms_helper cec rc_core fb_sys_fops syscopyarea sysfillrect sysimgblt msr parport_pc ppdev drm lp parport ip_tables x_tables autofs4 hid_generic crc32_pclmul usbhid ahci libahci psmouse hid e1000 mptspi pata_acpi mptscsih mptbase i2c_piix4 scsi_transport_spi</span><br><span class="line">[  139.812636] CR2: 0000000000000000</span><br><span class="line">[  139.812637] ---[ end trace 840a29bcd63bee0c ]---</span><br><span class="line">[  139.812638] RIP: 0010:my_oops_init+0x15/0x31 [oops_mod]</span><br><span class="line">[  139.812640] Code: Unable to access opcode bytes at RIP 0xffffffffc0b1bfeb.</span><br><span class="line">[  139.812641] RSP: 0018:ffffb1bb85c6bb98 EFLAGS: 00010246</span><br><span class="line">[  139.812642] RAX: 000000000000000b RBX: 0000000000000000 RCX: 0000000000000027</span><br><span class="line">[  139.812642] RDX: 0000000000000000 RSI: ffffb1bb85c6b9e0 RDI: ffff942775e60588</span><br><span class="line">[  139.812643] RBP: ffffb1bb85c6bb98 R08: ffff942775e60580 R09: 0000000000000001</span><br><span class="line">[  139.812644] R10: 0000000000000001 R11: 000000000000000f R12: ffffffffc0b1c000</span><br><span class="line">[  139.812644] R13: ffff942695cb5ac0 R14: ffffffffc0b1e000 R15: 0000000000000000</span><br><span class="line">[  139.812645] FS:  00007f0f977db740(0000) GS:ffff942775e40000(0000) knlGS:0000000000000000</span><br><span class="line">[  139.812646] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">[  139.812647] CR2: ffffffffc0b1bfeb CR3: 00000001a9510003 CR4: 0000000000770ee0</span><br><span class="line">[  139.812664] PKRU: 55555554</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Kernel/" rel="tag"><i class="fa fa-tag"></i> Kernel</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/18/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9ASocket%E7%AE%80%E8%BF%B0/" rel="prev" title="网络相关知识：Socket简述">
      <i class="fa fa-chevron-left"></i> 网络相关知识：Socket简述
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86/" rel="next" title="网络相关知识：网络抓包原理">
      网络相关知识：网络抓包原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E7%AE%80%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">Linux 内核简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">Linux 内核源码的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">4.</span> <span class="nav-text">进程的调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.</span> <span class="nav-text">内核数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">中断处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5"><span class="nav-number">8.</span> <span class="nav-text">内核同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4"><span class="nav-number">9.</span> <span class="nav-text">系统时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">11.</span> <span class="nav-text">虚拟文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9D%97I-O%E5%B1%82"><span class="nav-number">12.</span> <span class="nav-text">块I&#x2F;O层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">13.</span> <span class="nav-text">进程地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98-amp-%E9%A1%B5%E5%9B%9E%E5%86%99"><span class="nav-number">14.</span> <span class="nav-text">页高速缓存&amp;页回写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87-amp-%E6%A8%A1%E5%9D%97"><span class="nav-number">15.</span> <span class="nav-text">设备&amp;模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95"><span class="nav-number">16.</span> <span class="nav-text">内核调试</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">332</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:53</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
