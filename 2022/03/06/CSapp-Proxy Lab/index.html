<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Proxy Lab网络代理是一个在网络浏览器和终端服务器之间充当中间人的程序，而不是直接联系终端服务器以获取网页，浏览器会联系代理，代理会转发请求发送到终端服务器 当终端服务器回复代理时，代理将回复发送到浏览器 代理有很多用途：  有时在防火墙中使用代理，因此防火墙只能通过代理与防火墙之外的服务器联系 代理也可以充当匿名者：通过剥离所有标识信息的请求 代理可以使浏览器对Web匿名服务器 代理甚至可">
<meta property="og:type" content="article">
<meta property="og:title" content="CSapp-Proxy Lab">
<meta property="og:url" content="http://example.com/2022/03/06/CSapp-Proxy%20Lab/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="Proxy Lab网络代理是一个在网络浏览器和终端服务器之间充当中间人的程序，而不是直接联系终端服务器以获取网页，浏览器会联系代理，代理会转发请求发送到终端服务器 当终端服务器回复代理时，代理将回复发送到浏览器 代理有很多用途：  有时在防火墙中使用代理，因此防火墙只能通过代理与防火墙之外的服务器联系 代理也可以充当匿名者：通过剥离所有标识信息的请求 代理可以使浏览器对Web匿名服务器 代理甚至可">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/03/06/CSapp-Proxy%20Lab/1646286501329.png">
<meta property="og:image" content="http://example.com/2022/03/06/CSapp-Proxy%20Lab/1646475179455.png">
<meta property="og:image" content="http://example.com/2022/03/06/CSapp-Proxy%20Lab/1646286717853.png">
<meta property="og:image" content="http://example.com/2022/03/06/CSapp-Proxy%20Lab/1646312037232.png">
<meta property="article:published_time" content="2022-03-06T07:48:39.000Z">
<meta property="article:modified_time" content="2022-10-09T16:09:00.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="CSapp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/03/06/CSapp-Proxy%20Lab/1646286501329.png">

<link rel="canonical" href="http://example.com/2022/03/06/CSapp-Proxy%20Lab/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CSapp-Proxy Lab | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/CSapp-Proxy%20Lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSapp-Proxy Lab
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-06 15:48:39" itemprop="dateCreated datePublished" datetime="2022-03-06T15:48:39+08:00">2022-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-10 00:09:00" itemprop="dateModified" datetime="2022-10-10T00:09:00+08:00">2022-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>52k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>47 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Proxy-Lab"><a href="#Proxy-Lab" class="headerlink" title="Proxy Lab"></a>Proxy Lab</h2><p>网络代理是一个在网络浏览器和终端服务器之间充当中间人的程序，而不是直接联系终端服务器以获取网页，浏览器会联系代理，代理会转发请求发送到终端服务器</p>
<p>当终端服务器回复代理时，代理将回复发送到浏览器</p>
<p>代理有很多用途：</p>
<ul>
<li>有时在防火墙中使用代理，因此防火墙只能通过代理与防火墙之外的服务器联系</li>
<li>代理也可以充当匿名者：通过剥离所有标识信息的请求</li>
<li>代理可以使浏览器对Web匿名服务器</li>
<li>代理甚至可以通过存储来自服务器的对象的本地副本来缓存web对象，通过从缓存中读取请求来响应未来的请求，而不是通过再次与远程服务器</li>
</ul>
<p>在本实验室中，您将编写一个简单的HTTP代理来缓存web对象，在实验室的第一部分，你将设置代理以接受传入连接、读取和分析请求、将请求转发到web服务器、读取服务器的响应，并将这些响应转发给相应的客户端</p>
<p>第一部分：您将学习基本的HTTP操作，以及如何使用套接字编写通信程序通过网络连接</p>
<p>第二部分：您将升级代理以处理多个并发事件连接，这将向您介绍如何处理并发性，这是一个至关重要的系统概念</p>
<p>第三部分：您将使用一个简单的最近访问的内存缓存向代理添加缓存网络内容</p>
<h2 id="实验文件"><a href="#实验文件" class="headerlink" title="实验文件"></a>实验文件</h2><ul>
<li>proxy.c：启动代理服务器的代码写在此处</li>
<li>tiny：Tiny web服务器的源代码</li>
<li>driver.sh：打分文件</li>
</ul>
<p>在开始实验前，需要一些储备知识：</p>
<h2 id="服务器简析"><a href="#服务器简析" class="headerlink" title="服务器简析"></a>服务器简析</h2><p>每个网络应用都是基于客户端—服务器模型的，釆用这个模型，一个应用是由 <strong>一个服务器进程</strong> 和一个或者多个 <strong>客户端</strong> 进程组成 </p>
<img src="/2022/03/06/CSapp-Proxy%20Lab/1646286501329.png" class width="1646286501329"> 
<p>个客户端—服务器事务由以下四步组成：</p>
<ol>
<li>当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务，例如，当 Web 浏览器需要一个文件时，它就发送一个请求给 Web 服务器</li>
<li>服务器收到请求后，解释它，并以适当的方式操作它的资源，例如，当 Web 服务器收到浏览器发出的请求后，它就读一个磁盘文</li>
<li>服务器给客户端发送一个响应，并等待下一个请求，例如，Web 服务器将文件发送回客户端</li>
<li>客户端收到响应并处理它，例如，当 Web 浏览器收到来自服务器的一页后，就在屏幕上显示此页</li>
</ol>
<p><strong>服务器请求</strong></p>
<p>一般的请求消息如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /home.html HTTP/1.0 <span class="comment">&lt;!-- 请求消息行 --&gt;</span></span><br><span class="line">Accept: */* <span class="comment">&lt;!-- 请求消息头 --&gt;</span></span><br><span class="line">Host: localhost:GET /home.html HTTP/1.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: localhost:GET /home.html HTTP/1.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: localhost:</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</span><br><span class="line">Connection: close</span><br><span class="line">Proxy-Connection: close</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- 消息正文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span></span><br><span class="line">Dave O&#x27;Hallaron</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>请求消息行：请求消息的第一行为请求消息行</p>
<ul>
<li>例如：GET  /test/test.html  HTTP/1.1</li>
<li>GET 为请求方式，请求方式分为：Get（默认）、POST、DELETE、HEAD等<ul>
<li>GET：明文传输 不安全，数据量有限，不超过1kb</li>
<li>POST：暗文传输，安全，数据量没有限制</li>
</ul>
</li>
<li>/test/test.html 为URI，统一资源标识符</li>
<li>HTTP/1.1 为协议版本</li>
</ul>
</li>
<li><p>请求消息头：从第二行开始到空白行统称为请求消息头</p>
<ul>
<li>Accept：浏览器可接受的MIME类型告诉服务器客户端能接收什么样类型的文件</li>
<li>Accept-Charset：浏览器通过这个头告诉服务器，它支持哪种字符集</li>
<li>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如 gzip</li>
<li>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到，可以在浏览器中进行设置</li>
<li>Host：初始URL中的主机和端口</li>
<li>Referrer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</li>
<li>Content-Type：内容类型告诉服务器浏览器传输数据的MIME类型，文件传输的类型</li>
<li>If-Modified-Since：利用这个头与服务器的文件进行比对，如果一致，则从缓存中直接读取文件</li>
<li>User-Agent：浏览器类型</li>
<li>Content-Length：表示请求消息正文的长度</li>
<li>Connection：表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接）</li>
<li>Cookie：用于分辨两个请求是否来自同一个浏览器，以及保存一些状态信息</li>
<li>Date：请求时间GMT</li>
</ul>
</li>
<li><p>消息正文：当请求方式是[POST]方式时，才能看见消息正文，消息正文就是要传输的一些数据，如果没有数据需要传输时，消息正文为空</p>
</li>
</ul>
<p><strong>服务器响应</strong></p>
<p>一般的请求消息如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK <span class="comment">&lt;!-- 响应消息行 --&gt;</span></span><br><span class="line">Server: Tiny Web Server <span class="comment">&lt;!-- 响应消息头 --&gt;</span></span><br><span class="line">Content-length: 120</span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- 响应正文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span></span><br><span class="line">Dave O&#x27;Hallaron</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>响应消息行：第一行响应消息为响应消息行<ul>
<li>例如：HTTP/1.0 200 OK</li>
<li>HTTP/1.0 为协议版本</li>
<li>200 为响应状态码，常用的响应状态码有40余种，这里我们仅列出几种，详细请看：<ul>
<li>200：一切正常</li>
<li>302/307：临时重定向</li>
<li>304：未修改，客户端可以从缓存中读取数据，无需从服务器读取</li>
<li>404：服务器上不存在客户端所请求的资源</li>
<li>500：服务器内部错误</li>
</ul>
</li>
<li>OK 为状态码描述</li>
</ul>
</li>
<li>响应消息头：<ul>
<li>Location：指示新的资源的位置通常和302/307一起使用，完成请求重定向</li>
<li>Server：指示服务器的类型</li>
<li>Content-Encoding：服务器发送的数据采用的编码类型</li>
<li>Content-Length：告诉浏览器正文的长度</li>
<li>Content-Language：服务发送的文本的语言</li>
<li>Content-Type：服务器发送的内容的MIME类型</li>
<li>Last-Modified：文件的最后修改时间</li>
<li>Refresh：指示客户端刷新频率，单位是秒</li>
<li>Content-Disposition：指示客户端下载文件</li>
<li>Set-Cookie：服务器端发送的Cookie</li>
<li>Expires：-1</li>
<li>Cache-Control：no-cache (1.1)  </li>
<li>Pragma：no-cache   (1.0)  表示告诉客户端不要使用缓存</li>
<li>Connection：close/Keep-Alive   </li>
<li>Date：请求时间</li>
</ul>
</li>
<li>响应正文：即网页的源代码（F12可查看）</li>
</ul>
<h2 id="网络编程结构体"><a href="#网络编程结构体" class="headerlink" title="网络编程结构体"></a>网络编程结构体</h2><p><strong>通用结构体：struct sockaddr，16个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generic socket address structure (for connect, bind, and accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>   sa_family;      <span class="comment">/* Protocol family */</span></span><br><span class="line">    <span class="keyword">char</span>       sa_data[<span class="number">14</span>];    <span class="comment">/* Address data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct sockaddr 是一个通用地址结构，这是为了统一地址结构的表示方法，统一接口函数，使不同的地址结构可以被bind() , connect() 等函数调用</p>
<p>sockaddr的缺陷：sa_data 把目标地址和端口信息混在一起了 </p>
<p><strong>通用结构体：struct sockaddr_storage，128个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure large enough to hold any socket address </span></span><br><span class="line"><span class="comment">  (with the historical exception of AF_UNIX). 128 bytes reserved.  */</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ULONG_MAX &gt; 0xffffffff</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ss_aligntype __uint64_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ss_aligntype __uint32_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_SIZE        128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_PADSIZE     (_SS_SIZE - (2 * sizeof (__ss_aligntype)))</span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">     <span class="keyword">uint16_t</span>          ss_family;     <span class="comment">/* Address family */</span></span><br><span class="line">     __ss_aligntype   __ss_align;     <span class="comment">/* Force desired alignment.  */</span></span><br><span class="line">     <span class="keyword">char</span> __ss_padding[_SS_PADSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct sockaddr_storage 被设计为同时适合 struct sockaddr_in 和 struct sockaddr_in6 </p>
<p>为了避免试图知道要使用的IP版本，可以使用 struct sockaddr_storage，该版本可以保存其中任何一个，后将通过 connect()，bind() 等函数将其类型转换为 struct sockaddr 并以这种方式进行访问 </p>
<p><strong>IPv4：struct sockaddr_in，16个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IP socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_family;   <span class="comment">/* Protocol family (always AF_INET) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_port;     <span class="comment">/* 16位的端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">/* 32位的IP地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">sa_family_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (struct in_addr)]; <span class="comment">// sin_zero[8]</span></span><br><span class="line">    <span class="comment">/* Pad to sizeof(struct sockaddr) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  &#123;</span></span><br><span class="line">     <span class="keyword">in_addr_t</span>   s_addr;            <span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体解决了 sockaddr 的缺陷，把 port 和 addr 分开储存在两个变量中 </p>
<p><strong>IPv6：struct sockaddr_in6，28个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin6_family;      <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin6_port;        <span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    sin6_flowinfo;    <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>    <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;       <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> u6_addr8[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">uint16_t</span> u6_addr16[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> u6_addr32[<span class="number">4</span>];</span><br><span class="line">    &#125; in6_u;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr                 in6_u.u6_addr8</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr16               in6_u.u6_addr16</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr32               in6_u.u6_addr32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="网络编程中的信号"><a href="#网络编程中的信号" class="headerlink" title="网络编程中的信号"></a>网络编程中的信号</h2><p><strong>进程组</strong></p>
<p>进程组就是一系列相互关联的进程集合，系统中的每一个进程也必须从属于某一个进程组，每个进程组中都会有一个唯一的 ID(process group id)，简称 PGID，PGID 一般等同于进程组的创建进程的 Process ID，而这个进进程一般也会被称为进程组先导(process group leader)，同一进程组中除了进程组先导外的其他进程都是其子进程</p>
<p>进程组的存在，方便了系统对多个相关进程执行某些统一的操作，例如：我们可以一次性发送一个信号量给同一进程组中的所有进程</p>
<p><strong>会话</strong></p>
<p>会话（session）是一个若干进程组的集合，同样的，系统中每一个进程组也都必须从属于某一个会话</p>
<ul>
<li>一个会话只拥有最多一个控制终端（也可以没有），该终端为会话中所有进程组中的进程所共用</li>
<li>一个会话中前台进程组只会有一个，只有其中的进程才可以和控制终端进行交互，除了前台进程组外的进程组，都是后台进程组</li>
</ul>
<p>和进程组先导类似，会话中也有会话先导(session leader)的概念，用来表示建立起到控制终端连接的进程，在拥有控制终端的会话中，session leader 也被称为控制进程(controlling process)，一般来说控制进程也就是登入系统的 shell 进程(login shell)</p>
<p><strong>带外数据</strong></p>
<p>带外数据用于迅速告知对方本端发生的重要的事件，它比普通的数据（带内数据）拥有更高的优先级， <strong>不论发送缓冲区中是否有排队等待发送的数据，它总是被立即发送</strong> ，带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中，</p>
<p>​        // 实际应用中，带外数据是使用很少见，有 telnet 和 ftp 等远程非活跃程序</p>
<p>UDP没有没有实现带外数据传输，TCP也没有真正的带外数据，不过TCP利用头部的紧急指针标志和紧急指针，为应用程序提供了一种紧急方式，含义和带外数据类似，TCP的紧急方式利用传输普通数据的连接来传输紧急数据</p>
<p><strong>SIGHUP信号</strong>（关闭进程）</p>
<p>SIGHUP 信号在 <strong>用户终端连接(正常或非正常)结束</strong> 时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业(任务)，这时它们与控制终端不再关联</p>
<p>系统对SIGHUP信号的默认处理是：<strong>终止收到该信号的进程</strong> ，所以若程序中没有捕捉该信号，当收到该信号时，进程就会退出</p>
<p>SIGHUP会在以下3种情况下被发送给相应的进程：</p>
<ul>
<li>终端关闭时，该信号被发送到 session 首进程以及作为 job 提交的进程（即用 &amp; 符号提交的进程）</li>
<li>session 首进程退出时，该信号被发送到该 session 中的前台进程组中的每一个进程</li>
<li>若父进程退出导致进程组成为孤儿进程组，且该进程组中有进程处于停止状态（收到SIGSTOP或SIGTSTP信号），该信号会被发送到该进程组中的每一个进程</li>
</ul>
<p>例如：在我们登录Linux时，系统会分配给登录用户一个终端(Session)，在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session，当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号，这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止</p>
<p>​        // 晦涩难懂，需要在实例中理解分析</p>
<p><strong>SIGPIPE信号</strong>（告知中断）</p>
<p>当 <strong>往一个写端关闭的管道或 socket 连接中连续写入数据时会引发 SIGPIPE 信号</strong>（引发 SIGPIPE 信号的写操作将设置 errno 为EPIPE）</p>
<p>在TCP通信中，当通信的双方中的一方close一个连接时，若另一方接着发数据，根据TCP协议的规定，会收到一个RST(Reset the connection)响应报文，若再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，<strong>告诉进程这个连接已经断开了，不能再写入数据</strong></p>
<ul>
<li>即使断开还可以进行一次通信，第二次发送数据时才触发SIGPIPE</li>
<li>可以用相应的 handle 进行处理SIGPIPE，完成想要的操作</li>
</ul>
<p>服务器代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> sig)</span> <span class="comment">// 处理程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SIGPIPE : %d\n&quot;</span>,sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysendmsg</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入第一条消息</span></span><br><span class="line">    <span class="keyword">char</span>* msg1 = <span class="string">&quot;first msg&quot;</span>; </span><br><span class="line">    <span class="keyword">int</span> n = write(fd, msg1, <span class="built_in">strlen</span>(msg1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)  <span class="comment">//成功写入第一条消息,server接收到client发送的RST</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;success write %d bytes\n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入第二条消息,触发SIGPIPE</span></span><br><span class="line">    <span class="keyword">char</span>* msg2 = <span class="string">&quot;second msg&quot;</span>;</span><br><span class="line">    n = write(fd, msg2, <span class="built_in">strlen</span>(msg2));</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGPIPE , handle); <span class="comment">//注册信号捕捉函数</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(AF_INET , SOCK_STREAM , <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    bind(listenfd, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="comment">/* 把一个本地协议地址赋予一个套接字&#x27;listenfd&#x27; */</span></span><br><span class="line"></span><br><span class="line">    listen(listenfd, <span class="number">128</span>);</span><br><span class="line">    <span class="comment">/* 让&#x27;listenfd&#x27;变为被动监听状态 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = accept(listenfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 等待来自客户端的连接请求到达侦听描述符listenfd，返回一个已连接描述符 */</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysendmsg(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAX] = &#123;<span class="string">&#x27;0&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">socklen_t</span> slen;</span><br><span class="line">    slen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line"></span><br><span class="line">    bzero(&amp;seraddr,<span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(PORT);</span><br><span class="line">    seraddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//socket()</span></span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//connect()</span></span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd,(struct sockaddr *)&amp;seraddr,slen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 试图与“套接字地址为seraddr的服务器”建立一个因特网连接 */</span></span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = shutdown(sockfd , SHUT_RDWR);</span><br><span class="line">    <span class="comment">/* 禁止在sockfd上进行数据的接收与发送(关闭sockfd的读写功能) */</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;shutdown perror&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<img src="/2022/03/06/CSapp-Proxy%20Lab/1646475179455.png" class width="1646475179455"> 
<p>依次触发：write_msg1，handle，write_msg2</p>
<p>此外，因为<strong>SIGPIPE信号的默认行为是结束进程</strong>，而我们绝对不希望因为写操作的错误而导致程序退出，尤其是作为服务器程序来说就更恶劣了。所以我们应该对这种信号加以处理，在这里，介绍两种处理SIGPIPE信号的方式： </p>
<ol>
<li>给SIGPIPE设置SIG_IGN信号处理函数，忽略该信号：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGPIPE, SIG_IGN);</span><br></pre></td></tr></table></figure>
<p>前文说过，引发SIGPIPE信号的写操作将设置errno为EPIPE，所以，第二次往关闭的socket中写入数据时，会返回-1，同时errno置为EPIPE，这样，便能知道对端已经关闭，然后进行相应处理，而不会导致整个进程退出</p>
<ol>
<li>使用send函数的MSG_NOSIGNAL标志来禁止写操作触发SIGPIPE信号：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send(sockfd , buf , size , MSG_NOSIGNAL);</span><br></pre></td></tr></table></figure>
<p>同样，我们可以根据send函数反馈的errno来判断socket的读端是否已经关闭</p>
<p>此外，我们也可以通过IO复用函数来检测管道和socket连接的读端是否已经关闭，以POLL为例，当socket连接被对方关闭时，socket上的POLLRDHUP事件将被触发</p>
<p><strong>SIGURG信号</strong></p>
<p>内核通知应用程序带外数据到达的方式有两种：</p>
<ul>
<li>一种就是利用ＩＯ复用技术的系统调用（如select）在接受到带外数据时将返回，并向应用程序报告socket上的异常事件</li>
<li>另一种方法就是使用SIGURG信号</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/z_ryan/article/details/80952498">网络编程的三个重要信号</a></p>
<h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口</strong>（socket interface）是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用</p>
<p>大多数现代系统上都实现套接字接口，包括所有的 Unix 变种、Windows 和 Macintosh 系统</p>
<img src="/2022/03/06/CSapp-Proxy%20Lab/1646286717853.png" class width="1646286717853">  
<p>​        // 从 Linux 内核的角度来看，一个套接字就是 <strong>通信的一个端点</strong> ，从 Linux 程序的角度来看，套接字就是一个 <strong>有相应描述符的打开文件</strong></p>
<p>因特网的套接字地址存放在所示的类型为 sockaddr_in 的 16 字节结构中（IP 地址和端口号总是以网络字节顺序（大端法）存放的）</p>
<p>下面将介绍套接字接口中的部分函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// domain：即协议域，又称为协议族（family）</span></span><br><span class="line"><span class="comment">// type：指定socket类型</span></span><br><span class="line"><span class="comment">// protocol：指定协议</span></span><br></pre></td></tr></table></figure>
<p>​        // 协议族决定了 socket 的地址类型，在通信中必须采用对应的地址</p>
<p><strong>socket 函数</strong> 用于来返回一个 <strong>套接字描述符</strong> （clientfd）</p>
<ul>
<li>套接字描述符：用来标定系统为当前的进程划分的一块缓冲空间，类似于文件描述符 </li>
<li>文件描述符：是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符（open的返回值fd）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：需要绑定的socket</span></span><br><span class="line"><span class="comment">// *addr：存放了服务端用于通信的地址和端口</span></span><br><span class="line"><span class="comment">// addrlen: sizeof(sockaddr_in)</span></span><br></pre></td></tr></table></figure>
<p><strong>bind 函数</strong> 告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来</p>
<p>​        // bind函数把一个本地协议地址赋予一个套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> clientfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// clientfd：套接字描述符的一种</span></span><br><span class="line"><span class="comment">// addrlen：sizeof(sockaddr_in)</span></span><br></pre></td></tr></table></figure>
<p><strong>connect 函数</strong> 试图与 “套接字地址为 addr 的服务器” 建立一个因特网连接</p>
<p>如果成功，clientfd 描述符现在就准备好可以读写了(最好用 getaddrinfo 来为 connect 提供参数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：需要绑定的socket</span></span><br><span class="line"><span class="comment">// backlog：暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量</span></span><br></pre></td></tr></table></figure>
<p><strong>listen 函数</strong> 将 sockfd 从一个 <strong>主动套接字</strong> 转化为一个 <strong>监听套接字</strong> （listening socket），该套接字可以接受来自客户端的连接请求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, struct sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// listenfd：服务器的socket描述符</span></span><br><span class="line"><span class="comment">// *addr：指向struct sockaddr *的指针</span></span><br><span class="line"><span class="comment">// *addrlen：协议地址的长度</span></span><br></pre></td></tr></table></figure>
<p><strong>accept 函数</strong> 等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个 <strong>已连接描述符</strong> </p>
<p>一个服务器通常通常仅仅只创建一个监听socket描述字，内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *service,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> struct addrinfo *hints,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct addrinfo **result)</span></span>;</span><br><span class="line"><span class="comment">// host &amp; service：套接字地址的两个组成部分</span></span><br><span class="line"><span class="comment">// 可选的参数 hints 是一个 addrinfo 结构，它提供对 getaddrinfo 返回的套接字地址列表的更好的控制</span></span><br><span class="line"><span class="comment">// getaddrinfo 返回 result，result 一个指向 addrinfo 结构的链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *result)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> errcode)</span></span>; <span class="comment">// 返回：错误消息</span></span><br></pre></td></tr></table></figure>
<p><strong>getaddrinfo 函数</strong> 将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构，它是已弃用的 gethostbyname 和 getservbyname 函数的新的替代品 </p>
<p>在客户端调用了 getaddrinfo 之后，会遍历这个列表，依次尝试每个套接字地址，直到调用 socket 和 connect 成功，建立起连接，类似地，服务器会尝试遍历列表中的每个套接字地址，直到调用 socket 和 bind 成功，描述符会被绑定到一个合法的套接字地址，</p>
<ul>
<li>为了避免内存泄漏，应用程序必须在最后调用 freeaddrinfo，释放该链表</li>
<li>如果 getaddrinfo 返回非零的错误代码，应用程序可以调用 gai_streeror，将该代码转换成消息字符串</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>             ai_flags;      <span class="comment">/* Hints argument flags */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_family;     <span class="comment">/* First arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_socktype;   <span class="comment">/* Second arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_protocol;   <span class="comment">/* Third arg to socket function */</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname; <span class="comment">/* Canonical hostname */</span></span><br><span class="line">    <span class="keyword">size_t</span>          ai_addrlen;    <span class="comment">/* Size of ai_addr struct */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>      <span class="comment">/* Ptr to socket address structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>      <span class="comment">/* Ptr to next item in linked list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2022/03/06/CSapp-Proxy%20Lab/1646312037232.png" class width="1646312037232"> 
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">char</span> *host, <span class="keyword">size_t</span> hostlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">char</span> *service, <span class="keyword">size_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// *sa：指向大小为 salen 字节的套接字地址结构</span></span><br><span class="line"><span class="comment">// *host 指向大小为 hostlen 字节的缓冲区</span></span><br><span class="line"><span class="comment">// *service 指向大小为 servlen 字节的缓冲区</span></span><br><span class="line"><span class="comment">// 参数 flags 是一个位掩码，能够修改默认的行为</span></span><br></pre></td></tr></table></figure>
<p><strong>getnameinfo 函数</strong> 和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串，它是已弃用的 gethostbyaddr 和 getservbyport 函数的新的替代品 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span></span>;</span><br><span class="line"><span class="comment">// *hostname：服务器运行的地址</span></span><br><span class="line"><span class="comment">// *port：指向端口</span></span><br></pre></td></tr></table></figure>
<p>客户端调用 open_clientfd 建立与服务器的连接 </p>
<p><strong>open_clientfd 函数</strong> 建立与服务器的连接，该服务器运行在主机 hostname 上，并在端口号 port 上监听连接请求 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span>;</span><br><span class="line"><span class="comment">// *port：指向端口号</span></span><br></pre></td></tr></table></figure>
<p><strong>open_listenfd 函数</strong> 打开和返回一个监听描述符，这个描述符准备好在端口 port_h 接收连接请求 </p>
<p><strong>echo 客户端案例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">char</span> *host, *port, buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;host&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    host = argv[<span class="number">1</span>];</span><br><span class="line">    port = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    clientfd = Open_clientfd(host, port);</span><br><span class="line">    <span class="comment">/* 建立与服务器的连接，该服务器运行在主机hostname上，在端口号port上监听连接请求 */</span></span><br><span class="line">    Rio_readinitb(&amp;rio, clientfd);</span><br><span class="line">    <span class="comment">/* 将&quot;描述符clientfd&quot;和&quot;地址在rio处的一个的读缓冲区&quot;联系起来 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* 从标准输入中读取数据到buf */</span></span><br><span class="line">        Rio_writen(clientfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="comment">/* 从位置buf传送strlen(buf)个字节到描述符clientfd */</span></span><br><span class="line">        Rio_readlineb(&amp;rio, buf, MAXLINE);</span><br><span class="line">        <span class="comment">/* 从&amp;rio读出下一个文本行（包括结尾的换行符，数最多maxlen-1个字节），将它复制到内存位置buf，并且用NULL字符来结束这个文本行 */</span></span><br><span class="line">        Fputs(buf, <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="comment">/* 从&quot;标准输出&quot;输出buf */</span></span><br><span class="line">    &#125;</span><br><span class="line">    Close(clientfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在和服务器建立连接之后，客户端进入一个循环，反复从标准输入读取文本行，发送文本行给服务器，从服务器读取回送的行，并输出结果到标准输出</p>
<p>当 fgets 在标准输入上遇到 EOF 时，或者因为用户在键盘上键入 Ctrl+D，或者因为在一个重定向的输入文件中用尽了所有的文本行时，循环就终止</p>
<p><strong>echo 服务器案例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span> <span class="comment">/* Enough space for any address */</span></span><br><span class="line">    <span class="keyword">char</span> client_hostname[MAXLINE], client_port[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/* 打开和返回一个监听描述符，这个描述符准备好在端口argv[1]接收连接请求 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="comment">/* 等待来自客户端的连接请求到达侦听描述符listenfd，然后在clientaddr中填写客户端的套接字地址，并返回一个已连接描述符(connfd) */</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, client_hostname, MAXLINE,</span><br><span class="line">                    client_port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* 将一个套接字地址结构转换成相应的主机和服务名字符串 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Connected to (%s, %s)\n&quot;</span>, client_hostname, client_port);</span><br><span class="line">        <span class="comment">/* 打印客户端信息 */</span> </span><br><span class="line">        echo(connfd);</span><br><span class="line">        <span class="comment">/* 调用echo 函数为这些客户端服务 */</span></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, connfd);</span><br><span class="line">    <span class="comment">/* 将&quot;描述符clientfd&quot;和&quot;地址在rio处的一个的读缓冲区&quot;联系起来 */</span></span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 从&amp;rio读出下一个文本行（包括结尾的换行符，数最多maxlen-1个字节），将它复制到内存位置buf，并且用NULL字符来结束这个文本行 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server received %d bytes\n&quot;</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        Rio_writen(connfd, buf, n);</span><br><span class="line">        <span class="comment">/* 打印buf */</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在打开监听描述符后，它进入一个无限循环，每次循环都等待一个来自客户端的连接请求，输出已连接客户端的域名和 IP 地址，并调用 echo 函数为这些客户端服务，在 echo 程序返回后，主程序关闭已连接描述符，一旦客户端和服务器关闭了它们各自的描述符，连接也就终止了</p>
<p>echo函数将反复读写文本行，直到rio_readlineb函数遇到EOF</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/pashanhu6402/article/details/96428887?utm_source=app&amp;app_version=5.0.1&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">Socket原理讲解</a></p>
<h2 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h2><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑 <strong>同时</strong> 运行两个或两个以上的程序，一般情况下，两种类型的多任务处理：<strong>基于进程 和 基于线程</strong></p>
<ul>
<li>基于进程的多任务处理是程序的并发执行</li>
<li>基于线程的多任务处理是同一程序的片段的并发执行</li>
</ul>
<p>多线程程序包含可以同时运行的两个或多个部分，这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径</p>
<p>C语言中有专门控制线程的函数：</p>
<p><strong>创建新线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_create (thread, attr, start_routine, arg);</span><br></pre></td></tr></table></figure>
<ul>
<li>thread：指向线程标识符的指针</li>
<li>attr：一个不透明的属性对象，可以被用来设置线程属性，您可以指定线程属性对象，也可以使用默认值 NULL</li>
<li>start_routine：线程运行函数起始地址，一旦线程被创建就会执行（通常设置为某个函数）</li>
<li>arg：运行函数的参数，它必须通过把引用作为指针强制转换为 void 类型进行传递，如果没有传递参数，则使用 NULL</li>
</ul>
<p>pthread_create 创建一个新的线程，并让它可执行目标函数</p>
<p><strong>终止线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_exit (status);</span><br></pre></td></tr></table></figure>
<p>显式地退出一个线程，通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用，如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行，否则，它们将在 main() 结束时自动被终止</p>
<p><strong>连接和分离线程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_join (threadid, status) </span><br><span class="line">pthread_detach (threadid)</span><br></pre></td></tr></table></figure>
<ul>
<li>pthread_join()  阻塞等待线程退出（直到指定的 threadid 线程终止为止），获取线程退出状态</li>
<li>pthread_detach() 表示主线程与子线程（threadid）分离，两者相互不干涉，子线程结束同时子线程的资源自动回收 </li>
</ul>
<p>当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached），只有创建时定义为可连接的线程才可以被连接，如果线程创建时被定义为可分离的，则它永远也不能被连，pthread_join() 函数来等待线程的完成</p>
<p>​        // pthread库不是Linux系统默认的库，连接时需要使用库libpthread.a, 在使用pthread_create创建线程时，在编译中要加-lpthread参数: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -lpthread -o test</span><br></pre></td></tr></table></figure>
<p><strong>案例：pthread_join</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">64</span>];</span><br><span class="line">&#125;<span class="keyword">th_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">th_t</span>* retvar = (<span class="keyword">th_t</span>*)arg;</span><br><span class="line"></span><br><span class="line">    retvar-&gt;ch = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">    retvar-&gt;var = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(retvar-&gt;str, <span class="string">&quot;my thread&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;success!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程的退出可以将return换成pthread_exit</span></span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)retvar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">th_t</span>* retval = <span class="literal">NULL</span>;</span><br><span class="line">    retval = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">th_t</span>));</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, (<span class="keyword">void</span>*)retval);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 整个进程退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 阻塞并获取返回值(状态值) */</span></span><br><span class="line">    pthread_join(tid, (<span class="keyword">void</span>**)&amp;retval);</span><br><span class="line">    <span class="comment">/* 接下来就会演示把pthread_join注释后的结果 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c, var = %d, str = %s\n&quot;</span>, retval-&gt;ch, retval-&gt;var, retval-&gt;str);</span><br><span class="line">    <span class="keyword">if</span> (retval != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(retval);</span><br><span class="line">        retval = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 注意：这里只是将主线程退出，若还有其它子线程在运行则仍会运行</span></span><br><span class="line"><span class="comment">    而return将会使整个进程结束 */</span></span><br><span class="line"></span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  [/home/ywhkkx/桌面] gcc test.c -lpthread -o test</span><br><span class="line">➜  [/home/ywhkkx/桌面] ./test                      </span><br><span class="line">success!!!</span><br><span class="line">ch = m, var = <span class="number">200</span>, str = my thread</span><br></pre></td></tr></table></figure>
<p>把“pthread_join(tid, (void **)&amp;retval)”注释掉以后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  [/home/ywhkkx/桌面] gcc test.c -lpthread -o test</span><br><span class="line">➜  [/home/ywhkkx/桌面] ./test                      </span><br><span class="line">ch = , var = <span class="number">0</span>, str = </span><br><span class="line">success!!!</span><br></pre></td></tr></table></figure>
<p>发现主线程和副线程的执行次序改变了（主副线程同时执行，但是主线程先操作“retval”变量）</p>
<p>添加了“pthread_join”后，主线程就会被阻塞，直到标识符“tid”代表的副线程终止后，主线程才开始执行（需要副线程先给“retval”变量赋值后，主线程才可以打印出来）</p>
<p><strong>案例：pthread_detach</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thrd_func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am detach.\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">77</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thrd_func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实现线程分离，不再受主线程管理，由系统接任，线程结束后，其退出状态不由其他线程获取，而直接自己自动释放 */</span></span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_detach error:%s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main pid=%d, tid=%lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  [/home/ywhkkx/桌面] gcc test.c -lpthread -o test</span><br><span class="line">➜  [/home/ywhkkx/桌面] ./test                      </span><br><span class="line">i am detach.</span><br><span class="line">main pid=<span class="number">3830</span>, tid=<span class="number">140138689746752</span></span><br></pre></td></tr></table></figure>
<p>线程可以被置为 detach 状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态，不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误 </p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Robin5/p/11748016.html#_label0">C语言多线程操作</a></p>
<h2 id="实验一：实现顺序web代理"><a href="#实验一：实现顺序web代理" class="headerlink" title="实验一：实现顺序web代理"></a>实验一：实现顺序web代理</h2><p>实现一个顺序执行的代理，它可以处理GET方法并转发，对于其他方法可以不实现</p>
<p>命令行调用 “./proxy &lt; port &gt;” 来启动代理服务器，其中 port 可以通过实验包中的工具 port-for-user 来获取</p>
<p><strong>测试服务器</strong></p>
<p>运行该服务器，指定一个端口，必须是1024–49151之间的端口，其余端口不能使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  [/home/ywhkkx/proxylab-handout/tiny] ./tiny <span class="number">1444</span> </span><br></pre></td></tr></table></figure>
<p>在运行了TINY 服务器的基础上，打开另一个terminal，在linux shell输入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  [/home/ywhkkx/proxylab-handout/tiny] telnet localhost <span class="number">1444</span></span><br><span class="line">     telnet localhost <span class="number">1444</span></span><br><span class="line">Trying ::<span class="number">1.</span>..</span><br><span class="line">Trying <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line">GET /home.html HTTP/<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK <span class="comment">/* 200表示成功获取 */</span></span><br><span class="line">Server: Tiny Web Server</span><br><span class="line">Content-length: <span class="number">120</span></span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br><span class="line">&lt;html&gt; <span class="comment">// 获取的内容</span></span><br><span class="line">&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;img align=<span class="string">&quot;middle&quot;</span> src=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span><br><span class="line">Dave O<span class="number">&#x27;</span>Hallaron</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt; </span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure>
<p>此时服务端的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  [/home/ywhkkx/proxylab-handout/tiny] ./tiny <span class="number">1444</span></span><br><span class="line"><span class="function">Accepted connection <span class="title">from</span> <span class="params">(ip6-localhost, <span class="number">47590</span>)</span> <span class="comment">// 打印了用户信息</span></span></span><br><span class="line"><span class="function">GET /home.html HTTP/1.0</span></span><br></pre></td></tr></table></figure>
<p><strong>理解服务器代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_requesthdrs</span><span class="params">(<span class="keyword">rio_t</span>* rp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span>* uri, <span class="keyword">char</span>* filename, <span class="keyword">char</span>* cgiargs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* filename, <span class="keyword">int</span> filesize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_filetype</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">char</span>* filetype)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_dynamic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* filename, <span class="keyword">char</span>* cgiargs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* cause, <span class="keyword">char</span>* errnum,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span>* shortmsg, <span class="keyword">char</span>* longmsg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/* 打开和返回一个监听描述符，这个描述符准备好在端口 port_h 接收连接请求 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen); </span><br><span class="line">        <span class="comment">/* 等待来自客户端的连接请求到达侦听描述符listenfd，然后在clientaddr中填写客户端的套接字地址，并返回一个已连接描述符 */</span></span><br><span class="line">        Getnameinfo((SA*)&amp;clientaddr, clientlen, hostname, MAXLINE,</span><br><span class="line">            port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* 将一个套接字地址结构转换成相应的主机和服务名字符串 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);</span><br><span class="line">        <span class="comment">/* 调用打印信息 */</span> </span><br><span class="line">        doit(connfd);        </span><br><span class="line">        <span class="comment">/* 进行服务 */</span></span><br><span class="line">        Close(connfd);           </span><br><span class="line">        <span class="comment">/* 关闭连接 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> is_static;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span> <span class="comment">/* 这个结构体用来描述一个linux系统文件系统中的文件属性的结构 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> filename[MAXLINE], cgiargs[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">     <span class="comment">/* 将&quot;描述符fd&quot;和&quot;地址在rio处的一个的读缓冲区&quot;联系起来 */</span></span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE)) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 从&amp;rio读出下一个文本行（包括结尾的换行符，数最多MAXLINE-1个字节），将它复制到内存位置buf，并且用NULL字符来结束这个文本行 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="comment">/* 打印读取的数据 */</span></span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);       </span><br><span class="line">    <span class="comment">/* 输入&#x27;方法&#x27;,&#x27;标识&#x27;,&#x27;版本&#x27; */</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;                     </span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                   </span><br><span class="line">    read_requesthdrs(&amp;rio); </span><br><span class="line">    <span class="comment">/* 忽略请求报头中的信息 */</span></span><br><span class="line"></span><br><span class="line">    is_static = parse_uri(uri, filename, cgiargs); </span><br><span class="line">    <span class="comment">/* 解析uri(标识),得文件名存入filename中,参数存入cgiargs中 */</span></span><br><span class="line">    <span class="keyword">if</span> (stat(filename, &amp;sbuf) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">/* 将文件filename中的各个元数据填写进sbuf中,如果找不到文件返回0 */</span></span><br><span class="line">        clienterror(fd, filename, <span class="string">&quot;404&quot;</span>, <span class="string">&quot;Not found&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Tiny couldn&#x27;t find this file&quot;</span>);</span><br><span class="line">        <span class="comment">/* 向客户端返回错误信息 */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_static) &#123; </span><br><span class="line">        <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode)) &#123; </span><br><span class="line">            <span class="comment">/* 此文件为普通文件? 有读取权限?(-r)(若没有则return) */</span></span><br><span class="line">            clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Tiny couldn&#x27;t read the file&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serve_static(fd, filename, sbuf.st_size);  </span><br><span class="line">        <span class="comment">/* 提供静态服务(获取文件) */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode)) &#123; </span><br><span class="line">            <span class="comment">/* 此文件为普通文件? 有执行权限?(-x)(若没有则return) */</span></span><br><span class="line">            clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Tiny couldn&#x27;t run the CGI program&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serve_dynamic(fd, filename, cgiargs);       </span><br><span class="line">        <span class="comment">/* 提供动态服务(指令控制) */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_requesthdrs</span><span class="params">(<span class="keyword">rio_t</span>* rp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 读这些请求报头，直到空行，然后返回，跳过这些请求报头的 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    Rio_readlineb(rp, buf, MAXLINE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>)) &#123;          </span><br><span class="line">        Rio_readlineb(rp, buf, MAXLINE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span>* uri, <span class="keyword">char</span>* filename, <span class="keyword">char</span>* cgiargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 解析uri，得文件名存入filename中，参数存入cgiargs中 */</span></span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 据uri中是否含有cgi-bin来判断请求的是静态内容还是动态内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strstr</span>(uri, <span class="string">&quot;cgi-bin&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* 静态内容 */</span></span><br><span class="line">        <span class="built_in">strcpy</span>(cgiargs, <span class="string">&quot;&quot;</span>);                             </span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">&quot;.&quot;</span>);                           </span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);                           </span><br><span class="line">        <span class="keyword">if</span> (uri[<span class="built_in">strlen</span>(uri) - <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>)                   </span><br><span class="line">            <span class="built_in">strcat</span>(filename, <span class="string">&quot;home.html&quot;</span>);               </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">/* 动态内容 */</span></span><br><span class="line">        ptr = index(uri, <span class="string">&#x27;?&#x27;</span>);                           </span><br><span class="line">        <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, ptr + <span class="number">1</span>);</span><br><span class="line">            *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strcpy</span>(cgiargs, <span class="string">&quot;&quot;</span>);                         </span><br><span class="line">        <span class="built_in">strcpy</span>(filename, <span class="string">&quot;.&quot;</span>);                           </span><br><span class="line">        <span class="built_in">strcat</span>(filename, uri);                           </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* filename, <span class="keyword">int</span> filesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 打开文件名为filename的文件，把它映射到一个虚拟存储器空间，将文件的前filesize字节映射到从地址srcp开始的虚拟存储区域 */</span></span><br><span class="line">    <span class="keyword">int</span> srcfd;</span><br><span class="line">    <span class="keyword">char</span>* srcp, filetype[MAXLINE], buf[MAXBUF];</span><br><span class="line">    </span><br><span class="line">    get_filetype(filename, filetype);   </span><br><span class="line">    <span class="comment">/* 从*filename中获取filetype */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>); </span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n&quot;</span>, filesize);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: %s\r\n\r\n&quot;</span>, filetype);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));   </span><br><span class="line"></span><br><span class="line">    srcfd = Open(filename, O_RDONLY, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">/* 打开目标文件(只读方式) */</span></span><br><span class="line">    srcp = Mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">/* 让系统自动选定地址，把filesize字节的数据映射到内存，映射区域可被读取，对映射区域的写入操作会产生一个映射文件的复制(私人的“写入时复制”)，将要映射到内存中的文件描述符为‘srcfd’ */</span></span><br><span class="line">    Close(srcfd);                       </span><br><span class="line">    Rio_writen(fd, srcp, filesize);    </span><br><span class="line">    <span class="comment">/* 把内存中的‘srcp’读到fd */</span></span><br><span class="line">    Munmap(srcp, filesize);   </span><br><span class="line">    <span class="comment">/* 解除内存映射 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_filetype</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">char</span>* filetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 根据filename获取文件格式 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.html&quot;</span>))</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.gif&quot;</span>))</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/gif&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.png&quot;</span>))</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;.jpg&quot;</span>))</span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">strcpy</span>(filetype, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_dynamic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* filename, <span class="keyword">char</span>* cgiargs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Tiny在发送了响应的第一部分后，通过派生一个子进程并在子进程的上下文中运行一个cgi程序（可执行文件），来提供各种类型的动态内容 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], * emptylist[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">/* 在父进程中，fork返回子进程的进程ID，在子进程中，fork返回0 */</span></span><br><span class="line">        setenv(<span class="string">&quot;QUERY_STRING&quot;</span>, cgiargs, <span class="number">1</span>); <span class="comment">/* 设置QUERY_STRING环境变量 */</span></span><br><span class="line">        Dup2(fd, STDOUT_FILENO); <span class="comment">/* 重定向它的标准输出到已连接描述符 */</span>         </span><br><span class="line">        Execve(filename, emptylist, environ); <span class="comment">/* 加载运行cgi程序 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    Wait(<span class="literal">NULL</span>); <span class="comment">/* 允许线程阻止其自身执行(父进程等待) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* cause, <span class="keyword">char</span>* errnum,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span>* shortmsg, <span class="keyword">char</span>* longmsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 向客户端返回错误信息 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印HTTP响应头 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 %s %s\r\n&quot;</span>, errnum, shortmsg);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印HTTP响应正文 */</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;body bgcolor=&quot;</span><span class="string">&quot;ffffff&quot;</span><span class="string">&quot;&gt;\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s: %s\r\n&quot;</span>, errnum, shortmsg);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;p&gt;%s: %s\r\n&quot;</span>, longmsg, cause);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tiny是一个迭代服务器，监听在命令行中确定的端口上的连接请求，在通过 open_listenedfd 函数打开一个监听套接字以后，Tiny执行典型的无限服务循环，反复地接受一个连接(accept)请求，执行事务(doit)，最后关闭连接描述符(close)</p>
<p><strong>编写代理</strong></p>
<p>网络代理是一个在网络浏览器和终端服务器之间充当中间人的程序，而不是直接联系终端服务器以获取网页，浏览器会联系代理，代理会转发请求发送到终端服务器</p>
<p>用户在代理中输入指令，代理会解析指令并发送到服务器，同时它也会接收服务器上的反馈，并返回给用户</p>
<p>先抄 TINY 的框架：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Recommended max cache and object sizes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CACHE_SIZE 1049000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* You won&#x27;t lose style points for including this long line in your code */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* user_agent_hdr = <span class="string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* conn_hdr = <span class="string">&quot;Connection: close\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* prox_hdr = <span class="string">&quot;Proxy-Connection: close\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* cause, <span class="keyword">char</span>* errnum,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span>* shortmsg, <span class="keyword">char</span>* longmsg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span>* uri, <span class="keyword">char</span>* hostname, <span class="keyword">char</span>* path, <span class="keyword">int</span>* port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread</span><span class="params">(<span class="keyword">void</span>* vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd; </span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN); <span class="comment">/* 新添:给SIGPIPE设置SIG_IGN信号处理函数，忽略该信号 */</span></span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/* 打开和返回一个监听描述符，这个描述符准备好在端口port_h接收连接请求 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listening..\n&quot;</span>);</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line">        <span class="comment">/* 等待来自客户端的连接请求到达侦听描述符listenfd，然后在clientaddr中填写客户端的套接字地址，并返回一个已连接描述符 */</span></span><br><span class="line"></span><br><span class="line">        Getnameinfo((SA*)&amp;clientaddr, clientlen, hostname, MAXLINE,</span><br><span class="line">            port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* 获取用户信息 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);</span><br><span class="line">        <span class="comment">/* 打印用户信息 */</span></span><br><span class="line">        doit(connfd);</span><br><span class="line">        <span class="comment">/* 执行服务程序 */</span></span><br><span class="line">        Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> client_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endserver_fd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> from_client, to_endserver;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], path[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;from_client, client_fd);</span><br><span class="line">    <span class="comment">/* 将&quot;描述符client_fd&quot;和&quot;地址在from_client处的一个的读缓冲区&quot;联系起来 */</span></span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;from_client, buf, MAXLINE))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 从&amp;from_client读出下一个文本行（包括结尾的换行符，数最多MAXLINE-1个字节），将它复制到内存位置buf，并且用NULL字符来结束这个文本行 */</span></span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">        clienterror(client_fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Proxy Server does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    parse_uri(uri, hostname, path, &amp;port); <span class="comment">/* 改写:这个函数代码不同了 */</span></span><br><span class="line">	<span class="comment">/* 解析uri，得文件名存入filename中，参数存入cgiargs中 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line">    <span class="comment">/* 后面的内容TINY完全不同了(clienterror函数除外) */</span></span><br><span class="line">    <span class="comment">/*------------------------------------------------------------*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> port_str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(port_str, <span class="string">&quot;%d&quot;</span>, port);</span><br><span class="line">    endserver_fd = Open_clientfd(hostname, port_str);</span><br><span class="line">    <span class="comment">/* 将socket和connect封装成Open_clientfd，客户端可以用它来和服务器建立连接 */</span></span><br><span class="line">    <span class="keyword">if</span> (endserver_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Rio_readinitb(&amp;to_endserver, endserver_fd);</span><br><span class="line">    <span class="comment">/* 将&quot;描述符endserver_fd&quot;和&quot;地址在to_endserver处的一个的读缓冲区&quot;联系起来 */</span></span><br><span class="line">    <span class="keyword">char</span> newreq[MAXLINE]; </span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, path);</span><br><span class="line">    build_requesthdrs(&amp;from_client, newreq, hostname); <span class="comment">/* 新添:这是一个全新的函数 */</span></span><br><span class="line">    Rio_writen(endserver_fd, newreq, <span class="built_in">strlen</span>(newreq)); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;to_endserver, buf, MAXLINE))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>,n); <span class="comment">/* 新添:提示语句 */</span></span><br><span class="line">        Rio_writen(client_fd, buf, n); <span class="comment">/* 新增:向客户端发送请求的数据 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打印获取的数据 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* cause, <span class="keyword">char</span>* errnum,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span>* shortmsg, <span class="keyword">char</span>* longmsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], body[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;&lt;html&gt;&lt;title&gt;Proxy Error&lt;/title&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;body bgcolor=&quot;</span><span class="string">&quot;ffffff&quot;</span><span class="string">&quot;&gt;\r\n&quot;</span>, body);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s%s: %s\r\n&quot;</span>, body, errnum, shortmsg);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;p&gt;%s: %s\r\n&quot;</span>, body, longmsg, cause);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;hr&gt;&lt;em&gt;The Proxy Web server&lt;/em&gt;\r\n&quot;</span>, body);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 %s %s\r\n&quot;</span>, errnum, shortmsg);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n\r\n&quot;</span>, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(body));</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    Rio_writen(fd, body, <span class="built_in">strlen</span>(body));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面编写两个 改动&amp;新增 的函数：（这两个函数需要按照 “实验要求” 进行编写）</p>
<p>实验要求 消息请求行&amp;消息请求头为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /hub/index.html HTTP/<span class="number">1.0</span></span><br><span class="line">Host: www.cmu.edu</span><br><span class="line">Connection: close</span><br><span class="line">Proxy-Connection: close </span><br></pre></td></tr></table></figure>
<p>而我们在 Proxy 写入的指令为：（其中“GET”和“HTTP/1.0”已经被处理）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.cmu.edu/hub/index.html HTTP/<span class="number">1.0</span></span><br></pre></td></tr></table></figure>
<p>所以这两个函数的作用，就是把 uri（统一资源标识符）转化为请求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span> *uri,<span class="keyword">char</span> *hostname,<span class="keyword">char</span> *path,<span class="keyword">int</span> *port)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* hostname: www.cmu.edu */</span></span><br><span class="line">    <span class="comment">/* path: /hub/index.html */</span></span><br><span class="line">    *port = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">char</span>* pos1 = <span class="built_in">strstr</span>(uri,<span class="string">&quot;//&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pos1 = uri;</span><br><span class="line">    &#125; <span class="keyword">else</span> pos1 += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* pos2 = <span class="built_in">strstr</span>(pos1,<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *pos2 = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">        <span class="built_in">strncpy</span>(hostname,pos1,MAXLINE);</span><br><span class="line">        <span class="built_in">sscanf</span>(pos2+<span class="number">1</span>,<span class="string">&quot;%d%s&quot;</span>,port,path); </span><br><span class="line">        *pos2 = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos2 = <span class="built_in">strstr</span>(pos1,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(hostname,pos1,MAXLINE);</span><br><span class="line">            <span class="built_in">strcpy</span>(path,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *pos2 = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(hostname,pos1,MAXLINE);</span><br><span class="line">        *pos2 = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(path,pos2,MAXLINE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_requesthdrs</span><span class="params">(<span class="keyword">rio_t</span> *rp, <span class="keyword">char</span> *newreq, <span class="keyword">char</span> *hostname, <span class="keyword">char</span>* port)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 用于构建请求，把写入代理的指令进行包装，传输进服务器 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(Rio_readlineb(rp, buf, MAXLINE) &gt; <span class="number">0</span>) &#123;          </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf,<span class="string">&quot;Host:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf,<span class="string">&quot;User-Agent:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf,<span class="string">&quot;Connection:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf,<span class="string">&quot;Proxy-Connection:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(newreq,<span class="string">&quot;%s%s&quot;</span>, newreq,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;%sHost: %s:%s\r\n&quot;</span>,newreq, hostname,port);</span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;%s%s%s%s&quot;</span>, newreq, user_agent_hdr,conn_hdr,prox_hdr);</span><br><span class="line">    <span class="built_in">sprintf</span>(newreq,<span class="string">&quot;%s\r\n&quot;</span>,newreq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体逻辑：</p>
<ul>
<li>代理的前半部分和服务器如出一辙，先作为服务器链接用户端，然后调用 doit 启动自身服务，在 doit 中为“用户端的描述符”绑定内存空间，并把用户端信息复制到该空间，接着输入指令装入其中，并调用 parse_uri 进行解析</li>
<li>代理的后半部分又将作为客户端与目标服务器进行通信，先连接服务器并生成描述符，接着用类似的操作为“服务端的描述符”绑定内存空间，然后调用 build_requesthdrs 生成对应的服务请求，最后发送服务请求并打印数据</li>
</ul>
<p>打分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">➜  [/home/ywhkkx/proxylab-handout] ./driver.sh </span><br><span class="line">*** Basic ***</span><br><span class="line">Starting tiny on <span class="number">4113</span></span><br><span class="line">Starting proxy on <span class="number">21528</span></span><br><span class="line"><span class="number">1</span>: home.html</span><br><span class="line">   Fetching ./tiny/home.html into ./.proxy <span class="keyword">using</span> the proxy</span><br><span class="line">   Fetching ./tiny/home.html into ./.noproxy directly from Tiny</span><br><span class="line">   Comparing the two files</span><br><span class="line">   Success: Files are identical.</span><br><span class="line"><span class="number">2</span>: csapp.c</span><br><span class="line">   Fetching ./tiny/csapp.c into ./.proxy <span class="keyword">using</span> the proxy</span><br><span class="line">   Fetching ./tiny/csapp.c into ./.noproxy directly from Tiny</span><br><span class="line">   Comparing the two files</span><br><span class="line">   Success: Files are identical.</span><br><span class="line"><span class="number">3</span>: tiny.c</span><br><span class="line">   Fetching ./tiny/tiny.c into ./.proxy <span class="keyword">using</span> the proxy</span><br><span class="line">   Fetching ./tiny/tiny.c into ./.noproxy directly from Tiny</span><br><span class="line">   Comparing the two files</span><br><span class="line">   Success: Files are identical.</span><br><span class="line"><span class="number">4</span>: godzilla.jpg</span><br><span class="line">   Fetching ./tiny/godzilla.jpg into ./.proxy <span class="keyword">using</span> the proxy</span><br><span class="line">   Fetching ./tiny/godzilla.jpg into ./.noproxy directly from Tiny</span><br><span class="line">   Comparing the two files</span><br><span class="line">   Success: Files are identical.</span><br><span class="line"><span class="number">5</span>: tiny</span><br><span class="line">   Fetching ./tiny/tiny into ./.proxy <span class="keyword">using</span> the proxy</span><br><span class="line">   Fetching ./tiny/tiny into ./.noproxy directly from Tiny</span><br><span class="line">   Comparing the two files</span><br><span class="line">   Success: Files are identical.</span><br><span class="line">Killing tiny <span class="keyword">and</span> proxy</span><br><span class="line">basicScore: <span class="number">40</span>/<span class="number">40</span></span><br></pre></td></tr></table></figure>
<h2 id="实验二：实现多线程web代理"><a href="#实验二：实现多线程web代理" class="headerlink" title="实验二：实现多线程web代理"></a>实验二：实现多线程web代理</h2><p>整体变化不大，直接挂代码了：（我会标记改动的地方）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Recommended max cache and object sizes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CACHE_SIZE 1049000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* You won&#x27;t lose style points for including this long line in your code */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* user_agent_hdr = <span class="string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* conn_hdr = <span class="string">&quot;Connection: close\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* prox_hdr = <span class="string">&quot;Proxy-Connection: close\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* cause, <span class="keyword">char</span>* errnum,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span>* shortmsg, <span class="keyword">char</span>* longmsg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span>* uri, <span class="keyword">char</span>* hostname, <span class="keyword">char</span>* path, <span class="keyword">int</span>* port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread</span><span class="params">(<span class="keyword">void</span>* vargp)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, * connfd; <span class="comment">/* 不同:这里变指针了 */</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listening..\n&quot;</span>);</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="comment">/* 不同:这里改为在堆中分配内存空间(原来是栈,栈不稳定) */</span></span><br><span class="line">        *connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">        Getnameinfo((SA*)&amp;clientaddr, clientlen, hostname, MAXLINE,</span><br><span class="line">            port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfd);</span><br><span class="line">        <span class="comment">/* 新添:Pthread_create用于创建子线程(从thread开始执行,参数为connfd) */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread</span><span class="params">(<span class="keyword">void</span>* vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connfd = *((<span class="keyword">int</span>*)vargp);</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="comment">/* 设定线程分离,使其永远不会影响主线程 */</span></span><br><span class="line">    Free(vargp);</span><br><span class="line">    <span class="comment">/* 因为执行了Pthread_detach,所以free的操作不会影响到主线程 */</span></span><br><span class="line">    doit(connfd);</span><br><span class="line">    <span class="comment">/* 执行服务程序 */</span></span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> client_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endserver_fd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> from_client, to_endserver;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], path[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;from_client, client_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;from_client, buf, MAXLINE))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">        clienterror(client_fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Proxy Server does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parse_uri(uri, hostname, path, &amp;port);</span><br><span class="line">    <span class="keyword">char</span> port_str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(port_str, <span class="string">&quot;%d&quot;</span>, port);</span><br><span class="line">    endserver_fd = Open_clientfd(hostname, port_str);</span><br><span class="line">    <span class="keyword">if</span> (endserver_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Rio_readinitb(&amp;to_endserver, endserver_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> newreq[MAXLINE]; </span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, path);</span><br><span class="line">    build_requesthdrs(&amp;from_client, newreq, hostname);</span><br><span class="line"></span><br><span class="line">    Rio_writen(endserver_fd, newreq, <span class="built_in">strlen</span>(newreq)); </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;to_endserver, buf, MAXLINE))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>,n);</span><br><span class="line">        Rio_writen(client_fd, buf, n);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* cause, <span class="keyword">char</span>* errnum,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span>* shortmsg, <span class="keyword">char</span>* longmsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], body[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;&lt;html&gt;&lt;title&gt;Proxy Error&lt;/title&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;body bgcolor=&quot;</span><span class="string">&quot;ffffff&quot;</span><span class="string">&quot;&gt;\r\n&quot;</span>, body);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s%s: %s\r\n&quot;</span>, body, errnum, shortmsg);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;p&gt;%s: %s\r\n&quot;</span>, body, longmsg, cause);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;hr&gt;&lt;em&gt;The Proxy Web server&lt;/em&gt;\r\n&quot;</span>, body);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 %s %s\r\n&quot;</span>, errnum, shortmsg);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n\r\n&quot;</span>, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(body));</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    Rio_writen(fd, body, <span class="built_in">strlen</span>(body));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span>* uri, <span class="keyword">char</span>* hostname, <span class="keyword">char</span>* path, <span class="keyword">int</span>* port)</span> </span>&#123;</span><br><span class="line">    *port = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">char</span>* pos1 = <span class="built_in">strstr</span>(uri, <span class="string">&quot;//&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pos1 = uri;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> pos1 += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* pos2 = <span class="built_in">strstr</span>(pos1, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *pos2 = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">        <span class="built_in">strncpy</span>(hostname, pos1, MAXLINE);</span><br><span class="line">        <span class="built_in">sscanf</span>(pos2 + <span class="number">1</span>, <span class="string">&quot;%d%s&quot;</span>, port, path); </span><br><span class="line">        *pos2 = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pos2 = <span class="built_in">strstr</span>(pos1, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(hostname, pos1, MAXLINE);</span><br><span class="line">            <span class="built_in">strcpy</span>(path, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *pos2 = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(hostname, pos1, MAXLINE);</span><br><span class="line">        *pos2 = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(path, pos2, MAXLINE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_requesthdrs</span><span class="params">(<span class="keyword">rio_t</span>* rp, <span class="keyword">char</span>* newreq, <span class="keyword">char</span>* hostname, <span class="keyword">char</span>* port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Rio_readlineb(rp, buf, MAXLINE) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;Host:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;User-Agent:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;Connection:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;Proxy-Connection:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;%s%s&quot;</span>, newreq, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;%sHost: %s:%s\r\n&quot;</span>, newreq, hostname, port);</span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;%s%s%s%s&quot;</span>, newreq, user_agent_hdr, conn_hdr, prox_hdr);</span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;%s\r\n&quot;</span>, newreq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*** Concurrency ***</span><br><span class="line">Starting tiny on port <span class="number">11348</span></span><br><span class="line">Starting proxy on port <span class="number">8656</span></span><br><span class="line">Starting the blocking NOP server on port <span class="number">8806</span></span><br><span class="line">Trying to fetch a file from the blocking nop-server</span><br><span class="line">Fetching ./tiny/home.html into ./.noproxy directly from Tiny</span><br><span class="line">Fetching ./tiny/home.html into ./.proxy <span class="keyword">using</span> the proxy</span><br><span class="line">Checking whether the proxy fetch succeeded</span><br><span class="line">Success: Was able to fetch tiny/home.html from the proxy.</span><br><span class="line">Killing tiny, proxy, <span class="keyword">and</span> nop-server</span><br><span class="line">concurrencyScore: <span class="number">15</span>/<span class="number">15</span></span><br></pre></td></tr></table></figure>
<h2 id="实验三：缓存web对象"><a href="#实验三：缓存web对象" class="headerlink" title="实验三：缓存web对象"></a>实验三：缓存web对象</h2><p>要求实现缓存客户端的请求</p>
<ul>
<li>其中最大的缓存块大小要小于 MAX_OBJECT_SIZE（102400）</li>
<li>总的缓存大小 MAX_CACHE_SIZE（1049000）</li>
<li>cache需要牺牲缓存块时，运用LRU算法</li>
<li>在实现过程中需要解决不同线程同时访问cache的问题</li>
</ul>
<p><strong>定义cache结构体</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPES 6</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> cache_block_size[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> cache_cnt[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_block</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* url;				<span class="comment">/* 用于唯一确定所需要的cache */</span></span><br><span class="line">    <span class="keyword">char</span>* data;				<span class="comment">/* cache中存放的数据 */</span></span><br><span class="line">    <span class="keyword">int</span> datasize;			<span class="comment">/* 数据的长度 */</span></span><br><span class="line">    <span class="keyword">int64_t</span> time;			<span class="comment">/* 当前用户的时间*/</span></span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> rwlock; <span class="comment">/* 锁的状态 */</span></span><br><span class="line">&#125; cache_block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_type</span>&#123;</span></span><br><span class="line">    cache_block *cacheobjs; <span class="comment">/* 指向“存储客户端的请求消息”的内存空间 */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; cache_type;</span><br><span class="line"></span><br><span class="line">cache_type caches[TYPES];</span><br></pre></td></tr></table></figure>
<p><strong>LRU(基于系统时间)+隐式+暴力获取(直接遍历所有cache)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cache_block_size[] = &#123;<span class="number">102</span>, <span class="number">1024</span>, <span class="number">5120</span> ,<span class="number">10240</span>,<span class="number">25600</span>, <span class="number">102400</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cache_cnt[] = &#123;<span class="number">40</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* cache初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; TYPES; i++) &#123;</span><br><span class="line">        <span class="comment">/* 不同组的cache大小不同,组数也不同 */</span></span><br><span class="line">        caches[i].size = cache_cnt[i];</span><br><span class="line">        caches[i].cacheobjs </span><br><span class="line">              = (cache_block *)<span class="built_in">malloc</span>(cache_cnt[i] * <span class="keyword">sizeof</span>(cache_block));</span><br><span class="line">        cache_block *j = caches[i].cacheobjs;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; cache_cnt[i]; j++, k++) &#123;</span><br><span class="line">            <span class="comment">/* 把组中每一个元素的各个区域进行操作(重置为&quot;0&quot;或申请存储区) */</span></span><br><span class="line">            j-&gt;time = <span class="number">0</span>;</span><br><span class="line">            j-&gt;datasize = <span class="number">0</span>;</span><br><span class="line">            j-&gt;url = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * MAXLINE);</span><br><span class="line">            <span class="built_in">strcpy</span>(j-&gt;url,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            j-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * cache_block_size[i]);</span><br><span class="line">            <span class="built_in">memset</span>(j-&gt;data,<span class="number">0</span>,cache_block_size[i]);</span><br><span class="line">            pthread_rwlock_init(&amp;j-&gt;rwlock,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">/* 初始化一个读写锁 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_cache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; TYPES; i++) &#123;</span><br><span class="line">        cache_block *j = caches[i].cacheobjs;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; cache_cnt[i]; j++, k++) &#123;</span><br><span class="line">            <span class="built_in">free</span>(j-&gt;url);</span><br><span class="line">            <span class="built_in">free</span>(j-&gt;data);</span><br><span class="line">            pthread_rwlock_destroy(&amp;j-&gt;rwlock);</span><br><span class="line">            <span class="comment">/* 释放读写锁 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(caches[i].cacheobjs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_cache</span><span class="params">(<span class="keyword">char</span> *url,<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tar = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    cache_type cur;</span><br><span class="line">    cache_block *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read cache %s \n&quot;</span>, url);</span><br><span class="line">    <span class="keyword">for</span> (; tar &lt; TYPES; tar++) &#123;</span><br><span class="line">        <span class="comment">/* 遍历cache中的信息,依次对比url */</span></span><br><span class="line">        cur = caches[tar];</span><br><span class="line">        p = cur.cacheobjs;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; cur.size; i++,p++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;time != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(url,p-&gt;url) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; cur.size) <span class="keyword">break</span>;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == cur.size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read cache fail\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;p-&gt;rwlock);</span><br><span class="line">    <span class="comment">/* 读锁定读写锁 */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(url,p-&gt;url) != <span class="number">0</span>)&#123;</span><br><span class="line">        pthread_rwlock_unlock(&amp;p-&gt;rwlock);</span><br><span class="line">        <span class="comment">/* 解锁读写锁 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_unlock(&amp;p-&gt;rwlock);</span><br><span class="line">    <span class="comment">/* 解锁读写锁 */</span></span><br><span class="line">    <span class="keyword">if</span> (!pthread_rwlock_trywrlock(&amp;p-&gt;rwlock)) &#123;</span><br><span class="line">        <span class="comment">/* 非阻塞写锁定 */</span></span><br><span class="line">        p-&gt;time = currentTimeMillis();</span><br><span class="line">        <span class="comment">/* 返回当前的计算机时间 */</span></span><br><span class="line">        pthread_rwlock_unlock(&amp;p-&gt;rwlock); </span><br><span class="line">        <span class="comment">/* 解锁读写锁 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;p-&gt;rwlock);</span><br><span class="line">    <span class="comment">/* 读锁定读写锁 */</span></span><br><span class="line">    Rio_writen(fd,p-&gt;data,p-&gt;datasize);</span><br><span class="line">    pthread_rwlock_unlock(&amp;p-&gt;rwlock);</span><br><span class="line">    <span class="comment">/* 解锁读写锁 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read cache successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cache</span><span class="params">(<span class="keyword">char</span> *url, <span class="keyword">char</span> *data, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; tar &lt; TYPES &amp;&amp; len &gt; cache_block_size[tar]; tar++) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write cache %s %d\n&quot;</span>, url, tar);</span><br><span class="line">    <span class="comment">/* 寻找空cache块 */</span></span><br><span class="line">    cache_type cur = caches[tar];</span><br><span class="line">    cache_block *p = cur.cacheobjs, *pt;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; cur.size;i++,p++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;time == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* 实现LRU */</span></span><br><span class="line">    <span class="keyword">int64_t</span> min = currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span>(i == cur.size)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>,pt = cur.cacheobjs;i&lt;cur.size;i++,pt++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pt-&gt;time &lt;= min)&#123;</span><br><span class="line">                min = pt-&gt;time;</span><br><span class="line">                p = pt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;p-&gt;rwlock);</span><br><span class="line">    <span class="comment">/* 写锁定读写锁 */</span></span><br><span class="line">    p-&gt;time = currentTimeMillis();</span><br><span class="line">    p-&gt;datasize = len;</span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;url,url,MAXLINE);</span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;data,data,len);</span><br><span class="line">    pthread_rwlock_unlock(&amp;p-&gt;rwlock);</span><br><span class="line">    <span class="comment">/* 解锁读写锁 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write Cache\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line">  gettimeofday(&amp;time, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 把目前的时间通过time所指的结构返回,当地时区的信息则放到NULL所指的结构中 */</span></span><br><span class="line">  <span class="keyword">int64_t</span> s1 = (<span class="keyword">int64_t</span>)(time.tv_sec) * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">int64_t</span> s2 = (time.tv_usec / <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于锁我没有深入学习，这里挂个博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/renxinyuan/p/3875659.html">读写锁函数说明</a> </p>
<p>最后需要把这些函数插入到原来的代码中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;csapp.h&quot;</span></span></span><br><span class="line"><span class="comment">/* Recommended max cache and object sizes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CACHE_SIZE 1049000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* You won&#x27;t lose style points for including this long line in your code */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* user_agent_hdr = <span class="string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* conn_hdr = <span class="string">&quot;Connection: close\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* prox_hdr = <span class="string">&quot;Proxy-Connection: close\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPES 6</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> cache_block_size[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> cache_cnt[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* url;</span><br><span class="line">    <span class="keyword">char</span>* data;</span><br><span class="line">    <span class="keyword">int</span> datasize;</span><br><span class="line">    <span class="keyword">int64_t</span> time;</span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line">&#125; cache_block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_type</span> &#123;</span></span><br><span class="line">    cache_block* cacheobjs; <span class="comment">/* 指向“存储客户端的请求消息”的内存空间 */</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; cache_type;</span><br><span class="line"></span><br><span class="line">cache_type caches[TYPES];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* cause, <span class="keyword">char</span>* errnum,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span>* shortmsg, <span class="keyword">char</span>* longmsg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span>* uri, <span class="keyword">char</span>* hostname, <span class="keyword">char</span>* path, <span class="keyword">int</span>* port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread</span><span class="params">(<span class="keyword">void</span>* vargp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_cache</span><span class="params">(<span class="keyword">char</span>* url, <span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cache</span><span class="params">(<span class="keyword">char</span>* url, <span class="keyword">char</span>* data, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_cache</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cache_block_size[] = &#123; <span class="number">102</span>, <span class="number">1024</span>, <span class="number">5120</span> ,<span class="number">10240</span>,<span class="number">25600</span>, <span class="number">102400</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cache_cnt[] = &#123; <span class="number">40</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; TYPES; i++) &#123;</span><br><span class="line">        caches[i].size = cache_cnt[i];</span><br><span class="line">        caches[i].cacheobjs</span><br><span class="line">            = (cache_block*)<span class="built_in">malloc</span>(cache_cnt[i] * <span class="keyword">sizeof</span>(cache_block));</span><br><span class="line">        cache_block* j = caches[i].cacheobjs;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; cache_cnt[i]; j++, k++) &#123;</span><br><span class="line">            j-&gt;time = <span class="number">0</span>;</span><br><span class="line">            j-&gt;datasize = <span class="number">0</span>;</span><br><span class="line">            j-&gt;url = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * MAXLINE);</span><br><span class="line">            <span class="built_in">strcpy</span>(j-&gt;url, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            j-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * cache_block_size[i]);</span><br><span class="line">            <span class="built_in">memset</span>(j-&gt;data, <span class="number">0</span>, cache_block_size[i]);</span><br><span class="line">            pthread_rwlock_init(&amp;j-&gt;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_cache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; TYPES; i++) &#123;</span><br><span class="line">        cache_block* j = caches[i].cacheobjs;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; cache_cnt[i]; j++, k++) &#123;</span><br><span class="line">            <span class="built_in">free</span>(j-&gt;url);</span><br><span class="line">            <span class="built_in">free</span>(j-&gt;data);</span><br><span class="line">            pthread_rwlock_destroy(&amp;j-&gt;rwlock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(caches[i].cacheobjs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_cache</span><span class="params">(<span class="keyword">char</span>* url, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tar = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    cache_type cur;</span><br><span class="line">    cache_block* p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read cache %s \n&quot;</span>, url);</span><br><span class="line">    <span class="keyword">for</span> (; tar &lt; TYPES; tar++) &#123;</span><br><span class="line">        cur = caches[tar];</span><br><span class="line">        p = cur.cacheobjs;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cur.size; i++, p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;time != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(url, p-&gt;url) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; cur.size) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == cur.size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read cache fail\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;p-&gt;rwlock);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(url, p-&gt;url) != <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_rwlock_unlock(&amp;p-&gt;rwlock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_unlock(&amp;p-&gt;rwlock);</span><br><span class="line">    <span class="keyword">if</span> (!pthread_rwlock_trywrlock(&amp;p-&gt;rwlock)) &#123;</span><br><span class="line">        p-&gt;time = currentTimeMillis();</span><br><span class="line">        pthread_rwlock_unlock(&amp;p-&gt;rwlock);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;p-&gt;rwlock);</span><br><span class="line">    Rio_writen(fd, p-&gt;data, p-&gt;datasize);</span><br><span class="line">    pthread_rwlock_unlock(&amp;p-&gt;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read cache successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_cache</span><span class="params">(<span class="keyword">char</span>* url, <span class="keyword">char</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tar = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; tar &lt; TYPES &amp;&amp; len &gt; cache_block_size[tar]; tar++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write cache %s %d\n&quot;</span>, url, tar);</span><br><span class="line">    <span class="comment">/* 寻找空cache块 */</span></span><br><span class="line">    cache_type cur = caches[tar];</span><br><span class="line">    cache_block* p = cur.cacheobjs, * pt;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cur.size; i++, p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;time == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 实现LRU */</span></span><br><span class="line">    <span class="keyword">int64_t</span> min = currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (i == cur.size) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, pt = cur.cacheobjs; i &lt; cur.size; i++, pt++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pt-&gt;time &lt;= min) &#123;</span><br><span class="line">                min = pt-&gt;time;</span><br><span class="line">                p = pt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;p-&gt;rwlock);</span><br><span class="line">    p-&gt;time = currentTimeMillis();</span><br><span class="line">    p-&gt;datasize = len;</span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;url, url, MAXLINE);</span><br><span class="line">    <span class="built_in">memcpy</span>(p-&gt;data, data, len);</span><br><span class="line">    pthread_rwlock_unlock(&amp;p-&gt;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write Cache\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">currentTimeMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line">    gettimeofday(&amp;time, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int64_t</span> s1 = (<span class="keyword">int64_t</span>)(time.tv_sec) * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> s2 = (time.tv_usec / <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> s1 + s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, * connfd;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    init_cache(); <span class="comment">/* 新添:增加cache初始化操作 */</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listening..\n&quot;</span>);</span><br><span class="line">        clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = Malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        *connfd = Accept(listenfd, (SA*)&amp;clientaddr, &amp;clientlen);</span><br><span class="line"></span><br><span class="line">        Getnameinfo((SA*)&amp;clientaddr, clientlen, hostname, MAXLINE,</span><br><span class="line">            port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    free_cache(); <span class="comment">/* 新增:服务完成后释放cache */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread</span><span class="params">(<span class="keyword">void</span>* vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connfd = *((<span class="keyword">int</span>*)vargp);</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    Free(vargp);</span><br><span class="line">    doit(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> client_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endserver_fd;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> from_client, to_endserver;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], path[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;from_client, client_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;from_client, buf, MAXLINE))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">        clienterror(client_fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Proxy Server does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 新增:从cache中读取信息,如果读取成功返回给客户端(client_fd) */</span></span><br><span class="line">    <span class="keyword">int</span> ret = read_cache(uri, client_fd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parse_uri(uri, hostname, path, &amp;port);</span><br><span class="line">    <span class="keyword">char</span> port_str[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(port_str, <span class="string">&quot;%d&quot;</span>, port);</span><br><span class="line">    endserver_fd = Open_clientfd(hostname, port_str);</span><br><span class="line">    <span class="keyword">if</span> (endserver_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Rio_readinitb(&amp;to_endserver, endserver_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> newreq[MAXLINE];</span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, path);</span><br><span class="line">    build_requesthdrs(&amp;from_client, newreq, hostname);</span><br><span class="line"></span><br><span class="line">    Rio_writen(endserver_fd, newreq, <span class="built_in">strlen</span>(newreq));</span><br><span class="line">    <span class="keyword">int</span> n, size = <span class="number">0</span>; <span class="comment">/* 新增:参数size */</span></span><br><span class="line">    <span class="keyword">char</span> data[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="keyword">while</span> ((n = Rio_readlineb(&amp;to_endserver, buf, MAXLINE))) &#123;</span><br><span class="line">        <span class="comment">/* 新增:cache存储的数据不能太大,过大的数据将会被丢弃 */</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt;= MAX_OBJECT_SIZE) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(data + size, buf, n);</span><br><span class="line">            size += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>, n);</span><br><span class="line">        Rio_writen(client_fd, buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %d\n&quot;</span>, size);</span><br><span class="line">    <span class="comment">/* 新增:在cache中写入信息,下次申请前会进行读取操作,读取到后立刻返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; MAX_OBJECT_SIZE) &#123;</span><br><span class="line">        write_cache(uri, data, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clienterror</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* cause, <span class="keyword">char</span>* errnum,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span>* shortmsg, <span class="keyword">char</span>* longmsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], body[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;&lt;html&gt;&lt;title&gt;Proxy Error&lt;/title&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;body bgcolor=&quot;</span><span class="string">&quot;ffffff&quot;</span><span class="string">&quot;&gt;\r\n&quot;</span>, body);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s%s: %s\r\n&quot;</span>, body, errnum, shortmsg);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;p&gt;%s: %s\r\n&quot;</span>, body, longmsg, cause);</span><br><span class="line">    <span class="built_in">sprintf</span>(body, <span class="string">&quot;%s&lt;hr&gt;&lt;em&gt;The Proxy Web server&lt;/em&gt;\r\n&quot;</span>, body);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 %s %s\r\n&quot;</span>, errnum, shortmsg);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: text/html\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n\r\n&quot;</span>, (<span class="keyword">int</span>)<span class="built_in">strlen</span>(body));</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    Rio_writen(fd, body, <span class="built_in">strlen</span>(body));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span>* uri, <span class="keyword">char</span>* hostname, <span class="keyword">char</span>* path, <span class="keyword">int</span>* port)</span> </span>&#123;</span><br><span class="line">    *port = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">char</span>* pos1 = <span class="built_in">strstr</span>(uri, <span class="string">&quot;//&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pos1 = uri;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> pos1 += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* pos2 = <span class="built_in">strstr</span>(pos1, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pos2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *pos2 = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(hostname, pos1, MAXLINE);</span><br><span class="line">        <span class="built_in">sscanf</span>(pos2 + <span class="number">1</span>, <span class="string">&quot;%d%s&quot;</span>, port, path);</span><br><span class="line">        *pos2 = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pos2 = <span class="built_in">strstr</span>(pos1, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(hostname, pos1, MAXLINE);</span><br><span class="line">            <span class="built_in">strcpy</span>(path, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *pos2 = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(hostname, pos1, MAXLINE);</span><br><span class="line">        *pos2 = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="built_in">strncpy</span>(path, pos2, MAXLINE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_requesthdrs</span><span class="params">(<span class="keyword">rio_t</span>* rp, <span class="keyword">char</span>* newreq, <span class="keyword">char</span>* hostname, <span class="keyword">char</span>* port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Rio_readlineb(rp, buf, MAXLINE) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;\r\n&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;Host:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;User-Agent:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;Connection:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(buf, <span class="string">&quot;Proxy-Connection:&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;%s%s&quot;</span>, newreq, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;%sHost: %s:%s\r\n&quot;</span>, newreq, hostname, port);</span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;%s%s%s%s&quot;</span>, newreq, user_agent_hdr, conn_hdr, prox_hdr);</span><br><span class="line">    <span class="built_in">sprintf</span>(newreq, <span class="string">&quot;%s\r\n&quot;</span>, newreq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*** Cache ***</span><br><span class="line">Starting tiny on port <span class="number">10306</span></span><br><span class="line">Starting proxy on port <span class="number">2574</span></span><br><span class="line">Fetching ./tiny/tiny.c into ./.proxy <span class="keyword">using</span> the proxy</span><br><span class="line">Fetching ./tiny/home.html into ./.proxy <span class="keyword">using</span> the proxy</span><br><span class="line">Fetching ./tiny/csapp.c into ./.proxy <span class="keyword">using</span> the proxy</span><br><span class="line">Killing tiny</span><br><span class="line">Fetching a cached copy of ./tiny/home.html into ./.noproxy</span><br><span class="line">Success: Was able to fetch tiny/home.html from the cache.</span><br><span class="line">Killing proxy</span><br><span class="line">cacheScore: <span class="number">15</span>/<span class="number">15</span></span><br><span class="line"></span><br><span class="line">totalScore: <span class="number">70</span>/<span class="number">70</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/CSapp/" rel="tag"><i class="fa fa-tag"></i> CSapp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/05/House%20Of%20Force-2.23-64/" rel="prev" title="House Of Force-2.23-64">
      <i class="fa fa-chevron-left"></i> House Of Force-2.23-64
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/08/House%20Of%20Einherjar-2.23-64/" rel="next" title="House Of Einherjar-2.23-64">
      House Of Einherjar-2.23-64 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy-Lab"><span class="nav-number">1.</span> <span class="nav-text">Proxy Lab</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%96%87%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">实验文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">服务器简析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">4.</span> <span class="nav-text">网络编程结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="nav-number">5.</span> <span class="nav-text">网络编程中的信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.</span> <span class="nav-text">套接字接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">多线程编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0%E9%A1%BA%E5%BA%8Fweb%E4%BB%A3%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">实验一：实现顺序web代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8Bweb%E4%BB%A3%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">实验二：实现多线程web代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E7%BC%93%E5%AD%98web%E5%AF%B9%E8%B1%A1"><span class="nav-number">10.</span> <span class="nav-text">实验三：缓存web对象</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">329</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:32</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
