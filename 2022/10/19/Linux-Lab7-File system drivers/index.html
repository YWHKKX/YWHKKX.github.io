<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="File system drivers 实验室目标：  获取有关Linux中虚拟文件系统（VFS）的知识，并了解有关“inode”，“dentry”，“file”，超级块和数据块的概念 了解在 VFS 中挂载文件系统的过程 了解各种文件系统类型，并了解具有物理支持的文件系统（在磁盘上）和没有物理支持的文件系统之间的差异  Virtual File System (VFS) 虚拟文件系统（也称为 V">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-Lab7-File system drivers">
<meta property="og:url" content="http://example.com/2022/10/19/Linux-Lab7-File%20system%20drivers/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="File system drivers 实验室目标：  获取有关Linux中虚拟文件系统（VFS）的知识，并了解有关“inode”，“dentry”，“file”，超级块和数据块的概念 了解在 VFS 中挂载文件系统的过程 了解各种文件系统类型，并了解具有物理支持的文件系统（在磁盘上）和没有物理支持的文件系统之间的差异  Virtual File System (VFS) 虚拟文件系统（也称为 V">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-19T15:32:33.000Z">
<meta property="article:modified_time" content="2022-10-20T10:52:48.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="Kernel">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/10/19/Linux-Lab7-File%20system%20drivers/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux-Lab7-File system drivers | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/19/Linux-Lab7-File%20system%20drivers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux-Lab7-File system drivers
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-19 23:32:33" itemprop="dateCreated datePublished" datetime="2022-10-19T23:32:33+08:00">2022-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-20 18:52:48" itemprop="dateModified" datetime="2022-10-20T18:52:48+08:00">2022-10-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>41k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>38 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>File system drivers</strong></p>
<p>实验室目标：</p>
<ul>
<li>获取有关Linux中虚拟文件系统（VFS）的知识，并了解有关“inode”，“dentry”，“file”，超级块和数据块的概念</li>
<li>了解在 VFS 中挂载文件系统的过程</li>
<li>了解各种文件系统类型，并了解具有物理支持的文件系统（在磁盘上）和没有物理支持的文件系统之间的差异</li>
</ul>
<p><strong>Virtual File System (VFS)</strong></p>
<p>虚拟文件系统（也称为 VFS）是内核的一个组件，用于处理与文件和文件系统相关的所有系统调用</p>
<ul>
<li>VFS 是用户和特定文件系统之间的通用接口</li>
<li>VFS 的抽象简化了文件系统的实现，并提供了多个文件系统的集成</li>
<li>文件系统的实现就通过使用 VFS 提供的 API 来完成，通用硬件和 I/O 子系统通信部分由 VFS 处理</li>
</ul>
<p>从功能的角度来看，文件系统可以分为：</p>
<ul>
<li>磁盘文件系统（ext3, ext4, xfs, fat, ntfs …… ）</li>
<li>网络文件系统（nfs, smbfs/cifs, ncp …… ）</li>
<li>虚拟文件系统（procfs, sysfs, sockfs, pipefs …… ）</li>
</ul>
<p>Linux 内核将 VFS 用于目录和文件的层次结构（树），使用挂载操作将新的文件系统添加为 VFS 子树</p>
<p>VFS 可以使用普通文件作为虚拟块设备，因此可以在普通文件上挂载磁盘文件系统，这样，可以创建文件系统堆栈</p>
<p>VFS 的基本思想是提供一个可以表示来自任何文件系统的文件的单个文件模型，文件系统驱动程序负责引入公分母，这样，内核就可以创建包含整个系统的单个目录结构，将有一个文件系统将成为根，其余的将挂载在其各个目录中</p>
<p><strong>The general file system model</strong></p>
<p>通用文件系统模型（任何实现的文件系统都需要简化为通用文件系统模型）由几个明确定义的实体组成：</p>
<ul>
<li>超级块 superblock<ul>
<li>超级块存储已挂载文件系统所需的信息：<ul>
<li>输入和块位置</li>
<li>文件系统块大小</li>
<li>最大文件名长度</li>
<li>最大文件大小</li>
<li>根输入节点的位置</li>
</ul>
</li>
<li>对于磁盘文件系统，超级块在磁盘的第一个块中有一个对应项（文件系统控制块）</li>
</ul>
</li>
<li>索引结点 inode<ul>
<li>保留有关一般意义上的文件的信息：常规文件，目录，特殊文件 (pipe，fifo)，块设备，字符设备，链接，或任何可以抽象为文件的内容</li>
<li>一个索引结点存储信息：<ul>
<li>文件类型</li>
<li>文件大小</li>
<li>访问权限</li>
<li>访问或修改时间</li>
<li>磁盘上数据的位置（指向包含数据的磁盘块的指针）</li>
</ul>
</li>
<li>像超级块一样，每个 inodes 都有一个磁盘对应物，磁盘上的索引节点通常被分组到一个专门的区域（inode 区域，与数据块区域分开），在某些文件系统中，inode 的等效项分布在文件系统结构（FAT）中</li>
</ul>
</li>
<li>文件 file<ul>
<li>文件是最接近用户的文件系统模型的组件，该结构仅作为 VFS 实体存在于内存中，并且在磁盘上没有物理对应项</li>
<li>文件对象表示进程已打开的文件，维护以下信息：<ul>
<li>文件光标位置</li>
<li>文件打开权限</li>
<li>指向关联 inode 的指针（最终为其索引）</li>
</ul>
</li>
</ul>
</li>
<li>目录项 dentry<ul>
<li>目录（目录条目）将索引节点与文件名相关联</li>
<li>通常，dentry 结构包含两个字段：<ul>
<li>标识 inode 的整数</li>
<li>表示其名称的字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这些实体是文件系统元数据（它们包含有关数据或其他元数据的信息），其中需要注意的就是 <code>inode</code> 和 <code>file</code></p>
<p>从文件系统的角度来看，<code>inode</code> 表示文件：</p>
<ul>
<li><code>inode</code> 的属性是与文件关联的大小，权限，时间</li>
<li><code>inode</code> 唯一标识文件系统中的文件</li>
</ul>
<p>从用户的角度来看，<code>file</code> 表示文件：</p>
<ul>
<li><code>file</code> 的属性是 <code>inode</code>，文件名，文件打开属性，文件位置</li>
<li>所有打开的文件都有与之关联的 <code>file</code> 结构体</li>
</ul>
<p><strong>Register and unregister filesystems</strong></p>
<p>在单个系统上，不太可能有超过 5-6 个文件系统</p>
<p>因此，文件系统（或者更准确地说，文件系统类型）作为模块实现，并且可以随时加载或卸载</p>
<ul>
<li>描述特定文件系统的结构是 <code>file_system_type</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">int</span> fs_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_REQUIRES_DEV		1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_BINARY_MOUNTDATA	2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_HAS_SUBTYPE		4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_MOUNT		8	<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_DISALLOW_NOTIFY_PERM	16	<span class="comment">/* Disable fanotify permission events */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_THP_SUPPORT		8192	<span class="comment">/* Remove once all fs converted */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_RENAME_DOES_D_MOVE	32768	<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">	<span class="keyword">int</span> (*init_fs_context)(struct fs_context *);</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter_spec</span> *<span class="title">parameters</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">		       <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">	<span class="keyword">void</span> (*kill_sb) (struct super_block *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了能够动态加载/卸载文件系统模块，需要文件系统注册/注销的 API</p>
<p>将文件系统注册到内核中的操作，通常在模块初始化函数中执行，为了注册文件系统，需要完成如下的工作：</p>
<ul>
<li>填充 <code>file_system_type</code> 结构体（至少填充：<code>name</code> <code>mount</code> <code>kill_sb</code> <code>fs_flags</code>）</li>
<li>调用 <code>register_filesystem</code> 函数</li>
</ul>
<p>卸载模块时，必须通过调用函数 <code>unregister_filesystem</code> 来注销文件系统</p>
<p>注册操作系统的案例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">ramfs_fs_type</span> =</span> &#123;</span><br><span class="line">        .name           = <span class="string">&quot;ramfs&quot;</span>,</span><br><span class="line">        .mount          = ramfs_mount,</span><br><span class="line">        .kill_sb        = ramfs_kill_sb,</span><br><span class="line">        .fs_flags       = FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_ramfs_fs</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (test_and_set_bit(<span class="number">0</span>, &amp;once))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> register_filesystem(&amp;ramfs_fs_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>挂载文件系统时，内核会调用 <code>file_system_type-&gt;mount</code>，该函数会进行一组初始化并返回表示挂载点目录的 dentry 结构，最简单的做法是在 <code>mount</code> 中使用如下 API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dentry *<span class="title">mount_bdev</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> (*fill_super)(struct super_block *, <span class="keyword">void</span> *, <span class="keyword">int</span>))</span></span>; <span class="comment">/* 挂载存储在块设备上的文件系统 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct dentry *<span class="title">mount_single</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> flags, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> (*fill_super)(struct super_block *, <span class="keyword">void</span> *, <span class="keyword">int</span>))</span></span>; <span class="comment">/* 挂载在所有挂载操作之间共享的文件系统 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct dentry *<span class="title">mount_nodev</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> flags, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> (*fill_super)(struct super_block *, <span class="keyword">void</span> *, <span class="keyword">int</span>))</span></span>; <span class="comment">/* 挂载不在物理设备上的文件系统 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct dentry *<span class="title">mount_pseudo</span><span class="params">(struct file_system_type *fs_type, <span class="keyword">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">	     <span class="keyword">const</span> struct super_operations *ops,</span></span></span><br><span class="line"><span class="params"><span class="function">	     <span class="keyword">const</span> struct dentry_operations *dops, <span class="keyword">unsigned</span> <span class="keyword">long</span> magic)</span></span>; <span class="comment">/* 伪文件系统的帮助器函数(例如:sockfs,pipe,通常是无法挂载的文件系统的) */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这些函数会获取一个指针，该指针指向将在超级块初始化后调用的函数，以完成驱动程序的初始化</li>
</ul>
<p>卸载文件系统时，内核调用 <code>kill_sb</code>，它将会执行清理操作并调用以下 API 中的一个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_block_super</span><span class="params">(struct super_block *sb)</span></span>; <span class="comment">/* 卸载块设备上的文件系统 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_anon_super</span><span class="params">(struct super_block *sb)</span></span>; <span class="comment">/* 卸载虚拟文件系统 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill_litter_super</span><span class="params">(struct super_block *sb)</span></span>; <span class="comment">/* 卸载不在物理设备上的文件系统 */</span></span><br></pre></td></tr></table></figure>
<p><strong>Superblock in VFS</strong></p>
<p>超级块既作为物理实体存在（磁盘上的实体），也作为 VFS 实体存在（结构体 <code>super_block</code>），超级块仅包含信息，用于从磁盘写入和读取元数据</p>
<p>超级块操作由以下结构描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">   	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span> <span class="comment">/* 分配inode关联的资源 */</span></span><br><span class="line">	<span class="keyword">void</span> (*destroy_inode)(struct inode *); <span class="comment">/* 销毁inode关联的资源 */</span></span><br><span class="line">	<span class="keyword">void</span> (*free_inode)(struct inode *);</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">void</span> (*dirty_inode) (struct inode *, <span class="keyword">int</span> flags);</span><br><span class="line">	<span class="keyword">int</span> (*write_inode) (struct inode *, struct writeback_control *wbc); <span class="comment">/* 写入inode关联的资源 */</span></span><br><span class="line">	<span class="keyword">int</span> (*drop_inode) (struct inode *);</span><br><span class="line">	<span class="keyword">void</span> (*evict_inode) (struct inode *);</span><br><span class="line">	<span class="keyword">void</span> (*put_super) (struct super_block *); <span class="comment">/* 在卸载时释放超级块时调用 */</span></span><br><span class="line">	<span class="keyword">int</span> (*sync_fs)(struct super_block *sb, <span class="keyword">int</span> wait);</span><br><span class="line">	<span class="keyword">int</span> (*freeze_super) (struct super_block *);</span><br><span class="line">	<span class="keyword">int</span> (*freeze_fs) (struct super_block *);</span><br><span class="line">	<span class="keyword">int</span> (*thaw_super) (struct super_block *);</span><br><span class="line">	<span class="keyword">int</span> (*unfreeze_fs) (struct super_block *);</span><br><span class="line">	<span class="keyword">int</span> (*statfs) (struct dentry *, struct kstatfs *); <span class="comment">/* 当一个syscall完成时调用 */</span></span><br><span class="line">	<span class="keyword">int</span> (*remount_fs) (struct super_block *, <span class="keyword">int</span> *, <span class="keyword">char</span> *); <span class="comment">/* 当内核检测到重新挂载尝试时调用 */</span></span><br><span class="line">	<span class="keyword">void</span> (*umount_begin) (struct super_block *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*show_options)(struct seq_file *, struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*show_devname)(struct seq_file *, struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*show_path)(struct seq_file *, struct dentry *);</span><br><span class="line">	<span class="keyword">int</span> (*show_stats)(struct seq_file *, struct dentry *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line">	<span class="keyword">ssize_t</span> (*quota_read)(struct super_block *, <span class="keyword">int</span>, <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="keyword">ssize_t</span> (*quota_write)(struct super_block *, <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dquot</span> **(*<span class="title">get_dquots</span>)(<span class="keyword">struct</span> <span class="title">inode</span> *);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> (*bdev_try_to_free_page)(struct super_block*, struct page*, <span class="keyword">gfp_t</span>);</span><br><span class="line">	<span class="keyword">long</span> (*nr_cached_objects)(struct super_block *,</span><br><span class="line">				  struct shrink_control *);</span><br><span class="line">	<span class="keyword">long</span> (*free_cached_objects)(struct super_block *,</span><br><span class="line">				    struct shrink_control *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有一些重要的 API 可以使用 <code>super_operations</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *__<span class="title">bread</span>(<span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bdev</span>, <span class="title">sector_t</span> <span class="title">block</span>, <span class="title">unsigned</span> <span class="title">size</span>);</span> <span class="comment">/* 读取结构block_device中具有给定块号block和给定大小size的块buffer_head,如果成功,则返回指向buffer_head结构的指针,否则返回NULL */</span></span><br><span class="line"><span class="function">struct buffer_head *<span class="title">sb_bread</span><span class="params">(struct super_block *sb, <span class="keyword">sector_t</span> block)</span></span>; <span class="comment">/* 与上一个函数执行的操作相同,但读取块的大小取自超级块以及从中完成读取的设备 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark_buffer_dirty</span><span class="params">(struct buffer_head *bh)</span></span>; <span class="comment">/* 将缓冲区标记为脏Dirty */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brelse</span><span class="params">(struct buffer_head *bh)</span></span>; <span class="comment">/* 释放缓冲区使用的内存 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">map_bh</span><span class="params">(struct buffer_head *bh, struct super_block *sb, <span class="keyword">sector_t</span> block)</span></span>; <span class="comment">/* 将缓冲头与相应的扇区相关联 */</span></span><br></pre></td></tr></table></figure>
<p>填充超级块的一个案例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pagemap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAMFS_MAGIC     0x858458f6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">ramfs_ops</span> =</span> &#123;</span><br><span class="line">        .statfs         = simple_statfs,</span><br><span class="line">        .drop_inode     = generic_delete_inode,</span><br><span class="line">        .show_options   = ramfs_show_options,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ramfs_fill_super</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ramfs_fs_info</span> *<span class="title">fsi</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">        save_mount_options(sb, data);</span><br><span class="line"></span><br><span class="line">        fsi = kzalloc(<span class="keyword">sizeof</span>(struct ramfs_fs_info), GFP_KERNEL);</span><br><span class="line">        sb-&gt;s_fs_info = fsi;</span><br><span class="line">        <span class="keyword">if</span> (!fsi)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        err = ramfs_parse_options(data, &amp;fsi-&gt;mount_opts);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        sb-&gt;s_maxbytes          = MAX_LFS_FILESIZE;</span><br><span class="line">        sb-&gt;s_blocksize         = PAGE_SIZE;</span><br><span class="line">        sb-&gt;s_blocksize_bits    = PAGE_SHIFT;</span><br><span class="line">        sb-&gt;s_magic             = RAMFS_MAGIC;</span><br><span class="line">        sb-&gt;s_op                = &amp;ramfs_ops;</span><br><span class="line">        sb-&gt;s_time_gran         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        inode = ramfs_get_inode(sb, <span class="literal">NULL</span>, S_IFDIR | fsi-&gt;mount_opts.mode, <span class="number">0</span>);</span><br><span class="line">        sb-&gt;s_root = d_make_root(inode);</span><br><span class="line">        <span class="keyword">if</span> (!sb-&gt;s_root)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>内核提供了通用函数来实现文件系统结构的操作</li>
<li>例如，上述代码中使用的 <code>generic_delete_inode</code> 和 <code>simple_statfs</code>（一般都以 <code>generic</code> 或者 <code>simple</code> 开头）</li>
</ul>
<p><strong>Buffer cache</strong></p>
<p>缓冲区缓存是一个内核子系统，用于处理来自块设备的缓存（读取和写入）块，缓冲区缓存使用的基本实体是 <code>buffer_head</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> b_state;		<span class="comment">/* 缓冲区的状态 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span><span class="comment">/* circular list of page&#x27;s buffers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span>		<span class="comment">/* the page this bh is mapped to */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">sector_t</span> b_blocknr;		<span class="comment">/* 设备上已加载或需要保存在磁盘上的块数 */</span></span><br><span class="line">	<span class="keyword">size_t</span> b_size;			<span class="comment">/* 缓冲区大小 */</span></span><br><span class="line">	<span class="keyword">char</span> *b_data;			<span class="comment">/* 指向Read/Write内存区域的指针(缓冲区主体) */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span> <span class="comment">/* 指向块设备 */</span></span><br><span class="line">	<span class="keyword">bh_end_io_t</span> *b_end_io;		<span class="comment">/* I/O completion */</span></span><br><span class="line"> 	<span class="keyword">void</span> *b_private;		<span class="comment">/* reserved for b_end_io */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span> <span class="comment">/* associated with another mapping */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span>	<span class="comment">/* mapping this buffer is</span></span><br><span class="line"><span class="comment">						   associated with */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> b_count;		<span class="comment">/* users using this buffer_head */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> b_uptodate_lock;	<span class="comment">/* Used by the first bh in a page, to</span></span><br><span class="line"><span class="comment">					 * serialise IO completion of other</span></span><br><span class="line"><span class="comment">					 * buffers in the page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数和有用的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">find_first_zero_bit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>; <span class="comment">/* 查找内存区域中的第一个零位(size参数表示搜索区域中的位数) */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr)</span></span>; <span class="comment">/* 设置一位并获取旧值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_clear_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr)</span></span>; <span class="comment">/* 删除一位并获取旧值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_change_bit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *p)</span></span>; <span class="comment">/* 反转一位并获取旧值 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISDIR(mode)  (((mode) &amp; S_IFDIR) == S_IFDIR) <span class="comment">// 检查inode是否为目录</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISCHR(mode)  (((mode) &amp; S_IFCHR) == S_IFCHR) <span class="comment">// 检查inode是否为字符设备</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISBLK(mode)  (((mode) &amp; S_IFBLK) == S_IFBLK) <span class="comment">// 检查inode是否为块设备</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISREG(mode)  (((mode) &amp; S_IFREG) == S_IFREG) <span class="comment">// 检查inode是否为常规文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISFIFO(mode) (((mode) &amp; S_IFIFO) == S_IFIFO) <span class="comment">// 检查inode是否为FIFO</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISLNK(mode)  (((mode) &amp; S_IFLNK) == S_IFLNK) <span class="comment">// 检查inode是否为链接</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISSOCK(mode) (((mode) &amp; S_IFSOCK) == S_IFSOCK) <span class="comment">// 检查inode是否为socket</span></span></span><br></pre></td></tr></table></figure>
<p><strong>The Inode Structure</strong></p>
<p>索引节点 inode 是 UNIX 文件系统的重要组成部分，同时也是 VFS 的重要组成部分</p>
<p>索引节点是元数据（它具有有关信息的信息）：</p>
<ul>
<li>索引节点唯一标识磁盘上的文件并保存有关该文件的信息（uid、gid、访问权限、访问时间、指向数据块的指针等）</li>
<li>索引节点是指磁盘上的文件，一个 inode 可以关联任意数量的 <code>file</code> 结构（多个进程可以打开同一个文件，或者一个进程可以多次打开同一个文件）</li>
<li>与 VFS 中的其他结构一样，它是一种通用结构，它涵盖了所有受支持的文件类型的选项，甚至包括那些没有关联磁盘实体（如 FAT）的文件类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">	<span class="keyword">umode_t</span>			i_mode; <span class="comment">/* 访问权限 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>		i_opflags;</span><br><span class="line">	<span class="keyword">kuid_t</span>			i_uid; <span class="comment">/* uid */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>			i_gid; <span class="comment">/* gid */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		i_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>	*<span class="title">i_acl</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>	*<span class="title">i_default_acl</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>	*<span class="title">i_op</span>;</span> <span class="comment">/* 指向操作inode的回调函数集 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>	*<span class="title">i_sb</span>;</span> <span class="comment">/* inode所属文件系统的超级块结构 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>			*i_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		i_ino; <span class="comment">/* inode的编号(唯一标识文件系统中的inode) */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i_nlink; <span class="comment">/* 链接计数,对于没有链接(硬链接或符号链接)的文件系统,此值始终设置为&#x27;1&#x27; */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> __i_nlink;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">dev_t</span>			i_rdev; <span class="comment">/* 挂载此文件系统的设备 */</span></span><br><span class="line">	<span class="keyword">loff_t</span>			i_size; <span class="comment">/* 大小(以字节为单位) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>	<span class="title">i_atime</span>;</span> <span class="comment">/* access time:上一次访问该inode的时间 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>	<span class="title">i_mtime</span>;</span> <span class="comment">/* modify time:上一次修改该inode的时间 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>	<span class="title">i_ctime</span>;</span> <span class="comment">/* change time:上一次该inode状态改变的时间 */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		i_lock;	<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>          i_bytes;</span><br><span class="line">	u8			i_blkbits; <span class="comment">/* 用于块大小的位数 */</span></span><br><span class="line">	u8			i_write_hint;</span><br><span class="line">	<span class="keyword">blkcnt_t</span>		i_blocks; <span class="comment">/* 文件使用的块数(这仅由配额子系统使用) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">	<span class="keyword">seqcount_t</span>		i_size_seqcount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Misc */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		i_state;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">i_rwsem</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		dirtied_when;	<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		dirtied_time_when;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">i_hash</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_io_list</span>;</span>	<span class="comment">/* backing dev IO list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>	*<span class="title">i_wb</span>;</span>		<span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line">	<span class="keyword">int</span>			i_wb_frn_winner;</span><br><span class="line">	u16			i_wb_frn_avg_time;</span><br><span class="line">	u16			i_wb_frn_history;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_lru</span>;</span>		<span class="comment">/* inode LRU list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_sb_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_wb_list</span>;</span>	<span class="comment">/* backing dev writeback list */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>	<span class="title">i_dentry</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">i_rcu</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">atomic64_t</span>		i_version;</span><br><span class="line">	<span class="keyword">atomic_t</span>		i_count; <span class="comment">/* inode计数器(指示有多少内核组件使用该inode) */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		i_dio_count;</span><br><span class="line">	<span class="keyword">atomic_t</span>		i_writecount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">i_fop</span>;</span>	<span class="comment">/* 指向操作file的回调函数集 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>	*<span class="title">i_flctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	<span class="title">i_data</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">i_devices</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>	*<span class="title">i_pipe</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>	*<span class="title">i_bdev</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>		*<span class="title">i_cdev</span>;</span></span><br><span class="line">		<span class="keyword">char</span>			*i_link;</span><br><span class="line">		<span class="keyword">unsigned</span>		i_dir_seq;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	__u32			i_generation;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">	__u32			i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span>	*<span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_FS_ENCRYPTION)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_info</span>	*<span class="title">i_crypt_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>			*i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>相关 API 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct inode *<span class="title">new_inode</span><span class="params">(struct super_block *sb)</span></span>; <span class="comment">/* 创建一个新的inode,初始化字段i_nlink,i_blkbits,i_sbi_dev(设置为&#x27;1&#x27;) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_inode_hash</span><span class="params">(struct inode *inode)</span></span>; <span class="comment">/* 将传入的inode添加到inode的哈希表中,如果inode被标记为脏,它将写入磁盘 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark_inode_dirty</span><span class="params">(struct inode *inode)</span></span>; <span class="comment">/* 将井内脏标记为脏污后,将它写回磁盘 */</span></span><br><span class="line"><span class="function">struct inode * <span class="title">iget_locked</span><span class="params">(struct super_block *, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>; <span class="comment">/* 从磁盘加载具有给定编号的inode */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_new_inode</span><span class="params">(struct inode *)</span></span>; <span class="comment">/* 与iget_locked结合使用,释放inode上的锁 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iput</span><span class="params">(struct inode *)</span></span>; <span class="comment">/* 告诉内核在inode上的工作已完成,如果没有其他程序使用该inode,它将被销毁(如果该inode为脏,则在写回磁盘后销毁) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_bad_inode</span><span class="params">(struct inode *)</span></span>; <span class="comment">/* 告诉内核不能使用该inode */</span></span><br></pre></td></tr></table></figure>
<p>创建一个 inode：</p>
<ul>
<li>通常，此函数将调用 <code>iget_locked</code> 从 VFS 获取 inode 结构，如果 inode 是新创建的，则需要从磁盘读取对应的超级块（使用 sb_bread）并填写有用的信息</li>
<li>例如文件系统 minix 的 <code>minix_iget</code> 函数 ：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct inode *<span class="title">minix_iget</span><span class="params">(struct super_block *sb, <span class="keyword">unsigned</span> <span class="keyword">long</span> ino)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    inode = iget_locked(sb, ino);</span><br><span class="line">    <span class="keyword">if</span> (!inode)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    <span class="keyword">if</span> (!(inode-&gt;i_state &amp; I_NEW))</span><br><span class="line">        <span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (INODE_VERSION(inode) == MINIX_V1)</span><br><span class="line">        <span class="keyword">return</span> V1_minix_iget(inode);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">V1_minix_iget</span><span class="params">(struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">minix_inode</span> * <span class="title">raw_inode</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">minix_inode_info</span> *<span class="title">minix_inode</span> =</span> minix_i(inode);</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">      raw_inode = minix_V1_raw_inode(inode-&gt;i_sb, inode-&gt;i_ino, &amp;bh);</span><br><span class="line">      <span class="keyword">if</span> (!raw_inode) &#123;</span><br><span class="line">              iget_failed(inode);</span><br><span class="line">              <span class="keyword">return</span> ERR_PTR(-EIO);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>minix_iget</code> 会先调用 <code>iget_locked</code> 来获取具有给定编号的 inode</li>
<li>如果没有成功获取，程序将调用 <code>V1_minix_iget</code>，进而调用 <code>minix_V1_raw_inode</code> 来从磁盘读取输入，然后使用读取信息完成 inode</li>
</ul>
<p><strong>The File Structure</strong></p>
<p>文件结构对应于进程打开的文件，仅存在于内存中，与 inode 相关联</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span> <span class="comment">/* 文件对象链表 */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span> <span class="comment">/* 释放之后的RCU链表 */</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span> <span class="comment">/* 包含的目录项 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span> <span class="comment">/* 索引结点 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span> <span class="comment">/* 指向操作file的回调函数集 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">spinlock_t</span>		f_lock; <span class="comment">/* 保护文件的自旋锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rw_hint</span>		<span class="title">f_write_hint</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> 		f_flags; <span class="comment">/* 文件标志:O_RDONLY,O_NONBLOCK,O_SYNC */</span></span><br><span class="line">	<span class="keyword">fmode_t</span>			f_mode; <span class="comment">/* 文件读/写模式:FMODE_READ,FMODE_WRITE */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="keyword">loff_t</span>			f_pos; <span class="comment">/* 当前读写位置 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">	u64			f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>			*f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">	<span class="keyword">void</span>			*private_data; <span class="comment">/* 文件私有数据 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">	<span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_ep_links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>	*<span class="title">f_mapping</span>;</span> <span class="comment">/* 指向该页所在地址空间描述结构的指针 */</span></span><br><span class="line">	<span class="keyword">errseq_t</span>		f_wb_err;</span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));	<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文件系统的文件操作 <code>file-&gt;f_op</code> 是使用 <code>inode-&gt;i_fop</code> 字段初始化的，以便后续系统调用使用存储在 <code>file-&gt;f_op</code> 中的值</li>
<li>结构体 <code>file</code> 中还有一个有意思的条目 <code>address_space</code>，值得单独分析一下（其实这个条目是由 <code>inode-&gt;i_data</code> 进行初始化的）</li>
</ul>
<p><strong>Address space operations</strong></p>
<p>进程的地址空间和文件之间有着密切的联系：</p>
<ul>
<li>程序的执行几乎完全是通过将文件映射到进程地址空间来完成的（例如 <code>execve</code>）</li>
<li>由于此方法运行良好且非常通用，因此也可用于常规系统调用，如读取和写入</li>
</ul>
<p>描述地址空间的结构是 <code>address_space</code>（也被称为地址空间描述符），并且使用它的操作由结构体 <code>address_space_operations</code> 描述，要初始化地址空间操作，必须填写 <code>inode-&gt;i_mapping-&gt;a_ops</code></p>
<p>结构体 <code>address_space</code> 用于管理 “索引结点inode” 到 “内存页面-page” 的映射：</p>
<ul>
<li>一个文件对应一个 <code>address_space</code> 结构</li>
<li>一个 <code>address_space</code> 与一个偏移量能够确定 <code>page cache</code> 或 <code>swap cache</code> 中的一个页面</li>
<li>结构体 <code>address_space</code> 的条目如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">host</span>;</span> <span class="comment">/* 指向对应的索引结点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xarray</span>		<span class="title">i_pages</span>;</span></span><br><span class="line">	<span class="keyword">gfp_t</span>			gfp_mask;</span><br><span class="line">	<span class="keyword">atomic_t</span>		i_mmap_writable; <span class="comment">/* 共享映射数VM_SHARED记数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">i_mmap</span>;</span> <span class="comment">/* 优先搜索树的root */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">i_mmap_rwsem</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nrpages; <span class="comment">/* 页总数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nrexceptional;</span><br><span class="line">	<span class="keyword">pgoff_t</span>			writeback_index; <span class="comment">/* 回写的起始偏移 */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span>;</span> <span class="comment">/* 操作函数表 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags; <span class="comment">/* 掩码与错误标识 */</span></span><br><span class="line">	<span class="keyword">errseq_t</span>		wb_err;</span><br><span class="line">	<span class="keyword">spinlock_t</span>		private_lock; <span class="comment">/* 私有address_space锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">private_list</span>;</span> <span class="comment">/* 私有address_space链表 */</span></span><br><span class="line">	<span class="keyword">void</span>			*private_data; <span class="comment">/* 私有数据 */</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)))) __randomize_layout;</span><br></pre></td></tr></table></figure>
<p><strong>The Dentry Structure</strong></p>
<p>目录项 Dentry 的主要任务是在 inode 和文件名之间建立链接，该结构的重要字段如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">	<span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;		<span class="comment">/* protected by d_lock */</span></span><br><span class="line">	<span class="keyword">seqcount_t</span> d_seq;		<span class="comment">/* per dentry seqlock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span>	<span class="comment">/* lookup hash list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span>	<span class="comment">/* 与父目录关联的目录 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>			<span class="comment">/* 包含dentry名称和名称长度的结构体 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span>		<span class="comment">/* 此dentry引用的inode */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN];	<span class="comment">/* small names */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span>	<span class="comment">/* per-dentry lock and refcount */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span> <span class="comment">/* 操作dentry的回调函数集 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>	<span class="comment">/* The root of the dentry tree */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;		<span class="comment">/* used by d_revalidate */</span></span><br><span class="line">	<span class="keyword">void</span> *d_fsdata;			<span class="comment">/* 为实现dentry操作的文件系统保留的字段 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span>		<span class="comment">/* LRU list */</span></span><br><span class="line">		<span class="keyword">wait_queue_head_t</span> *d_wait;	<span class="comment">/* in-lookup ones only */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>	<span class="comment">/* child of parent list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span>	<span class="comment">/* our children */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span>	<span class="comment">/* inode alias list */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_in_lookup_hash</span>;</span>	<span class="comment">/* only for in-lookup ones */</span></span><br><span class="line">	 	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">	&#125; d_u;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<ul>
<li>内核使用 Dentry 来构建并管理文件系统的目录树 </li>
<li>目录项在内核中起到了连接不同的文件对象 inode 的作用，进而起到了维护文件系统目录树的作用 </li>
</ul>
<p><strong>Bitmap operations</strong></p>
<p>使用文件系统时，管理信息（哪个 block 是空闲或忙碌，哪个 inode 是空闲或忙碌）使用位图 Bitmap 存储，为此，我们经常需要使用位运算，此类操作包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">find_first_zero_bit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>; <span class="comment">/* 在bitmap指定范围内找到第一个zero bit的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">find_first_bit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>; <span class="comment">/* 在bitmap指定范围内找到第一个bit的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">void</span> *addr)</span></span>; <span class="comment">/* 将指针指向的数据的第nr位,置&quot;1&quot; */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">void</span> *addr)</span></span>; <span class="comment">/* 将指针指向的数据的第nr位,置&quot;0&quot; */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">void</span> *addr)</span></span>; <span class="comment">/* 将指针指向的数据的第nr位,置&quot;1&quot;,并返回原来这一位的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_clear_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">volatile</span> <span class="keyword">void</span> *addr)</span></span>; <span class="comment">/* 将指针指向的数据的第nr位,置&quot;0&quot;,并返回原来这一位的值 */</span></span><br></pre></td></tr></table></figure>
<p>下面列出了一些用法示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> array_map[NUM_BYTES];</span><br><span class="line"><span class="keyword">size_t</span> idx;</span><br><span class="line"><span class="keyword">int</span> changed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find first zero bit in 32 bit integer. */</span></span><br><span class="line">idx = find_first_zero_bit(&amp;<span class="built_in">map</span>, <span class="number">32</span>);</span><br><span class="line">printk (KERN_ALERT <span class="string">&quot;The %zu-th bit is the first zero bit.\n&quot;</span>, idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find first one bit in NUM_BYTES bytes array. */</span></span><br><span class="line">idx = find_first_bit(array_map, NUM_BYTES * <span class="number">8</span>);</span><br><span class="line">printk (KERN_ALERT <span class="string">&quot;The %zu-th bit is the first one bit.\n&quot;</span>, idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Clear the idx-th bit in integer.</span></span><br><span class="line"><span class="comment"> * It is assumed idx is less the number of bits in integer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clear_bit(idx, &amp;<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Test and set the idx-th bit in array.</span></span><br><span class="line"><span class="comment"> * It is assumed idx is less the number of bits in array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">changed = __test_and_set_bit(idx, &amp;sbi-&gt;imap);</span><br><span class="line"><span class="keyword">if</span> (changed)</span><br><span class="line">      printk(KERN_ALERT <span class="string">&quot;%zu-th bit changed\n&quot;</span>, idx);</span><br></pre></td></tr></table></figure>
<p><strong>Exercises</strong></p>
<p>要解决练习，您需要执行以下步骤：</p>
<ul>
<li>从模板准备 skeletons </li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动 VM 并在 VM 中测试模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">LABS=filesystems make skels</span><br><span class="line">make build</span><br></pre></td></tr></table></figure>
<p>1.myfs 完整代码：</p>
<p>首先，我们计划熟悉 Linux 内核和虚拟文件系统 （VFS） 组件公开的界面：</p>
<ul>
<li>设计并使用一个简单的虚拟文件系统（即没有物理磁盘支持）</li>
<li>文件系统称为 <strong>myfs</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 Lab - Filesystem drivers</span></span><br><span class="line"><span class="comment"> * Exercise #1 (no-dev filesystem)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pagemap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Simple no-dev filesystem&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFS_BLOCKSIZE		4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFS_BLOCKSIZE_BITS	12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYFS_MAGIC		0xbeefcafe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_LEVEL		KERN_ALERT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* declarations of functions that are part of operation structures */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_mknod</span><span class="params">(struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct dentry *dentry, <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> dev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_create</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">umode_t</span> mode, <span class="keyword">bool</span> excl)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_mkdir</span><span class="params">(struct inode *dir, struct dentry *dentry, <span class="keyword">umode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 2: define super_operations structure */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">myfs_ops</span> =</span> &#123;</span><br><span class="line">	.statfs		= simple_statfs,</span><br><span class="line">	.drop_inode	= generic_drop_inode,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">myfs_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/* TODO 5: Fill dir inode operations structure. */</span></span><br><span class="line">	.create         = myfs_create,</span><br><span class="line">	.lookup         = simple_lookup,</span><br><span class="line">	.link           = simple_link,</span><br><span class="line">	.unlink         = simple_unlink,</span><br><span class="line">	.mkdir          = myfs_mkdir,</span><br><span class="line">	.rmdir          = simple_rmdir,</span><br><span class="line">	.mknod          = myfs_mknod,</span><br><span class="line">	.rename         = simple_rename,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">myfs_file_operations</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/* TODO 6: Fill file operations structure. */</span></span><br><span class="line">	.read_iter      = generic_file_read_iter,</span><br><span class="line">	.write_iter     = generic_file_write_iter,</span><br><span class="line">	.mmap           = generic_file_mmap,</span><br><span class="line">	.llseek         = generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">myfs_file_inode_operations</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/* TODO 6: Fill file inode operations structure. */</span></span><br><span class="line">	.getattr        = simple_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> <span class="title">myfs_aops</span> =</span> &#123;</span><br><span class="line">	<span class="comment">/* TODO 6: Fill address space operations structure. */</span></span><br><span class="line">	.readpage       = simple_readpage,</span><br><span class="line">	.write_begin    = simple_write_begin,</span><br><span class="line">	.write_end      = simple_write_end,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct inode *<span class="title">myfs_get_inode</span><span class="params">(struct super_block *sb, <span class="keyword">const</span> struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> new_inode(sb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 3: fill inode structure</span></span><br><span class="line"><span class="comment">	 *     - mode</span></span><br><span class="line"><span class="comment">	 *     - uid</span></span><br><span class="line"><span class="comment">	 *     - gid</span></span><br><span class="line"><span class="comment">	 *     - atime,ctime,mtime</span></span><br><span class="line"><span class="comment">	 *     - ino</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	inode_init_owner(inode, dir, mode);</span><br><span class="line">	inode-&gt;i_atime = current_time(inode);</span><br><span class="line">	inode-&gt;i_mtime = current_time(inode);</span><br><span class="line">	inode-&gt;i_ctime = current_time(inode);</span><br><span class="line">	inode-&gt;i_ino = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 5: Init i_ino using get_next_ino */</span></span><br><span class="line">	inode-&gt;i_ino = get_next_ino();</span><br><span class="line">	<span class="comment">/* TODO 6: Initialize address space operations. */</span></span><br><span class="line">	inode-&gt;i_mapping-&gt;a_ops = &amp;myfs_aops;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(mode)) &#123;</span><br><span class="line">		<span class="comment">/* TODO 3: set inode operations for dir inodes. */</span></span><br><span class="line">		inode-&gt;i_op = &amp;simple_dir_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line">		<span class="comment">/* TODO 5: use myfs_dir_inode_operations for inode</span></span><br><span class="line"><span class="comment">		 * operations (i_op).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		inode-&gt;i_op = &amp;myfs_dir_inode_operations;</span><br><span class="line">		<span class="comment">/* TODO 3: directory inodes start off with i_nlink == 2 (for &quot;.&quot; entry).</span></span><br><span class="line"><span class="comment">		 * Directory link count should be incremented (use inc_nlink).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		inc_nlink(inode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 6: Set file inode and file operations for regular files</span></span><br><span class="line"><span class="comment">	 * (use the S_ISREG macro).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISREG(mode)) &#123;</span><br><span class="line">		inode-&gt;i_op = &amp;myfs_file_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;myfs_file_operations;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 5: Implement myfs_mknod, myfs_create, myfs_mkdir. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_mknod</span><span class="params">(struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct dentry *dentry, <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> myfs_get_inode(dir-&gt;i_sb, dir, mode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (inode == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">	d_instantiate(dentry, inode);</span><br><span class="line">	dget(dentry);</span><br><span class="line">	dir-&gt;i_mtime = dir-&gt;i_ctime = current_time(inode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_create</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">umode_t</span> mode, <span class="keyword">bool</span> excl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> myfs_mknod(dir, dentry, mode | S_IFREG, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_mkdir</span><span class="params">(struct inode *dir, struct dentry *dentry, <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = myfs_mknod(dir, dentry, mode | S_IFDIR, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	inc_nlink(dir);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">myfs_fill_super</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root_inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root_dentry</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: fill super_block</span></span><br><span class="line"><span class="comment">	 *   - blocksize, blocksize_bits</span></span><br><span class="line"><span class="comment">	 *   - magic</span></span><br><span class="line"><span class="comment">	 *   - super operations</span></span><br><span class="line"><span class="comment">	 *   - maxbytes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;</span><br><span class="line">	sb-&gt;s_blocksize = MYFS_BLOCKSIZE;</span><br><span class="line">	sb-&gt;s_blocksize_bits = MYFS_BLOCKSIZE_BITS;</span><br><span class="line">	sb-&gt;s_magic = MYFS_MAGIC;</span><br><span class="line">	sb-&gt;s_op = &amp;myfs_ops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* mode = directory &amp; access rights (755) */</span></span><br><span class="line">	root_inode = myfs_get_inode(sb, <span class="literal">NULL</span>,</span><br><span class="line">			S_IFDIR | S_IRWXU | S_IRGRP |</span><br><span class="line">			S_IXGRP | S_IROTH | S_IXOTH);</span><br><span class="line"></span><br><span class="line">	printk(LOG_LEVEL <span class="string">&quot;root inode has %d link(s)\n&quot;</span>, root_inode-&gt;i_nlink);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!root_inode)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	root_dentry = d_make_root(root_inode);</span><br><span class="line">	<span class="keyword">if</span> (!root_dentry)</span><br><span class="line">		<span class="keyword">goto</span> out_no_root;</span><br><span class="line">	sb-&gt;s_root = root_dentry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_no_root:</span><br><span class="line">	iput(root_inode);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">myfs_mount</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: call superblock mount function */</span></span><br><span class="line">	<span class="keyword">return</span> mount_nodev(fs_type, flags, data, myfs_fill_super);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 1: define file_system_type structure */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">my_fs_type</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.name		= <span class="string">&quot;myfs&quot;</span>,</span><br><span class="line">	.mount		= myfs_mount,</span><br><span class="line">	.kill_sb	= kill_litter_super,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">myfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: register */</span></span><br><span class="line">	err = register_filesystem(&amp;my_fs_type);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;register_filesystem failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">myfs_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: unregister */</span></span><br><span class="line">	unregister_filesystem(&amp;my_fs_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(myfs_init);</span><br><span class="line">module_exit(myfs_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一次写文件系统驱动，很多东西都不懂，所以很大程度上参考了答案</li>
<li>感觉我自己写的时候就是 API 操作不熟悉，在网上不一定能找到正确的 API，有些 API 有特殊的运用场景，不能随便使用</li>
<li>根据传入参数和返回值可以判断一些 API 是否符合使用场景，但后来懒得一个一个试就直接看答案了</li>
</ul>
<p>2.minfs 完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 Lab - Filesystem drivers</span></span><br><span class="line"><span class="comment"> * Exercise #2 (dev filesystem)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/buffer_head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cred.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pagemap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;minfs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Simple filesystem&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_LEVEL	KERN_ALERT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minfs_sb_info</span> &#123;</span></span><br><span class="line">	__u8 version;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> imap;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">sbh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> &#123;</span></span><br><span class="line">	__u16 data_block;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* declarations of functions that are part of operation structures */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_readdir</span><span class="params">(struct file *filp, struct dir_context *ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">minfs_lookup</span><span class="params">(struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct dentry *dentry, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_create</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">umode_t</span> mode, <span class="keyword">bool</span> excl)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dir and inode operation structures */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">minfs_dir_operations</span> =</span> &#123;</span><br><span class="line">	.read		= generic_read_dir,</span><br><span class="line">	.iterate	= minfs_readdir,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">minfs_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">	.lookup		= minfs_lookup,</span><br><span class="line">	<span class="comment">/* TODO 7: Use minfs_create as the create function. */</span></span><br><span class="line">	.create		= minfs_create,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> <span class="title">minfs_aops</span> =</span> &#123;</span><br><span class="line">	.readpage       = simple_readpage,</span><br><span class="line">	.write_begin    = simple_write_begin,</span><br><span class="line">	.write_end      = simple_write_end,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">minfs_file_operations</span> =</span> &#123;</span><br><span class="line">	.read_iter	= generic_file_read_iter,</span><br><span class="line">	.write_iter	= generic_file_write_iter,</span><br><span class="line">	.mmap		= generic_file_mmap,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">minfs_file_inode_operations</span> =</span> &#123;</span><br><span class="line">	.getattr	= simple_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">minfs_iget</span><span class="params">(struct super_block *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> ino)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode</span> *<span class="title">mi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocate VFS inode. */</span></span><br><span class="line">	inode = iget_locked(s, ino);</span><br><span class="line">	<span class="keyword">if</span> (inode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;error aquiring inode\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Return inode from cache */</span></span><br><span class="line">	<span class="keyword">if</span> (!(inode-&gt;i_state &amp; I_NEW))</span><br><span class="line">		<span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 4: Read block with inodes. It&#x27;s the second block on</span></span><br><span class="line"><span class="comment">	 * the device, i.e. the block with the index 1. This is the index</span></span><br><span class="line"><span class="comment">	 * to be passed to sb_bread().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bh = sb_bread(s,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(bh==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">goto</span> out_bad_sb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 4: Get inode with index ino from the block. */</span></span><br><span class="line">	mi = ((struct minfs_inode *)bh-&gt;b_data) + ino;</span><br><span class="line">	<span class="comment">/* TODO 4: fill VFS inode */</span></span><br><span class="line">	inode-&gt;i_mode = mi-&gt;mode;</span><br><span class="line">	inode-&gt;i_size = mi-&gt;size;</span><br><span class="line">	inode-&gt;i_blocks = mi-&gt;data_block;</span><br><span class="line">	i_uid_write(inode, mi-&gt;uid);</span><br><span class="line">	i_gid_write(inode, mi-&gt;gid);</span><br><span class="line">	inode-&gt;i_mtime = current_time(inode);</span><br><span class="line">	inode-&gt;i_atime = current_time(inode);</span><br><span class="line">	inode-&gt;i_ctime = current_time(inode);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 7: Fill address space operations (inode-&gt;i_mapping-&gt;a_ops) */</span></span><br><span class="line">	inode-&gt;i_mapping-&gt;a_ops = &amp;minfs_aops;</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">		<span class="comment">/* TODO 4: Fill dir inode operations. */</span></span><br><span class="line">		inode-&gt;i_op = &amp;simple_dir_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line">		<span class="comment">/* TODO 5: Use minfs_dir_inode_operations for i_op</span></span><br><span class="line"><span class="comment">		 * and minfs_dir_operations for i_fop. */</span></span><br><span class="line">		inode-&gt;i_op = &amp;minfs_dir_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;minfs_dir_operations;</span><br><span class="line">		<span class="comment">/* TODO 4: Directory inodes start off with i_nlink == 2.</span></span><br><span class="line"><span class="comment">		 * (use inc_link) */</span></span><br><span class="line">		inc_nlink(inode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 7: Fill inode and file operations for regular files</span></span><br><span class="line"><span class="comment">	 * (i_op and i_fop). Use the S_ISREG macro.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span>(S_ISREG(inode-&gt;i_mode))&#123;</span><br><span class="line">		inode-&gt;i_op = &amp;minfs_file_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;minfs_file_operations;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill data for mii */</span></span><br><span class="line">	mii = container_of(inode, struct minfs_inode_info, vfs_inode);</span><br><span class="line">	<span class="comment">/* TODO 4: uncomment after the minfs_inode is initialized */</span></span><br><span class="line">	mii-&gt;data_block = mi-&gt;data_block;</span><br><span class="line">	<span class="comment">/* Free resources. */</span></span><br><span class="line">	<span class="comment">/* TODO 4: uncomment after the buffer_head is initialized */</span></span><br><span class="line">	brelse(bh);</span><br><span class="line">	unlock_new_inode(inode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">out_bad_sb:</span><br><span class="line">	iget_failed(inode);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_readdir</span><span class="params">(struct file *filp, struct dir_context *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_dir_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">	<span class="keyword">int</span> over;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 5: Get inode of directory and container inode. */</span></span><br><span class="line">	inode = file_inode(filp);</span><br><span class="line">	mii  = container_of(inode, struct minfs_inode_info, vfs_inode);</span><br><span class="line">	<span class="comment">/* TODO 5: Get superblock from inode (i_sb). */</span></span><br><span class="line">	sb = inode-&gt;i_sb;</span><br><span class="line">	<span class="comment">/* TODO 5: Read data block for directory inode. */</span></span><br><span class="line">	bh = sb_bread(sb, mii-&gt;data_block);</span><br><span class="line">	<span class="keyword">if</span> (bh == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_bad_sb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; ctx-&gt;pos &lt; MINFS_NUM_ENTRIES; ctx-&gt;pos++) &#123;</span><br><span class="line">		<span class="comment">/* TODO 5: Data block contains an array of</span></span><br><span class="line"><span class="comment">		 * &quot;struct minfs_dir_entry&quot;. Use `de&#x27; for storing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		de = (struct minfs_dir_entry *) bh-&gt;b_data + ctx-&gt;pos;</span><br><span class="line">		<span class="comment">/* TODO 5: Step over empty entries (de-&gt;ino == 0). */</span></span><br><span class="line">		<span class="keyword">if</span> (de-&gt;ino == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Use `over` to store return value of dir_emit and exit</span></span><br><span class="line"><span class="comment">		 * if required.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		over = dir_emit(ctx, de-&gt;name, MINFS_NAME_LEN, de-&gt;ino,</span><br><span class="line">				DT_UNKNOWN);</span><br><span class="line">		<span class="keyword">if</span> (over) &#123;</span><br><span class="line">			printk(KERN_DEBUG <span class="string">&quot;Read %s from folder %s, ctx-&gt;pos: %lld\n&quot;</span>,</span><br><span class="line">				de-&gt;name,</span><br><span class="line">				filp-&gt;f_path.dentry-&gt;d_name.name,</span><br><span class="line">				ctx-&gt;pos);</span><br><span class="line">			ctx-&gt;pos++;</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	brelse(bh);</span><br><span class="line">out_bad_sb:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find dentry in parent folder. Return parent folder&#x27;s data buffer_head.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct minfs_dir_entry *<span class="title">minfs_find_entry</span><span class="params">(struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct buffer_head **bhp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span> =</span> dentry-&gt;d_parent-&gt;d_inode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span> =</span> container_of(dir,</span><br><span class="line">			struct minfs_inode_info, vfs_inode);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name = dentry-&gt;d_name.name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_dir_entry</span> *<span class="title">final_de</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_dir_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 6: Read parent folder data block (contains dentries).</span></span><br><span class="line"><span class="comment">	 * Fill bhp with return value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bh = sb_bread(sb,mii-&gt;data_block);</span><br><span class="line">	<span class="keyword">if</span> (bh == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*bhp = bh;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MINFS_NUM_ENTRIES; i++) &#123;</span><br><span class="line">		<span class="comment">/* TODO 6: Traverse all entries, find entry by name</span></span><br><span class="line"><span class="comment">		 * Use `de&#x27; to traverse. Use `final_de&#x27; to store dentry</span></span><br><span class="line"><span class="comment">		 * found, if existing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		de = ((struct minfs_dir_entry *) bh-&gt;b_data) + i;</span><br><span class="line">		<span class="keyword">if</span> (de-&gt;ino != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* found it */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, de-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">				printk(KERN_DEBUG <span class="string">&quot;Found entry %s on position: %zd\n&quot;</span>,</span><br><span class="line">					name, i);</span><br><span class="line">				final_de = de;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bh needs to be released by caller. */</span></span><br><span class="line">	<span class="keyword">return</span> final_de;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">minfs_lookup</span><span class="params">(struct inode *dir,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct dentry *dentry, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 6: Comment line. */</span></span><br><span class="line">	<span class="keyword">return</span> simple_lookup(dir, dentry, flags);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_dir_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	dentry-&gt;d_op = sb-&gt;s_root-&gt;d_op;</span><br><span class="line"></span><br><span class="line">	de = minfs_find_entry(dentry, &amp;bh);</span><br><span class="line">	<span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;getting entry: name: %s, ino: %d\n&quot;</span>,</span><br><span class="line">			de-&gt;name, de-&gt;ino);</span><br><span class="line">		inode = minfs_iget(sb, de-&gt;ino);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(inode))</span><br><span class="line">			<span class="keyword">return</span> ERR_CAST(inode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d_add(dentry, inode);</span><br><span class="line">	brelse(bh);</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;looked up dentry %s\n&quot;</span>, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">minfs_alloc_inode</span><span class="params">(struct super_block *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 3: Allocate minfs_inode_info. */</span></span><br><span class="line">	mii = (struct minfs_inode_info *)kmalloc(<span class="keyword">sizeof</span>(struct minfs_inode_info),<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* TODO 3: init VFS inode in minfs_inode_info */</span></span><br><span class="line">	inode_init_once(&amp;mii-&gt;vfs_inode);</span><br><span class="line">	<span class="keyword">return</span> &amp;mii-&gt;vfs_inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minfs_destroy_inode</span><span class="params">(struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 3: free minfs_inode_info */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span> =</span> container_of(inode, struct minfs_inode_info, vfs_inode);</span><br><span class="line">	kfree(mii);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a new VFS inode. Do basic initialization and fill imap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode *<span class="title">minfs_new_inode</span><span class="params">(struct inode *dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_sb_info</span> *<span class="title">sbi</span> =</span> sb-&gt;s_fs_info;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 7: Find first available inode. */</span></span><br><span class="line">	idx = find_first_zero_bit(&amp;sbi-&gt;imap, MINFS_NUM_INODES);</span><br><span class="line">	<span class="keyword">if</span> (idx == MINFS_NUM_INODES) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;no space left in imap\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 7: Mark the inode as used in the bitmap and mark</span></span><br><span class="line"><span class="comment">	 * the superblock buffer head as dirty.</span></span><br><span class="line"><span class="comment">	 */</span>	</span><br><span class="line">	__test_and_set_bit(idx, &amp;sbi-&gt;imap);</span><br><span class="line">	mark_buffer_dirty(sbi-&gt;sbh);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 7: Call new_inode(), fill inode fields</span></span><br><span class="line"><span class="comment">	 * and insert inode into inode hash table.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	inode = new_inode(sb);</span><br><span class="line">	inode-&gt;i_uid = current_fsuid();</span><br><span class="line">	inode-&gt;i_gid = current_fsgid();</span><br><span class="line">	inode-&gt;i_ino = idx;</span><br><span class="line">	inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line">	inode-&gt;i_blocks = <span class="number">0</span>;</span><br><span class="line">	insert_inode_hash(inode);</span><br><span class="line">	<span class="comment">/* Actual writing to the disk will be done in minfs_write_inode,</span></span><br><span class="line"><span class="comment">	 * which will be called at a later time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Add dentry link on parent inode disk structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_add_link</span><span class="params">(struct dentry *dentry, struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_dir_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 7: Get: directory inode (in inode); containing inode (in mii); superblock (in sb). */</span></span><br><span class="line">	dir = dentry-&gt;d_parent-&gt;d_inode;</span><br><span class="line">	mii = container_of(dir, struct minfs_inode_info, vfs_inode);</span><br><span class="line">	sb = dir-&gt;i_sb;</span><br><span class="line">	<span class="comment">/* TODO 7: Read dir data block (use sb_bread). */</span></span><br><span class="line">	bh = sb_bread(sb, mii-&gt;data_block);</span><br><span class="line">	<span class="comment">/* TODO 7: Find first free dentry (de-&gt;ino == 0). */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MINFS_NUM_ENTRIES; i++) &#123;</span><br><span class="line">		de = (struct minfs_dir_entry *) bh-&gt;b_data + i;</span><br><span class="line">		<span class="keyword">if</span> (de-&gt;ino == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i == MINFS_NUM_ENTRIES) &#123;</span><br><span class="line">		err = -ENOSPC;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 7: Place new entry in the available slot. Mark buffer_head</span></span><br><span class="line"><span class="comment">	 * as dirty. */</span></span><br><span class="line">	de-&gt;ino = inode-&gt;i_ino;</span><br><span class="line">	<span class="built_in">memcpy</span>(de-&gt;name, dentry-&gt;d_name.name, MINFS_NAME_LEN);</span><br><span class="line">	dir-&gt;i_mtime = dir-&gt;i_ctime = current_time(inode);</span><br><span class="line">	mark_buffer_dirty(bh);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	brelse(bh);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a VFS file inode. Use minfs_file_... operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_create</span><span class="params">(struct inode *dir, struct dentry *dentry, <span class="keyword">umode_t</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">bool</span> excl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	inode = minfs_new_inode(dir);</span><br><span class="line">	<span class="keyword">if</span> (inode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;error allocating new inode\n&quot;</span>);</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err_new_inode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inode-&gt;i_mode = mode;</span><br><span class="line">	inode-&gt;i_op = &amp;minfs_file_inode_operations;</span><br><span class="line">	inode-&gt;i_fop = &amp;minfs_file_operations;</span><br><span class="line">	mii = container_of(inode, struct minfs_inode_info, vfs_inode);</span><br><span class="line">	mii-&gt;data_block = MINFS_FIRST_DATA_BLOCK + inode-&gt;i_ino;</span><br><span class="line"></span><br><span class="line">	err = minfs_add_link(dentry, inode);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_add_link;</span><br><span class="line"></span><br><span class="line">	d_instantiate(dentry, inode);</span><br><span class="line">	mark_inode_dirty(inode);</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;new file inode created (ino = %lu)\n&quot;</span>,</span><br><span class="line">		inode-&gt;i_ino);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_add_link:</span><br><span class="line">	inode_dec_link_count(inode);</span><br><span class="line">	iput(inode);</span><br><span class="line">err_new_inode:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Write VFS inode contents to disk inode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_write_inode</span><span class="params">(struct inode *inode,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct writeback_control *wbc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> inode-&gt;i_sb;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode</span> *<span class="title">mi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_inode_info</span> *<span class="title">mii</span> =</span> container_of(inode,</span><br><span class="line">			struct minfs_inode_info, vfs_inode);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	bh = sb_bread(sb, MINFS_INODE_BLOCK);</span><br><span class="line">	<span class="keyword">if</span> (bh == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;could not read block\n&quot;</span>);</span><br><span class="line">		err = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mi = (struct minfs_inode *) bh-&gt;b_data + inode-&gt;i_ino;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill disk inode */</span></span><br><span class="line">	mi-&gt;mode = inode-&gt;i_mode;</span><br><span class="line">	mi-&gt;uid = i_uid_read(inode);</span><br><span class="line">	mi-&gt;gid = i_gid_read(inode);</span><br><span class="line">	mi-&gt;size = inode-&gt;i_size;</span><br><span class="line">	mi-&gt;data_block = mii-&gt;data_block;</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;mode is %05o; data_block is %d\n&quot;</span>, mi-&gt;mode,</span><br><span class="line">		mii-&gt;data_block);</span><br><span class="line"></span><br><span class="line">	mark_buffer_dirty(bh);</span><br><span class="line">	brelse(bh);</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;wrote inode %lu\n&quot;</span>, inode-&gt;i_ino);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minfs_put_super</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_sb_info</span> *<span class="title">sbi</span> =</span> sb-&gt;s_fs_info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Free superblock buffer head. */</span></span><br><span class="line">	mark_buffer_dirty(sbi-&gt;sbh);</span><br><span class="line">	brelse(sbi-&gt;sbh);</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;released superblock resources\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">minfs_ops</span> =</span> &#123;</span><br><span class="line">	.statfs		= simple_statfs,</span><br><span class="line">	.put_super	= minfs_put_super,</span><br><span class="line">	<span class="comment">/* TODO 4: add alloc and destroy inode functions */</span></span><br><span class="line">	.alloc_inode = minfs_alloc_inode,</span><br><span class="line">	.destroy_inode = minfs_destroy_inode,</span><br><span class="line">	<span class="comment">/* TODO 7:	= set write_inode function. */</span></span><br><span class="line">	.write_inode = minfs_write_inode,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minfs_fill_super</span><span class="params">(struct super_block *s, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_sb_info</span> *<span class="title">sbi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">minfs_super_block</span> *<span class="title">ms</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root_inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root_dentry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	sbi = kzalloc(<span class="keyword">sizeof</span>(struct minfs_sb_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sbi)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	s-&gt;s_fs_info = sbi;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set block size for superblock. */</span></span><br><span class="line">	<span class="keyword">if</span> (!sb_set_blocksize(s, MINFS_BLOCK_SIZE))</span><br><span class="line">		<span class="keyword">goto</span> out_bad_blocksize;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: Read block with superblock. It&#x27;s the first block on</span></span><br><span class="line"><span class="comment">	 * the device, i.e. the block with the index 0. This is the index</span></span><br><span class="line"><span class="comment">	 * to be passed to sb_bread().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	bh = sb_bread(s,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(bh == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">goto</span> out_bad_sb;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 2: interpret read data as minfs_super_block */</span></span><br><span class="line">	ms = (struct minfs_super_block*)bh-&gt;b_data;</span><br><span class="line">	<span class="comment">/* TODO 2: check magic number with value defined in minfs.h. jump to out_bad_magic if not suitable */</span></span><br><span class="line">	<span class="keyword">if</span>(ms-&gt;magic != MINFS_MAGIC)&#123;</span><br><span class="line">		<span class="keyword">goto</span> out_bad_magic;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* TODO 2: fill super_block with magic_number, super_operations */</span></span><br><span class="line">	s-&gt;s_magic = MINFS_MAGIC;</span><br><span class="line">	s-&gt;s_op = &amp;minfs_ops;</span><br><span class="line">	<span class="comment">/* TODO 2: Fill sbi with rest of information from disk superblock</span></span><br><span class="line"><span class="comment">	 * (i.e. version).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sbi-&gt;version = ms-&gt;version;</span><br><span class="line">	sbi-&gt;imap = ms-&gt;imap;</span><br><span class="line">	<span class="comment">/* allocate root inode and root dentry */</span></span><br><span class="line">	<span class="comment">/* TODO 2: use myfs_get_inode instead of minfs_iget */</span></span><br><span class="line">	root_inode = minfs_iget(s, MINFS_ROOT_INODE);</span><br><span class="line">	<span class="keyword">if</span> (!root_inode)</span><br><span class="line">		<span class="keyword">goto</span> out_bad_inode;</span><br><span class="line"></span><br><span class="line">	root_dentry = d_make_root(root_inode);</span><br><span class="line">	<span class="keyword">if</span> (!root_dentry)</span><br><span class="line">		<span class="keyword">goto</span> out_iput;</span><br><span class="line">	s-&gt;s_root = root_dentry;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Store superblock buffer_head for further use. */</span></span><br><span class="line">	sbi-&gt;sbh = bh;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_iput:</span><br><span class="line">	iput(root_inode);</span><br><span class="line">out_bad_inode:</span><br><span class="line">	printk(LOG_LEVEL <span class="string">&quot;bad inode\n&quot;</span>);</span><br><span class="line">out_bad_magic:</span><br><span class="line">	printk(LOG_LEVEL <span class="string">&quot;bad magic number\n&quot;</span>);</span><br><span class="line">	brelse(bh);</span><br><span class="line">out_bad_sb:</span><br><span class="line">	printk(LOG_LEVEL <span class="string">&quot;error reading buffer_head\n&quot;</span>);</span><br><span class="line">out_bad_blocksize:</span><br><span class="line">	printk(LOG_LEVEL <span class="string">&quot;bad block size\n&quot;</span>);</span><br><span class="line">	s-&gt;s_fs_info = <span class="literal">NULL</span>;</span><br><span class="line">	kfree(sbi);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct dentry *<span class="title">minfs_mount</span><span class="params">(struct file_system_type *fs_type,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: call superblock mount function */</span></span><br><span class="line">	<span class="keyword">return</span> mount_bdev(fs_type, flags, dev_name, data, minfs_fill_super);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">minfs_fs_type</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.name		= <span class="string">&quot;minfs&quot;</span>,</span><br><span class="line">	<span class="comment">/* TODO 1: add mount, kill_sb and fs_flags */</span></span><br><span class="line">	.mount		= minfs_mount,</span><br><span class="line">	.kill_sb	= kill_litter_super,</span><br><span class="line">	.fs_flags	= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">minfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = register_filesystem(&amp;minfs_fs_type);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		printk(LOG_LEVEL <span class="string">&quot;register_filesystem failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">minfs_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unregister_filesystem(&amp;minfs_fs_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(minfs_init);</span><br><span class="line">module_exit(minfs_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># set -ex</span></span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># insmod ../kernel/minfs.ko</span></span><br><span class="line">+ insmod ../kernel/minfs.ko</span><br><span class="line">minfs: loading out-of-tree <span class="keyword">module</span> taints kernel.</span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># mkdir -p /mnt/minfs</span></span><br><span class="line">+ mkdir -p /mnt/minfs</span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user# ./mkfs.minfs /dev/vdb</span><br><span class="line">+ ./mkfs.minfs /dev/vdb</span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># mount -t minfs /dev/vdb /mnt/minfs</span></span><br><span class="line">+ mount -t minfs /dev/vdb /mnt/minfs</span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># cat /proc/filesystems | grep minfs</span></span><br><span class="line">+ cat /proc/filesystems</span><br><span class="line">+ grep minfs</span><br><span class="line">nodev   minfs</span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># cat /proc/mounts | grep minfs</span></span><br><span class="line">+ + grep minfs</span><br><span class="line">cat /proc/mounts</span><br><span class="line">/dev/vdb /mnt/minfs minfs rw,relatime <span class="number">0</span> <span class="number">0</span></span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># stat -f /mnt/minfs</span></span><br><span class="line">+ stat -f /mnt/minfs</span><br><span class="line">  File: <span class="string">&quot;/mnt/minfs&quot;</span></span><br><span class="line">    ID: <span class="number">0</span>        Namelen: <span class="number">255</span>     Type: UNKNOWN</span><br><span class="line">Block size: <span class="number">4096</span>      </span><br><span class="line">Blocks: Total: <span class="number">0</span>          Free: <span class="number">0</span>          Available: <span class="number">0</span></span><br><span class="line">Inodes: Total: <span class="number">0</span>          Free: <span class="number">0</span></span><br><span class="line">root@qemux86:~/skels/filesystems/minfs/user<span class="meta"># cd /mnt/minfs</span></span><br><span class="line">+ cd /mnt/minfs</span><br><span class="line">root@qemux86:/mnt/minfs<span class="meta"># ls -la</span></span><br><span class="line">Read a.txt from folder /, ctx-&gt;pos: <span class="number">0</span></span><br><span class="line">ls: ./a.txt: No such file <span class="keyword">or</span> directory</span><br><span class="line">root@qemux86:/mnt/minfs<span class="meta"># mode is 40755; data_block is 2</span></span><br><span class="line">wrote inode <span class="number">0</span></span><br><span class="line"></span><br><span class="line">root@qemux86:/mnt/minfs<span class="meta"># cd ..</span></span><br><span class="line">root@qemux86:/mnt<span class="meta"># umount /mnt/minfs</span></span><br><span class="line">released superblock resources</span><br><span class="line">root@qemux86:/mnt<span class="meta"># rmmod minfs</span></span><br></pre></td></tr></table></figure>
<ul>
<li>感觉本实验其实就主要完成了两个工作：<ul>
<li><code>register_filesystem(&amp;minfs_fs_type)</code> 和 <code>unregister_filesystem(&amp;minfs_fs_type)</code></li>
<li>其他的操作都是对上面这两个操作的完善</li>
</ul>
</li>
<li>新注册文件系统只有一个操作是需要由我们完成的：<code>minfs_mount</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">minfs_fs_type</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.name		= <span class="string">&quot;minfs&quot;</span>,</span><br><span class="line">	.mount		= minfs_mount,</span><br><span class="line">	.kill_sb	= kill_block_super,</span><br><span class="line">	.fs_flags	= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>而在 <code>minfs_mount</code> 我们又只需要完成用于填充超级块的函数 <code>minfs_fill_super</code></li>
<li>这一部分和模板差不多，使用 <code>sb_bread</code> 读出超级块，效验 <code>magic number</code> 并且把超级块的信息填入 <code>minfs_sb_info</code>，我们需要完成 <code>minfs_ops</code> 中的函数：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">minfs_ops</span> =</span> &#123;</span><br><span class="line">	.statfs		= simple_statfs,</span><br><span class="line">	.put_super	= minfs_put_super,</span><br><span class="line">	.alloc_inode = minfs_alloc_inode,</span><br><span class="line">	.destroy_inode = minfs_destroy_inode,</span><br><span class="line">	.write_inode = minfs_write_inode,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>另外程序用于读取 inode 的 <code>minfs_iget</code> 函数需要实现</li>
<li>在 <code>minfs_iget</code> 中：<ul>
<li>先是使用 <code>iget_locked(s, ino)</code> 从挂载的文件系统获取 inode </li>
<li>然后就是对 inode 的初始化，分配 <code>address_space_operations</code></li>
<li>再根据 inode 类型为其分配对应的 <code>inode_operations</code> 和 <code>file_operations</code> </li>
<li>最后返回 inode</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">minfs_dir_operations</span> =</span> &#123;</span><br><span class="line">	.read		= generic_read_dir,</span><br><span class="line">	.iterate	= minfs_readdir,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">minfs_file_operations</span> =</span> &#123;</span><br><span class="line">	.read_iter	= generic_file_read_iter,</span><br><span class="line">	.write_iter	= generic_file_write_iter,</span><br><span class="line">	.mmap		= generic_file_mmap,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">minfs_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">	.lookup		= minfs_lookup,</span><br><span class="line">	.create		= minfs_create,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">minfs_file_inode_operations</span> =</span> &#123;</span><br><span class="line">	.getattr	= simple_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> <span class="title">minfs_aops</span> =</span> &#123;</span><br><span class="line">	.readpage       = simple_readpage,</span><br><span class="line">	.write_begin    = simple_write_begin,</span><br><span class="line">	.write_end      = simple_write_end,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中又需要我们实现的函数有：<code>minfs_create</code> <code>minfs_lookup</code> <code>minfs_readdir</code></li>
<li>借助参考答案和多次试错，感觉大体的流程清楚了，不过细节还需要打磨</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Kernel/" rel="tag"><i class="fa fa-tag"></i> Kernel</a>
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i> Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/17/Linux-Lab6-Block%20Device%20Drivers/" rel="prev" title="Linux-Lab6-Block Device Drivers">
      <i class="fa fa-chevron-left"></i> Linux-Lab6-Block Device Drivers
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/21/Linux-Lab8-Networking/" rel="next" title="Linux-Lab8-Networking">
      Linux-Lab8-Networking <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">171</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">75:28</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
