<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Deferred work 实验目标：  了解延迟的工作（即计划在以后执行的代码） 用延迟工作的常见任务的实现 了解延迟工作的同步特性  延迟工作是一类内核工具，它允许人们计划代码在以后的计时器上执行，此计划代码可以在进程上下文中运行，也可以在中断上下文中运行，具体取决于延迟工作的类型 延迟工作用于补充中断处理程序功能，因为中断具有重要的要求和限制：  中断处理程序的执行时间必须尽可能短 在中断上">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux-Lab5-Deferred work">
<meta property="og:url" content="http://example.com/2022/10/16/Linux-Lab5-Deferred%20work/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="Deferred work 实验目标：  了解延迟的工作（即计划在以后执行的代码） 用延迟工作的常见任务的实现 了解延迟工作的同步特性  延迟工作是一类内核工具，它允许人们计划代码在以后的计时器上执行，此计划代码可以在进程上下文中运行，也可以在中断上下文中运行，具体取决于延迟工作的类型 延迟工作用于补充中断处理程序功能，因为中断具有重要的要求和限制：  中断处理程序的执行时间必须尽可能短 在中断上">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-16T09:46:45.000Z">
<meta property="article:modified_time" content="2022-10-16T09:47:20.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="Kernel">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/10/16/Linux-Lab5-Deferred%20work/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux-Lab5-Deferred work | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/16/Linux-Lab5-Deferred%20work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux-Lab5-Deferred work
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-16 17:46:45 / Modified: 17:47:20" itemprop="dateCreated datePublished" datetime="2022-10-16T17:46:45+08:00">2022-10-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>Deferred work</strong></p>
<p>实验目标：</p>
<ul>
<li>了解延迟的工作（即计划在以后执行的代码）</li>
<li>用延迟工作的常见任务的实现</li>
<li>了解延迟工作的同步特性</li>
</ul>
<p>延迟工作是一类内核工具，它允许人们计划代码在以后的计时器上执行，此计划代码可以在进程上下文中运行，也可以在中断上下文中运行，具体取决于延迟工作的类型</p>
<p>延迟工作用于补充中断处理程序功能，因为中断具有重要的要求和限制：</p>
<ul>
<li>中断处理程序的执行时间必须尽可能短</li>
<li>在中断上下文中，我们不能使用阻塞调用</li>
</ul>
<p>使用延迟工作 Deferred work，我们可以在中断处理程序中执行所需的最少工作，并安排中断处理程序的异步操作在以后运行并执行其余操作</p>
<ul>
<li>在中断上下文中运行的延迟工作也称为下半部分，因为它的目的是从中断处理程序（上半部分）执行其余操作</li>
</ul>
<p>有三种典型操作可用于所有类型的延迟工作：</p>
<ul>
<li>Initialization 初始化：每种类型都由一个结构描述，该结构的字段必须初始化，此时还设置了要计划的处理程序</li>
<li>Scheduling 调度：计划处理程序的执行尽快（或在超时到期后）</li>
<li>Masking or Canceling 掩蔽/取消：禁用处理程序的执行，此操作可以是同步的（这保证了处理程序在取消完成后不会运行）或异步的</li>
</ul>
<p>延迟工作 Deferred work 的主要类型是内核线程和软件：</p>
<ul>
<li>工作队列在内核线程之上实现，任务集和计时器在软件线程之上实现</li>
<li>下半部分处理程序是 Linux 中延迟工作的第一个实现（但与此同时，它被软中断 softirqs 所取代，基于 softirqs 又诞生了可以动态分配的 Tasklets）</li>
<li>这就是为什么所呈现的某些函数在其名称中包含 bh（下半部分 bottom half）的原因</li>
</ul>
<p><strong>Softirqs</strong></p>
<p>软中断 Softirqs，软中断是在编译期间静态分配的，因此不能由设备驱动使用，它们是为各种内核子系统保留的</p>
<p>因此，在编译时定义了固定数量的 softirq，对于当前的内核版本，我们定义了以下类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    HI_SOFTIRQ = <span class="number">0</span>, <span class="comment">/* 运行tasklets */</span></span><br><span class="line">    TIMER_SOFTIRQ, <span class="comment">/* 运行timers */</span></span><br><span class="line">    NET_TX_SOFTIRQ, <span class="comment">/* 由网络子系统使用 */</span></span><br><span class="line">    NET_RX_SOFTIRQ, <span class="comment">/* 由网络子系统使用 */</span></span><br><span class="line">    BLOCK_SOFTIRQ, <span class="comment">/* 由IO子系统使用 */</span></span><br><span class="line">    IRQ_POLL_SOFTIRQ, </span><br><span class="line">    TASKLET_SOFTIRQ, <span class="comment">/* 运行tasklets */</span></span><br><span class="line">    SCHED_SOFTIRQ, <span class="comment">/* 负载平衡 */</span></span><br><span class="line">    HRTIMER_SOFTIRQ, <span class="comment">/* 实现高精度计时器 */</span></span><br><span class="line">    RCU_SOFTIRQ, <span class="comment">/* 实施区域控制单元类型机制 */</span></span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>不同类型的 Softirqs 有不同的作用（部分类型会在后面讲到）</li>
</ul>
<p>Softirqs 在中断上下文中运行，这意味着它们不能调用阻塞函数，如果 sofitrq 处理程序需要调用此类函数，则可以安排工作队列 work queues 来执行这些阻塞调用</p>
<p><strong>Tasklets</strong></p>
<p>任务集 Tasklets 是一种特殊形式的延迟工作，在中断上下文中运行，类似于 softirqs，两者主要区别在于：</p>
<ul>
<li>Tasklets 可以动态分配，因此它们可以由设备驱动程序使用</li>
<li>Tasklets 由 <code>struct tasklet</code> 和许多其他内核结构表示，在使用之前需要对其进行初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span>;</span><br><span class="line"></span><br><span class="line">DECLARE_TASKLET(tasklet, handler, data);</span><br><span class="line">DECLARE_TASKLET_DISABLED(tasklet, handler, data);</span><br></pre></td></tr></table></figure>
<p>如果我们想手动初始化 Tasklets，我们可以使用以下方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">tasklet_init(&amp;tasklet, handler, data);</span><br></pre></td></tr></table></figure>
<p>针对运行的 Tasklets 编程称为调度 scheduling，Tasklets 调度通过以下方式完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *tasklet)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_hi_schedule</span><span class="params">(struct tasklet_struct *tasklet)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以通过以下的函数屏蔽 Tasklets：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_enable</span><span class="params">(struct tasklet_struct * tasklet)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_disable</span><span class="params">(struct tasklet_struct * tasklet)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：由于 Tasklets 是从 softirqs 运行的，因此无法在处理程序函数中使用阻塞调用</li>
</ul>
<p><strong>Timers</strong></p>
<p>计时器 Timers 一种特殊类型的延迟工作：</p>
<ul>
<li>由结构定义 <code>timer_list</code></li>
<li>在中断上下文中运行，并在软件之上实现</li>
</ul>
<p>由于 Timers 必须是原子的，所以 Timers 运行在原子上下文中，内核不能访问用户空间，而且内核是不能休眠或调度（其实 Timers 也是用 Softirqs 实现的，当然不能休眠或调度）</p>
<p>注册好的 Timers 是由内核子模块组织并存储的，其底层的核心功能“定时”是由内核实现，Timers 需要提供一个回调函数，该回调函数和定时器注册程序使用的是同一个线程（这也是在删除模块之前，必须停止计时器的原因）</p>
<p>要使用 Timers，必须首先调用如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_setup</span><span class="params">(struct timer_list * timer,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">void</span> (*function)(struct timer_list *),</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>用于初始化 <code>timer_list</code> 的内部字段，并将函数关联为计时器处理程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All fields that change during normal runtime grouped to the</span></span><br><span class="line"><span class="comment">	 * same cacheline</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">entry</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		expires;</span><br><span class="line">	<span class="keyword">void</span>			(*function)(struct timer_list *);</span><br><span class="line">	u32			flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>expires</code>：运行处理程序函数 <code>(*function)(struct timer_list *)</code> 的时间</li>
<li><code>function</code>：回调函数</li>
</ul>
<p>使用计时器的一个常见错误是忘记关闭计时器:</p>
<ul>
<li>在删除模块之前，我们必须停止计时器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del_timer_sync(struct timer_list * timer); <span class="comment">/* 摘除一个定时器对象,确保当函数返回时系统中没有任何处理器正在执行定时器对象上的定时器函数 */</span></span><br><span class="line">del_timer(struct timer_list * timer); <span class="comment">/* 从系统的定时器管理队列中摘除一个定时器对象 */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果计时器在模块被删除后过期，则处理程序函数将不再加载到内核中，并且将生成内核 oops</li>
</ul>
<p>定时器的使用案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">    ......</span><br><span class="line">&#125; dev;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_function</span><span class="params">(struct timer_list * tl)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span> from_timer(my_data, tl, timer);</span><br><span class="line">    .....</span><br><span class="line">    mod_timer(&amp;my_data-&gt;timer, jiffies + seconds * HZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_access</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> seconds = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    timer_setup(&amp;dev.timer, timer_function, <span class="number">0</span>);</span><br><span class="line">    mod_timer(&amp;dev.timer, jiffies + seconds * HZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的 <code>from_timer</code> 用于从 <code>timer_list</code> 中获取父结构体 <code>my_device_data</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> from_timer(var, callback_timer, timer_fieldname) \</span></span><br><span class="line"><span class="meta">	container_of(callback_timer, typeof(*var), timer_fieldname)</span></span><br></pre></td></tr></table></figure>
<p><strong>Locking</strong></p>
<p>为了在进程上下文（简称 “A”）中运行的代码和在 softirq 上下文（简称 “B”）中运行的代码之间保持同步，我们需要使用特殊的锁定基元：</p>
<ul>
<li>必须在 A 中使用 “停用当前处理器上的下半部分处理程序” 的自旋锁操作</li>
<li>并且在 B 中仅使用基本的自旋锁操作</li>
</ul>
<p>使用自旋锁可以确保我们不会在多个CPU之间进行 Race 条件竞争，而停用 softirq 可以确保我们不会在已经获得自旋锁的同一 CPU 上安排 softirq look 时出现死锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">my_access</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    spin_lock_bh(&amp;my_data-&gt;lock);</span><br><span class="line">    ......</span><br><span class="line">    spin_unlock_bh(&amp;my_data-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">(struct timer_list *tl)</span></span>&#123;</span><br><span class="line">    spin_lock(&amp;my_data-&gt;lock);</span><br><span class="line">    ......</span><br><span class="line">    spin_unlock(&amp;my_data-&gt;lock);</span><br><span class="line">    mod_timer(&amp;my_data-&gt;timer, jiffies + HZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定期器的回调函数在任何时候都可能会发生（内核会直接抢占原来的进程，从而执行回调函数）</li>
<li>如果在 <code>my_access</code> 中拿了自旋锁之后被 <code>timer_handler</code> 抢占，就会发生死锁（回调函数和定时器注册程序使用的是同一个线程）</li>
<li>如果不在 <code>timer_handler</code> 中加锁，又可能会破坏共享数据（例如：在引用指针之前置空了指针）</li>
<li>因此需要使用 <code>spin_lock_bh</code> 在加锁的同时禁止中断下半部（多指软中断）</li>
</ul>
<p>我们可以使用如下函数来 禁用/启用 softirqs 处理程序：（并且由于它们运行在 softirqs 之上，所以计时器和任务集也更少）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">local_bh_disable</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">/* 禁用softirqs处理程序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">local_bh_enable</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">/* 启用softirqs处理程序 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_bh</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span>; <span class="comment">/* 禁用softirqs处理程序,添加自旋锁 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock_bh</span><span class="params">(<span class="keyword">spinlock_t</span> *lock)</span></span>; <span class="comment">/* 启用softirqs处理程序,释放自旋锁 */</span></span><br></pre></td></tr></table></figure>
<p><strong>Workqueues</strong></p>
<p>工作队列 Workqueues 用于计划在流程上下文中运行的操作，其实就是一个用于创建内核线程的接口，通过它可以创建一个“工作者线程”来专门处理中断的下半部工作</p>
<ul>
<li>Workqueues 的优点就是可以使用独立于原进程的内核线程</li>
<li>如果想要在中断处理程序中进行调度，就必须使用 Workqueues</li>
</ul>
<p>它们工作的基本单位称为工作项 Work items，有两种类型的工作：</p>
<ul>
<li>struct work_struct：它计划稍后运行的任务</li>
<li>struct delayed_work：它计划任务在至少给定的时间间隔后运行</li>
</ul>
<p>在使用工作项之前，必须初始化工作项，可以使用两种类型的宏：</p>
<ul>
<li>一种是同时声明和初始化工作项 Work items </li>
<li>另一种是仅初始化工作项 Work items </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_WORK(name , <span class="keyword">void</span> (*function)(struct work_struct *));</span><br><span class="line">DECLARE_DELAYED_WORK(name, <span class="keyword">void</span>(*function)(struct work_struct *));</span><br><span class="line"></span><br><span class="line">INIT_WORK(struct work_struct *work, <span class="keyword">void</span>(*function)(struct work_struct *));</span><br><span class="line">INIT_DELAYED_WORK(struct delayed_work *work, <span class="keyword">void</span>(*function)(struct work_struct *));</span><br></pre></td></tr></table></figure>
<p>一旦声明和初始化工作队列，我们可以使用以下函数来调度任务：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_delayed_work</span><span class="params">(struct delayed_work *work, <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以用如下函数取消工作项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cancel_work_sync</span><span class="params">(struct delayed_work *work)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cancel_delayed_work_sync</span><span class="params">(struct delayed_work *work)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以通过以下方式等待工作队列完成运行其所有工作项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_scheduled_work</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然以上这些函数都是针对某个工作项 Work items 而言</p>
<p>工作队列由结构 <code>workqueue_struct</code> 表示，可以使用以下这些函数创建新的工作队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct workqueue_struct *<span class="title">create_workqueue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">struct workqueue_struct *<span class="title">create_singlethread_workqueue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<p>要在新队列中添加任务（某个工作项），使用如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct * <span class="built_in">queue</span>, struct work_struct *work)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_delayed_work</span><span class="params">(struct workqueue_struct *<span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                       struct delayed_work * work , <span class="keyword">unsigned</span> <span class="keyword">long</span> delay)</span></span>;</span><br></pre></td></tr></table></figure>
<p>等待所有工作项完成调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush_workqueue</span><span class="params">(struct worksqueue_struct * <span class="built_in">queue</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>销毁工作队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_workqueue</span><span class="params">(struct workqueue_struct *<span class="built_in">queue</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Kernel threads</strong></p>
<p>内核线程是工作队列机制的基础，从本质上讲，内核线程是仅在内核模式下运行的线程，没有用户地址空间或其他用户属性</p>
<p>创建内核线程的函数：（但是不会直接运行）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct task_struct *<span class="title">kthread_create</span><span class="params">(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">void</span> *data, <span class="keyword">const</span> <span class="keyword">char</span> namefmt[], ...)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>threadfn</code>：将由内核线程运行的函数</li>
<li><code>data</code>：要发送到函数的参数</li>
<li><code>namefmt</code>：表示内核线程名称</li>
</ul>
<p>启动内核线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wake_up_process</span><span class="params">(struct task_struct *p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建和运行内核线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct task_struct * <span class="title">kthread_run</span><span class="params">(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">void</span> *data, <span class="keyword">const</span> <span class="keyword">char</span> namefmt[], ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>内核线程的终止是在内核线程中运行的函数中自愿完成的，通过调用如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fastcall NORET_TYPE <span class="keyword">void</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">long</span> code)</span></span>;</span><br></pre></td></tr></table></figure>
<p>内核线程处理程序的大多数实现都使用相同的模型，建议开始使用相同的模型以避免常见错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_WAIT_QUEUE_HEAD(wq); <span class="comment">/* 初始化等待队列 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list events to be processed by kernel thread</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">events_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spin_lock</span> <span class="title">events_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// structure describing the event to be processed</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lh</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> stop;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct event* <span class="title">get_next_event</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span>;</span></span><br><span class="line">    spin_lock(&amp;events_lock);</span><br><span class="line">    e = list_first_entry(&amp;events_list, struct event*, lh);</span><br><span class="line">    <span class="keyword">if</span> (e)</span><br><span class="line">        list_del(&amp;e-&gt;lh);</span><br><span class="line">    spin_unlock(&amp;events_lock);</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> my_thread_f(<span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    struct event *e;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        wait_event(wq, (e = get_next_event));</span><br><span class="line">        <span class="comment">/* Event processing */</span></span><br><span class="line">        <span class="keyword">if</span> (e-&gt;stop)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    do_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start and start kthread */</span></span><br><span class="line">kthread_run(my_thread_f, <span class="literal">NULL</span>, <span class="string">&quot;%skthread%d&quot;</span>, <span class="string">&quot;my&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>使用上面的模板，内核线程请求可以通过以下方式发出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_event</span><span class="params">(struct event *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    spin_lock(&amp;events_lock);</span><br><span class="line">    list_add(&amp;ev-&gt;lh, &amp;events_list);</span><br><span class="line">    spin_unlock(&amp;events_lock);</span><br><span class="line">    wake_up(&amp;wq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Exercises</strong></p>
<p>要解决练习，您需要执行以下步骤：</p>
<ul>
<li>从模板准备 skeletons </li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动 VM 并在 VM 中测试模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABS=deferred_work make skels</span><br><span class="line">make build</span><br><span class="line">make copy</span><br></pre></td></tr></table></figure>
<p>1.Timer 完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Deferred Work</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Exercise #1, #2: simple timer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Simple kernel timer&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_TIMEOUT	1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">(struct timer_list *tl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: print a message */</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> message = <span class="number">0</span>;</span><br><span class="line">	pr_info(<span class="string">&quot;message :%d\n&quot;</span>,message++);</span><br><span class="line">	<span class="comment">/* TODO 2: rechedule timer */</span></span><br><span class="line">	mod_timer(&amp;timer, jiffies + TIMER_TIMEOUT * HZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">timer_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;[timer_init] Init module\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: initialize timer */</span></span><br><span class="line">	timer_setup(&amp;timer, timer_handler, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* TODO 1: schedule timer for the first time */</span></span><br><span class="line">	mod_timer(&amp;timer, jiffies + TIMER_TIMEOUT * HZ);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">timer_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;[timer_exit] Exit module\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* TODO 1: cleanup; make sure the timer is not running after we exit */</span></span><br><span class="line">	del_timer_sync(&amp;timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(timer_init);</span><br><span class="line">module_exit(timer_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">1</span><span class="number">-2</span>-timer<span class="meta"># insmod timer.ko                   </span></span><br><span class="line">timer: loading out-of-tree <span class="keyword">module</span> taints kernel.                                </span><br><span class="line">[timer_init] Init <span class="keyword">module</span>                                                        </span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">1</span><span class="number">-2</span>-timer<span class="meta"># message :0                        </span></span><br><span class="line">message :<span class="number">1</span>                                                                      </span><br><span class="line">message :<span class="number">2</span>                                                                      </span><br><span class="line">message :<span class="number">3</span>                                                                      </span><br><span class="line">message :<span class="number">4</span>   </span><br></pre></td></tr></table></figure>
<ul>
<li>在定时器处理程序中还可以调用定时器，这样就可以实现定时循环</li>
</ul>
<p>2.Deferred 完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 - Lab 6 - Deferred Work</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Exercises #3, #4, #5: deferred work</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Code skeleton.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../include/deferred.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MAJOR		42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MINOR		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_NAME		<span class="meta-string">&quot;deferred&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_TYPE_NONE		-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_TYPE_SET		0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_TYPE_ALLOC	1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_TYPE_MON		2</span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Deferred work character device&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mon_proc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 1: add timer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 2: add flag */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flag;</span><br><span class="line">	<span class="comment">/* TODO 3: add work */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 4: add list for monitored processes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="comment">/* TODO 4: add spinlock to protect list */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">&#125; dev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc_io</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">	schedule_timeout(<span class="number">5</span> * HZ);</span><br><span class="line">	pr_info(<span class="string">&quot;Yawn! I&#x27;ve been sleeping for 5 seconds.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct mon_proc *<span class="title">get_proc</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mon_proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	task = pid_task(find_vpid(pid), PIDTYPE_PID);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">if</span> (!task)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ESRCH);</span><br><span class="line"></span><br><span class="line">	p = kmalloc(<span class="keyword">sizeof</span>(*p), GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	get_task_struct(task);</span><br><span class="line">	p-&gt;task = task;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO 3: define work handler */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work_handler</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	alloc_io();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOC_IO_DIRECT</span></span><br><span class="line"><span class="comment">/* TODO 3: undef ALLOC_IO_DIRECT*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ALLOC_IO_DIRECT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">(struct timer_list *tl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* TODO 1: implement timer handler */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span> from_timer(my_data, tl, timer);</span><br><span class="line">	pr_info(<span class="string">&quot;[timer_handler] pid = %d, comm = %s\n&quot;</span>,</span><br><span class="line">		current-&gt;pid, current-&gt;comm);</span><br><span class="line">	<span class="comment">/* TODO 2: check flags: TIMER_TYPE_SET or TIMER_TYPE_ALLOC */</span></span><br><span class="line">	<span class="keyword">switch</span> (my_data-&gt;flag) &#123;</span><br><span class="line">		<span class="keyword">case</span> TIMER_TYPE_SET:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> TIMER_TYPE_ALLOC:</span><br><span class="line">			<span class="comment">// alloc_io();</span></span><br><span class="line">		<span class="comment">/* TODO 3: schedule work */</span></span><br><span class="line">			schedule_work(&amp;my_data-&gt;work);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/* TODO 4: iterate the list and check the proccess state */</span></span><br><span class="line">		<span class="keyword">case</span> TIMER_TYPE_MON:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">mon_proc</span> *<span class="title">p</span>, *<span class="title">n</span>;</span></span><br><span class="line">			spin_lock(&amp;my_data-&gt;lock);</span><br><span class="line">			<span class="comment">/* TODO 4: if task is dead print info ... */</span></span><br><span class="line">			<span class="comment">/* TODO 4: ... decrement task usage counter ... */</span></span><br><span class="line">			<span class="comment">/* TODO 4: ... remove it from the list ... */</span></span><br><span class="line">			<span class="comment">/* TODO 4: ... free the struct mon_proc */</span></span><br><span class="line">			list_for_each_entry_safe(p, n, &amp;my_data-&gt;<span class="built_in">list</span>, <span class="built_in">list</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;task-&gt;state == TASK_DEAD) &#123;</span><br><span class="line">					pr_info(<span class="string">&quot;task %s (%d) is dead\n&quot;</span>, p-&gt;task-&gt;comm,</span><br><span class="line">						p-&gt;task-&gt;pid);</span><br><span class="line">					put_task_struct(p-&gt;task);</span><br><span class="line">					list_del(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">					kfree(p);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			spin_unlock(&amp;my_data-&gt;lock);</span><br><span class="line"></span><br><span class="line">			mod_timer(&amp;my_data-&gt;timer, jiffies + HZ);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deferred_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span></span><br><span class="line">		container_of(inode-&gt;i_cdev, struct my_device_data, cdev);</span><br><span class="line">	file-&gt;private_data = my_data;</span><br><span class="line">	pr_info(<span class="string">&quot;[deferred_open] Device opened\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deferred_release</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;[deferred_release] Device released\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">deferred_ioctl</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">my_device_data</span> *<span class="title">my_data</span> =</span> (struct my_device_data*) file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;[deferred_ioctl] Command: %s\n&quot;</span>, ioctl_command_to_string(cmd));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> MY_IOCTL_TIMER_SET:</span><br><span class="line">			<span class="comment">/* TODO 2: set flag */</span></span><br><span class="line">			my_data-&gt;flag = TIMER_TYPE_SET;</span><br><span class="line">			<span class="comment">/* TODO 1: schedule timer */</span></span><br><span class="line">			mod_timer(&amp;dev.timer,jiffies + arg * HZ);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MY_IOCTL_TIMER_CANCEL:</span><br><span class="line">			<span class="comment">/* TODO 1: cancel timer */</span></span><br><span class="line">			del_timer_sync(&amp;dev.timer);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MY_IOCTL_TIMER_ALLOC:</span><br><span class="line">			<span class="comment">/* TODO 2: set flag and schedule timer */</span></span><br><span class="line">			my_data-&gt;flag = TIMER_TYPE_ALLOC;</span><br><span class="line">			mod_timer(&amp;dev.timer,jiffies + arg * HZ);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MY_IOCTL_TIMER_MON:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* TODO 4: use get_proc() and add task to list */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">mon_proc</span> *<span class="title">p</span> =</span> get_proc(current-&gt;pid);</span><br><span class="line">			<span class="comment">/* TODO 4: protect access to list */</span></span><br><span class="line">			spin_lock_bh(&amp;my_data-&gt;lock);</span><br><span class="line">			list_add(&amp;p-&gt;<span class="built_in">list</span>,&amp;my_data-&gt;<span class="built_in">list</span>);</span><br><span class="line">			spin_unlock_bh(&amp;my_data-&gt;lock);</span><br><span class="line">			<span class="comment">/* TODO 4: set flag and schedule timer */</span></span><br><span class="line">			my_data-&gt;flag = TIMER_TYPE_MON;</span><br><span class="line">			mod_timer(&amp;my_data-&gt;timer,jiffies + arg * HZ);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = deferred_open,</span><br><span class="line">	.release = deferred_release,</span><br><span class="line">	.unlocked_ioctl = deferred_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deferred_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;[deferred_init] Init module\n&quot;</span>);</span><br><span class="line">	err = register_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR), <span class="number">1</span>, MODULE_NAME);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_info(<span class="string">&quot;[deffered_init] register_chrdev_region: %d\n&quot;</span>, err);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 2: Initialize flag. */</span></span><br><span class="line">	dev.flag = TIMER_TYPE_NONE;</span><br><span class="line">	<span class="comment">/* TODO 3: Initialize work. */</span></span><br><span class="line">	INIT_WORK(&amp;dev.work, work_handler);</span><br><span class="line">	<span class="comment">/* TODO 4: Initialize lock and list. */</span></span><br><span class="line">	spin_lock_init(&amp;dev.lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;dev.<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;dev.cdev, &amp;my_fops);</span><br><span class="line">	cdev_add(&amp;dev.cdev, MKDEV(MY_MAJOR, MY_MINOR), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Initialize timer. */</span></span><br><span class="line">	timer_setup(&amp;dev.timer,timer_handler,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deferred_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mon_proc</span> *<span class="title">p</span>, *<span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;[deferred_exit] Exit module\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">	cdev_del(&amp;dev.cdev);</span><br><span class="line">	unregister_chrdev_region(MKDEV(MY_MAJOR, MY_MINOR), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* TODO 1: Cleanup: make sure the timer is not running after exiting. */</span></span><br><span class="line">	del_timer_sync(&amp;dev.timer);</span><br><span class="line">	<span class="comment">/* TODO 3: Cleanup: make sure the work handler is not scheduled. */</span></span><br><span class="line">	flush_scheduled_work();</span><br><span class="line">	<span class="comment">/* TODO 4: Cleanup the monitered process list */</span></span><br><span class="line">	list_for_each_entry_safe(p, n, &amp;dev.<span class="built_in">list</span>, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="comment">/* TODO 4: ... decrement task usage counter ... */</span></span><br><span class="line">		<span class="comment">/* TODO 4: ... remove it from the list ... */</span></span><br><span class="line">		<span class="comment">/* TODO 4: ... free the struct mon_proc */</span></span><br><span class="line">		put_task_struct(p-&gt;task);</span><br><span class="line">		list_del(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">		kfree(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(deferred_init);</span><br><span class="line">module_exit(deferred_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred<span class="meta"># insmod ./kernel/deferred.ko  </span></span><br><span class="line">deferred: loading out-of-tree <span class="keyword">module</span> taints kernel.                             </span><br><span class="line">[deferred_init] Init <span class="keyword">module</span> </span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred<span class="meta"># mknod /dev/deferred c 42 0</span></span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred# ./user/test a <span class="number">3</span>              </span><br><span class="line">[deferred_open] Device opened                                                   </span><br><span class="line">Allocate memory after <span class="number">3</span> seconds                                                 </span><br><span class="line">[deferred_ioctl] Command: Allocate memory                                       </span><br><span class="line">[deferred_release] Device released                                              </span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred# [timer_handler] pid = <span class="number">0</span>, com0</span><br><span class="line">BUG: scheduling <span class="keyword">while</span> atomic: swapper/<span class="number">0</span>/<span class="number">0</span>/<span class="number">0x00000102</span>  </span><br></pre></td></tr></table></figure>
<ul>
<li>驱动程序导致错误，因为在原子上下文中调用了阻塞函数 <code>alloc_io</code>（计时器处理程序运行中断上下文）</li>
<li>但是 <code>schedule_work(&amp;my_data-&gt;work)</code> 中，使用工作队列新开一个内核线程来运行 <code>alloc_io</code> 就不会报错（这也是工作队列的优势）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred# ./user/test p <span class="number">3</span>              </span><br><span class="line">[deferred_open] Device opened                                                   </span><br><span class="line">Monitor PID <span class="number">3.</span>                                                                  </span><br><span class="line">[deferred_ioctl] Command: Monitor pid                                           </span><br><span class="line">[deferred_release] Device released                                              </span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">3</span><span class="number">-4</span><span class="number">-5</span>-deferred# [timer_handler] pid = <span class="number">0</span>, com0</span><br><span class="line">task test (<span class="number">239</span>) is dead                                                         </span><br><span class="line">[timer_handler] pid = <span class="number">0</span>, comm = swapper/<span class="number">0</span>                                       </span><br><span class="line">[timer_handler] pid = <span class="number">0</span>, comm = swapper/<span class="number">0</span>   </span><br></pre></td></tr></table></figure>
<ul>
<li>正常打印进程信息</li>
</ul>
<p>3.Kthread 完整代码：</p>
<ul>
<li>实现一个简单的模块，该模块会创建用于显示当前进程标识符的内核线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SO2 - Lab 6 - Deferred Work</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Exercise #6: kernel thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Simple kernel thread&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;SO2&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wq_stop_thread;</span><br><span class="line"><span class="keyword">atomic_t</span> flag_stop_thread;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wq_thread_terminated;</span><br><span class="line"><span class="keyword">atomic_t</span> flag_thread_terminated;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_thread_f</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;[my_thread_f] Current process id is %d (%s)\n&quot;</span>,</span><br><span class="line">		current-&gt;pid, current-&gt;comm);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> Wait for command to remove module on wq_stop_thread queue. */</span></span><br><span class="line">	wait_event_interruptible(wq_stop_thread,atomic_read(&amp;flag_stop_thread)!=<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> set flag to mark kernel thread termination */</span></span><br><span class="line">	atomic_set(&amp;flag_thread_terminated,<span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> notify the unload process that we have exited */</span></span><br><span class="line">	wake_up_interruptible(&amp;wq_thread_terminated);</span><br><span class="line">	pr_info(<span class="string">&quot;[my_thread_f] Exiting\n&quot;</span>);</span><br><span class="line">	do_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">kthread_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pr_info(<span class="string">&quot;[kthread_init] Init module\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> init the waitqueues and flags */</span></span><br><span class="line">	init_waitqueue_head(&amp;wq_stop_thread);</span><br><span class="line">	init_waitqueue_head(&amp;wq_thread_terminated);</span><br><span class="line">	atomic_set(&amp;flag_stop_thread,<span class="number">0</span>);</span><br><span class="line">	atomic_set(&amp;flag_thread_terminated,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> create and start the kernel thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">kt</span> =</span> kthread_create(my_thread_f,<span class="literal">NULL</span>,<span class="string">&quot;yhellow&quot;</span>);</span><br><span class="line">	wake_up_process(kt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">kthread_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> notify the kernel thread that its time to exit */</span></span><br><span class="line">	atomic_set(&amp;flag_stop_thread,<span class="number">1</span>);</span><br><span class="line">	wake_up_interruptible(&amp;wq_stop_thread);</span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> wait for the kernel thread to exit */</span></span><br><span class="line">	wait_event_interruptible(wq_thread_terminated,atomic_read(&amp;flag_thread_terminated) != <span class="number">0</span>);</span><br><span class="line">	pr_info(<span class="string">&quot;[kthread_exit] Exit module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kthread_init);</span><br><span class="line">module_exit(kthread_exit);</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">6</span>-kthread<span class="meta"># insmod kthread.ko                 </span></span><br><span class="line">kthread: loading out-of-tree <span class="keyword">module</span> taints kernel.                              </span><br><span class="line">[kthread_init] Init <span class="keyword">module</span>                                                      </span><br><span class="line">[my_thread_f] Current process id is <span class="number">258</span> (yhellow)  </span><br><span class="line">root@qemux86:~/skels/deferred_work/<span class="number">6</span>-kthread<span class="meta"># rmmod kthread.ko                  </span></span><br><span class="line">[my_thread_f] Exiting                                                           </span><br><span class="line">[kthread_exit] Exit modul</span><br></pre></td></tr></table></figure>
<ul>
<li>必须等到内核线程停止以后，内核模块才可以停止</li>
<li>由于内核线程和内核模块是同时运行的，为了使内核模块先停止，做了以下操作：<ul>
<li>在 <code>kthread_exit</code> 执行之前，内核线程会因为 <code>flag_stop_thread = 0</code> 被添加到等待队列中</li>
<li>在 <code>kthread_exit</code> 执行的过程中设置 <code>flag_stop_thread = 1</code>，同时唤醒内核线程（如果不设置 <code>flag_stop_thread = 1</code> 而直接唤醒，就会导致死锁），然后因为 <code>flag_thread_terminated = 0</code> 被添加到等待队列中</li>
<li>在 <code>my_thread_f</code> 中设置 <code>flag_thread_terminated = 1</code>，同时唤醒内核模块</li>
<li>由于唤醒需要时间：内核线程先关闭，内核模块后关闭</li>
</ul>
</li>
<li>本实验只涉及的“单个内核线程”的情况，如果需要处理多个内核线程，则可以使用之前给出的模板</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Kernel/" rel="tag"><i class="fa fa-tag"></i> Kernel</a>
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i> Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/15/Linux-Lab4-IO%20access%20and%20Interrupts/" rel="prev" title="Linux-Lab4-IO access and Interrupts">
      <i class="fa fa-chevron-left"></i> Linux-Lab4-IO access and Interrupts
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/17/Linux-Lab6-Block%20Device%20Drivers/" rel="next" title="Linux-Lab6-Block Device Drivers">
      Linux-Lab6-Block Device Drivers <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">171</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">75:28</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
