<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="从CSapp中收获的知识CSapp是一本很好的书，它像极了一本“技术字典”，知识十分全面但又不深入，对学习计算机有着引领性的作用 我学习CSapp已经有一段时间了，有些章节可以调起我的兴趣，使我在网络上进行了知识扩充，但有些章节用大段大段的文字来劝退我，甚至还有一些章节玩起了“高数”，搞得我很懵逼 CSapp上的知识太杂，太广，我感觉好多知识我都没法利用上（或许以后用得上），我害怕搞忘了这些知识，">
<meta property="og:type" content="article">
<meta property="og:title" content="从CSapp中收获的知识（持续更新）">
<meta property="og:url" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="从CSapp中收获的知识CSapp是一本很好的书，它像极了一本“技术字典”，知识十分全面但又不深入，对学习计算机有着引领性的作用 我学习CSapp已经有一段时间了，有些章节可以调起我的兴趣，使我在网络上进行了知识扩充，但有些章节用大段大段的文字来劝退我，甚至还有一些章节玩起了“高数”，搞得我很懵逼 CSapp上的知识太杂，太广，我感觉好多知识我都没法利用上（或许以后用得上），我害怕搞忘了这些知识，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641111569636-1646286364492-1646808754595-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639405451872-1640399662182-1640976664503-1646286364492-1646808754595-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640400471882-1640976664503-1646286364492-1646808754595-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641118618666-1646286364492-1646808754595-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646665002297-1646808754595-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639413250532-1640976664503-1646286364492-1646808754595-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115585515-1646286364492-1646808754595-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641117200100-1646286364492-1646808754595-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639410149675-1640976664503-1646286364492-1646808754595-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641872879336-1646286364492-1646808754596-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1642074027298-1646286364492-1646808754596-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1642074041508-1646286364492-1646808754596-1646808862601.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639410537327-1640976664503-1646286364492-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641630776102-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1644400609758-1646657383403-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639411220256-1640976664503-1646286364492-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639568507336-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639569041012-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639569059817-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640064445176-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640840566258-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640841353636-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640843878222-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115117925-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115127425-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640849464616-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013069193-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640850052720-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013117768-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013659516-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640852450140-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640852477583-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640853366687-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640853224793-1640976664503-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641014928544-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641012026126-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641012787423-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641009467416-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641010785822-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011441241-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011450090-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011460116-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641352337650-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641720884346-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641279880688-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641286551347-1646286364493-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646800862254-1646808754596-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646800924153-1646808754597-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646632648612-1646808754597-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641356351200-1646286364493-1646808754597-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/ELF-Walkthrough-1646286364493-1646808754597-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641626351152-1646286364493-1646808754597-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641628962609-1646286364493-1646808754597-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641723629180-1646286364493-1646808754597-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641724561880-1646286364493-1646808754597-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808617642-1646286364493-1646808754597-1646808862602.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808601924-1646286364493-1646808754597-1646808862603.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795301380-1646286364493-1646808754597-1646808862603.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795607023-1646286364493-1646808754597-1646808862603.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795655882-1646286364493-1646808754597-1646808862603.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641809627084-1646286364493-1646808754597-1646808862603.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808750527-1646286364493-1646808754597-1646808862603.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641809596891-1646286364493-1646808754597-1646808862603.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646286717853-1646657383406-1646808754597-1646808862603.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646312037232-1646808754597-1646808862603.png">
<meta property="og:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646286501329-1646657383406-1646808754597-1646808862603.png">
<meta property="article:published_time" content="2021-12-31T18:25:43.000Z">
<meta property="article:modified_time" content="2022-05-18T15:47:48.475Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="miscellaneous">
<meta property="article:tag" content="CSapp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641111569636-1646286364492-1646808754595-1646808862601.png">

<link rel="canonical" href="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>从CSapp中收获的知识（持续更新） | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          从CSapp中收获的知识（持续更新）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-01 02:25:43" itemprop="dateCreated datePublished" datetime="2022-01-01T02:25:43+08:00">2022-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 23:47:48" itemprop="dateModified" datetime="2022-05-18T23:47:48+08:00">2022-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>29 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="从CSapp中收获的知识"><a href="#从CSapp中收获的知识" class="headerlink" title="从CSapp中收获的知识"></a>从CSapp中收获的知识</h2><p><strong>CSapp</strong>是一本很好的书，它像极了一本“技术字典”，知识十分全面但又不深入，对学习计算机有着引领性的作用</p>
<p>我学习<strong>CSapp</strong>已经有一段时间了，有些章节可以调起我的兴趣，使我在网络上进行了知识扩充，但有些章节用大段大段的文字来劝退我，甚至还有一些章节玩起了“高数”，搞得我很懵逼</p>
<p><strong>CSapp</strong>上的知识太杂，太广，我感觉好多知识我都没法利用上（或许以后用得上），我害怕搞忘了这些知识，于是我也做过章节总结，但是我发现这样做的效率并不高，所以我打算不以章节为单位进行总结，而是把知识拆分为小块，逐一记录</p>
<hr>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641111569636-1646286364492-1646808754595-1646808862601.png" class width="1641111569636"> 
<h2 id="程序执行流程"><a href="#程序执行流程" class="headerlink" title="程序执行流程"></a>程序执行流程</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639405451872-1640399662182-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639405451872"> 
<p>文字版本如下：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640400471882-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1640400471882"> 
<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>编译器驱动程序的工作：调用语言预处理器，编译器，汇编器，链接器</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641118618666-1646286364492-1646808754595-1646808862601.png" class width="1641118618666"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646665002297-1646808754595-1646808862601.png" class width="1646665002297"> 
<p>详细过程：</p>
<ul>
<li><strong>预处理阶段</strong>：预处理器（cpp）根据以字符 “#” 开头的命令，修改原始的 C 程序（比如 hello.c 中第 1 行的<code>#include</code>命令告诉预处理器读取系统头文件 stdio.h 的内容）并把它直接插入程序文本中，结果就得到了另一个 C 程序<ul>
<li>通常是以 .i 作为文件扩展名</li>
<li>所谓的头文件，里面装的其实就是函数声明（libc库中的函数：scanf，printf 等）</li>
</ul>
</li>
<li><strong>编译阶段</strong>：编译器（ccl）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序<ul>
<li>.s 文件其实就是装有汇编语言的文件</li>
</ul>
</li>
<li><strong>汇编阶段</strong>：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中<ul>
<li>hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main 的指令编码</li>
<li>如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码（二进制）</li>
</ul>
</li>
<li><strong>链接阶段</strong>：链接器（ld）就负责处理合并各个 hello.o 文件，结果就得到 hello 文件，它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中，由系统执行<ul>
<li>请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数</li>
<li>printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中</li>
<li>通过修改 hello.o 可以影响最终文件 hello 的效果</li>
</ul>
</li>
</ul>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>抽象是从众多的事物中抽取出共同的、本质性的<strong>特征</strong></p>
<p><strong>指令集架构</strong>是对 <strong>实际处理器硬件</strong> 的抽象</p>
<p><strong>文件</strong>是对 <strong>I/O设备</strong> 的抽象</p>
<p><strong>虚拟内存</strong>是对 <strong>程序存储器</strong> 的抽象</p>
<p><strong>虚拟机</strong>是对 <strong>整个计算机</strong> 的抽象</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639413250532-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639413250532"> 
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>缓存</strong>（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用 <strong>[DRAM]技术</strong> ，而使用昂贵但较快速的 <strong>[SRAM]技术</strong> ，缓存的设置是所有现代计算机系统发挥高性能的重要因素之一</p>
<p>缓存的工作原理是当CPU要读取一个数据时，首先从CPU缓存中查找，找到就立即读取并送给CPU处理，没有找到，就从速率相对较慢的内存中读取并送给CPU处理 </p>
<p><strong>缓存命中</strong></p>
<p>但程序需要在第 <strong>n</strong> 层中查找数据时：它会首先在第 <strong>n-1</strong> 层中查找， 如果数据刚好就在第 <strong>n-1</strong> 层中，就直接使用第 <strong>n-1</strong> 层中的数据，称为<strong>缓存命中</strong></p>
<p>从第 <strong>n-1</strong> 层中读取，要比从第 <strong>n</strong> 层中读取更快</p>
<p><strong>缓存不命中</strong></p>
<p>另一方面，如果程序没有在第 <strong>n-1</strong> 层中查找到数据，那么它便会在第 <strong>n</strong> 层中查找，称为<strong>缓存不命中</strong>，同时会把第 <strong>n</strong> 层的数据写入第 <strong>n-1</strong> 层</p>
<h2 id="内存阶层"><a href="#内存阶层" class="headerlink" title="内存阶层"></a>内存阶层</h2><p>速度快的存储器往往容量小，容量大的储存器往往速度慢</p>
<p>所以综合存储器的优劣，内存阶层的机制出现了</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115585515-1646286364492-1646808754595-1646808862601.png" class width="1641115585515"> 
<p>核心思想为：上一层（更快更小）为下一层（更大更慢）的缓存</p>
<p>内存阶层是在电脑架构下储存系统阶层的排列顺序，每一层于下一层相比都拥有较高的速度和较低延迟性，以及较小的容量（也有少量例外）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left"><strong>位于哪里</strong></th>
<th style="text-align:left"><strong>存储容量</strong></th>
<th style="text-align:left"><strong>访问时间</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU寄存器</td>
<td style="text-align:left">位于CPU执行单元中</td>
<td style="text-align:left">CPU寄存器通常只有几个到几十个，每个寄存器的容量取决于CPU的字长，所以一共只有几十到几百字节</td>
<td style="text-align:left">寄存器是访问速度最快的存储器，典型的访问时间是几纳秒</td>
</tr>
<tr>
<td>Cache</td>
<td style="text-align:left">和MMU一样位于CPU核中</td>
<td style="text-align:left">Cache通常分为几级，最典型的是如上图所示的两级Cache，一级Cache更靠近CPU执行单元，二级Cache更靠近物理内存，通常一级Cache有几十到几百KB，二级Cache有几百KB到几MB</td>
<td style="text-align:left">典型的访问时间是几十纳秒</td>
</tr>
<tr>
<td>内存</td>
<td style="text-align:left">位于CPU外的芯片，与CPU通过地址和数据总线相连</td>
<td style="text-align:left">典型的存储容量是几百MB到几GB</td>
<td style="text-align:left">典型的访问时间是几百纳秒</td>
</tr>
<tr>
<td>硬盘</td>
<td style="text-align:left">位于设备总线上，并不直接和CPU相连，CPU通过设备总线的控制器访问硬盘</td>
<td style="text-align:left">典型的存储容量是几百GB</td>
<td style="text-align:left">典型的访问时间是几毫秒，是寄存器的“10的6次方”倍</td>
</tr>
</tbody>
</table>
</div>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641117200100-1646286364492-1646808754595-1646808862601.png" class width="1641117200100"> 
<h2 id="管理单元"><a href="#管理单元" class="headerlink" title="管理单元"></a>管理单元</h2><p>计算机常用“扇区”，“簇”，“块”，“页”等概念，这些都是<strong>管理单元</strong></p>
<p><strong>扇区：</strong>（Sector）</p>
<p>扇区，顾名思义，每个磁盘有多条同心圆似的磁道，磁道被分割成多个部分，每部分的弧长加上到圆心的两个半径，恰好形成一个扇形，所以叫做扇区 </p>
<p>扇区是磁盘中最小的物理存储单位（每个扇区的大小是512字节，通常4096字节）</p>
<p><strong>块：</strong>（Block）</p>
<p>块是操作系统中最小的逻辑存储单元（例如内存块的基本组成单元：chunk）</p>
<p><strong>簇：</strong></p>
<p>簇是微软操作系统（DOS、WINDOWS等）中磁盘文件存储管理的最小单位 </p>
<p><strong>块和簇的关系：</strong></p>
<p>在Windows下如NTFS等文件系统中叫做簇</p>
<p>在Linux下如Ext4等文件系统中叫做块</p>
<p>每个簇或者块可以包括2、4、8、16、32、64… “2的n次方” 个扇区 </p>
<p><strong>页：</strong>（page）</p>
<p>页是内存的最小存储单位，页的大小通常为磁盘块大小的 “2的n次方” 倍，是内存操作的基本单位 </p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统有两目的：</p>
<p>1.防止硬件被失控的应用滥用</p>
<p>2.向应用程序提供简单一致的机制来控制复杂的低级硬件</p>
<p>操作系统通过几个基本的<strong>抽象</strong>概念来实现这两个功能：</p>
<p>1.<strong>文件</strong>是对 <strong>I/O设备</strong> 的抽象</p>
<p>2.<strong>虚拟内存</strong>是对 <strong>程序存储器</strong> 的抽象</p>
<p>3.<strong>进程</strong>是对 <strong>处理器，内存，I/O设备</strong> 的抽象</p>
<h2 id="程序计数器-PC"><a href="#程序计数器-PC" class="headerlink" title="程序计数器(PC)"></a>程序计数器(PC)</h2><p>程序计数器（PC）是CPU控制部件中的一种，用于存放指令的地址 </p>
<p>程序计数器是一个概念上的说法，<strong>不同的机型把不同的存储器当成程序计数器</strong></p>
<ul>
<li>8086：IP寄存器  </li>
<li>i386：EIP寄存器</li>
<li>amd64：RIP寄存器</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>内核可以决定抢占当前进程，并重新开始一个被抢占的进程，这种决策叫做<strong>调度</strong>，是由内核中被称为“调度器”的代码处理的</p>
<p><strong>上下文切换机制</strong>用于：保存“被调度进程”的数据</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>当程序在系统上运行时，操作系统会提供一种 <strong>假象</strong> ，就好像系统上只有这个程序在运行一样，程序看上去是在 <strong>独占</strong> 处理器（该程序是系统资源中唯一的对象）</p>
<p>这些 <strong>假象</strong> 是通过 <strong>进程</strong> 这个概念来实现的</p>
<p>​        //在系统中，各种程序交替执行，而 <strong>进程</strong> 把不同功能的程序 <strong>区分</strong> 开来</p>
<p>在单处理器系统中：</p>
<p>程序想要“并发处理多个进程”时，必须要先保存当前进程的 <strong>上下文</strong> ，然后创建新进程的 <strong>上下文</strong></p>
<p>比如“hello”执行的过程就涉及到两个进程：1.shell    2.hello</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639410149675-1640976664503-1646286364492-1646808754595-1646808862601.png" class width="1639410149675"> 
<p>系统中的每个程序都运行在某个进程的上下文中，上下文就是程序正确运行所需要的状态（包括：存放在内存中的代码和数据，栈和通用寄存器中的内容，程序计数器，环境变量，打开文件描述符的集合）</p>
<p>进程将会提供给应用程序两个关键的抽象：</p>
<ul>
<li>逻辑控制流</li>
<li>私有地址空间</li>
</ul>
<h2 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641872879336-1646286364492-1646808754596-1646808862601.png" class width="1641872879336"> 
<p>实际上：系统中的进程是<strong>交错运行</strong>的，每个进程执行它流的一部分，然后被抢占（暂时挂起），接着轮到其他进程</p>
<p>进程提供的假象：好像每个程序都在<strong>单独地</strong>使用处理器</p>
<p>这种假象就是：逻辑控制流，它仿佛可以控制程序的逻辑行为，一步一步的流向，可以使用<strong>流程图</strong>来表现这种行为的流动，方便了调试人员对程序执行流程的把控</p>
<h2 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h2><p>系统中的逻辑流有多种不同的形式：异常处理，进程，信号处理，线程，java进程……</p>
<p>并发流：在时间上，一个逻辑流和另一个逻辑流冲突，这两个流并发运行</p>
<p>并发：多条流在同时执行的一般现象</p>
<p>多任务（时间分片）：多个进程流量执行的现象</p>
<h2 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h2><p>私有地址空间也是进程提供的假象，好像程序在单独地使用系统地址空间一样</p>
<p>​        // 私有地址空间是虚拟内存的子集</p>
<p>每个进程都会为所对应的程序提供一份“私有地址空间”，每个“私有地址空间”完全一致，并且只能被所对应的程序访问</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>Unix提供了大量从C程序中操作进程的系统调用</p>
<h2 id="僵死进程"><a href="#僵死进程" class="headerlink" title="僵死进程"></a>僵死进程</h2><p>当一个进程因为某种原因终止后，内核并不会马上把它清除，而是等待它的父进程把它回收</p>
<p>一个终止了但是还没有被回收的进程被称为<strong>僵死进程</strong></p>
<p>如果一个进程的父进程终止了，内核会安排“init进程”成为它的“养父”（代替父进程回收子进程）</p>
<p>​        // “init进程”的PID为“1”，“调度进程”（系统进程）的PID为“0”</p>
<h2 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h2><p>PID，就是“比例（proportional）、积分（integral）、微分（derivative）” </p>
<p>PID控制应该算是应用非常广泛的控制算法，小到控制一个元件的温度，大到控制无人机的飞行姿态和飞行速度等等，都可以使用PID控制。这里我们从原理上来理解PID控制</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1642074027298-1646286364492-1646808754596-1646808862601.png" class> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1642074041508-1646286364492-1646808754596-1646808862601.png" class width="1642074041508"> 
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程（英语：thread）是操作系统能够进行<strong>运算调度</strong>的最小单位 </p>
<p>线程被包含在进程之中，是进程中的实际运作单位 </p>
<p>​        // <strong>多线程</strong> 比 <strong>多进程</strong> 跟高效 </p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存为每个进程提供了一个<strong>假象</strong></p>
<p>就好像每个进程在<strong>单独占用</strong>内存空间一样，每个进程中看到的内存是一样的（虚拟地址空间）</p>
<p>即：该进程是系统资源中唯一的对象</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639410537327-1640976664503-1646286364492-1646808754596-1646808862602.png" class width="1639410537327">   
<p>物理内存是不连续的，但是操作系统完成了“使内存看起来是连续的”这样一份抽象，创造了 <strong>虚拟内存</strong> ，并且为虚拟内存中的各个空间进行了编号</p>
<ul>
<li>虚拟内存<strong>用户空间</strong>每个进程各一份</li>
<li>虚拟内存<strong>内核空间</strong>所有进程共享一份</li>
<li>虚拟内存 mmap 段中的<strong>动态链接库</strong>仅在物理内存中装载一份</li>
</ul>
<p><strong>虚拟内存的作用</strong></p>
<p>硬件只能识别“物理地址”，而“物理地址”是不连续的并且不方便显示，这就给调试程序带来了巨大的影响</p>
<p>所以操作系统抽象出了“虚拟内存”，把硬件中的数据映射到“虚拟内存”中，方便了调试</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641630776102-1646286364493-1646808754596-1646808862602.png" class width="1641630776102">  
<h2 id="虚拟内存作为缓存工具"><a href="#虚拟内存作为缓存工具" class="headerlink" title="虚拟内存作为缓存工具"></a>虚拟内存作为缓存工具</h2><p>VM系统（虚拟程序系统）将虚拟内存分割成块，这些块被称为虚拟页</p>
<p>每个虚拟页的大小为“P = 2的p次方”字节，类似地，物理内存被分割为物理页，大小也为P字节（物理页也被称为“页帧”）</p>
<p>在任意时刻，虚拟页面的集合都分为3个不相交的子集：</p>
<ul>
<li>未分配的：VM系统还未分配的页，没有数据和它们相关，不占用磁盘空间</li>
<li>缓存的：当前已缓存在物理内存中的已分配页</li>
<li>未缓存的：当前未缓存在物理内存中的已分配页</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1644400609758-1646657383403-1646808754596-1646808862602.png" class width="1644400609758"> 
<h2 id="Proc文件系统"><a href="#Proc文件系统" class="headerlink" title="Proc文件系统"></a>Proc文件系统</h2><p>Proc文件系统是一个伪文件系统，它只存在于内存中（不占用外存空间），允许“用户模式进程”访问“内核数据结构”的内容</p>
<p>Proc文件系统将许多“内核数据结构”的内容输出为一个用户程序可以读的“文本文件”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /proc/cpuinfo				<span class="comment"># 输出CPU属性</span></span><br></pre></td></tr></table></figure>
<h2 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I/O"></a>Unix I/O</h2><p>一个 Linux 文件就是一个 m 个字节的序列，所有的 I/O 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行</p>
<p>这种将设备优雅地映射为文件的方式，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：</p>
<ul>
<li><strong>打开文件</strong>：一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备，内核返回一个小的非负整数，叫做 <strong>描述符</strong> ，它在后续对此文件的所有操作中标识这个文件，内核记录有关这个打开文件的所有信息，应用程序只需记住这个描述符</li>
<li><strong>改变当前的文件位置</strong>：对于 <strong>每个打开的文件</strong> ，内核保持着一个 <strong>文件位置</strong>（符号为 k），初始为 0，这个文件位置是 <strong>从文件开头起始的字节偏移量（相当于“指向”内存中文件末尾的一个标记，也可以用来记录该文件在内存中的大小）</strong>，应用程序能够通过执行 seek 操作，显式地设置文件的当前位置为 k</li>
<li><strong>读写文件</strong>：一个读操作就是 <strong>从文件复制 n &gt; 0 个字节到内存（从当前文件位置 k 开始，然后将 k 增加到 k+n）</strong> ，假设给定一个大小为 m 字节的文件，当 k&gt;=m 时（文件被完全读入内存）会触发一个称为 end-of-file（EOF）的条件，应用程序能检测到这个条件，在文件结尾处并没有明确的“EOF符号”，类似地，写操作就是 <strong>从内存复制 n &gt; 0 个字节到一个文件）从当前文件位置 k 开始，然后更新 k）</strong></li>
<li><strong>关闭文件</strong>：当应用完成了对文件的访问之后，它就通知内核关闭这个文件，作为响应，<strong>内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中</strong>，无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源</li>
</ul>
<p>Linux shell 创建的每个进程开始时都有三个打开的文件：<strong>标准输入</strong>（描述符为 0）、<strong>标准输出</strong>（描述符为 1）和 <strong>标准错误</strong>（描述符为 2），头文件  定义了常量 STDIN_FILENO、STDOUT_FILENO 和 STDERR_FILENO，它们可用来代替显式的描述符值</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件就是 <strong>字节序列</strong></p>
<p>系统中所有的输入输出都是通过使用 <strong>Unix I/O</strong> 的 <strong>系统函数</strong> 来实现的，文件向应用程序提供了一个 <strong>统一的视图</strong> ，来看待系统中可能含有的各种形式的 <strong>I/O设备</strong>，在linux操作系统中有一个思想“一切皆文件”，即使是内存中的进程都可以被当成文件输出</p>
<p>每个 Linux 文件都有一个 <strong>类型</strong>（type）来表明它在系统中的角色： </p>
<ul>
<li><strong>普通文件</strong>（regular file）：包含任意数据，应用程序常常要区分 <strong>文本文件</strong> 和 <strong>二进制文件 </strong> ，文本文件是只含有 ASCII 或 Unicode 字符的普通文件，二进制文件是所有其他的文件<ul>
<li>对内核而言，文本文件和二进制文件没有区别</li>
<li>Linux 文本文件包含了一个 <strong>文本行</strong>（text line）序列，其中每一行都是一个字符序列，以一个新行符（“\n”）结束</li>
<li>新行符与 ASCII 的换行符（LF）是一样的，其数字值为 0x0a</li>
</ul>
</li>
<li><strong>目录</strong>（directory）：是包含一组 <strong>链接</strong> 的文件，其中每个链接都将一个 <strong>文件名</strong> 映射到一个文件，这个文件可能是另一个目录<ul>
<li>每个目录至少含有两个条目：是到该目录自身的链接，以及是到目录层次结构中 <strong>父目录</strong> 的链接</li>
<li>你可以用 mkdir 命令创建一个目录，用 Is 查看其内容，用 rmdir 删除该目录</li>
</ul>
</li>
<li><strong>套接字</strong>（socket）：是用来与另一个进程进行跨网络通信的文件</li>
</ul>
<p>其他文件类型包含 <strong>命名通道</strong> （named pipe）、  <strong>符号链接</strong> （symbolic link），以及 <strong>字符和块设备</strong> （character and block device）</p>
<h2 id="RIO-健壮地读写"><a href="#RIO-健壮地读写" class="headerlink" title="RIO-健壮地读写"></a>RIO-健壮地读写</h2><p>我们会讲述一个 I/O 包，称为 RIO（Robust I/O，健壮的 I/O）包，它会自动为你处理上文中所述的不足值，在像网络程序这样容易出现不足值的应用中，RIO 包提供了方便、健壮和高效的 I/O</p>
<p>RIO 提供了两类不同的函数： </p>
<ul>
<li><strong>无缓冲的输入输出函数</strong>：这些函数直接在内存和文件之间传送数据，没有应用级缓冲，它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用</li>
<li><strong>带缓冲的输入函数</strong>：这些函数允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为 printf 这样的标准 I/O 函数提供的缓冲区<ul>
<li>与【110】中讲述的带缓冲的 I/O 例程不同，带缓冲的 RIO 输入函数是线程安全的，它在同一个描述符上可以被交错地调用</li>
<li>例如，你可以从一个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行</li>
</ul>
</li>
</ul>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>可以用许多不同的方式来共享 Linux 文件，内核用三个相关的数据结构来表示打开的文件： </p>
<ul>
<li><strong>描述符表</strong>（descriptor table）：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项</li>
<li><strong>文件表</strong>（file table）：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表，每个文件表的表项组成：<ul>
<li>包括当前的 <strong>文件位置</strong> 、<strong>引用计数</strong>（reference count）（即当前指向该表项的描述符表项数），以及一个 <strong>指向 v-node 表</strong> 中对应表项的指针</li>
<li>关闭一个描述符会减少相应的文件表表项中的引用计数</li>
<li>内核不会删除这个文件表表项，直到它的引用计数为零</li>
</ul>
</li>
<li><strong>v-node 表</strong>（v-node table）：同文件表一样，所有的进程共享这张 v-node 表，每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>系统并不是由 <strong>孤立的</strong> 硬件和软件组成的结合体，而是可以通过 <strong>网络</strong> 相互通信</p>
<p>对于一个单独的系统而言，网络可以认为是一个<strong>I/O设备</strong>（输入或输出数据到本机）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639411220256-1640976664503-1646286364492-1646808754596-1646808862602.png" class width="1639411220256"> 
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>计算机的发展始终围绕两个目的：1.更多    2.更快</p>
<p><strong>并发</strong>：指一个同时具有多活动的系统</p>
<p><strong>并行</strong>：指使用 <strong>并发</strong> 来使一个系统运行得更快</p>
<p>并行可以在计算机系统的多个 <strong>抽象层次</strong> 中运用，其中最主要的有3个：</p>
<p><strong>1.线程级并发</strong></p>
<p>构建在进程这个抽象之上，我们可以设计出有多个 <strong>“程序执行工具”</strong> 的系统，这导致了 <strong>并行</strong></p>
<p>这个“程序执行工具”就是线程，使用线程，我们甚至可以在一个进程中执行多个 <strong>控制流</strong></p>
<p><strong>2.指令级并行</strong></p>
<p>构建在较低的抽象层次上，使处理器可以<strong>同时执行</strong>多条指令</p>
<p><strong>3.单指令，多数据并行</strong></p>
<p>构建在较最的抽象层次上，允许一条指令可以产生多个<strong>“并行执行”</strong>的操作</p>
<p>​        //即<strong>SIMD</strong>并行</p>
<h2 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h2><p>指令集架构（InstructionSetArchitecture）</p>
<p>描述：指的是CPU机器码所使用的指令的集合以及其背后的寄存器体系、总线设计等逻辑框架 ，也是规定的一系列CPU与其他硬件电路相配合的指令系统 </p>
<p>作用：定义 <strong>机器级程序</strong> 的格式和行为，它定义了 <strong>处理器状态</strong> ， <strong>指令的格式</strong> ，以及 <strong>每条指令的影响</strong></p>
<p>行为：每条指令<strong>顺序执行</strong>，一条指令完成后，另一条指令开始</p>
<p>​        //不同进程中的指令会被CPU<strong>并发</strong>处理，但是就一个进程而言，它的指令是<strong>“顺序执行”</strong>的</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>大端序：符合人类的认知（低地址存低位，高地址存高位）</p>
<p>小端序：利用机器的运算（低地址存高位，高地址存低位）</p>
<p>为了方便阅读程序，我们通常把低地址写在上面，把高地址写在下面</p>
<p>​        // 这样小端序就“符合人类的认知”</p>
<p>不同的系统采用不同的<strong>字节序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_show_bytes</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ival = val;</span><br><span class="line">    <span class="keyword">float</span> fval = (<span class="keyword">float</span>) ival;</span><br><span class="line">    <span class="keyword">int</span> *pval = &amp;ival;</span><br><span class="line">    show_int(ival);</span><br><span class="line">    show_fload(fval);</span><br><span class="line">    show_pointer(pval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639568507336-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639568507336"> 
<h2 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h2><p>将逻辑值True和False用二进制值“1”和“0”表示，设计出了一种代数</p>
<p>基础逻辑运算：“ ~ ”（非），“ &amp; ”（或），“ | ”（与），“ ^ ”（异或）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639569041012-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639569041012"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1639569059817-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1639569059817"> 
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程是软件中一种很重要的抽象，它提供了一种 <strong>封装</strong> 代码的方式，用一组 <strong>指定的参数</strong> 和一个 <strong>可选择的返回值</strong> 实现了某种功能，而程序可以在任何一个位置引用这种功能</p>
<p>设计良好的软件用 <strong>过程</strong> 作为抽象机制，隐藏某个行为的具体表现，同时又提供清晰简洁的 <strong>接口定义</strong> ，说明需要计算的是哪些值，过程会对程序状态产生什么影响</p>
<p>过程在不同的<strong>编译语言</strong>中有不同的名称：函数（Function），方法（method），子例程，处理函数</p>
<h2 id="嵌套数组-amp-变长数组"><a href="#嵌套数组-amp-变长数组" class="headerlink" title="嵌套数组&amp;变长数组"></a>嵌套数组&amp;变长数组</h2><p>嵌套数组：（多维数组）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">5</span>][<span class="number">3</span>]</span><br><span class="line">------------------------</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> row3_[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">row3_t</span> A[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>两者是等价的</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640064445176-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640064445176"> 
<p>变长数组：</p>
<p>变长数组既数组大小待定的数组， C语言中结构体的最后一个元素可以是大小未知的数组，也就是所谓的0长度，所以我们可以用结构体来创建变长数组 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">&#125;SoftArray;</span><br></pre></td></tr></table></figure>
<h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>c语言提供了两种不同类型的对象组合到一起创建数据类型的机制：</p>
<p>1.结构（structure）    2.联合（union）</p>
<p>structure可以将多个对象集合到一个单位中</p>
<p>union可以用几种不同的类型来引用一个对象</p>
<h2 id="缓存区保护"><a href="#缓存区保护" class="headerlink" title="缓存区保护"></a>缓存区保护</h2><p>1.栈随机化</p>
<p>使栈在每一次加载时都会发生变化</p>
<p>对抗：空操作雪橇，在shellcode前面插入相等长度的“nop”，只要有一个地址命中“nop”就行</p>
<p>​        //汇编指令“nop”让IP指针+1，没有其他作用</p>
<p>2.栈破坏机制</p>
<p>Canary（金丝雀）是系统生成的一个随机数，如果它被破坏，系统就会强行终止程序</p>
<p>3.限制可执行权限</p>
<h2 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h2><p>以“ . ”开头的指令就是 <strong>伪指令</strong> ，它们告诉汇编器<strong>调整地址</strong>，以便在那里产生代码或插入一些数据</p>
<p>例如：伪指令“.pos 0”告诉汇编器应该从地址“0”开始产生代码</p>
<h2 id="控制语言-HCL"><a href="#控制语言-HCL" class="headerlink" title="控制语言(HCL)"></a>控制语言(HCL)</h2><p>大多数现代的电路技术都是用<strong>信号线上的高低电压</strong>来表示不同的值</p>
<p>​        //逻辑1用1.0伏特的高电压，逻辑0用0.0伏特的低电压</p>
<p>为了方便编程，<strong>硬件描述语言HDL</strong>（Hardware Description Language）诞生了</p>
<p>HDL是一种文本表示，和编程语言类似，但是它是用来描述 <strong>硬件结构</strong> 而不是 <strong>程序行为</strong> 的</p>
<p>HCL语言只表达硬件设计的<strong>控制逻辑</strong>部分，只有有限的操作集合（控制逻辑是处理器中最困难的）</p>
<h2 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h2><p>逻辑门是数字电路的基本计算单元，它们的产生和输出，等于它们输入位数的某个布尔函数</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640840566258-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640840566258"> 
<h2 id="组合电路"><a href="#组合电路" class="headerlink" title="组合电路"></a>组合电路</h2><p>将很多的逻辑门组合成一个网，就可以构建出一个<strong>计算块</strong>（computational block），称为组合电路</p>
<h2 id="优化编译器的能力"><a href="#优化编译器的能力" class="headerlink" title="优化编译器的能力"></a>优化编译器的能力</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640841353636-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640841353636"> 
<p>这两个函数有相同的功能，但CPU读写效率却有不同：</p>
<p>第一个函数需要：2次读 <em>xp，2次读 </em>yp，2次写 *xp</p>
<p>第二个函数需要：1次读 <em>xp，1次读 </em>yp，1次写 *xp</p>
<h2 id="程序性能的表示"><a href="#程序性能的表示" class="headerlink" title="程序性能的表示"></a>程序性能的表示</h2><p>我们引入度量标准：<strong>每元素的周期数</strong>（Cycles Per Element），作为一种表示程序性能并指引我们改进代码的方法</p>
<p>处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用<strong>千兆赫兹</strong>，十亿周期每秒来表示</p>
<p>例如：一个系统有“4GHz”处理器，表示这个系统的处理器时钟运行频率为<strong>4 * 10的9次方 /每秒</strong></p>
<h2 id="存储器系统"><a href="#存储器系统" class="headerlink" title="存储器系统"></a>存储器系统</h2><p>存储器系统是一个具有不同<strong>容量，成本，访问时间</strong>的存储设备层次结构</p>
<p>靠近CPU的，小的，快速的，称为<strong>高速缓存存储器</strong></p>
<p>这个思想围绕着计算机程序的一种称为 <strong>局部性</strong> 的基本属性，具有良好局部性的程序倾向于一次又一次地访问相同的 <strong>数据项集合</strong> ，或是倾向访问邻近的 <strong>数据项集合</strong> ，并且更多的倾向于从存储器层次结构中较高层次处访问 <strong>数据项集合</strong> ，这些操作都可以使程序运行得更快</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p><strong>简述</strong></p>
<p>原指处理器在访问某些数据时短时间内存在重复访问，某些数据或者位置访问的 <strong>概率极大</strong> ，大多数时间只访问局部的数据（随着优化技术的提升，局部性的概念也得到了扩充）</p>
<p>其实就是概率的不均等，这个宇宙中，很多东西都不是平均分布的，平均分布是概率论中几何分布的一种特殊形式，非常简单，但世界就是没这么简单。我们更长听到的发布叫做高斯发布，同时也被称为正态分布，因为它就是正常状态下的概率发布，起概率图如下 ：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640843878222-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640843878222"> 
<p><strong>时间局部性(Temporal locality):</strong> </p>
<p>如果某个信息这次被访问，那它有可能在不久的未来被多次访问</p>
<p>时间局部性是空间局部性访问地址一样时的一种特殊情况，这种情况下，可以把常用的数据加<strong>cache</strong>（缓存）来优化访存</p>
<p><strong>空间局部性(Spatial locality):</strong> </p>
<p>如果某个位置的信息被访问，那和它相邻的信息也很有可能被访问到</p>
<p>这个也很好理解，我们大部分情况下代码都是顺序执行，数据也是顺序访问的 </p>
<p><strong>内存局部性(Memory locality):</strong> </p>
<p>访问内存时，大概率会访问连续的块，而不是单一的内存地址，其实就是 <strong>空间局部性在内存上</strong> 的体现</p>
<p>目前计算机设计中，都是以块/页为单位管理调度存储，其实就是在利用空间局部性来优化性能 </p>
<p><strong>分支局部性(Branch locality)</strong> </p>
<p>这个又被称为顺序局部性，计算机中大部分指令是顺序执行，即便有if这种选择分支，其实大多数情况下某个分支都是被大概率选中的</p>
<p>于是就有了CPU的分支预测优化，设计CPU优先选择 <strong>概率较大 </strong>的if分支</p>
<p><strong>等距局部性(Equidistant locality)</strong> </p>
<p>等距局部性是指如果某个位置被访问，那和它 <strong>相邻等距离的连续地址</strong> 极有可能会被访问到，它位于空间局部性和分支局部性之间</p>
<p>举个例子，比如多个相同格式的数据数组，你只取其中每个数据的一部分字段，那么他们可能在内存中地址距离是等距的，这个可以通过简单的线性预测就预测是未来访问的位置</p>
<p><strong>步长对局部性的影响</strong></p>
<p>步长：连续序列号的差值</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115117925-1646286364493-1646808754596-1646808862602.png" class width="1641115117925"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641115127425-1646286364493-1646808754596-1646808862602.png" class width="1641115127425"> 
<p>两个函数只是交互了循环的次序，但程序的性能却截然不同</p>
<p>第一个程序：步长为“4”（int类型） [ 4 - 0 ]</p>
<p>第二个程序：步长为“12”（int类型 * 3）[ 12 - 0 ]</p>
<p>第一个程序的性能远高于第二个程序（步长越长，性能越差）</p>
<h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p><strong>静态RAM</strong>（SRAM）</p>
<p>SRAM将每个<strong>位</strong>存储在一个 <strong>双稳态</strong> 的存储器单元中（每个单元通常是用一个 <strong>6晶体管电路</strong> 来实现的）</p>
<p>这个电路有这样一个属性：它可以无限期地保持 “两个不同的电压配置” 中的一个</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640849464616-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640849464616"> 
<p>这个<strong>双稳态</strong>的存储器单元就像图中的钟摆一样，除了左右稳态以外的任何区域都是不稳定的</p>
<p>只要有电，它就会永远保持它的值，即使有外界干扰也会马上回复</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013069193-1646286364493-1646808754596-1646808862602.png" class width="1641013069193"> 
<p><strong>动态RAM</strong>（DRAM）</p>
<p>DRAM将每个<strong>位</strong>存储为一个 <strong>电容的充电</strong>（每个单元由一个 <strong>电容</strong> 和一个 <strong>访问晶体管</strong> 组成）</p>
<p>和SRAM有着较强的稳定性不同，DRAM对干扰非常敏感，电容电压被扰乱以后就不会恢复了</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640850052720-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640850052720"> 
<p>DRAM芯片被封装在内存模块中</p>
<p>内存模块 (Memory Module)是指一个 <strong>印刷电路板</strong> 表面上有镶嵌数个 <strong>记忆体</strong> ， <strong>芯片chips</strong>(碎片)，而这 内存芯片 通常是 DRAM芯片</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013117768-1646286364493-1646808754596-1646808862602.png" class width="1641013117768"> 
<p><strong>增强型DRAM</strong></p>
<p>快页模式DRAM（FPM DRAM）</p>
<p>扩展数据DRAM（EDO DRAM）</p>
<p>同步DRAM（SDRAM）</p>
<p>双倍数据速率同步DRAM（DDR SDRAM）</p>
<p>视频RAM（VRAM）</p>
<p><strong>只读存储器ROM</strong>（ROM是一种非易失性存储器）</p>
<p>如果计算机突然断电，DRAM和SRAM都会失去它们的数据，所以它们是<strong>易失的</strong></p>
<p>在失去电源的情况下，数据也不会丢失的存储器就是<strong>非易失性存储器</strong></p>
<p>最开始的ROM是真的“只读”的，但是随着技术的发展，ROM也慢慢“可读”了起来</p>
<p><strong>可编程ROM</strong>（PROM）</p>
<p>PROM只能每编程一次（PROM的每个存储器单元都有一种熔丝（fuse），只能被高温熔断一次）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641013659516-1646286364493-1646808754596-1646808862602.png" class width="1641013659516"> 
<p><strong>可擦写可编程ROM</strong>（EPROM）</p>
<p>EPROM有一个透明的石英窗口，允许光线到达存储单元，当紫外线射过窗口时，EPROM单元会被清除为“0”，对EPROM的编程需要通过特殊设备（把“1”写入EPROM），EPROM总共可以擦除重编程的次数为：10的3次方</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640852450140-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640852450140"> 
<p><strong>电子可擦除PROM</strong>（EEPROM）</p>
<p>EEPROM和EPROM类似，只不过不用特殊设备就可以对它进行编程，可以直接在印制电路卡上进行编程，EEPROM总共可以被编程的次数为：10的5次方</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640852477583-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640852477583"> 
<p><strong>闪存</strong>（flash memory）</p>
<p>闪存基于EEPROM，是一种重要的存储技术（U盘就是利用Flash实现的）</p>
<p>与前面的PROM，EPROM，EEPROM以 <strong>位</strong> 为单位不同，Flash以 <strong>块</strong> 为单位（128kb，256kb）</p>
<p>Flash的基本构成单位为<strong>浮栅场效应管</strong>（这是一个三端器件，分别为：源极，漏极，栅极）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640853366687-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640853366687"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1640853224793-1640976664503-1646286364493-1646808754596-1646808862602.png" class width="1640853224793"> 
<p><strong>磁盘</strong></p>
<p>磁盘是用于大量存储数据的存储设备，存储数据的数量级可以达到几千千兆字节，但从磁盘上读取数据的时间为毫秒级，比DRAM慢了10万倍，比SRAM慢了100万倍</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641014928544-1646286364493-1646808754596-1646808862602.png" class width="1641014928544"> 
<p>磁盘由多个重叠在一起的盘片组成，它们被封装在一个密封的包装中</p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>在内存调试时，经常需要用到rank、bank等参数，可以看到电脑的内存条中，有很多一片一片的芯片，这就是内存芯片，也是叫内存颗粒 </p>
<p>内存的基本单元称为 <strong>cell</strong> ，cell按行( <strong>row</strong> )、列( <strong>column</strong> )分布组成一个 <strong>bank</strong> </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641012026126-1646286364493-1646808754596-1646808862602.png" class width="1641012026126"> 
<p>一颗内存颗粒由多个 <strong>bank</strong> 组成，现在的内存颗粒一般是8个bank，每个bank对于内存来说是平等的关系，因为内存控制器的原因，每个时钟周期只能对一个bank进行操作 </p>
<p>所有在内存容量关系中：<strong>颗粒</strong> &gt; <strong>bank</strong> &gt; <strong>row</strong> ， <strong>column</strong> &gt; <strong>cell</strong> </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641012787423-1646286364493-1646808754596-1646808862602.png" class width="1641012787423"> 
<h2 id="IO桥接器"><a href="#IO桥接器" class="headerlink" title="IO桥接器"></a>IO桥接器</h2><p>数据通过总线进行流通，每次CPU和主存之间的数据传输都是通过一系列步骤完成的，这些步骤被称为<strong>总线事务</strong></p>
<p>读事务：把数据从主存传输到CPU</p>
<p>写事务：把数据从CPU传输到主存</p>
<p>而现代计算机中IO是通过 <strong>共享一条总线</strong> 的方式来实现的，这就是 <strong>IO总线</strong>（I/O bus）</p>
<p>而<strong>IO桥接器</strong>则是一组芯片组（其中包括内存控制器）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641009467416-1646286364493-1646808754596-1646808862602.png" class width="1641009467416"> 
<p>CPU芯片，IO桥接器，DRAM内存模块</p>
<p>系统总线（system bus）连接了CPU和IO桥接器</p>
<p>内存总线（memory bus）连接IO桥接器和主存</p>
<p>系统总线和内存总线都通过IO桥接器连接到IO总线上，这就实现了各个硬件之间的交互</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641010785822-1646286364493-1646808754596-1646808862602.png" class width="1641010785822"> 
<p>在这个过程中：CPU上被称为<strong>总线接口</strong>的电路会在总线上发起“读事务”</p>
<p>​        //交换“A”和“%rax”位置，则会发起“写事务”</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011441241-1646286364493-1646808754596-1646808862602.png" class width="1641011441241"> 
<p>CPU会把A放到系统总线上，IO桥接器将信号传递到内存总线,传输到主存</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011450090-1646286364493-1646808754596-1646808862602.png" class width="1641011450090"> 
<p>接下来主存会识别内存总线上的地址信号，从内存总线中读取地址，从DRAM中取出数据字，并将数据写入内存总线通过IO桥又写入系统总线，传输到CPU</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641011460116-1646286364493-1646808754596-1646808862602.png" class width="1641011460116"> 
<p>最后CPU会读取系统总线上的数据，赋值给寄存器rax</p>
<h2 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h2><p>链接（linking）是将 <strong>各种代码</strong> 和 <strong>数据片段</strong> 收集并组合成一个单一文件的过程</p>
<p>负责链接工作的程序被称为“链接器”</p>
<p>链接器的出现使我们不用将一个应用组织为一个庞大的文件，而是可以分割为更小的模块</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641352337650-1646286364493-1646808754596-1646808862602.png" class width="1641352337650"> 
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接的链接器必须完成两个任务：符号解析，重定位</p>
<p>符号解析：解析目标文件的符号，把 <strong>符号引用</strong> 和 <strong>符号定义</strong> 关联起来</p>
<p>重定位：通过把 <strong>符号定义</strong> 和 <strong>内存位置</strong> 关联起来，来重定位这些节片段，然后修改对这些符号的引用，使它们指向对应的内存位置</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>在创建可执行文件时，静态执行一些链接</p>
<p>在程序加载时，动态完成链接</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641720884346-1646286364493-1646808754596-1646808862602.png" class width="1641720884346"> 
<p>动态链接器通过执行下面的重定位来完成链接任务：</p>
<ul>
<li>重定位 libc.so 的文本和数据到某个内存段</li>
<li>重定位 libvector.so 的文本和数据到另一个内存段</li>
<li>重定位 prog21 中所有的 “由 libc.so 和 libvector.so(存档文件) 定义的” 符号的引用</li>
</ul>
<h2 id="存档文件"><a href="#存档文件" class="headerlink" title="存档文件"></a>存档文件</h2><p>存档文件（libvector.so）是一种文件格式，用于存储一组文件以及与这些文件有关的信息（元数据），创建存档文件的目的是将多个文件存储在一起，通常采用压缩格式，这样可以提高可移植性，同时节省磁盘上的存储空间</p>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>目标文件分为3种：</p>
<p>1.可重定位目标文件：包含二进制代码和数据，可以在编译时与其他可重定位目标文件合并，创建一个可执行目标文件</p>
<p>2.可执行目标文件：包含二进制代码和数据，可以直接放入内存执行（就是可执行文件）</p>
<p>3.共享目标文件：一种特殊的可重定位目标文件，可以在加载或者运行时被 <strong>动态</strong> 地加载进内存并进行连接</p>
<p>编译器和汇编器生成：可重定位目标文件</p>
<p>链接器生成：可执行目标文件</p>
<p>各个系统目标文件的格式不同：Unix系统，采用a.out格式；Windows系统，采用PE格式；MacOS系统，采用Mach-O格式</p>
<h2 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641279880688-1646286364493-1646808754596-1646808862602.png" class width="1641279880688"> 
<p>这个就是可重定位目标文件的格式，ELF头描述了产生该文件的系统的 <strong>字的大小</strong> 和 <strong>字节序</strong></p>
<p>ELF头剩下的部分包含：帮助链接器进行 <strong>语法分析</strong> 和 <strong>解释目标文件</strong> 的信息</p>
<p>不同节的位置大小是由 “节头部” 决定的，其中目标文件的每个节都有一个固定大小的条目（entry），夹在“ELF头”和“节头部表”之间的都是节</p>
<p>一个经典的ELF可重定位目标文件包含下面几个节：</p>
<p>.text：已经编译的程序机器代码</p>
<p>.rodata：只读数据</p>
<p>.data：已经初始化的 全局变量 和 静态变量（局部变量保存在栈中）</p>
<p>.bss：未初始化的 全局变量 和 静态变量（被初始化为“0”的变量也会保存在这里）</p>
<p>.symtab：符号表，用于存放程序中定义或引用的 “函数和全局变量” 的信息</p>
<p>.rel.text：“.text节”的重定位信息，用于重新修改代码段的指令中的地址信息 </p>
<p>.debug：调试符号表</p>
<p>.line：原始C源程序中的行号 和 “.text节”中机器指令之间的映射</p>
<p>.strtab：字符串表（包含“.symtab”和“.debug”中的符号名和节名）</p>
<h2 id="符号及其相关"><a href="#符号及其相关" class="headerlink" title="符号及其相关"></a>符号及其相关</h2><p><strong>符号（symbol）</strong></p>
<p>函数名，变量名，数组名，结构体名都可以称之为符号</p>
<p>在链接器的上下文中一共有3中不同的符号：</p>
<ul>
<li>Global symbols（模块内部定义的全局符号）<ul>
<li>由模块m定义并能被其他模块引用的符号（非static函数，非static全局变量）</li>
</ul>
</li>
<li>External symbols（外部定义的全局符号）<ul>
<li>由其他模块定义并被模块m引用的全局符号</li>
</ul>
</li>
<li>Local symbols（本模块的局部符号）<ul>
<li>仅由模块m定义和引用的本地符号（带有static的函数和全局变量）</li>
<li>注意：局部变量不会在过程外被引用（分配在栈中），因此不是符号定义</li>
</ul>
</li>
</ul>
<p><strong>符号表（symtab）</strong></p>
<p>符号表是由汇编器构造的，包含一个条目的数组，每个条目都是一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf32_Word    st_name;      <span class="comment">/* 符号对应字符串在strtab节中的偏移量 */</span> </span><br><span class="line">        Elf32_Word    st_value;     <span class="comment">/* 在对应节中的偏移量，可执行文件中是虚拟地址 */</span></span><br><span class="line">        Elf32_Word    st_size;      <span class="comment">/* 符号对应目标所占字节数 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   type: <span class="number">4</span>,    <span class="comment">/* 符号对应目标的类型：数据、函数、源文件、节 */</span></span><br><span class="line">              		 binding: <span class="number">4</span>;    <span class="comment">/* 符号类别：全局符号、局部符号、弱符号 */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>   st_other;</span><br><span class="line">        Elf32_Section   st_shndx;    <span class="comment">/* 符号对应目标所在的节，或其他情况 */</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    Elf64_Word    st_name;        <span class="comment">/* Symbol name (string tbl index) */</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;        <span class="comment">/* Symbol type and binding */</span>  </span><br><span class="line">    <span class="comment">// 高4字节为type，低4字节为binding</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;       <span class="comment">/* Symbol visibility */</span>  </span><br><span class="line">    Elf64_Addr    st_value;       <span class="comment">/* Symbol value */</span>  </span><br><span class="line">    Elf64_Xword   st_size;        <span class="comment">/* Symbol size */</span>  </span><br><span class="line">&#125;Elf64_Sym; </span><br></pre></td></tr></table></figure>
<p>st_name：对应字符串表的偏移</p>
<p>st_value：距离目标符号地址的偏移</p>
<p>st_size：目标的大小</p>
<p>st_info：高字节为type，低字节为binding</p>
<p>type：表示符号类型（要么是数据，要么是函数）</p>
<p>binding：表示符号是本地的，还是全局的</p>
<p><strong>符号和节</strong></p>
<p>每个符号都会被分配到目标文件的某个节，由 section 字段表示，改字段也是一个到节头部表的<strong>索引</strong>，但是存在3个 <strong>伪节</strong> ，它们在节头部表中是没有条目的</p>
<p>ABS：代表不应该被重定位的符号</p>
<p>UNDEF：代表未定义的符号，就是在本目标模块中被引用，但是却在其他地方定义的符号</p>
<p>COMMON：代表未被分配位置的未初始化数据的目录</p>
<p>​        // 只有在可重定位目标文件中才有这些伪节，可执行目标文件是没有的</p>
<p>COMMON和bss节的区别很细微：</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641286551347-1646286364493-1646808754596-1646808862602.png" class width="1641286551347"> 
<p><strong>符号解析</strong></p>
<p>链接器从左往右按照它们在编译器驱动程序命令行上出现的顺序，来扫描可重定位目标文件和存档文件，在这次扫描中，链接器会维护：</p>
<p>一个 <strong>可重定位目标文件的集合E</strong> （将会被合并为可执行目标文件）</p>
<p>一个 <strong>未解析符号集合U</strong> （引用了但是未定义）</p>
<p>一个 <strong>在前面输入文件中已经定义的符号集合D</strong>（自己定义的符号也会被装入）</p>
<p>符号解析的工作流程如下：</p>
<ol>
<li>在命令行上输入文件F，链接器会判断文件F是一个目标文件，还是一个存档文件 </li>
<li>如果是目标文件，则添加到E，并且修改U和D来反应F中的 <strong>符号定义</strong> 和 <strong>引用</strong></li>
<li>如果F是一个存档文件，那么链接会尝试匹配 <strong>未解析符号集合U</strong> 和 <strong>存档文件成员定义的符号</strong> ，假设存档文件中有个成员 m，定义了一个符号来解析U中的一个引用，那么就将 m 添加到E中，并且链接器修改U和D来反映 m 中的 <strong>符号定义</strong> 和 <strong>引用</strong></li>
</ol>
<p>扫描完成以后，集合U非空，链接器就会输出一个错误并终止，以表明有符号未定义</p>
<p>扫描完成以后，集合U为空，那么链接器就会合并集合E中的目标文件，构建可执行文件</p>
<p>​        // 当D被新填入时，对应的U会减少</p>
<p><strong>符号变量</strong></p>
<p>自动变量（动态局部变量）：auto </p>
<ul>
<li>离开函数，值就消失</li>
<li>不写 static 就默认是 auto</li>
</ul>
<p>静态局部变量：static </p>
<ul>
<li>离开函数，值任然保留</li>
<li>变量的值只在函数内部生效</li>
<li>带有 static 的变量只会初始化一次（数据存储在 data 段）</li>
<li>当上一级函数多次调用本函数时，带有 static 的变量数值不变（并且不会进行初始化）</li>
</ul>
<p>寄存器变量：register</p>
<ul>
<li>离开函数，值就消失</li>
<li>变量的值只在函数内部生效</li>
</ul>
<p>全局变量：在 main 之外</p>
<ul>
<li>允许 main 中所有函数访问</li>
<li>允许外部其他文件访问</li>
</ul>
<p>静态全局变量：在 main 之外，static</p>
<ul>
<li>允许 main 中所有函数访问</li>
<li>变量的值只在文件内部生效</li>
</ul>
<h2 id="节"><a href="#节" class="headerlink" title="节"></a>节</h2><p>使用目标文件的节头表，可以定位文件的所有节，节头表是 <code>Elf32_Shdr</code> 或 <code>Elf64_Shdr</code> 结构的数组</p>
<p><strong>节头</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        elf32_Word      sh_name; <span class="comment">/* 节的名称，此成员值是节头字符串表节的索引，用于指定以空字符结尾的字符串的位置 */</span></span><br><span class="line">        Elf32_Word      sh_type; <span class="comment">/* 用于将节的内容和语义分类 */</span></span><br><span class="line">        Elf32_Word      sh_flags; <span class="comment">/* 节可支持用于说明杂项属性的1位标志 */</span></span><br><span class="line">        Elf32_Addr      sh_addr; <span class="comment">/* 如果节显示在进程的内存映像中，则此成员会指定节的第一个字节所在的地址 */</span></span><br><span class="line">        Elf32_Off       sh_offset; <span class="comment">/* 从文件的起始位置到节中第一个字节的字节偏移 */</span></span><br><span class="line">        Elf32_Word      sh_size; <span class="comment">/* 节的大小 */</span></span><br><span class="line">        Elf32_Word      sh_link; <span class="comment">/* 节头表索引链接，其解释依赖于节类型 */</span></span><br><span class="line">        Elf32_Word      sh_info; <span class="comment">/* 额外信息，其解释依赖于节类型 */</span></span><br><span class="line">        Elf32_Word      sh_addralign; <span class="comment">/* 一些节具有地址对齐约束 */</span></span><br><span class="line">        Elf32_Word      sh_entsize; <span class="comment">/* 指定每一项的大小(一些节包含固定大小的项的表) */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Elf64_Word      sh_name;</span><br><span class="line">        Elf64_Word      sh_type;</span><br><span class="line">        Elf64_Xword     sh_flags;</span><br><span class="line">        Elf64_Addr      sh_addr;</span><br><span class="line">        Elf64_Off       sh_offset;</span><br><span class="line">        Elf64_Xword     sh_size;</span><br><span class="line">        Elf64_Word      sh_link;</span><br><span class="line">        Elf64_Word      sh_info;</span><br><span class="line">        Elf64_Xword     sh_addralign;</span><br><span class="line">        Elf64_Xword     sh_entsize;</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<p><strong>节分配</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646800862254-1646808754596-1646808862602.png" class width="1646800862254"> 
<p><strong>节简述</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646800924153-1646808754597-1646808862602.png" class width="1646800924153"> 
<ul>
<li>ELF头：包括16字节的标识信息，文件类型（.o，exec，.so），机器类型（如Intel 80386），节头表的偏移，节头表的表项大小及表项个数 </li>
<li>.text节：编译后的代码部分 </li>
<li>.rodata节：只读数据，如 printf 用到的格式串，switch 跳转表等</li>
<li>.data节：已初始化的全局变量和静态变量</li>
<li>.bss节：未初始化全局变量和静态变量，仅是占位符，不占据任何磁盘空间，区分初始化和非初始化是为了空间效率</li>
<li>.symtab节：存放函数和全局变量（符号表）的信息，它不包括局部变量</li>
<li>.rel.text节：.text节的重定位信息，用于重新修改代码段的指令中的地址信息</li>
<li>.debug节：调试用的符号表（gcc -g） </li>
<li>.strtab节：包含 .symtab节和 .debug节 中的符号及节名 </li>
</ul>
<p><strong>示例</strong>（可能会有不同，比如：在我的电脑上 .data 为第4节）</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646632648612-1646808754597-1646808862602.png" class width="1646632648612"> 
<h2 id="运行-amp-链接-amp-加载-amp-存储地址"><a href="#运行-amp-链接-amp-加载-amp-存储地址" class="headerlink" title="运行&amp;链接&amp;加载&amp;存储地址"></a>运行&amp;链接&amp;加载&amp;存储地址</h2><p><strong>运行地址 ~~ 链接地址</strong></p>
<p>链接地址：在程序编译的时候，每个目标文件都是由源代码编译得到，最终多个目标文件链接生成一个最终的可执行文件，而链接地址就是指示链接器，各个目标文件的在可执行程序中的位置 </p>
<ul>
<li>链接地址是静态的，在进行程序编译的时候指定的</li>
</ul>
<p>运行地址： 程序实际在内存中运行时候的地址 </p>
<ul>
<li>运行地址是动态的，如果你将程序加载到内存中时，改变存放在内存的地址，那么运行地址也就随之改变了</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641356351200-1646286364493-1646808754597-1646808862602.png" class width="1641356351200"> 
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如上图所示，指令ldr r0, =func就是一条位置相关指令，在编译的时候，编译器根据链接地址（链接地址入口是 <span class="number">0x40008000</span> ）将其翻译成：ldr r0, [pc, #<span class="number">0x80</span>]，也就是将func标号等价于地址 <span class="number">0x40008080</span> ，然后将 <span class="number">0x40008080</span> 这个地址数值放在a.out文件中链接地址 <span class="number">0x50008000</span> 的位置。当程序运行时，a.out会被加载到内存中运行，如果程序运行的地址和链接的地址都是 <span class="number">0x40008000</span> ，那么程序运行时，没有任何问题，因为读取的func的地址是 <span class="number">0x40008080</span> ，实际跳转的时候，跳转到 <span class="number">0x40008080</span> 中存放的也是func对应的代码。但是如果运行的地址和链接地址不一样（运行地址是 <span class="number">0x20008000</span> ），这时候，func的地址还是编译的时候计算的地址 <span class="number">0x40008080</span> ，但是实际在内存中，func的地址是 <span class="number">0x20008080</span> ，那么当你跳转执行func的时候，取出来的是 <span class="number">0x40008080</span> ，跳转的地址也是 <span class="number">0x40008080</span> ，而 <span class="number">0x40008080</span> 中存放的是什么代码我们不确定，但是一定不是func的代码（func存放在 <span class="number">0x20008080</span> 中）。这个就是位置相关的概念</span><br></pre></td></tr></table></figure>
<p><strong>加载地址 ~~ 存储地址</strong> </p>
<p>加载地址：每一个程序一开始都是存放在flash中的，而运行是在内存中，这个时候就需要从flash中将指令读取到内存中（运行地址），flash的地址就是加载地址 </p>
<p>存储地址：指令在flash中存放的存储地址，就是存储地址 </p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDNmianfeixiazai001/article/details/81455692">链接地址、运行地址、加载地址、存储地址</a></p>
<h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>但链接器完成符号解析这一步时，就会把代码中的 <strong>每个符号引用</strong> 和 <strong>一个符号定义</strong> 关联起来</p>
<p>此时，链接器就知道它输入目标模块的 “代码节” 和 “数据节” 的切确大小</p>
<p>重定位的工作流程如下：</p>
<ul>
<li>重定位“节”和“符号定义”：链接器会把所有同类型的节合并起来，然后将“运行地址”赋值给 <strong>“新的聚合节”</strong> ， <strong>“输入模块中定义的每个节”</strong> ，以及 <strong>“输入模块中定义的每个符号”</strong> ，这一步完成之后，程序中的每条指令和全局变量都有唯一的“运行地址” </li>
<li>重定位“节”中的“符号引用”：链接器会修改 代码节 和 数据节 中对应 <strong>每个符号的引用</strong> ，使得它们指向 <strong>正确的运行地址</strong> （链接器需要依赖“重定位条目relocation entry”完成此操作）</li>
</ul>
<h2 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h2><p>代码的重定位条目存放于“.rel.text”中</p>
<p>已初始化数据的重定位条目存放于“.rel.data”中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr  r_offset;</span><br><span class="line">    Elf32_Word  r_info; </span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Addr  r_offset;	</span><br><span class="line">    Elf64_Word  r_info; 	</span><br><span class="line">    Elf64_Word r_addend;	</span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>r_offset：需要 “被修改引用” 的节偏移</p>
<p>r_info：高字节为type，低字节为symbol</p>
<p>type：告知链接器如何修改新的引用</p>
<p>symbol：标识 “被修改引用” 应该指向的符号</p>
<p>r_addend：一个符号常数，一些类型的重定位要使用它进行调整</p>
<p>ELF文件定义了32种不同的重定位类型，其中最基本的两种为：</p>
<ul>
<li>R_X86_64_PC32：使用32位 <strong>PC相对地址</strong> 的引用（PC相对地址：距离程序计数器（PC）的当前运行值的偏移量），类似于 “jmp xxxx” 等汇编指令，“xxxx” 加上 程序的“SP指针”得到 <strong>有效地址</strong> ，PC值通常是下一条指令在内存中的地址</li>
<li>R_X86_64_32：使用32位 <strong>绝对地址</strong> ，CPU直接获取 <strong>有效地址</strong></li>
</ul>
<p>文件中的代码和数据总体大小“小于2GB”，使用“R_X86_64_PC32”（小型代码模型）</p>
<p>文件中的代码和数据总体大小“大于2GB”，使用“R_X86_64_32”（中型代码模型，大型代码模型）</p>
<p>GCC默认使用“R_X86_64_PC32”</p>
<h2 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/ELF-Walkthrough-1646286364493-1646808754597-1646808862602.png" class title="ELF-Walkthrough"> 
<p><strong>段和节</strong></p>
<p>段视图：是用来描述ELF加载到进程中后，来划分“读，写，执行”权限划分的视图</p>
<p>节视图：是ELF存放在磁盘中时，进行不同功能区域划分的视图</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641626351152-1646286364493-1646808754597-1646808862602.png" class width="1641626351152">
<p>在汇编源码中，通常用语法关键字section或segment来表示一段区域，它们是编译器提供的伪指令，作用是相同的，都是在程序中”逻辑地”规划一段区域，此区域便是节 </p>
<p>注意，此时所说的section或segment都是汇编语法中的关键字，它们在语法中都表示”节”，不是段，只是不同编译器的关键字不同而已，关键字segment在语法中也被认为与section意义相同  </p>
<p>只有ELF文件加载到内存成为进程过后，才有“段”的概念</p>
<p><strong>ELF文件到虚拟内存的映射</strong></p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641628962609-1646286364493-1646808754597-1646808862602.png" class width="1641628962609"> 
<p>​        // 左边为“节”，右边为“段”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump -s elf	<span class="comment">#查看elf文件结构</span></span><br><span class="line">cat /proc/pid/maps	<span class="comment">#输出进程对应的‘虚拟内存’结构</span></span><br></pre></td></tr></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>当linux系统加载某个文件时，会通过调用某个驻留在存储器中的 <strong>加载器</strong>（loader）来运行它，加载器本质上也是一段“操作系统代码”（通过execve函数来调用加载器）</p>
<p>加载器把目标文件的“代码”和“数据”，从磁盘复制到内存中的过程就叫做<strong>加载</strong></p>
<h2 id="位置无关代码-PIC"><a href="#位置无关代码-PIC" class="headerlink" title="位置无关代码(PIC)"></a>位置无关代码(PIC)</h2><p>无需“重定位”就可以加装的代码就是 <strong>位置无关代码</strong> （PIC）</p>
<p>位置无关代码无论被加载到哪个地址上都可以正常执行 </p>
<p><strong>PIC的数据引用</strong></p>
<p>无论我们在内存何处加装一个目标模块，它的“数据段”和“代码段”的距离总是保持不变的，因此，代码段中 <strong>任何指令</strong> 和 <strong>任何变量</strong> 之间的距离都是常量</p>
<p>生成全局变量PIC的偏移器利用了这个事实，它在数据段开始的地方创建了一个表，叫做<strong>全局偏移量表</strong>（GOT表），在GOT表中，每个被此模块引用的“全局数据”，“过程”，“全局变量”，都有一个8字节条目</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641723629180-1646286364493-1646808754597-1646808862602.png" class width="1641723629180"> 
<p>加载时，动态链接会重定位GOT表中的每个条目，使其包含目标的绝对地址</p>
<p><strong>PIC的函数调用</strong></p>
<p>编译器没法直接获取“共享库函数”的绝对地址，所以这里采用了<strong>延迟绑定</strong>的方式</p>
<p>延迟绑定技术是通过GOT表（全局偏移量表）和PLT表（过程链接表）的交互完成的</p>
<ul>
<li>过程链接表（plt）：plt是一个数组，每个条目都是16字节的代码，每一个条目负责一个具体的函数，plt[0]是一个特殊条目（它可以跳转 <strong>动态链接器</strong> ），plt[1]调用系统启动函数“libc_start_main”，从plt[2]开始的条目依次调用“用户代码中的函数”</li>
<li>全局偏移量表（got）：got是一个数组，每个条目都是8字节地址，got[0]和got[1]会包含 <strong>动态链接器 </strong>在解析函数地址时需要的信息，got[2]是 <strong>动态链接器</strong> 在“ld-linux.so”模块中的入口点，其余的每一个got表条目都对应一个被调用的函数，每一个条目都有一个对应的plt[n]</li>
</ul>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641724561880-1646286364493-1646808754597-1646808862602.png" class width="1641724561880"> 
<ul>
<li>第1步：程序进入plt[n]（对应被调用函数的plt条目），跳转got[n]</li>
<li>第2步：got[n]没有对应的libc地址，程序跳转回plt[n]</li>
<li>第3步：把偏移压栈，接着跳转plt[0]</li>
<li>第4步：把got[1]（link_map）压栈，跳转got[2]</li>
<li>第5步：got[2]中存放的<strong>动态链接器</strong>会根据“偏移”和“got[1]”查找libc库中的函数</li>
<li>第6步：找到对应函数后，进入函数，并且把got[n]对应位置写入libc函数的地址</li>
</ul>
<h2 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h2><p>linux链接器允许用户截获程序对共享库函数的调用，取而代之自己的代码，这种技术被称为<strong>“库打桩”</strong></p>
<p>利用“库打桩”，用户可以追踪某个函数的调用次数，验证和追踪它的输入值和输出值，或者把它替换为一个完全不同的实现</p>
<p><strong>基本思想</strong></p>
<p>先给定一个需要打桩的目标函数，创建一个包装函数（它的原型和目标函数一样），使用特殊的打桩机制，<strong>可以欺骗程序程序调用包装函数而不是目标函数</strong></p>
<p>假设有程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;malloc.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size) <span class="comment">//把malloc全替换为mymalloc</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*打桩函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>编译时打桩：主要利用了C预处理机制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -MYMOCK -c mymalloc.c	</span><br><span class="line">$ gcc -I. -o test test.c mymalloc.o <span class="comment">//test就是目标文件</span></span><br></pre></td></tr></table></figure>
<p>参数 <strong>“- I.”</strong> 会告诉C预处理器，在搜索通常的系统目录之前，先在当前目录中查找“malloc.h”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0xdbd010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：“malloc.h”被“mymalloc.o”调包了</p>
<p><strong>链接时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> malloc(size) mymalloc(size) <span class="comment">//把malloc全替换为mymalloc</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> *__real_malloc(<span class="keyword">size_t</span> size);<span class="comment">//注意声明</span></span><br><span class="line"><span class="comment">/*打桩函数*/</span></span><br><span class="line"><span class="keyword">void</span> *__wrap_malloc(<span class="keyword">size_t</span> size) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = __real_malloc(size);<span class="comment">//最后会被解析成malloc</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>链接时打桩：linux静态链接器支持用 “—wrap，function”进行打桩 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DMYMOCK mymalloc.c</span><br><span class="line">$ gcc -c main.c</span><br><span class="line">$ gcc -Wl,--wrap,<span class="built_in">malloc</span> -o test test.o mymalloc.o <span class="comment">//test就是目标文件</span></span><br></pre></td></tr></table></figure>
<p>“-Wl option”表示把“option”传递给链接器</p>
<p>“—wrap，malloc”告诉静态链接器：</p>
<p>把“malloc”解析为“ __wrap_malloc ”</p>
<p>把“ __real_malloc ”解析为“真正的malloc”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0x95f010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：“malloc”被解析为了“ __wrap_malloc ”</p>
<p><strong>运行时打桩</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MYMOCK <span class="comment">//只有MYMOCK编译选项是，这段代码才会编译进去</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE  <span class="comment">//这行特别注意加上</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> FILE *<span class="built_in">stdout</span>;</span><br><span class="line"><span class="comment">/*打桩的malloc函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> calltimes;</span><br><span class="line">    calltimes++;</span><br><span class="line">    <span class="comment">/*函数指针*/</span></span><br><span class="line">    <span class="keyword">void</span> *(*realMalloc)(<span class="keyword">size_t</span> size) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> *error;</span><br><span class="line"></span><br><span class="line">    realMalloc = dlsym(RTLD_NEXT,<span class="string">&quot;malloc&quot;</span>);<span class="comment">//RTLD_NEXT</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == realMalloc)</span><br><span class="line">    &#123;</span><br><span class="line">        error = dlerror();</span><br><span class="line">        <span class="built_in">fputs</span>(error,<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ptr = realMalloc(size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == calltimes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ptr is %p\n&quot;</span>,ptr);</span><br><span class="line">    &#125; </span><br><span class="line">    calltimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>运行时打桩：可以通过设置LD_PRELOAD环境变量，达到在你加载一个动态库或者解析一个符号时，先从LD_PRELOAD指定的目录下的库去寻找需要的符号，然后再去其他库中寻找 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -DMYMOCK -shared -fPIC -o libmymalloc.so mymalloc.c -ldl</span><br><span class="line">    <span class="comment">//将mymalloc.c制作成动态库 &gt;&gt; libmymalloc.so</span></span><br><span class="line">$ LD_PRELOAD=<span class="string">&quot;./libmymalloc.so&quot;</span> <span class="comment">//设置LD_PRELOAD环境变量</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">ptr is <span class="number">0x95f010</span></span><br></pre></td></tr></table></figure>
<p>可以发现：程序优先从”./libmymalloc.so”找到了“打桩malloc”</p>
<h2 id="异常控制流-ECF"><a href="#异常控制流-ECF" class="headerlink" title="异常控制流(ECF)"></a>异常控制流(ECF)</h2><p>程序可以使控制流发生“突变”来处理异常情况，这些“突变”就是<strong>异常控制流</strong></p>
<p>应用程序可以使用“陷阱（trap）”或者“系统调用（syscall）”的ECF形式，向操作系统请求服务：向磁盘中写数据，从网络中读数据，创建一个新进程，终止当前进程</p>
<h2 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步&amp;异步"></a>同步&amp;异步</h2><p>同步，是所有的操作都做完，才返回给用户结果，即写完数据库之后，在相应用户</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808617642-1646286364493-1646808754597-1646808862602.png" class width="1641808617642">  
<p>异步，不用等所有操作等做完，就相应用户请求，即先相应用户请求，然后慢慢去写数据库</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808601924-1646286364493-1646808754597-1646808862603.png" class width="1641808601924">  
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是控制流中的一种形式，它一部分由硬件实现，一部分由操作系统实现</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795301380-1646286364493-1646808754597-1646808862603.png" class width="1641795301380"> 
<ul>
<li>CPU检测到flag寄存器中的异常数据</li>
<li>CPU控制IP指针，通过“异常表的跳转表”跳转对应的处理程序</li>
<li>处理完成后，进行相对应的操作（终止进程，继续进程，输出报错信息……）</li>
</ul>
<p>系统把每种类型的异常都分配了一个<strong>唯一非负</strong>的异常号</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795607023-1646286364493-1646808754597-1646808862603.png" class width="1641795607023"> 
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641795655882-1646286364493-1646808754597-1646808862603.png" class width="1641795655882"> 
<p>异常表的基址放在一个叫<strong>异常表基址寄存器</strong>的特殊CPU寄存器中</p>
<p><strong>异常的类型</strong></p>
<p>异常分为4种：中断（interrupt），陷阱（trap），故障（fault），终止（abort）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>来自“I/O”设备的信号</td>
<td>同步&amp;异步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>陷阱</td>
<td>有意的异常</td>
<td>同步</td>
<td>总是返回到下一条指令</td>
</tr>
<tr>
<td>故障</td>
<td>潜在可恢复的错误</td>
<td>同步</td>
<td>可能返回到当前指令</td>
</tr>
<tr>
<td>终止</td>
<td>不可恢复的错误</td>
<td>同步</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
</div>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断程序信号处理的一种机制</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641809627084-1646286364493-1646808754597-1646808862603.png" class width="1641809627084"> 
<p>中断分为 <strong>内中断</strong> 和 <strong>外中断</strong></p>
<p><strong>内中断概述</strong></p>
<p>任何一个CPU都有一种能力：</p>
<p>可以在执行完<strong>当前指令</strong>后检测到从CPU内部产生的一种<strong>特殊信息</strong>，并立刻进行处理</p>
<p>这种特殊信息就是<strong>中断信息</strong></p>
<p>​        //中断信息要求CPU立马进行处理，并携带了必备的参数</p>
<p>内中断可以使计算机可以处理<strong>紧急情况</strong></p>
<p>内中断在程序中有意地产生，所以是主动的，也是<strong>“同步”</strong>的</p>
<p><strong>内中断产生</strong></p>
<p>1.除法错误（TF=0）</p>
<p>2.单步执行（TF=1）</p>
<p>3.执行”into”指令（TF=4）</p>
<p>4.执行”int  n”指令（TF=n）</p>
<p>对于8086CPU，这4种情况可以产生<strong>中断信息</strong></p>
<p><strong>外中断概述</strong></p>
<p>CPU除了进行运算以外，还要有对 <strong>I/O</strong> 能力（输入/输出），但是外设的输入输出 <strong>随时</strong> 可能发生，CPU必须要拥有可以 <strong>及时处理</strong> 这些信息的能力，这就引入了外中断的思想</p>
<p>这种中断发生完全是<strong>“异步”</strong>的，根本无法预测到此类中断会在什么时候发生</p>
<p><strong>外中断产生</strong></p>
<p>外设的输入将被存放在端口中，而其输入随时可能到达</p>
<p>信息到达时，外设的相关芯片会给CPU发出相应的<strong>中断信息</strong>，当CPU执行完当前的指令后，一旦检测到该<strong>中断信息</strong>，就会触发外中断，行为上和内中断相似</p>
<p>在PC系统中，外中断源一般有以下两类：</p>
<p>1.可屏蔽中断：</p>
<p>可屏蔽中断是CPU可以<strong>不响应</strong>的中断</p>
<p>其到底响不响应，主要是看<strong>IF</strong>寄存器（“<strong>IF</strong> = 1” ——&gt; 响应，“<strong>IF</strong> = 0” ——&gt; 不响应）</p>
<p>在CPU执行某个中断时，会把<strong>IF</strong>设置为“0”，可以暂时屏蔽其他中断</p>
<p>​        //指令sti：设置“IF=1”，指令cli：设置“IF=0”</p>
<p>2.不可屏蔽中断：</p>
<p>不可屏蔽中断是CPU必须执行的外中断，不可屏蔽中断<strong>不需要</strong>中断类型码，立即引发响应</p>
<p><strong>中断向量表</strong></p>
<p>中断向量表中保存了256个中断处理程序的入口</p>
<p>CPU接收到中断类型码后，就会根据中断类型表找到中断处理程序的入口</p>
<p><strong>中断过程</strong></p>
<p>1.CPU获取中断类型码</p>
<p>2.flag寄存器入栈（中断过程会改变flag寄存器）</p>
<p>3.设置flag寄存器的<strong>TF</strong>和<strong>IF</strong>为“0”</p>
<p>4.<strong>CS</strong>寄存器入栈</p>
<p>5.<strong>IP</strong>寄存器入栈</p>
<p>6.从中断向量表中读取中断处理程序的入口地址</p>
<p><strong>中断检查</strong></p>
<p>中断信息会被存储在flag寄存器的<strong>TF</strong>位中（TF = n：中断类型码为“n”）</p>
<p>CPU读取到此信息后就会开始<strong>中断过程</strong></p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>陷阱是有意的异常，是执行一条指令的结果</p>
<p>陷阱最重要的用途：在“用户程序”和“内核”之间提供一个一样的接口，称为<strong>系统调用</strong></p>
<p>处理器提供了一条特殊的指令：syscall，用于用户请求系统调用</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641808750527-1646286364493-1646808754597-1646808862603.png" class width="1641808750527"> 
<p>有些基于读写的操作必须要在 <strong>“内核模式”</strong> 中完成，而系统调用为了实现这些功能而诞生的，它通过提供 <strong>有权限限制</strong> 的  <strong>“内核模式”</strong> ，来实现一些 <strong>“用户模式”</strong> 无法办到的操作</p>
<p>用户程序通过系统调用从用户态（user mode）切换到核心态（ kernel mode ），从而可以访问相应的资源。这样做的好处是：</p>
<ul>
<li>为用户空间提供了一种硬件的抽象接口，使编程更加容易</li>
<li>有利于系统安全</li>
<li>有利于每个进程度运行在虚拟系统中，接口统一有利于移植</li>
</ul>
<p>当然，中断也可以实现系统调用（“int 80”）</p>
<h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2><p>故障是由错误引起的，但是它<strong>可能</strong>可以被故障处理程序修正</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1641809596891-1646286364493-1646808754597-1646808862603.png" class width="1641809596891"> 
<p>当发生故障时，处理器会将控制转移给<strong>故障处理程序</strong>：如果可以修正故障，那么程序将返回并继续执行，否则，程序将返回内核中的“abort例程”并终止该程序</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>终止是不可恢复的致命错误的结果，通常是一些硬件错误</p>
<p>终止处理程序将直接<strong>终止</strong>目标程序，不会返回任何信息</p>
<h2 id="内核模式"><a href="#内核模式" class="headerlink" title="内核模式"></a>内核模式</h2><p>处理器通常是用某个控制寄存器中的<strong>模式位</strong>来表示“当前进程的特权”</p>
<p>共两种特权：“用户模式”，“内核模式”</p>
<h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p><strong>套接字接口</strong>（socket interface）是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用</p>
<p>大多数现代系统上都实现套接字接口，包括所有的 Unix 变种、Windows 和 Macintosh 系统</p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646286717853-1646657383406-1646808754597-1646808862603.png" class width="1646286717853">  
<p>​        // 从 Linux 内核的角度来看，一个套接字就是 <strong>通信的一个端点</strong> ，从 Linux 程序的角度来看，套接字就是一个 <strong>有相应描述符的打开文件</strong></p>
<p>因特网的套接字地址存放在所示的类型为 sockaddr_in 的 16 字节结构中（IP 地址和端口号总是以网络字节顺序（大端法）存放的）</p>
<p>下面将介绍套接字接口中的部分函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">// domain：即协议域，又称为协议族（family）</span></span><br><span class="line"><span class="comment">// type：指定socket类型</span></span><br><span class="line"><span class="comment">// protocol：指定协议</span></span><br></pre></td></tr></table></figure>
<p>​        // 协议族决定了 socket 的地址类型，在通信中必须采用对应的地址</p>
<p><strong>socket 函数</strong> 用于来返回一个 <strong>套接字描述符</strong> （clientfd）</p>
<ul>
<li>套接字描述符：用来标定系统为当前的进程划分的一块缓冲空间，类似于文件描述符 </li>
<li>文件描述符：是内核为了高效管理已被打开的文件所创建的索引，用于指代被打开的文件，对文件所有 I/O 操作相关的系统调用都需要通过文件描述符（open的返回值fd）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：需要绑定的socket</span></span><br><span class="line"><span class="comment">// *addr：存放了服务端用于通信的地址和端口</span></span><br><span class="line"><span class="comment">// addrlen: sizeof(sockaddr_in)</span></span><br></pre></td></tr></table></figure>
<p><strong>bind 函数</strong> 告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来</p>
<p>​        // bind函数把一个本地协议地址赋予一个套接字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> clientfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">// clientfd：套接字描述符的一种</span></span><br><span class="line"><span class="comment">// addrlen：sizeof(sockaddr_in)</span></span><br></pre></td></tr></table></figure>
<p><strong>connect 函数</strong> 试图与 “套接字地址为 addr 的服务器” 建立一个因特网连接</p>
<p>如果成功，clientfd 描述符现在就准备好可以读写了(最好用 getaddrinfo 来为 connect 提供参数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// sockfd：需要绑定的socket</span></span><br><span class="line"><span class="comment">// backlog：暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量</span></span><br></pre></td></tr></table></figure>
<p><strong>listen 函数</strong> 将 sockfd 从一个 <strong>主动套接字</strong> 转化为一个 <strong>监听套接字</strong> （listening socket），该套接字可以接受来自客户端的连接请求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> listenfd, struct sockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">// listenfd：服务器的socket描述符</span></span><br><span class="line"><span class="comment">// *addr：指向struct sockaddr *的指针</span></span><br><span class="line"><span class="comment">// *addrlen：协议地址的长度</span></span><br></pre></td></tr></table></figure>
<p><strong>accept 函数</strong> 等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个 <strong>已连接描述符</strong> </p>
<p>一个服务器通常通常仅仅只创建一个监听socket描述字，内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *service,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> struct addrinfo *hints,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct addrinfo **result)</span></span>;</span><br><span class="line"><span class="comment">// host &amp; service：套接字地址的两个组成部分</span></span><br><span class="line"><span class="comment">// 可选的参数 hints 是一个 addrinfo 结构，它提供对 getaddrinfo 返回的套接字地址列表的更好的控制</span></span><br><span class="line"><span class="comment">// getaddrinfo 返回 result，result 一个指向 addrinfo 结构的链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *result)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> errcode)</span></span>; <span class="comment">// 返回：错误消息</span></span><br></pre></td></tr></table></figure>
<p><strong>getaddrinfo 函数</strong> 将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构，它是已弃用的 gethostbyname 和 getservbyname 函数的新的替代品 </p>
<p>在客户端调用了 getaddrinfo 之后，会遍历这个列表，依次尝试每个套接字地址，直到调用 socket 和 connect 成功，建立起连接，类似地，服务器会尝试遍历列表中的每个套接字地址，直到调用 socket 和 bind 成功，描述符会被绑定到一个合法的套接字地址，</p>
<ul>
<li>为了避免内存泄漏，应用程序必须在最后调用 freeaddrinfo，释放该链表</li>
<li>如果 getaddrinfo 返回非零的错误代码，应用程序可以调用 gai_streeror，将该代码转换成消息字符串</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>             ai_flags;      <span class="comment">/* Hints argument flags */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_family;     <span class="comment">/* First arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_socktype;   <span class="comment">/* Second arg to socket function */</span></span><br><span class="line">    <span class="keyword">int</span>             ai_protocol;   <span class="comment">/* Third arg to socket function */</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname; <span class="comment">/* Canonical hostname */</span></span><br><span class="line">    <span class="keyword">size_t</span>          ai_addrlen;    <span class="comment">/* Size of ai_addr struct */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>      <span class="comment">/* Ptr to socket address structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>      <span class="comment">/* Ptr to next item in linked list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646312037232-1646808754597-1646808862603.png" class width="1646312037232"> 
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">char</span> *host, <span class="keyword">size_t</span> hostlen,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">char</span> *service, <span class="keyword">size_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// *sa：指向大小为 salen 字节的套接字地址结构</span></span><br><span class="line"><span class="comment">// *host 指向大小为 hostlen 字节的缓冲区</span></span><br><span class="line"><span class="comment">// *service 指向大小为 servlen 字节的缓冲区</span></span><br><span class="line"><span class="comment">// 参数 flags 是一个位掩码，能够修改默认的行为</span></span><br></pre></td></tr></table></figure>
<p><strong>getnameinfo 函数</strong> 和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串，它是已弃用的 gethostbyaddr 和 getservbyport 函数的新的替代品 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_clientfd</span><span class="params">(<span class="keyword">char</span> *hostname, <span class="keyword">char</span> *port)</span></span>;</span><br><span class="line"><span class="comment">// *hostname：服务器运行的地址</span></span><br><span class="line"><span class="comment">// *port：指向端口</span></span><br></pre></td></tr></table></figure>
<p>客户端调用 open_clientfd 建立与服务器的连接 </p>
<p><strong>open_clientfd 函数</strong> 建立与服务器的连接，该服务器运行在主机 hostname 上，并在端口号 port 上监听连接请求 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_listenfd</span><span class="params">(<span class="keyword">char</span> *port)</span></span>;</span><br><span class="line"><span class="comment">// *port：指向端口号</span></span><br></pre></td></tr></table></figure>
<p><strong>open_listenfd 函数</strong> 打开和返回一个监听描述符，这个描述符准备好在端口 port_h 接收连接请求 </p>
<h2 id="网络编程中的信号"><a href="#网络编程中的信号" class="headerlink" title="网络编程中的信号"></a>网络编程中的信号</h2><p><strong>进程组</strong></p>
<p>进程组就是一系列相互关联的进程集合，系统中的每一个进程也必须从属于某一个进程组，每个进程组中都会有一个唯一的 ID(process group id)，简称 PGID，PGID 一般等同于进程组的创建进程的 Process ID，而这个进进程一般也会被称为进程组先导(process group leader)，同一进程组中除了进程组先导外的其他进程都是其子进程</p>
<p>进程组的存在，方便了系统对多个相关进程执行某些统一的操作，例如：我们可以一次性发送一个信号量给同一进程组中的所有进程</p>
<p><strong>会话</strong></p>
<p>会话（session）是一个若干进程组的集合，同样的，系统中每一个进程组也都必须从属于某一个会话</p>
<ul>
<li>一个会话只拥有最多一个控制终端（也可以没有），该终端为会话中所有进程组中的进程所共用</li>
<li>一个会话中前台进程组只会有一个，只有其中的进程才可以和控制终端进行交互，除了前台进程组外的进程组，都是后台进程组</li>
</ul>
<p>和进程组先导类似，会话中也有会话先导(session leader)的概念，用来表示建立起到控制终端连接的进程，在拥有控制终端的会话中，session leader 也被称为控制进程(controlling process)，一般来说控制进程也就是登入系统的 shell 进程(login shell)</p>
<p><strong>带外数据</strong></p>
<p>带外数据用于迅速告知对方本端发生的重要的事件，它比普通的数据（带内数据）拥有更高的优先级， <strong>不论发送缓冲区中是否有排队等待发送的数据，它总是被立即发送</strong> ，带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中，</p>
<p>​        // 实际应用中，带外数据是使用很少见，有 telnet 和 ftp 等远程非活跃程序</p>
<p>UDP没有没有实现带外数据传输，TCP也没有真正的带外数据，不过TCP利用头部的紧急指针标志和紧急指针，为应用程序提供了一种紧急方式，含义和带外数据类似，TCP的紧急方式利用传输普通数据的连接来传输紧急数据</p>
<p><strong>SIGHUP信号</strong>（关闭进程）</p>
<p>SIGHUP 信号在 <strong>用户终端连接(正常或非正常)结束</strong> 时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业(任务)，这时它们与控制终端不再关联</p>
<p>系统对SIGHUP信号的默认处理是：<strong>终止收到该信号的进程</strong> ，所以若程序中没有捕捉该信号，当收到该信号时，进程就会退出</p>
<p>SIGHUP会在以下3种情况下被发送给相应的进程：</p>
<ul>
<li>终端关闭时，该信号被发送到 session 首进程以及作为 job 提交的进程（即用 &amp; 符号提交的进程）</li>
<li>session 首进程退出时，该信号被发送到该 session 中的前台进程组中的每一个进程</li>
<li>若父进程退出导致进程组成为孤儿进程组，且该进程组中有进程处于停止状态（收到SIGSTOP或SIGTSTP信号），该信号会被发送到该进程组中的每一个进程</li>
</ul>
<p>例如：在我们登录Linux时，系统会分配给登录用户一个终端(Session)，在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session，当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号，这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止</p>
<p>​        // 晦涩难懂，需要在实例中理解分析</p>
<p><strong>SIGPIPE信号</strong>（告知中断）</p>
<p>当 <strong>往一个写端关闭的管道或 socket 连接中连续写入数据时会引发 SIGPIPE 信号</strong>（引发 SIGPIPE 信号的写操作将设置 errno 为EPIPE）</p>
<p>在TCP通信中，当通信的双方中的一方close一个连接时，若另一方接着发数据，根据TCP协议的规定，会收到一个RST(Reset the connection)响应报文，若再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，<strong>告诉进程这个连接已经断开了，不能再写入数据</strong></p>
<ul>
<li>即使断开还可以进行一次通信，第二次发送数据时才触发SIGPIPE</li>
<li>可以用相应的 handle 进行处理SIGPIPE，完成想要的操作</li>
</ul>
<h2 id="网络编程结构体"><a href="#网络编程结构体" class="headerlink" title="网络编程结构体"></a>网络编程结构体</h2><p><strong>通用结构体：struct sockaddr，16个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generic socket address structure (for connect, bind, and accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>   sa_family;      <span class="comment">/* Protocol family */</span></span><br><span class="line">    <span class="keyword">char</span>       sa_data[<span class="number">14</span>];    <span class="comment">/* Address data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct sockaddr 是一个通用地址结构，这是为了统一地址结构的表示方法，统一接口函数，使不同的地址结构可以被bind() , connect() 等函数调用</p>
<p>sockaddr的缺陷：sa_data 把目标地址和端口信息混在一起了 </p>
<p><strong>通用结构体：struct sockaddr_storage，128个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure large enough to hold any socket address </span></span><br><span class="line"><span class="comment">  (with the historical exception of AF_UNIX). 128 bytes reserved.  */</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ULONG_MAX &gt; 0xffffffff</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ss_aligntype __uint64_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ss_aligntype __uint32_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_SIZE        128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_PADSIZE     (_SS_SIZE - (2 * sizeof (__ss_aligntype)))</span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">     <span class="keyword">uint16_t</span>          ss_family;     <span class="comment">/* Address family */</span></span><br><span class="line">     __ss_aligntype   __ss_align;     <span class="comment">/* Force desired alignment.  */</span></span><br><span class="line">     <span class="keyword">char</span> __ss_padding[_SS_PADSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct sockaddr_storage 被设计为同时适合 struct sockaddr_in 和 struct sockaddr_in6 </p>
<p>为了避免试图知道要使用的IP版本，可以使用 struct sockaddr_storage，该版本可以保存其中任何一个，后将通过 connect()，bind() 等函数将其类型转换为 struct sockaddr 并以这种方式进行访问 </p>
<p><strong>IPv4：struct sockaddr_in，16个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IP socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_family;   <span class="comment">/* Protocol family (always AF_INET) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>       sin_port;     <span class="comment">/* 16位的端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">/* 32位的IP地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">sa_family_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (struct in_addr)]; <span class="comment">// sin_zero[8]</span></span><br><span class="line">    <span class="comment">/* Pad to sizeof(struct sockaddr) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  &#123;</span></span><br><span class="line">     <span class="keyword">in_addr_t</span>   s_addr;            <span class="comment">/* IPv4 address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体解决了 sockaddr 的缺陷，把 port 和 addr 分开储存在两个变量中 </p>
<p><strong>IPv6：struct sockaddr_in6，28个字节</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin6_family;      <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>    sin6_port;        <span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    sin6_flowinfo;    <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>    <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;       <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> u6_addr8[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">uint16_t</span> u6_addr16[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">uint32_t</span> u6_addr32[<span class="number">4</span>];</span><br><span class="line">    &#125; in6_u;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr                 in6_u.u6_addr8</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr16               in6_u.u6_addr16</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr32               in6_u.u6_addr32</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="服务器简析"><a href="#服务器简析" class="headerlink" title="服务器简析"></a>服务器简析</h2><p>每个网络应用都是基于客户端—服务器模型的，釆用这个模型，一个应用是由 <strong>一个服务器进程</strong> 和一个或者多个 <strong>客户端</strong> 进程组成 </p>
<img src="/2022/01/01/%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86/1646286501329-1646657383406-1646808754597-1646808862603.png" class width="1646286501329"> 
<p>个客户端—服务器事务由以下四步组成：</p>
<ol>
<li>当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务，例如，当 Web 浏览器需要一个文件时，它就发送一个请求给 Web 服务器</li>
<li>服务器收到请求后，解释它，并以适当的方式操作它的资源，例如，当 Web 服务器收到浏览器发出的请求后，它就读一个磁盘文</li>
<li>服务器给客户端发送一个响应，并等待下一个请求，例如，Web 服务器将文件发送回客户端</li>
<li>客户端收到响应并处理它，例如，当 Web 浏览器收到来自服务器的一页后，就在屏幕上显示此页</li>
</ol>
<h2 id="服务器请求"><a href="#服务器请求" class="headerlink" title="服务器请求"></a>服务器请求</h2><p>一般的请求消息如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /home.html HTTP/1.0 <span class="comment">&lt;!-- 请求消息行 --&gt;</span></span><br><span class="line">Accept: */* <span class="comment">&lt;!-- 请求消息头 --&gt;</span></span><br><span class="line">Host: localhost:GET /home.html HTTP/1.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: localhost:GET /home.html HTTP/1.0</span><br><span class="line">Accept: */*</span><br><span class="line">Host: localhost:</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3</span><br><span class="line">Connection: close</span><br><span class="line">Proxy-Connection: close</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- 消息正文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span></span><br><span class="line">Dave O&#x27;Hallaron</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>请求消息行：请求消息的第一行为请求消息行</p>
<ul>
<li>例如：GET  /test/test.html  HTTP/1.1</li>
<li>GET 为请求方式，请求方式分为：Get（默认）、POST、DELETE、HEAD等<ul>
<li>GET：明文传输 不安全，数据量有限，不超过1kb</li>
<li>POST：暗文传输，安全，数据量没有限制</li>
</ul>
</li>
<li>/test/test.html 为URI，统一资源标识符</li>
<li>HTTP/1.1 为协议版本</li>
</ul>
</li>
<li><p>请求消息头：从第二行开始到空白行统称为请求消息头</p>
<ul>
<li>Accept：浏览器可接受的MIME类型告诉服务器客户端能接收什么样类型的文件</li>
<li>Accept-Charset：浏览器通过这个头告诉服务器，它支持哪种字符集</li>
<li>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如 gzip</li>
<li>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到，可以在浏览器中进行设置</li>
<li>Host：初始URL中的主机和端口</li>
<li>Referrer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</li>
<li>Content-Type：内容类型告诉服务器浏览器传输数据的MIME类型，文件传输的类型</li>
<li>If-Modified-Since：利用这个头与服务器的文件进行比对，如果一致，则从缓存中直接读取文件</li>
<li>User-Agent：浏览器类型</li>
<li>Content-Length：表示请求消息正文的长度</li>
<li>Connection：表示是否需要持久连接。如果服务器看到这里的值为“Keep -Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接）</li>
<li>Cookie：用于分辨两个请求是否来自同一个浏览器，以及保存一些状态信息</li>
<li>Date：请求时间GMT</li>
</ul>
</li>
<li><p>消息正文：当请求方式是[POST]方式时，才能看见消息正文，消息正文就是要传输的一些数据，如果没有数据需要传输时，消息正文为空</p>
</li>
</ul>
<h2 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h2><p>一般的响应如下代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK <span class="comment">&lt;!-- 响应消息行 --&gt;</span></span><br><span class="line">Server: Tiny Web Server <span class="comment">&lt;!-- 响应消息头 --&gt;</span></span><br><span class="line">Content-length: 120</span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> <span class="comment">&lt;!-- 响应正文 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">src</span>=<span class="string">&quot;godzilla.gif&quot;</span>&gt;</span></span><br><span class="line">Dave O&#x27;Hallaron</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>响应消息行：第一行响应消息为响应消息行<ul>
<li>例如：HTTP/1.0 200 OK</li>
<li>HTTP/1.0 为协议版本</li>
<li>200 为响应状态码，常用的响应状态码有40余种，这里我们仅列出几种，详细请看：<ul>
<li>200：一切正常</li>
<li>302/307：临时重定向</li>
<li>304：未修改，客户端可以从缓存中读取数据，无需从服务器读取</li>
<li>404：服务器上不存在客户端所请求的资源</li>
<li>500：服务器内部错误</li>
</ul>
</li>
<li>OK 为状态码描述</li>
</ul>
</li>
<li>响应消息头：<ul>
<li>Location：指示新的资源的位置通常和302/307一起使用，完成请求重定向</li>
<li>Server：指示服务器的类型</li>
<li>Content-Encoding：服务器发送的数据采用的编码类型</li>
<li>Content-Length：告诉浏览器正文的长度</li>
<li>Content-Language：服务发送的文本的语言</li>
<li>Content-Type：服务器发送的内容的MIME类型</li>
<li>Last-Modified：文件的最后修改时间</li>
<li>Refresh：指示客户端刷新频率，单位是秒</li>
<li>Content-Disposition：指示客户端下载文件</li>
<li>Set-Cookie：服务器端发送的Cookie</li>
<li>Expires：-1</li>
<li>Cache-Control：no-cache (1.1)  </li>
<li>Pragma：no-cache   (1.0)  表示告诉客户端不要使用缓存</li>
<li>Connection：close/Keep-Alive   </li>
<li>Date：请求时间</li>
</ul>
</li>
<li>响应正文：即网页的源代码（F12可查看）</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/miscellaneous/" rel="tag"><i class="fa fa-tag"></i> miscellaneous</a>
              <a href="/tags/CSapp/" rel="tag"><i class="fa fa-tag"></i> CSapp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/01/%E8%A7%A3%E6%9E%90pwn%E9%A2%98%E4%B8%AD%E9%99%84%E5%B8%A6%E7%9A%84%E6%96%87%E4%BB%B6/" rel="prev" title="解析pwn题中附带的文件（持续更新）">
      <i class="fa fa-chevron-left"></i> 解析pwn题中附带的文件（持续更新）
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/02/%E5%90%84%E7%A7%8D%E6%A8%A1%E6%9D%BF/" rel="next" title="各种模板">
      各种模板 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8ECSapp%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">从CSapp中收获的知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7"><span class="nav-number">2.</span> <span class="nav-text">栈帧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">程序执行流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">编译器驱动程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">抽象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">6.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%98%B6%E5%B1%82"><span class="nav-number">7.</span> <span class="nav-text">内存阶层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83"><span class="nav-number">8.</span> <span class="nav-text">管理单元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">9.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-PC"><span class="nav-number">10.</span> <span class="nav-text">程序计数器(PC)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">11.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">12.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">13.</span> <span class="nav-text">逻辑控制流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%B5%81"><span class="nav-number">14.</span> <span class="nav-text">并发流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">15.</span> <span class="nav-text">私有地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">16.</span> <span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B"><span class="nav-number">17.</span> <span class="nav-text">僵死进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PID%E7%AE%97%E6%B3%95"><span class="nav-number">18.</span> <span class="nav-text">PID算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">19.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">20.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BD%9C%E4%B8%BA%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7"><span class="nav-number">21.</span> <span class="nav-text">虚拟内存作为缓存工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">22.</span> <span class="nav-text">Proc文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unix-I-O"><span class="nav-number">23.</span> <span class="nav-text">Unix I&#x2F;O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6"><span class="nav-number">24.</span> <span class="nav-text">文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RIO-%E5%81%A5%E5%A3%AE%E5%9C%B0%E8%AF%BB%E5%86%99"><span class="nav-number">25.</span> <span class="nav-text">RIO-健壮地读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6"><span class="nav-number">26.</span> <span class="nav-text">共享文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">27.</span> <span class="nav-text">网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">28.</span> <span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84"><span class="nav-number">29.</span> <span class="nav-text">指令集架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">30.</span> <span class="nav-text">字节序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0"><span class="nav-number">31.</span> <span class="nav-text">布尔代数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B"><span class="nav-number">32.</span> <span class="nav-text">过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84-amp-%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-number">33.</span> <span class="nav-text">嵌套数组&amp;变长数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E8%B4%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">34.</span> <span class="nav-text">异质的数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%8C%BA%E4%BF%9D%E6%8A%A4"><span class="nav-number">35.</span> <span class="nav-text">缓存区保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="nav-number">36.</span> <span class="nav-text">伪指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80-HCL"><span class="nav-number">37.</span> <span class="nav-text">控制语言(HCL)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E9%97%A8"><span class="nav-number">38.</span> <span class="nav-text">逻辑门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF"><span class="nav-number">39.</span> <span class="nav-text">组合电路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="nav-number">40.</span> <span class="nav-text">优化编译器的能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">41.</span> <span class="nav-text">程序性能的表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="nav-number">42.</span> <span class="nav-text">存储器系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">43.</span> <span class="nav-text">局部性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="nav-number">44.</span> <span class="nav-text">存储技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">45.</span> <span class="nav-text">内存结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%A1%A5%E6%8E%A5%E5%99%A8"><span class="nav-number">46.</span> <span class="nav-text">IO桥接器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8"><span class="nav-number">47.</span> <span class="nav-text">链接器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">48.</span> <span class="nav-text">静态链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">49.</span> <span class="nav-text">动态链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E6%A1%A3%E6%96%87%E4%BB%B6"><span class="nav-number">50.</span> <span class="nav-text">存档文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-number">51.</span> <span class="nav-text">目标文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-number">52.</span> <span class="nav-text">可重定位目标文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3"><span class="nav-number">53.</span> <span class="nav-text">符号及其相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82"><span class="nav-number">54.</span> <span class="nav-text">节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C-amp-%E9%93%BE%E6%8E%A5-amp-%E5%8A%A0%E8%BD%BD-amp-%E5%AD%98%E5%82%A8%E5%9C%B0%E5%9D%80"><span class="nav-number">55.</span> <span class="nav-text">运行&amp;链接&amp;加载&amp;存储地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="nav-number">56.</span> <span class="nav-text">重定位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E6%9D%A1%E7%9B%AE"><span class="nav-number">57.</span> <span class="nav-text">重定位条目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-number">58.</span> <span class="nav-text">可执行目标文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">59.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81-PIC"><span class="nav-number">60.</span> <span class="nav-text">位置无关代码(PIC)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%93%E6%89%93%E6%A1%A9%E6%9C%BA%E5%88%B6"><span class="nav-number">61.</span> <span class="nav-text">库打桩机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81-ECF"><span class="nav-number">62.</span> <span class="nav-text">异常控制流(ECF)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5-amp-%E5%BC%82%E6%AD%A5"><span class="nav-number">63.</span> <span class="nav-text">同步&amp;异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">64.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">65.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%B7%E9%98%B1"><span class="nav-number">66.</span> <span class="nav-text">陷阱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%85%E9%9A%9C"><span class="nav-number">67.</span> <span class="nav-text">故障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2"><span class="nav-number">68.</span> <span class="nav-text">终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F"><span class="nav-number">69.</span> <span class="nav-text">内核模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3"><span class="nav-number">70.</span> <span class="nav-text">套接字接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="nav-number">71.</span> <span class="nav-text">网络编程中的信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">72.</span> <span class="nav-text">网络编程结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E6%9E%90"><span class="nav-number">73.</span> <span class="nav-text">服务器简析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%B7%E6%B1%82"><span class="nav-number">74.</span> <span class="nav-text">服务器请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94"><span class="nav-number">75.</span> <span class="nav-text">服务器响应</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">233</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">136</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">3.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">47:18</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
