<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="原子操作原子操作（Atomic Operator）是指一次不存在任何中断或失效的操作 等待队列前面的实验中已经实现了进程运行队列（就绪队列），而等待队列和它们类似： 12345678910typedef struct &amp;#123;    list_entry_t wait_head; &#x2F;* 等待队列的头结点(哨兵节点) *&#x2F;&amp;#125; wait_queue_t;typedef struct &amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="Ucore-Lab7">
<meta property="og:url" content="http://example.com/2022/05/01/Ucore-Lab7/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="原子操作原子操作（Atomic Operator）是指一次不存在任何中断或失效的操作 等待队列前面的实验中已经实现了进程运行队列（就绪队列），而等待队列和它们类似： 12345678910typedef struct &amp;#123;    list_entry_t wait_head; &#x2F;* 等待队列的头结点(哨兵节点) *&#x2F;&amp;#125; wait_queue_t;typedef struct &amp;#">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/01/Ucore-Lab7/1651291477532-1651554724146.png">
<meta property="article:published_time" content="2022-05-01T03:55:59.000Z">
<meta property="article:modified_time" content="2023-03-16T15:43:18.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="miscellaneous">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="Kernel">
<meta property="article:tag" content="Ucore">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/01/Ucore-Lab7/1651291477532-1651554724146.png">

<link rel="canonical" href="http://example.com/2022/05/01/Ucore-Lab7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Ucore-Lab7 | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/Ucore-Lab7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Ucore-Lab7
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-01 11:55:59" itemprop="dateCreated datePublished" datetime="2022-05-01T11:55:59+08:00">2022-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:43:18" itemprop="dateModified" datetime="2023-03-16T23:43:18+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作（Atomic Operator）是指一次不存在任何中断或失效的操作</p>
<h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p>前面的实验中已经实现了进程运行队列（就绪队列），而等待队列和它们类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_head; <span class="comment">/* 等待队列的头结点(哨兵节点) */</span></span><br><span class="line">&#125; <span class="keyword">wait_queue_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span> <span class="comment">/* 关联的进程 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> wakeup_flags; <span class="comment">/* 唤醒标识 */</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> *wait_queue; <span class="comment">/* 该节点所属的等待队列 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_link; <span class="comment">/* 其等待队列的链表结构,可以看作是队列结点 */</span></span><br><span class="line">&#125; <span class="keyword">wait_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>等待队列结构底层操作：</strong></p>
<ul>
<li>wait_init：初始化 wait 等待队列项，为 wait（等待队列结构体）绑定一个 proc（进程）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wait_init</span><span class="params">(<span class="keyword">wait_t</span> *wait, struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    wait-&gt;proc = proc; <span class="comment">/* 设置关联的进程 */</span></span><br><span class="line">    wait-&gt;wakeup_flags = WT_INTERRUPTED; <span class="comment">/* 等待状态可中断(苏醒) */</span></span><br><span class="line">    list_init(&amp;(wait-&gt;wait_link)); <span class="comment">/* 初始化等待队列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_init：初始化等待队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wait_queue_init</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;(<span class="built_in">queue</span>-&gt;wait_head)); <span class="comment">/* 初始化等待队列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_add：将 wait 节点项插入等待队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wait_queue_add</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait)</span> </span>&#123;</span><br><span class="line">    assert(list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;proc != <span class="literal">NULL</span>);</span><br><span class="line">    wait-&gt;wait_queue = <span class="built_in">queue</span>; <span class="comment">/* 设置该等待队列结点所属的等待队列 */</span></span><br><span class="line">    list_add_before(&amp;(<span class="built_in">queue</span>-&gt;wait_head), &amp;(wait-&gt;wait_link)); <span class="comment">/* 插头 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_del：将 wait 项从等待队列中移除</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wait_queue_del</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait)</span> </span>&#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    list_del_init(&amp;(wait-&gt;wait_link)); <span class="comment">/* 脱链 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_next：获取等待队列中wait节点的下一项</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">wait_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">wait_queue_next</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait)</span> </span>&#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(wait-&gt;wait_link));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link); <span class="comment">/* 根据链表信息获取wait结构体 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_prev：获取等待队列中wait节点的前一项</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">wait_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">wait_queue_prev</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait)</span> </span>&#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_prev(&amp;(wait-&gt;wait_link));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link); <span class="comment">/* 根据链表信息获取wait结构体 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_first：获取等待队列的第一项</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">wait_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">wait_queue_first</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link); <span class="comment">/* 根据链表信息获取wait结构体 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_last：获取等待队列的最后一项</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">wait_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">wait_queue_last</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_prev(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link); <span class="comment">/* 根据链表信息获取wait结构体 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_queue_empty：检查等待队列是否为空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">wait_queue_empty</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list_empty(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">list_empty</span><span class="params">(<span class="keyword">list_entry_t</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;next == <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_in_queue：检查 wait 项是否在等待队列中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">wait_in_queue</span><span class="params">(<span class="keyword">wait_t</span> *wait)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;(wait-&gt;wait_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>等待队列休眠/唤醒等高层操作：</strong> </p>
<ul>
<li>wakeup_wait：将等待队列中的 wait 项对应的线程唤醒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_wait</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait, <span class="keyword">uint32_t</span> wakeup_flags, <span class="keyword">bool</span> del)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (del) &#123;</span><br><span class="line">        wait_queue_del(<span class="built_in">queue</span>, wait); <span class="comment">/* 根据del标识来决定该wait结构体是否保留 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    wait-&gt;wakeup_flags = wakeup_flags; <span class="comment">/* 已经苏醒 */</span></span><br><span class="line">    wakeup_proc(wait-&gt;proc); <span class="comment">/* 唤醒该进程 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_proc</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE);</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            proc-&gt;state = PROC_RUNNABLE; <span class="comment">/* 设置&quot;PROC_RUNNABLE&quot; */</span></span><br><span class="line">            proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">                sched_class_enqueue(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            warn(<span class="string">&quot;wakeup runnable process.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wakeup_first：将等待队列中的第一项对应的线程唤醒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_first</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">uint32_t</span> wakeup_flags, <span class="keyword">bool</span> del)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">wait_t</span> *wait;</span><br><span class="line">    <span class="keyword">if</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* 调用wait_queue_first获取等待队列的第一项,然后将其唤醒 */</span></span><br><span class="line">        wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, del);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wakeup_queue：将等待队列中的所有项对应的线程全部唤醒</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup_queue</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">uint32_t</span> wakeup_flags, <span class="keyword">bool</span> del)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">wait_t</span> *wait;</span><br><span class="line">    <span class="keyword">if</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (del) &#123; <span class="comment">/* 根据del标识来决定该wait结构体是否保留 */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, <span class="number">1</span>); </span><br><span class="line">            &#125; <span class="keyword">while</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> ((wait = wait_queue_next(<span class="built_in">queue</span>, wait)) != <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_current_set：为当前进程绑定 wait，使其休眠并且插入等待队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wait_current_set</span><span class="params">(<span class="keyword">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="keyword">wait_t</span> *wait, <span class="keyword">uint32_t</span> wait_state)</span> </span>&#123;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    wait_init(wait, current); <span class="comment">/* 为wait绑定进程current */</span></span><br><span class="line">    current-&gt;state = PROC_SLEEPING; <span class="comment">/* 设置当前进程状态为:PROC_SLEEPING(睡眠) */</span></span><br><span class="line">    current-&gt;wait_state = wait_state; <span class="comment">/* 设置等待原因(人工输入) */</span></span><br><span class="line">    wait_queue_add(<span class="built_in">queue</span>, wait); <span class="comment">/* 将wait节点项插入等待队列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>wait_current_del：将 wait 项（绑定有当前进程）从等待队列中删除（如果存在的话）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> wait_current_del(queue, wait)                                       \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                    \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (wait_in_queue(wait)) &#123;                                          \</span></span><br><span class="line"><span class="meta">            wait_queue_del(queue, wait);                                    \</span></span><br><span class="line"><span class="meta">        &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__KERN_SYNC_WAIT_H__ */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>每个进程中访问临界资源的那段程序称为临界区，临界资源是一次仅允许一个进程使用的共享资源，每次只准许一个进程进入临界区，进入后不允许其他进程进入  </p>
<p>相关区域的概念：</p>
<ul>
<li>临界区（critical section）：进程中访问临界资源的一段需要互斥执行的代码</li>
<li>进入区（entry section）：检查可否进入临界区的一段代码，如果可以进入，则设置“正在访问临界区”标志</li>
<li>退出区（exit section）：清除标志</li>
<li>剩余区（remainder section）：代码中的其余部分</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个有整数值的对象，可以用两个函数来操作它</p>
<p>Linux中的信号量是一种睡眠锁，本质上是一个计数器，用于多进程对共享数据对象的读取，它和管道有所不同，它不以传送数据为主要目的，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享</p>
<ul>
<li>信号量（Semaphore）是操作系统提供的一种协调共享资源访问的方法<ul>
<li>软件同步是平等线程间的一种同步协商机制</li>
<li>OS 是管理者，地位高于进程</li>
<li>用信号量表示系统资源的数量</li>
</ul>
</li>
<li>信号量是一种抽象数据类型<ul>
<li>由一个整数（sem）变量和两个原子操作（PV）组成</li>
<li>整数sem：<ul>
<li>sem &gt;= 0：代表剩余可供并发进程使用的资源实体数</li>
<li>sem &lt; 0：代表正在使用的资源实体数</li>
</ul>
</li>
<li>P操作：<ul>
<li>sem —</li>
<li>如果 sem &lt; 0，则该进程进入阻塞队列（等待队列）</li>
<li>如果 sem &gt;= 0，则该进程继续执行</li>
</ul>
</li>
<li>V操作：<ul>
<li>sem ++</li>
<li>如果 sem &lt; 0，则唤醒阻塞队列中的第一个等待信号量的进程 </li>
<li>如果 sem &gt; 0，则该进程继续执行</li>
</ul>
</li>
</ul>
</li>
<li>信号量是被保护的整数变量<ul>
<li>初始化完成后，只能通过 P() 和 V() 操作修改</li>
<li>由操作系统来保证，PV操作是原子操作</li>
</ul>
</li>
</ul>
<p><strong>PV操作</strong></p>
<p>PV操作是一种实现进程互斥与同步的有效方法，PV操作与信号量的处理相关（P表示通过的意思，V表示释放的意思）</p>
<p>PV操作是典型的同步机制之一，用一个信号量与一个消息联系起来</p>
<ul>
<li>当信号量的值为“0”时，表示期望的消息尚未产生</li>
<li>当信号量的值非“0”时，表示期望的消息已经存在</li>
</ul>
<p>用PV操作实现进程同步时，调用P操作测试消息是否到达，调用V操作发送消息</p>
<p><strong>ucore 中采用以下结构体来管理信号量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">/* 信号量值 */</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue; <span class="comment">/* 等待队列 */</span></span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>value 是用于判断该信号量能否进入临界区的关键参数</li>
<li>wait_queue 记录了该信号量所属的等待队列，便于之后的 <code>wait_current_set</code> 和 <code>wait_current_del</code> 把当前进程填入或取出该等待队列</li>
</ul>
<p><strong>进入临界区时，uCore会执行 down 函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">down</span><span class="params">(<span class="keyword">semaphore_t</span> *sem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags = __down(sem, WT_KSEM); <span class="comment">/* 等待原因:内核信号量WT_KSEM */</span></span><br><span class="line">    assert(flags == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> __down(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 当信号量的value值大于&#x27;0&#x27;时,说明还能容纳当前线程进入临界区 */</span></span><br><span class="line">        sem-&gt;value --; <span class="comment">/* value值递减(扣减信号量) */</span></span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当信号量的value值等于&#x27;0&#x27;时,说明已经无法容纳更多的线程了 */</span></span><br><span class="line">    <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state); <span class="comment">/* 使当前进程休眠 */</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    schedule(); <span class="comment">/* 重新执行调度程序(当前进程放弃CPU资源) */</span></span><br><span class="line"></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait); <span class="comment">/* 将wait项从等待队列中删除 */</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当信号量的value值大于“0”时，说明还能容纳当前线程进入临界区</li>
<li>当信号量的value值等于“0”时。说明已经无法容纳更多的线程了，此时需要将当前线程阻塞在信号量的等待队列上，等待信号量的 up 操作将其唤醒</li>
<li>按照程序的逻辑，value值不可能小于“0”</li>
</ul>
<p><strong>退出临界区时，uCore会执行 up 函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">up</span><span class="params">(<span class="keyword">semaphore_t</span> *sem)</span> </span>&#123;</span><br><span class="line">    __up(sem, WT_KSEM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">void</span> __up(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">wait_t</span> *wait;</span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* 尝试获取等待队列的第一项,如果有就唤醒,没有就增加信号量 */</span></span><br><span class="line">            sem-&gt;value ++; <span class="comment">/* value值递增(增加信号量) */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>); <span class="comment">/* 将等待队列中的wait项对应的线程唤醒 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>等待队列为NULL，代表了资源实体充足，也就是说没有进程因为“互斥资源实体不足”而进入等待队列，自然没有必要唤醒</li>
<li>信号量增加，代表了剩余可供并发进程使用的资源实体数增加</li>
</ul>
<p>PS：可以发现，ucore 对临界区的处理和 PV 操作有点不同，并没有刻意让 value 值为负，而是直接将当前进程添加入等待队列，退出临界区时，又从等待队列中唤醒该进程</p>
<p><strong>与信号量有关的函数</strong></p>
<ul>
<li>sem_init：初始化信息量（各个条目需要手动输入）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sem_init</span><span class="params">(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>未进行初始化的信号量根本就没有对应的等待队列，所以需要调用 <code>wait_queue_init</code> 来初始化一个等待队列</li>
<li>因为信号量是分配到栈上的，所以不需要格外的“create”或者“destroy”操作</li>
</ul>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程（Monitor）是一种用于多线程互斥访问共享资源的程序结构（其实就是封装了一下PV操作），它为进程提供了一种“抽象”，使进程可以通过访问管程来间接访问共享资源</p>
<ul>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</li>
</ul>
<p>管程的组成</p>
<ul>
<li>一个锁：控制管程代码的互斥访问</li>
<li>0-n 个条件变量：用于管理共享数据的并发访问</li>
</ul>
<p>引入管程机制的目的：</p>
<ul>
<li>把分散在各进程中的临界区集中起来进行管理</li>
<li>防止进程有意或无意的违法同步操作（防止死锁）</li>
<li>便于用高级语言来书写程序，也便于程序正确性验证</li>
</ul>
<p><strong>在 ucore 中有如下结构体来管理管程：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> <span class="title">monitor_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex;      <span class="comment">// 管程锁,每次只能有一个进程执行管程代码(该值初始化为&#x27;1&#x27;)</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> next;       <span class="comment">// 用于条件同步(进程同步操作的信号量),发出signal操作的进程等条件为真之前进入睡眠</span></span><br><span class="line">    <span class="keyword">int</span> next_count;         <span class="comment">// 休眠的信令进程数</span></span><br><span class="line">    <span class="keyword">condvar_t</span> *cv;          <span class="comment">// 当前管程中存放所有条件变量的数组</span></span><br><span class="line">&#125; <span class="keyword">monitor_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>mutex：<ul>
<li>管程中的成员变量 mutex 是一个二值信号量，是实现每次只允许一个进程进入管程的关键元素，确保了互斥访问性质</li>
</ul>
</li>
<li>cv：<ul>
<li>管程中的条件变量 cv 通过执行 wait_cv，会使得等待某个条件 C 为真的进程能够离开管程并睡眠，且让其他进程进入管程继续执行</li>
<li>而进入管程的某进程设置条件 C 为真并执行 signal_cv 时，能够让等待某个条件 C 为真的睡眠进程被唤醒，从而继续进入管程中执行</li>
</ul>
</li>
<li>next，next_count：<ul>
<li>管程中的成员变量信号量 next 和整形变量 next_count 是配合进程对条件变量 cv 的操作而设置的</li>
<li>这是由于发出signal_cv 的进程 A 会唤醒睡眠进程 B，进程 B 执行会导致进程 A 睡眠，直到进程 B 离开管程，进程 A 才能继续执行，这个同步过程是通过信号量 next 完成的 </li>
</ul>
</li>
</ul>
<p><strong>下面是与条件变量有关的结构体：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;        <span class="comment">// 条件变量所对应的信号量</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">// 等待当前条件变量的等待进程总数</span></span><br><span class="line">    <span class="keyword">monitor_t</span> * owner;      <span class="comment">// 当前条件变量的父管程</span></span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sem：信号量 sem 用于让发出 wait_cv 操作的</li>
<li>count：表示等在这个条件变量上的睡眠进程的个数 </li>
<li>owner：表示此条件变量的宿主是哪个管程 </li>
</ul>
<p><strong>与管程有关的函数：</strong></p>
<ul>
<li>monitor_init：初始化一个管程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>     </span></span><br><span class="line"><span class="function"><span class="title">monitor_init</span> <span class="params">(<span class="keyword">monitor_t</span> * mtp, <span class="keyword">size_t</span> num_cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    assert(num_cv&gt;<span class="number">0</span>);</span><br><span class="line">    mtp-&gt;next_count = <span class="number">0</span>;</span><br><span class="line">    mtp-&gt;cv = <span class="literal">NULL</span>;</span><br><span class="line">    sem_init(&amp;(mtp-&gt;mutex), <span class="number">1</span>); <span class="comment">/* 初始化信号量mutex(管程锁)为&#x27;1&#x27; */</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;next), <span class="number">0</span>); <span class="comment">/* 初始化信号量next为&#x27;0&#x27; */</span></span><br><span class="line">    mtp-&gt;cv =(<span class="keyword">condvar_t</span> *) kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">condvar_t</span>)*num_cv); <span class="comment">/* 分配条件变量 */</span></span><br><span class="line">    assert(mtp-&gt;cv!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num_cv; i++)&#123; <span class="comment">/* 初始化各个条件变量的值 */</span></span><br><span class="line">        mtp-&gt;cv[i].count=<span class="number">0</span>;</span><br><span class="line">        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="number">0</span>);</span><br><span class="line">        mtp-&gt;cv[i].owner=mtp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>cond_signal：当某个线程准备离开临界区，准备释放对应的条件变量时，执行该函数（需要实现）</li>
<li>cond_wait：当某个线程需要等待锁时，执行该函数（需要实现）</li>
</ul>
<h2 id="进程的交互关系"><a href="#进程的交互关系" class="headerlink" title="进程的交互关系"></a>进程的交互关系</h2><div class="table-container">
<table>
<thead>
<tr>
<th>相互感知的程度</th>
<th>交互关系</th>
<th>进程间的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>相互不感知（完全不了解其他进程的存在）</td>
<td>独立</td>
<td>一个进程的操作对其他进程的结果无影响</td>
</tr>
<tr>
<td>间接感知（双方都与第三方交互，例如数据共享）</td>
<td>通过共享进行协作</td>
<td>一个进程的结果依赖于共享资源的状态</td>
</tr>
<tr>
<td>直接感知（双方直接交互，例如通信）</td>
<td>通过通信进行协作</td>
<td>一个进程的结果依赖于从其他进程获得的信息</td>
</tr>
</tbody>
</table>
</div>
<p>进程之间可能出现三种关系：</p>
<ul>
<li>互斥（mutual exclusion）：一个进程占用资源，其他进程不能使用</li>
<li>死锁（deadlock）：多个进程占用部分资源，形成循环等待</li>
<li>饥饿（starvation）：其他进程可能轮流占用资源，一个进程一直得不到资源</li>
</ul>
<h2 id="CAS与锁"><a href="#CAS与锁" class="headerlink" title="CAS与锁"></a>CAS与锁</h2><p><strong>CAS</strong></p>
<p>CPU拥有多个物理核心，利用超线程技术可以把这些物理核心分为更多的逻辑核心</p>
<p>这就产生了一些问题：</p>
<img src="/2022/05/01/Ucore-Lab7/1651291477532-1651554724146.png" class width="1651291477532"> 
<p>左边是我们预想的执行顺序，右边是可以产生的情况（从不同的寄存器中读取了“0”）</p>
<p>如果把 “i++” 设置为原子操作，那么 “i+2”，“i+3”，“i*3” …… 这些都要设置为原子操作，大大影响了效率，于是 CPU 就提供了一个抽象的底层指令 cas（Compare and Set）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas(&amp;i,<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>更新内存地址“i”的时候，需要告诉CPU过去的值“0”，和想要更新的值“1”，CPU会先对比过去的值，然后再更新需要的值“1”，如果对比不通过，CPU就不作出相应</li>
<li>通过这种方式，CPU可以给更多指令添加原子操作</li>
</ul>
<p>假设有两个线程：（“i”初始化为“0”）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: i++;</span><br><span class="line">B: i++;</span><br></pre></td></tr></table></figure>
<p>线程A可以通过“cas(&amp;i,0,1)”，然后“i”变为“1”，线程B就不能通过了，然后线程B就会采取如下操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!cas(&amp;i,i,i++));</span><br></pre></td></tr></table></figure>
<p><strong>锁</strong></p>
<p>锁是一个抽象的数据结构：</p>
<ul>
<li>使用一个二进制变量，用于表示锁定/解锁</li>
<li>Lock::Acquire()：锁被释放前一直等待，直到得到锁</li>
<li>Lock::Release()：释放锁，唤醒任何等待的进程</li>
</ul>
<p>使用锁可以解决一些 cas 无法解决的问题</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器（timer）可以帮助操作系统在 <strong>经过一段特定时间</strong> 后执行一些特殊操作（例如：唤醒执行线程），可以说，正是有了定时器，操作系统才有了时间这个概念</p>
<p><code>timer_t</code> 结构体中存储了一个定时器所需要的相关数据，包括 <strong>倒计时时间</strong> 以及 <strong>所绑定的进程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> expires;			<span class="comment">// 定时器的过期时间(指定定时器到期的时间)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>		<span class="comment">// 在计时器中等待的进程(如果过期时间已结束,该进程将被重新安排)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> timer_link;		<span class="comment">// 计时器链表(用于管理计时器)</span></span><br><span class="line">&#125; <span class="keyword">timer_t</span>;</span><br></pre></td></tr></table></figure>
<p>以下便是 ucore 中和定时器有关的函数：</p>
<ul>
<li>timer_init：用于初始化并返回某个 <code>timer</code>（各个参数都需要手动设置）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">timer_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">timer_init</span><span class="params">(<span class="keyword">timer_t</span> *timer, struct proc_struct *proc, <span class="keyword">int</span> expires)</span> </span>&#123;</span><br><span class="line">    timer-&gt;expires = expires; </span><br><span class="line">    timer-&gt;proc = proc;</span><br><span class="line">    list_init(&amp;(timer-&gt;timer_link));</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>add_timer：用于将某个 <code>timer</code> 按照 <code>expires</code> 的大小添加进 <code>timer链表</code> 中 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> timer_list; <span class="comment">/* 记录有timer链表的链表头 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">add_timer</span><span class="params">(<span class="keyword">timer_t</span> *timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* local_intr_save:屏蔽中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(timer-&gt;expires &gt; <span class="number">0</span> &amp;&amp; timer-&gt;proc != <span class="literal">NULL</span>);</span><br><span class="line">        assert(list_empty(&amp;(timer-&gt;timer_link)));</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = list_next(&amp;timer_list); <span class="comment">/* 获取链表头 */</span></span><br><span class="line">        <span class="keyword">while</span> (le != &amp;timer_list) &#123; <span class="comment">/* 遍历整个链表,按照expires大小插链(从小到大) */</span></span><br><span class="line">            <span class="keyword">timer_t</span> *next = le2timer(le, timer_link); </span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires &lt; next-&gt;expires) &#123; </span><br><span class="line">                next-&gt;expires -= timer-&gt;expires; <span class="comment">/* 使目标结点next的expires减去timer-&gt;expires */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            timer-&gt;expires -= next-&gt;expires; <span class="comment">/* 每遍历一次,timer-&gt;expires不断减小(保证了expires是从小到大排序的) */</span></span><br><span class="line">            le = list_next(le);</span><br><span class="line">        &#125;</span><br><span class="line">        list_add_before(le, &amp;(timer-&gt;timer_link)); <span class="comment">/* 插入结点前(从小到大) */</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* local_intr_restore:打开中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>del_timer：用于将某个 <code>timer</code> 从 <code>timer链表</code> 中删除</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(<span class="keyword">timer_t</span> *timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* local_intr_save:屏蔽中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;(timer-&gt;timer_link))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">list_entry_t</span> *le = list_next(&amp;(timer-&gt;timer_link));</span><br><span class="line">                <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">                    <span class="keyword">timer_t</span> *next = le2timer(le, timer_link);</span><br><span class="line">                    next-&gt;expires += timer-&gt;expires; <span class="comment">/* 设使目标结点next的expires加上timer-&gt;expires(平衡add_timer的影响) */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list_del_init(&amp;(timer-&gt;timer_link)); <span class="comment">/* 将当前timer从链表中移除 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* local_intr_restore:打开中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>run_timer_list：用于更新定时器的时间，并更新当前进程的运行时间片，如果当前定时器的剩余时间结束，则唤醒某个处于 <code>WT_INTERRUPTED</code> 等待状态的进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WT_INTERRUPTED               0x80000000 <span class="comment">/* 等待状态可以被中断(可以苏醒) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">run_timer_list</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* local_intr_save:屏蔽中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = list_next(&amp;timer_list); <span class="comment">/* 获取timer链表头 */</span></span><br><span class="line">        <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">            <span class="keyword">timer_t</span> *timer = le2timer(le, timer_link); <span class="comment">/* 获取第一个timer结构体 */</span></span><br><span class="line">            assert(timer-&gt;expires != <span class="number">0</span>); </span><br><span class="line">            timer-&gt;expires --; <span class="comment">/* 间接使所有timer的expires都减一的目的 */</span></span><br><span class="line">            <span class="keyword">while</span> (timer-&gt;expires == <span class="number">0</span>) &#123; <span class="comment">/* 遍历timer链表,找出所有连续的expires为0的timer,将其唤醒后再把timer删除 */</span></span><br><span class="line">                le = list_next(le);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> timer-&gt;proc; <span class="comment">/* 获取对应的进程 */</span></span><br><span class="line">                <span class="keyword">if</span> (proc-&gt;wait_state != <span class="number">0</span>) &#123;</span><br><span class="line">                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED); <span class="comment">/* 断言正在等待的目标进程的wait_state是WT_INTERRUPTED */</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    warn(<span class="string">&quot;process %d&#x27;s wait_state == 0.\n&quot;</span>, proc-&gt;pid);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeup_proc(proc); <span class="comment">/* 设置新的子进程可执行(唤醒该进程) */</span></span><br><span class="line">                del_timer(timer); <span class="comment">/* 用于将某个timer从timer链表中删除 */</span></span><br><span class="line">                <span class="keyword">if</span> (le == &amp;timer_list) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                timer = le2timer(le, timer_link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sched_class_proc_tick(current); <span class="comment">/* 处理时钟中断的函数,令调度框架更新对应的调度参数(lab6中用此函数处理时钟中断,lab7中被run_timer_list替代) */</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* local_intr_restore:打开中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时器的检查机制：</p>
<p>内核会每隔一段时间会检查一次定时器（如果定时器的 <code>expires</code> 为“0”，内存就会执行某个进程），但是检查的频率可能不相同，对于 <code>expires</code> 越小的定时器，内核检查的频率越高（例如：如果 <code>expires</code> 为“一年”，可能内核就一个月检查一次，如果 <code>expires</code> 小于一个月，内核就每天检查一次）</p>
<ul>
<li>处于性能考虑，每个新添加的 timer 都会按照其 <code>expires</code> 属性的大小排列，同时减去上一个 timer 的 <code>expires</code> 属性<ul>
<li>在 run_timer_list 中，程序会遍历 timer 链表，找出所有连续的expires为“0”的 timer，所以按大小排序后，一次执行 run_timer_list 后可能会找到多个目标，提高了效率</li>
<li>按照 timer 的机制：在更新 timer_list 中的所有 timer 的 expires 时，只需递减链首的第一个 timer 的 expire，即可间接达到所有 timer 的 expires 减一的目的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">timer1-&gt;expires = <span class="number">20</span>;</span><br><span class="line">timer2-&gt;expires = <span class="number">38</span>;</span><br><span class="line">timer3-&gt;expires = <span class="number">24</span>;</span><br><span class="line">timer4-&gt;expires = <span class="number">10</span>;</span><br><span class="line">----------------------------</span><br><span class="line">timer1插入 &gt;&gt; timer1:<span class="number">20</span> </span><br><span class="line">timer2插入 &gt;&gt; timer1:<span class="number">20</span> &lt;=&gt; timer2:<span class="number">18</span>(<span class="number">38</span>)</span><br><span class="line">timer3插入 &gt;&gt; timer1:<span class="number">20</span> &lt;=&gt; timer3:<span class="number">4</span>(<span class="number">24</span>) &lt;=&gt; timer2:<span class="number">14</span>(<span class="number">38</span>)</span><br><span class="line">timer4插入 &gt;&gt; timer4:<span class="number">10</span> &lt;=&gt; timer1:<span class="number">10</span>(<span class="number">20</span>) &lt;=&gt; timer3:<span class="number">4</span>(<span class="number">24</span>) &lt;=&gt; timer2:<span class="number">14</span>(<span class="number">38</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>在目标 timer 遍历的时候会不断减去 “结点timer-&gt;expires” ，这样保证了 timer 链表中，原来的 timer-&gt;expires（没有进行过加减操作，是真正的 timer）是按从小到大排序的</li>
<li>这样也避免了 “结点timer-&gt;expires” 或者 “目标timer-&gt;expires” 被减到“0”的情况发生</li>
</ul>
<p>案例：do_sleep（将当前进程状态设置为睡眠）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 关闭中断 */</span></span><br><span class="line">    <span class="keyword">timer_t</span> __timer, *timer = timer_init(&amp;__timer, current, time); </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    __timer:未初始化的timer</span></span><br><span class="line"><span class="comment">    current:为该timer绑定进程(current当前进程)</span></span><br><span class="line"><span class="comment">    time:设置剩余时间</span></span><br><span class="line"><span class="comment">    *timer:初始化完毕的timer(__timer只是临时数据,最终会把数据返回给*timer)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    current-&gt;state = PROC_SLEEPING; <span class="comment">/* 设置进程状态为:PROC_SLEEPING(睡眠) */</span></span><br><span class="line">    current-&gt;wait_state = WT_TIMER; <span class="comment">/* 设置等待原因为:等待定时器 */</span></span><br><span class="line">    add_timer(timer); <span class="comment">/* 添加该定时器 */</span></span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 重新打开中断 */</span></span><br><span class="line"></span><br><span class="line">    schedule(); <span class="comment">/* 执行调度程序(当前进程放弃CPU资源) */</span></span><br><span class="line"></span><br><span class="line">    del_timer(timer); <span class="comment">/* 删除定时器 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我会结合前面实验中有关进程的调度的部分内容，详细描述一下这个过程：</p>
<ul>
<li>内核的第一个进程 <code>idleproc</code>（空闲进程）会执行 <code>cpu_idle</code> 函数，在这个函数中循环执行 <code>schedule</code> 用于空闲进程的调度，这个函数是永远不会停止的</li>
<li>其他的进程都会因为<code>schedule</code> 而被调度，又会因为各种原因被中断，然后再次调度</li>
<li>当 “PROC_SLEEPING” 被设置时：<code>schedule</code> 就已经不会再调度该进程了，如果再次执行<code>schedule</code> ，CPU就会放弃当前进程，转而去遍历整个进程链表，直到找出处于就绪状态的进程，并将其调度</li>
<li>当 “add_timer(timer)” 执行时：绑定有当前进程的 timer 被链入 timer 链表，然后CPU会周期性调用 run_timer_list 检查 timer-&gt;expires 是否为“0”</li>
<li>如果时间结束，就会调用 wakeup_proc 重新设置该进程为 “PROC_RUNNABLE” ，这样<code>schedule</code> 就可以再次调度该进程了</li>
</ul>
<h2 id="练习0-把-lab6-的内容复制粘贴到-lab7"><a href="#练习0-把-lab6-的内容复制粘贴到-lab7" class="headerlink" title="练习0-把 lab6 的内容复制粘贴到 lab7"></a>练习0-把 lab6 的内容复制粘贴到 lab7</h2><p>trap_dispatch 中有关时钟中断的部分需要更新：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> T_PGFLT: <span class="comment">/* 页错误异常(page fault) */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = pgfault_handler(tf)) != <span class="number">0</span>) &#123;</span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="comment">/* lab5新增:与进程相关的if判断语句 */</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;handle pgfault failed. ret=%d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (trap_in_kernel(tf)) &#123;</span><br><span class="line">                    panic(<span class="string">&quot;handle pgfault failed in kernel mode. ret=%d\n&quot;</span>, ret);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(<span class="string">&quot;killed by kernel.\n&quot;</span>);</span><br><span class="line">                panic(<span class="string">&quot;handle user mode pgfault failed. ret=%d\n&quot;</span>, ret); </span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SYSCALL: <span class="comment">/* 系统调用(syscall) */</span></span><br><span class="line">        syscall();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*  &lt;---- start ----&gt;  */</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks ++;</span><br><span class="line">        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">        run_timer_list(); <span class="comment">/* lab7新添:更新定时器的时间,并更新当前进程的运行时间片 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/*  &lt;---- end ----&gt;  */</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_COM1: <span class="comment">/* 中断请求-串口中断 */</span></span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;serial [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD: <span class="comment">/* 中断请求-键盘中断 */</span></span><br><span class="line">        c = cons_getc();</span><br><span class="line">        cprintf(<span class="string">&quot;kbd [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOU: <span class="comment">/* 中断请求-内核到用户空间触发的中断 */</span></span><br><span class="line">    <span class="keyword">case</span> T_SWITCH_TOK: <span class="comment">/* 中断请求-用户空间到内核触发的中断 */</span></span><br><span class="line">        panic(<span class="string">&quot;T_SWITCH_** ??\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE1: <span class="comment">/* 中断请求-IDE通道1中断 */</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_IDE2: <span class="comment">/* 中断请求-IDE通道2中断 */</span></span><br><span class="line">            <span class="comment">/* 本实验不涉及这一部分 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* lab5改动:完善了报错处理 */</span></span><br><span class="line">        print_trapframe(tf); <span class="comment">/* 打印trapframe结构体(中断帧,用于存储执行中断的信息) */</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;unhandled trap.\n&quot;</span>);</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        &#125;</span><br><span class="line">        panic(<span class="string">&quot;unexpected trap in kernel.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"><a href="#练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题" class="headerlink" title="练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"></a>练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</h2><p>哲学家就餐问题：</p>
<ul>
<li>五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替的进行思考和进餐，平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐，进餐完毕，放下筷子继续思考</li>
</ul>
<p>ucore 中的案例：</p>
<ul>
<li>相关宏定义与结构体：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">/* 哲学家数目 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i-1+N)%N <span class="comment">/* i的左邻号码 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i+1)%N <span class="comment">/* i的右邻号码 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0 <span class="comment">/* 哲学家正在思考 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY 1 <span class="comment">/* 哲学家想取得叉子 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING 2 <span class="comment">/* 哲学家正在吃面 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMES  4 <span class="comment">/* 吃4次饭 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLEEP_TIME 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>philosopher_using_semaphore：实现主体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state_sema[N]; <span class="comment">/* 记录每个人状态的数组 */</span></span><br><span class="line"><span class="keyword">semaphore_t</span> mutex; <span class="comment">/* 临界区互斥 */</span></span><br><span class="line"><span class="keyword">semaphore_t</span> s[N]; <span class="comment">/* 每个哲学家一个信号量 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">philosopher_proc_sema</span>[<span class="title">N</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">philosopher_using_semaphore</span><span class="params">(<span class="keyword">void</span> * arg)</span> <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">&quot;I am No.%d philosopher_sema\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; <span class="comment">/* 无限循环 */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_sema is thinking\n&quot;</span>,iter,i); <span class="comment">/* 哲学家正在思考 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_sema(i); <span class="comment">/* 需要两只叉子,或者阻塞 */</span></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_sema is eating\n&quot;</span>,iter,i); <span class="comment">/* 进餐 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_sema(i); <span class="comment">/* 把两把叉子同时放回桌子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;No.%d philosopher_sema quit\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_take_forks_sema：需要两只叉子,或者阻塞 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_sema</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">        phi_test_sema(i); <span class="comment">/* 哲学家尝试得到两只叉子,并且进餐 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">        down(&amp;s[i]); <span class="comment">/* 如果得不到叉子就阻塞 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_put_forks_sema：把两把叉子同时放回桌子 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_sema</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=THINKING; <span class="comment">/* 哲学家进餐结束 */</span></span><br><span class="line">        phi_test_sema(LEFT); <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">        phi_test_sema(RIGHT); <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_test_sema：哲学家尝试得到两只叉子，并且进餐</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_sema</span><span class="params">(i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(state_sema[i]==HUNGRY &amp;&amp; state_sema[LEFT]!=EATING &amp;&amp; state_sema[RIGHT]!=EATING) <span class="comment">/* 哲学家自己是饥饿状态,左右两边的哲学家都不是进食状态 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        state_sema[i]=EATING; <span class="comment">/* 设置为进食状态 */</span></span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整过程：</p>
<ul>
<li>哲学家会循环进行两件事情：<ul>
<li>phi_take_forks_sema：拿起两把叉子准备进食</li>
<li>phi_put_forks_sema：放回两把叉子</li>
</ul>
</li>
<li>本程序没有对叉子进行标记，而是通过检查相邻哲学家的进食状态，来判断自己是否可以进食</li>
<li>在哲学家执行 phi_put_forks_sema 时，会检查相邻的哲学家是否可以进食（因为自己进食以后会归还叉子，给相邻哲学家创造了进食机会）</li>
</ul>
<h2 id="练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"><a href="#练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题" class="headerlink" title="练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"></a>练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span> <span class="comment">/* 管程 */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex;      <span class="comment">// 管程锁,每次只能有一个进程执行管程代码(该值初始化为&#x27;1&#x27;)</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> next;       <span class="comment">// 用于条件同步(进程同步操作的信号量),发出signal操作的进程等条件为真之前进入睡眠</span></span><br><span class="line">    <span class="keyword">int</span> next_count;         <span class="comment">// 休眠的信令进程数</span></span><br><span class="line">    <span class="keyword">condvar_t</span> *cv;          <span class="comment">// 当前管程中存放所有条件变量的数组</span></span><br><span class="line">&#125; <span class="keyword">monitor_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span> <span class="comment">/* 条件变量 */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;        <span class="comment">// 条件变量所对应的信号量</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">// 等待当前条件变量的等待进程总数</span></span><br><span class="line">    <span class="keyword">monitor_t</span> * owner;      <span class="comment">// 当前条件变量的父管程</span></span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* 信号量 */</span></span><br><span class="line">    <span class="keyword">int</span> value;					   <span class="comment">// 信号量值 </span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue;		<span class="comment">// 等待队列</span></span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br></pre></td></tr></table></figure>
<p>monitor_init 函数会初始管程，而对信号量进行的 P()，V() 操作（up，down）将会被封装为控制管程的两个函数 - cond_signal 和 cond_wait：</p>
<ul>
<li>cond_signal：当某个线程准备离开临界区，准备释放对应的条件变量时，执行该函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">cond_signal</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">   cprintf(<span class="string">&quot;cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);  </span><br><span class="line">    <span class="keyword">if</span>(cvp-&gt;count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        cvp-&gt;owner-&gt;next_count ++;</span><br><span class="line">        up(&amp;(cvp-&gt;sem)); <span class="comment">/* 尝试唤醒条件变量cvp对应的信号量中的等待队列中的第一项 */</span></span><br><span class="line">        down(&amp;(cvp-&gt;owner-&gt;next));</span><br><span class="line">        cvp-&gt;owner-&gt;next_count --;</span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>cond_wait：当某个线程需要等待锁时，执行该函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cond_wait</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">    cvp-&gt;count++;</span><br><span class="line">    <span class="keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="number">0</span>)</span><br><span class="line">        up(&amp;(cvp-&gt;owner-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(cvp-&gt;owner-&gt;mutex));</span><br><span class="line">    down(&amp;(cvp-&gt;sem));</span><br><span class="line">    cvp-&gt;count --;</span><br><span class="line">    cprintf(<span class="string">&quot;cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是对哲学家就餐问题的改进：（基于管程）</p>
<ul>
<li>philosopher_using_condvar：程序主体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">philosopher_proc_condvar</span>[<span class="title">N</span>];</span> <span class="comment">// N个哲学家</span></span><br><span class="line"><span class="keyword">int</span> state_condvar[N];                            <span class="comment">// 哲学家的状态</span></span><br><span class="line"><span class="keyword">monitor_t</span> mt, *mtp=&amp;mt;                          <span class="comment">// 管程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">philosopher_using_condvar</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">&quot;I am No.%d philosopher_condvar\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; </span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_condvar is thinking\n&quot;</span>,iter,i); </span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_condvar(i); <span class="comment">/* 需要两只叉子,或者阻塞 */</span></span><br><span class="line"></span><br><span class="line">        cprintf(<span class="string">&quot;Iter %d, No.%d philosopher_condvar is eating\n&quot;</span>,iter,i);</span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_condvar(i); <span class="comment">/* 把两把叉子同时放回桌子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">&quot;No.%d philosopher_condvar quit\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_take_forks_condvar：需要两只叉子，或者阻塞</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">    state_condvar[i]=HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">    phi_test_condvar(i); <span class="comment">/* 哲学家尝试得到两只叉子,并且进餐 */</span></span><br><span class="line">    <span class="keyword">if</span> (state_condvar[i] != EATING) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_take_forks_condvar: %d didn&#x27;t get fork and will wait\n&quot;</span>,i);</span><br><span class="line">        cond_wait(&amp;mtp-&gt;cv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_put_forks_condvar：把两把叉子同时放回桌子</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">    state_condvar[i]=THINKING;</span><br><span class="line">    phi_test_condvar(LEFT); <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">    phi_test_condvar(RIGHT); <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">    <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>phi_test_condvar：哲学家尝试得到两只叉子,并且进餐</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_condvar</span> <span class="params">(i)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(state_condvar[i]==HUNGRY&amp;&amp;state_condvar[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_condvar[RIGHT]!=EATING) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_test_condvar: state_condvar[%d] will eating\n&quot;</span>,i);</span><br><span class="line">        state_condvar[i] = EATING ;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_test_condvar: signal self_cv[%d] \n&quot;</span>,i);</span><br><span class="line">        cond_signal(&amp;mtp-&gt;cv[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PS：为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      down(&amp;(mtp-&gt;mutex));</span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">      <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">         up(&amp;(mtp-&gt;next));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的好处有两个</p>
<ul>
<li>只有一个进程在执行管程中的函数</li>
<li>避免由于执行了 <code>cond_signal</code> 函数而睡眠的进程无法被唤醒</li>
</ul>
<p>针对 “避免由于执行了 <code>cond_signal</code> 函数而睡眠的进程无法被唤醒” 这个优点简单说一下：</p>
<ul>
<li>管程中 <code>wait</code> 和 <code>signal</code> 函数的调用存在时间顺序<ul>
<li>例如：当线程1先调用 <code>signal</code> 唤醒线程2并将自身线程挂起后，线程2在开始执行时将无法唤醒原先的在 <code>signal</code> 中挂起的线程1</li>
</ul>
</li>
<li>也就是说，只要存在线程在管程中执行了 <code>signal</code>，那么至少存在一个线程在管程中被挂起</li>
<li>此时，就只能在临界区外唤醒挂起的线程1，而这一步在代码中也得到了实现</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/miscellaneous/" rel="tag"><i class="fa fa-tag"></i> miscellaneous</a>
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/Kernel/" rel="tag"><i class="fa fa-tag"></i> Kernel</a>
              <a href="/tags/Ucore/" rel="tag"><i class="fa fa-tag"></i> Ucore</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/29/mybash/" rel="prev" title="mybash">
      <i class="fa fa-chevron-left"></i> mybash
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/03/Ucore-Lab8/" rel="next" title="Ucore-Lab8">
      Ucore-Lab8 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.</span> <span class="nav-text">原子操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">等待队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">3.</span> <span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">管程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="nav-number">6.</span> <span class="nav-text">进程的交互关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS%E4%B8%8E%E9%94%81"><span class="nav-number">7.</span> <span class="nav-text">CAS与锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A00-%E6%8A%8A-lab6-%E7%9A%84%E5%86%85%E5%AE%B9%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%88%B0-lab7"><span class="nav-number">9.</span> <span class="nav-text">练习0-把 lab6 的内容复制粘贴到 lab7</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01-%E7%90%86%E8%A7%A3%E5%86%85%E6%A0%B8%E7%BA%A7%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">10.</span> <span class="nav-text">练习1-理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02-%E5%AE%8C%E6%88%90%E5%86%85%E6%A0%B8%E7%BA%A7%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">332</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:53</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
