<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="POSIX 简析POSIX：可移植操作系统接口（ Portable Operating System Interface，缩写为 POSIX ） POSIX是一套标准，为了提高Unix的 兼容性 和 应用程序可移植性 而诞生，这套标准涵盖了很多方面，比如：Unix系统调用的C语言接口，shell程序和工具，线程及网络编程   POSIX兼容也就指定了接口函数兼容，但是并不管API具体如何实现  K">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel基础知识（持续更新）">
<meta property="og:url" content="http://example.com/2022/05/09/Kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="POSIX 简析POSIX：可移植操作系统接口（ Portable Operating System Interface，缩写为 POSIX ） POSIX是一套标准，为了提高Unix的 兼容性 和 应用程序可移植性 而诞生，这套标准涵盖了很多方面，比如：Unix系统调用的C语言接口，shell程序和工具，线程及网络编程   POSIX兼容也就指定了接口函数兼容，但是并不管API具体如何实现  K">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/09/Kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1652275165959-1664718736208.png">
<meta property="article:published_time" content="2022-05-09T15:12:58.000Z">
<meta property="article:modified_time" content="2022-10-02T13:52:34.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/09/Kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1652275165959-1664718736208.png">

<link rel="canonical" href="http://example.com/2022/05/09/Kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Kernel基础知识（持续更新） | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/09/Kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kernel基础知识（持续更新）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-09 23:12:58" itemprop="dateCreated datePublished" datetime="2022-05-09T23:12:58+08:00">2022-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-02 21:52:34" itemprop="dateModified" datetime="2022-10-02T21:52:34+08:00">2022-10-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="POSIX-简析"><a href="#POSIX-简析" class="headerlink" title="POSIX 简析"></a>POSIX 简析</h2><p>POSIX：可移植操作系统接口（ Portable Operating System Interface，缩写为 POSIX ）</p>
<p>POSIX是一套标准，为了提高Unix的 <strong>兼容性</strong> 和 <strong>应用程序可移植性</strong> 而诞生，这套标准涵盖了很多方面，比如：Unix系统调用的C语言接口，shell程序和工具，线程及网络编程 </p>
<ul>
<li>POSIX兼容也就指定了接口函数兼容，但是并不管API具体如何实现</li>
</ul>
<h2 id="Kernel-简析"><a href="#Kernel-简析" class="headerlink" title="Kernel 简析"></a>Kernel 简析</h2><p>Kernel 是一个程序，是操作系统底层用来管理上层软件发出的各种请求的程序，Kernel 将各种请求转换为指令，交给硬件去处理，简而言之，Kernel 是连接软件与硬件的中间层 </p>
<p>Kernel 主要提供两个功能，与硬件交互，提供应用运行环境</p>
<p>在 intel 的 CPU 中，会将 CPU 的权限分为 Ring 0，Ring 1，Ring 2，Ring 3，四个等级，权限依次递减，高权限等级可以调用低权限等级的资源</p>
<p>在常见的系统（Windows，Linux，MacOS）中，内核处于 Ring 0 级别，应用程序处于 Ring 3 级别</p>
<h2 id="Kernel-信息获取"><a href="#Kernel-信息获取" class="headerlink" title="Kernel 信息获取"></a>Kernel 信息获取</h2><p>先关闭 kaslr：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-append &quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot;</span><br></pre></td></tr></table></figure>
<p>在 root 权限下启动 kernel：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># lsmod </span></span><br><span class="line">d3kheap <span class="number">16384</span> <span class="number">2</span> - Live <span class="number">0xffffffffc0133000</span> (OE)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="meta"># grep anon_pipe_buf_ops /proc/kallsyms</span></span><br><span class="line">ffffffff88c3fe40 r anon_pipe_buf_ops</span><br><span class="line">/ <span class="meta"># grep commit_creds /proc/kallsyms</span></span><br><span class="line">ffffffff87cd25c0 T commit_creds</span><br></pre></td></tr></table></figure>
<h2 id="Kernel-提权"><a href="#Kernel-提权" class="headerlink" title="Kernel 提权"></a>Kernel 提权</h2><p>内核提权指的是普通用户可以获取到 root 用户的权限，访问原先受限的资源，这里从两种角度来考虑如何提权</p>
<ul>
<li>改变自身：通过改变自身进程的权限，使其具有 root 权限</li>
<li>改变别人：通过影响高权限进程的执行，使其完成我们想要的功能</li>
</ul>
<p><strong>Change Self：</strong></p>
<p>内核会通过进程的 <code>task_struct</code> 结构体中的 cred 指针来索引 cred 结构体，然后根据 cred 的内容来判断一个进程拥有的权限，如果 cred 结构体成员中的 uid-fsgid 都为 0，那一般就会认为进程具有 root 权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="keyword">void</span>        *put_addr;</span><br><span class="line">    <span class="keyword">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，提权方式为：</p>
<ul>
<li>直接修改 cred 结构体的内容（需要先定位 cred，然后将其修改）</li>
<li>修改 task_struct 结构体中的 cred 指针指向一个满足要求的 cred</li>
</ul>
<p><strong>Change Others：</strong></p>
<p>如果我们可以改变特权进程的执行轨迹，也可以实现提权，这里我们从以下角度来考虑如何改变特权进程的执行轨迹：</p>
<ul>
<li>改数据</li>
<li>改代码</li>
</ul>
<h2 id="修改-cred-结构体的内容"><a href="#修改-cred-结构体的内容" class="headerlink" title="修改 cred 结构体的内容"></a>修改 cred 结构体的内容</h2><p>想要修改 cred 结构体，首先需要确定该结构体的位置：</p>
<p><strong>cred定位-直接扫描 cred</strong></p>
<p>cred 结构体的最前面记录了各种 id 信息，对于一个普通的进程而言，uid-fsgid 都是执行进程的用户的身份，因此我们可以通过 <strong>扫描内存</strong> 来定位 cred</p>
<ul>
<li>在实际定位的过程中，我们可能会发现很多满足要求的 cred，这主要是因为 cred 结构体可能会被拷贝、释放</li>
<li>一个很直观的想法是在定位的过程中，利用 usage 不为 0 来筛除掉一些 cred，但仍然会发现一些 usage 为 0 的 cred</li>
<li>这是因为 cred 从 usage 为 0， 到释放有一定的时间</li>
<li>此外，cred 是使用 rcu 延迟释放的</li>
</ul>
<p><strong>cred定位-通过task_struct间接定位</strong></p>
<p>进程的 <code>task_struct</code> 结构体中会存放指向 cred 的指针，因此我们可以：</p>
<ul>
<li>定位当前进程 <code>task_struct</code> 结构体的地址</li>
<li>根据 cred 指针相对于 task_struct 结构体的偏移计算得出 <code>cred</code> 指针存储的地址</li>
<li>获取 <code>cred</code> 具体的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state; <span class="comment">// 说明了该进程是否可以执行,还是可中断等信息</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">// Flage 是进程号,在调用fork()时给出</span></span><br><span class="line"><span class="keyword">int</span> sigpending; <span class="comment">// 进程上是否有待处理的信号</span></span><br><span class="line"><span class="keyword">mm_segment_t</span> addr_limit; <span class="comment">// 进程地址空间,区分内核进程与普通进程在内存存放的位置不同</span></span><br><span class="line">    <span class="comment">/* 0-0xBFFFFFFF for user-thead */</span></span><br><span class="line">    <span class="comment">/* 0-0xFFFFFFFF for kernel-thread */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> need_resched; <span class="comment">// 调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度</span></span><br><span class="line"><span class="keyword">int</span> lock_depth; <span class="comment">// 锁深度</span></span><br><span class="line"><span class="keyword">long</span> nice; <span class="comment">// 进程的基本时间片</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> policy; <span class="comment">// 进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHER</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">// 进程内存管理信息</span></span><br><span class="line"><span class="keyword">int</span> processor; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cpus_runnable, cpus_allowed; <span class="comment">// 若进程不在任何CPU上运行, cpus_runnable 的值是0,否则是1(这个值在运行队列被锁时更新)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span> <span class="comment">// 指向运行队列的指针</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sleep_time; <span class="comment">// 进程的睡眠时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_task</span>, *<span class="title">prev_task</span>;</span> <span class="comment">// 用于将系统中所有的进程连成一个双向循环链表,其根是init_task</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">local_pages</span>;</span> <span class="comment">// 指向本地页面      </span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> allocation_order, nr_local_pages;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span> <span class="comment">// 进程所运行的可执行文件的格式</span></span><br><span class="line"><span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line"><span class="keyword">int</span> pdeath_signal; <span class="comment">// 父进程终止时向子进程发送的信号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> personality;</span><br><span class="line"><span class="keyword">int</span> did_exec:<span class="number">1</span>; <span class="comment">// Linux可以运行由其他UNIX操作系统生成的符合iBCS2标准的程序</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;				<span class="comment">/* 进程标识符,用来代表一个进程 */</span></span><br><span class="line"><span class="keyword">pid_t</span> pgrp;				<span class="comment">/* 进程组标识,表示进程所属的进程组 */</span></span><br><span class="line"><span class="keyword">pid_t</span> tty_old_pgrp;		<span class="comment">/* 进程控制终端所在的组标识 */</span></span><br><span class="line"><span class="keyword">pid_t</span> session;  		<span class="comment">/* 进程的会话标识 */</span></span><br><span class="line"><span class="keyword">pid_t</span> tgid;</span><br><span class="line"><span class="keyword">int</span> leader; <span class="comment">// 表示进程是否为会话主管</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_opptr</span>,*<span class="title">p_pptr</span>,*<span class="title">p_cptr</span>,*<span class="title">p_ysptr</span>,*<span class="title">p_osptr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span> <span class="comment">// 线程链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pidhash_next</span>;</span> <span class="comment">// 用于将进程链入HASH表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">pidhash_pprev</span>;</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wait_chldexit; <span class="comment">// 供wait4()使用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span> <span class="comment">// 供vfork()使用</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> rt_priority; <span class="comment">// 实时优先级，用它计算实时进程调度时的weight值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* it_real_value,it_real_incr用于REAL定时器(单位为jiffies):</span></span><br><span class="line"><span class="comment">系统根据it_real_value设置定时器的第一个终止时间,在定时器到期时,向进程发送SIGALRM信号,同时根据it_real_incr重置终止时间 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* it_prof_value，it_prof_incr用于Profile定时器(单位为jiffies):</span></span><br><span class="line"><span class="comment">当进程运行时,不管在何种状态下,每个tick都使it_prof_value值减一,当减到0时,向进程发送</span></span><br><span class="line"><span class="comment">信号SIGPROF,并根据it_prof_incr重置时间 */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* it_virt_value,it_virt_value用于Virtual定时器(单位为jiffies):</span></span><br><span class="line"><span class="comment">当进程运行时,不管在何种状态下,每个tick都使it_virt_value值减一,当减到0时,向进程发送信号SIGVTALRM,根据it_virt_incr重置初值 */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> it_real_value, it_prof_value, it_virt_value;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> it_real_incr, it_prof_incr, it_virt_value;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">real_timer</span>;</span> <span class="comment">// 指向实时定时器的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">times</span>;</span> <span class="comment">// 记录进程消耗的时间</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> start_time; <span class="comment">// 进程创建的时间</span></span><br><span class="line"><span class="keyword">long</span> per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS]; <span class="comment">// 记录进程在每个CPU上所消耗的用户态时间和核心态时间</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 内存缺页和交换信息:</span></span><br><span class="line"><span class="comment">min_flt,maj_flt:累计进程的次缺页数(Copy on　Write页和匿名页)和主缺页数(从映射文件或交换</span></span><br><span class="line"><span class="comment">设备读入的页面数)</span></span><br><span class="line"><span class="comment">nswap:记录进程累计换出的页面数,即写到交换设备上的页面数</span></span><br><span class="line"><span class="comment">cmin_flt,cmaj_flt,cnswap:记录本进程为祖先的所有子孙进程的累计次缺页数,主缺页数和换出页面数,在父进程回收终止的子进程时,父进程会将子进程的这些信息累计到自己结构的这些域中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;</span><br><span class="line"><span class="keyword">int</span> swappable:<span class="number">1</span>; <span class="comment">// 表示进程的虚拟地址空间是否允许换出</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 进程认证信息:</span></span><br><span class="line"><span class="comment">uid,gid:为运行该进程的用户的用户标识符和组标识符,通常是进程创建者的uid,gid</span></span><br><span class="line"><span class="comment">euid,egid:为有效uid,gid</span></span><br><span class="line"><span class="comment">fsuid,fsgid:为文件系统uid,gid,这两个ID号通常与有效uid,gid相等,在检查对于文件系统的访问权限时使用他们</span></span><br><span class="line"><span class="comment">suid,sgid:为备份uid,gid</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">uid_t</span> uid,euid,suid,fsuid;</span><br><span class="line"><span class="keyword">gid_t</span> gid,egid,sgid,fsgid;</span><br><span class="line"><span class="keyword">int</span> ngroups; <span class="comment">// 记录进程在多少个用户组中</span></span><br><span class="line"><span class="keyword">gid_t</span> groups[NGROUPS]; <span class="comment">// 记录进程所在的组</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span> cap_effective, cap_inheritable, cap_permitted; <span class="comment">// 进程的权能,分别是有效位集合,继承位集合,允许位集合</span></span><br><span class="line"><span class="keyword">int</span> keep_capabilities:<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span> <span class="comment">// 与进程相关的资源限制信息</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> used_math; <span class="comment">// 是否使用FPU</span></span><br><span class="line"><span class="keyword">char</span> comm[<span class="number">16</span>]; <span class="comment">// 进程正在运行的可执行文件名</span></span><br><span class="line"><span class="keyword">int</span> link_count, total_link_count; <span class="comment">// 文件系统信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span> <span class="comment">// 指向进程所在的控制终端,如果不需要控制终端,则该指针为空</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> locks;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">semundo</span>;</span> <span class="comment">// 进程在信号灯上的所有undo操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">semsleeping</span>;</span> <span class="comment">// 当进程因为信号灯操作而挂起时,他在该队列中记录等待的操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span> <span class="comment">// 进程的CPU状态,切换时,要保存到停止进程的task_struct中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span> <span class="comment">// 文件系统信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 打开文件信息</span></span><br><span class="line"><span class="keyword">spinlock_t</span> sigmask_lock; <span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span> <span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="keyword">sigset_t</span> blocked; <span class="comment">// 进程当前要阻塞的信号,每个信号对应一位</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span> <span class="comment">// 进程上是否有待处理的信号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;</span><br><span class="line"><span class="keyword">size_t</span> sas_ss_size;</span><br><span class="line"><span class="keyword">int</span> (*notifier)(<span class="keyword">void</span> *priv);</span><br><span class="line"><span class="keyword">void</span> *notifier_data;</span><br><span class="line"><span class="keyword">sigset_t</span> *notifier_mask;</span><br><span class="line">u32 parent_exec_id;</span><br><span class="line">u32 self_exec_id;</span><br><span class="line"><span class="keyword">spinlock_t</span> alloc_lock;</span><br><span class="line"><span class="keyword">void</span> *journal_info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>cred定位-通过comm间接定位</strong></p>
<p>comm 用来标记可执行文件的名字，位于进程的 <code>task_struct</code> 结构体中，我们可以发现 comm 其实在 cred 的正下方，所以我们也可以先定位 comm ，然后定位 cred 的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>     *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>          *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>                comm[TASK_COMM_LEN];</span><br></pre></td></tr></table></figure>
<p>然而，在进程名字并不特殊的情况下，内核中可能会有多个同样的字符串，这会影响搜索的正确性与效率，因此，我们可以使用 prctl 设置进程的 comm 为一个特殊的字符串，然后再开始定位 comm</p>
<p><strong>cred间接定位-UAF使用同样堆块</strong></p>
<p>虽然我们确实想要修改 cred 的内容，但是不一定非得知道 cred 的具体位置，我们只需要能够修改 cred 即可</p>
<p>如果我们在进程初始化时能控制 cred 结构体的位置，并且我们可以在初始化后修改该部分的内容，那么我们就可以很容易地达到提权的目的，这里给出一个典型的例子：</p>
<ul>
<li>申请一块与 cred 结构体大小一样的堆块</li>
<li>释放该堆块</li>
<li>fork 出新进程，恰好使用刚刚释放的堆块</li>
<li>此时，修改 cred 结构体特定内存，从而提权</li>
</ul>
<p><strong>cred修改</strong></p>
<p>在具体修改时，我们可以使用如下方式：</p>
<ul>
<li>修改 cred 指针为内核镜像中已有的 init_cred 的地址（这种方法适合于我们能够直接修改 cred 指针以及知道 init_cred 地址的情况）</li>
<li>伪造一个 cred，然后修改 cred 指针指向该地址即可（这种方式比较麻烦，一般并不使用）</li>
<li>使用 commit_creds(prepare_kernel_cred(0)) 来进行提权，该方式会自动生成一个合法的 cred，并定位当前线程的 task_struct 的位置，然后修改它的 cred 为新的 cred（该方式比较适用于控制程序执行流后使用，例如ROP后）</li>
</ul>
<h2 id="改变特权进程的执行轨迹"><a href="#改变特权进程的执行轨迹" class="headerlink" title="改变特权进程的执行轨迹"></a>改变特权进程的执行轨迹</h2><p>如果我们可以改变特权进程的执行轨迹，也可以实现提权，这里我们从以下角度来考虑如何改变特权进程的执行轨迹：改数据，改代码</p>
<p><strong>改数据-符号链接</strong></p>
<p>如果一个 root 权限的进程会执行一个符号链接的程序，并且该符号链接或者符号链接指向的程序可以由攻击者控制，攻击者就可以实现提权</p>
<p><strong>改数据-利用 call_usermodehelper</strong></p>
<p>修改 modprobe_path 实现提权的基本流程如下：</p>
<ul>
<li>获取 modprobe_path 的地址</li>
<li>修改 modprobe_path 为指定的程序（当前进程）</li>
<li>触发执行 <code>call_modprobe</code>，从而实现提权 ，这里我们可以利用以下几种方式来触发：<ul>
<li>执行一个非法的可执行文件，非法的可执行文件需要满足相应的要求</li>
<li>使用未知协议来触发</li>
</ul>
</li>
</ul>
<p>使用 modprobe_path 的模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 1: 将modprobe_path修改为目标值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2: 创建相关文件</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;#!/bin/sh\n/bin/cp /flag /home/pwn/flag\n/bin/chmod 777 /home/pwn/flag\ncat flag&#x27; &gt; /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/catflag.sh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3.1: 使用未知的可执行文件触发它</span></span><br><span class="line">system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /home/pwn/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/home/pwn/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3.2: 使用未知协议触发它</span></span><br><span class="line">socket(AF_INET,SOCK_STREAM,<span class="number">132</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>由于 modprobe_path 的取值是确定的，所以我们可以直接扫描内存，寻找对应的字符串，这需要我们具有扫描内存的能力</li>
<li>考虑到 modprobe_path 相对于内核基地址的偏移是固定的，我们可以先获取到内核的基地址，然后根据相对偏移来得到 modprobe_path 的地址</li>
</ul>
<p><strong>改数据-修改 poweroff_cmd</strong></p>
<ul>
<li>获取 poweroff_cmd 的地址</li>
<li>修改 poweroff_cmd 为指定的程序（当前进程）</li>
<li>劫持控制流执行 <code>__orderly_poweroff</code></li>
</ul>
<p>关于如何定位 <code>poweroff_cmd</code>，我们可以采用类似于定位 <code>modprobe_path</code> 的方法</p>
<p><strong>改代码-修改 vDSO 代码</strong></p>
<p>内核中 vDSO 的代码会被映射到所有的用户态进程中，如果有一个高特权的进程会周期性地调用 vDSO 中的函数，那我们可以考虑把 vDSO 中相应的函数修改为特定的 shellcode，当高权限的进程执行相应的代码时，我们就可以进行提权</p>
<ul>
<li>在早期的时候，Linux 中的 vDSO 是可写的，考虑到这样的风险，Kees Cook 提出引入 <code>post-init read-only</code> 的数据，即将那些初始化后不再被写的数据标记为只读，来防御这样的利用</li>
</ul>
<p>通过修改 vDSO 进行提权的基本方式如下：</p>
<ul>
<li>定位 vDSO（IDA中查看为：raw_data）</li>
<li>修改 vDSO 的特定函数为指定的 shellcode</li>
<li>等待触发执行 shellcode</li>
</ul>
<p>这里我们着重关注下如何定位 vDSO：</p>
<p>在 IDA 中定位：</p>
<ul>
<li>在 ida 里定位 init_vdso 函数的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">init_vdso</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  init_vdso_image(&amp;vdso_image_64 + <span class="number">0x20000000</span>);</span><br><span class="line">  init_vdso_image(&amp;vdso_image_x32 + <span class="number">0x20000000</span>);</span><br><span class="line">  cpu_maps_update_begin();</span><br><span class="line">  on_each_cpu((<span class="keyword">char</span> *)startup_64 + <span class="number">0x100003EA0</span>LL, <span class="number">0LL</span>, <span class="number">1LL</span>);</span><br><span class="line">  _register_cpu_notifier(&amp;sdata + <span class="number">536882764</span>);</span><br><span class="line">  cpu_maps_update_done();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>进入“vdso_image_64”或者“vdso_image_x32”后，就可以看到“raw_data”了</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rodata:FFFFFFFF81A01300                 <span class="keyword">public</span> vdso_image_64</span><br><span class="line">.rodata:FFFFFFFF81A01300 vdso_image_64   dq offset raw_data      ; DATA XREF: arch_setup_additional_pages+<span class="number">18</span>↑o</span><br><span class="line">.rodata:FFFFFFFF81A01300                                         ; init_vdso+<span class="number">1</span>↓o</span><br></pre></td></tr></table></figure>
<p>在内存中定位：</p>
<ul>
<li>vDSO 其实是一个 ELF 文件，具有 ELF 文件头，同时，vDSO 中特定位置存储着导出函数的字符串，因此我们可以根据这两个特征来扫描内存，定位 vDSO 的位置</li>
<li>考虑到 vDSO 相对于内核基地址的偏移是固定的，我们可以先获取到内核的基地址，然后根据相对偏移来得到 vDSO 的地址</li>
</ul>
<h2 id="Kernel-目录结构"><a href="#Kernel-目录结构" class="headerlink" title="Kernel 目录结构"></a>Kernel 目录结构</h2><p>通常一个文件系统映像（core.cpio）解压以后有如下目录/文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  core ls</span><br><span class="line">bin      etc  init     lib64   proc  sbin  tmp  vmlinux</span><br><span class="line">core.ko  lib  linuxrc  root    sys   usr</span><br></pre></td></tr></table></figure>
<ul>
<li>bin目录：普通用户使用的二进制文件，包括了各种终端命令</li>
<li>sbin目录：超级用户专用的二进制代码存放目录，主要用于系统管理</li>
<li><p>usr目录：usr 是 unix shared resources(共享资源) 的缩写，用户的很多应用程序和文件都放在这个目录下</p>
<ul>
<li>/usr/bin：普通用户在后期安装的一些软件的运行脚本</li>
<li>/usr/sbin：存放了超级用户使用的，对于boot启动时非必须的二进制程序文件</li>
</ul>
</li>
<li>etc目录：配置文件目录 </li>
<li>sys目录：包含硬件设备的驱动程序信息（一般为NULL）</li>
<li>proc文件：proc虚拟文件系统在内核空间和用户空间之间打开了一个通信窗口（一般为NULL）</li>
<li>init文件：初始化脚本（拥有关键信息）</li>
<li>lib64目录：包含大量库文件（通常 lib32，lib64 只会有一个，而 lib 是其中一个的符号链接）</li>
<li>lib目录：包含基本的共享库和内核模块，arch(架构)，drivers(驱动)，fs(文件系统)，net(网络)</li>
<li>tmp目录：用于存放临时文件（一般为NULL）</li>
<li>vmlinux文件：静态链接的可执行文件格式的 Linux 内核，分析的目标之一</li>
<li>core.ko文件：驱动文件，分析的目标之一（文件名可能不是“core”，主要看这个“ko”后缀）</li>
<li>linuxrc链接：链接目标 [bin/busybox]</li>
<li>root目录：root用户使用的目录，通常装有“flag”</li>
</ul>
<h2 id="驱动函数"><a href="#驱动函数" class="headerlink" title="驱动函数"></a>驱动函数</h2><p>当我们用 IDA 分析一个驱动文件时，会得到以下函数：</p>
<img src="/2022/05/09/Kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1652275165959-1664718736208.png" class width="1652275165959"> 
<p>这些函数就是驱动函数，也被称为 ioctl 函数：</p>
<ul>
<li>ioctl 是设备驱动程序中对设备的 I/O 通道进行管理的函数</li>
<li>ioctl 函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对 ioctl 的支持，用户就可以在用户程序中使用 ioctl 函数控制设备的 I/O 通道</li>
<li>在驱动程序中实现的 ioctl 函数体内，实际上是有一个 switch{case} 结构，每一个 case 对应一个命令码，做出一些相应的操作，怎么实现这些操作，这是由每一个程序员自己控制的，因为设备都是特定的</li>
</ul>
<p>驱动函数是 kernel 中容易出问题的点，是该重点分析的对象</p>
<h2 id="内核结构体"><a href="#内核结构体" class="headerlink" title="内核结构体"></a>内核结构体</h2><p>这里整理了一些内核常用的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="built_in">list</span>            struc ; (<span class="keyword">sizeof</span>=<span class="number">0x28</span>, mappedto_3)</span><br><span class="line"><span class="number">00000000</span> item            dq ?                    ; offset</span><br><span class="line"><span class="number">00000008</span> mutex           dq ?                    ; offset</span><br><span class="line"><span class="number">00000010</span> field_10        dq ?</span><br><span class="line"><span class="number">00000018</span> field_18        dq ?</span><br><span class="line"><span class="number">00000020</span> field_20        dq ?</span><br><span class="line"><span class="number">00000028</span> <span class="built_in">list</span>            ends</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> fd              struc ; (<span class="keyword">sizeof</span>=<span class="number">0xD0</span>, mappedto_6)</span><br><span class="line"><span class="number">00000000</span> field_0         db <span class="number">200</span> dup(?)</span><br><span class="line"><span class="number">000000</span>C8 using_list      dq ?                    ; offset</span><br><span class="line"><span class="number">000000</span>D0 fd              ends</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> input           struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, mappedto_4)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: add_item/r</span><br><span class="line"><span class="number">00000000</span> size            dq ?                    ; XREF: add_item+<span class="number">1</span>A/r</span><br><span class="line"><span class="number">00000000</span>                                         ; add_item+<span class="number">35</span>/r</span><br><span class="line"><span class="number">00000008</span> ptr             dq ?                    ; XREF: add_item+<span class="number">39</span>/r</span><br><span class="line"><span class="number">00000010</span> input           ends</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> item            struc ; (<span class="keyword">sizeof</span>=<span class="number">0x20</span>, mappedto_5)</span><br><span class="line"><span class="number">00000000</span> refcount        dd ?</span><br><span class="line"><span class="number">00000004</span> null            dd ?</span><br><span class="line"><span class="number">00000008</span> size            dq ?</span><br><span class="line"><span class="number">00000010</span> next            dq ?                    ; offset</span><br><span class="line"><span class="number">00000018</span> data            dq ?</span><br><span class="line"><span class="number">00000020</span> item            ends</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/kernel/" rel="tag"><i class="fa fa-tag"></i> kernel</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="prev" title="机器学习（持续更新）">
      <i class="fa fa-chevron-left"></i> 机器学习（持续更新）
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/10/Machine-Learning-Lab3/" rel="next" title="Machine-Learning-Lab3">
      Machine-Learning-Lab3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#POSIX-%E7%AE%80%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">POSIX 简析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-%E7%AE%80%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">Kernel 简析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96"><span class="nav-number">3.</span> <span class="nav-text">Kernel 信息获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-%E6%8F%90%E6%9D%83"><span class="nav-number">4.</span> <span class="nav-text">Kernel 提权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-cred-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">5.</span> <span class="nav-text">修改 cred 结构体的内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E7%89%B9%E6%9D%83%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BD%A8%E8%BF%B9"><span class="nav-number">6.</span> <span class="nav-text">改变特权进程的执行轨迹</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kernel-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">7.</span> <span class="nav-text">Kernel 目录结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">驱动函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">9.</span> <span class="nav-text">内核结构体</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">332</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:53</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
