<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="文件系统和文件文件系统简述： 文件系统是操作系统用于明确 “存储设备或分区上的文件” 的 “一组方法和数据结构”，是操作系统中负责管理和存储文件信息的软件机构（被称为文件管理系统，简称文件系统）  注意：文件系统是对应硬盘的分区的，而不是整个硬盘，不管是硬盘只有一个分区，还是几个分区，不同的分区可以有着不同的文件系统  文件系统由三部分组成：  文件系统的接口层（用于对文件系统进行操作的一系列函数">
<meta property="og:type" content="article">
<meta property="og:title" content="Ucore-Lab8">
<meta property="og:url" content="http://example.com/2022/05/03/Ucore-Lab8/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="文件系统和文件文件系统简述： 文件系统是操作系统用于明确 “存储设备或分区上的文件” 的 “一组方法和数据结构”，是操作系统中负责管理和存储文件信息的软件机构（被称为文件管理系统，简称文件系统）  注意：文件系统是对应硬盘的分区的，而不是整个硬盘，不管是硬盘只有一个分区，还是几个分区，不同的分区可以有着不同的文件系统  文件系统由三部分组成：  文件系统的接口层（用于对文件系统进行操作的一系列函数">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-05-03T15:23:04.000Z">
<meta property="article:modified_time" content="2023-03-16T15:43:22.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="miscellaneous">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="Kernel">
<meta property="article:tag" content="Ucore">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/05/03/Ucore-Lab8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Ucore-Lab8 | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/Ucore-Lab8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Ucore-Lab8
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-03 23:23:04" itemprop="dateCreated datePublished" datetime="2022-05-03T23:23:04+08:00">2022-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-16 23:43:22" itemprop="dateModified" datetime="2023-03-16T23:43:22+08:00">2023-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>38k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>34 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h2><p><strong>文件系统简述：</strong></p>
<p>文件系统是操作系统用于明确 “存储设备或分区上的文件” 的 “一组方法和数据结构”，是操作系统中负责管理和存储文件信息的软件机构（被称为文件管理系统，简称文件系统）</p>
<ul>
<li>注意：文件系统是对应硬盘的分区的，而不是整个硬盘，不管是硬盘只有一个分区，还是几个分区，不同的分区可以有着不同的文件系统</li>
</ul>
<p><strong>文件系统由三部分组成：</strong></p>
<ul>
<li>文件系统的接口层（用于对文件系统进行操作的一系列函数）</li>
<li>文件系统抽象层（“对象操纵和管理” 软件的集合）</li>
<li>对象及属性</li>
</ul>
<p>从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统，具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等，文件系统是软件系统的一部分，它的存在使得应用可以方便的使用抽象命名的数据对象和大小可变的空间</p>
<ul>
<li>比如桌面上的各种文件：操作系统提供了一种抽象来控制管理这些文件，可以是图形界面，也可以是命令行，这些抽象可以让我们忽略一些底层的原理，免去了大量复杂的操作</li>
</ul>
<p><strong>文件系统的功能：</strong></p>
<ul>
<li>管理和调度文件的存储空间，提供文件的逻辑结构、物理结构和存储方法</li>
<li>实现文件从标识到实际地址的映射，实现文件的控制操作和存取操作，实现文件信息的共享并提供可靠的文件保密和保护措施，提供文件的安全措施</li>
</ul>
<h2 id="文件系统-访问接口层"><a href="#文件系统-访问接口层" class="headerlink" title="文件系统-访问接口层"></a>文件系统-访问接口层</h2><p>下面就是在内核中通用的文件相关函数（上层的文件系统需要的系统调用），同时也是我们在uCore中最常使用的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags)</span></span>;    <span class="comment">// 打开或创建一个文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;                                  <span class="comment">// 关闭一个打开的vnode</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span></span>;               <span class="comment">// 读-Read file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span></span>;              <span class="comment">// 写-Write file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_seek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> pos, <span class="keyword">int</span> whence)</span></span>;                <span class="comment">// 查找-Seek file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *stat)</span></span>;                   <span class="comment">// 统计-Stat file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;                                      <span class="comment">// 同步-Sync file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                      <span class="comment">// 改变DIR(页目录表)  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                      <span class="comment">// 创建DIR(页目录表)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path1, <span class="keyword">const</span> <span class="keyword">char</span> *path2)</span></span>;         <span class="comment">// 设置path1的链接设置为path2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path1, <span class="keyword">const</span> <span class="keyword">char</span> *path2)</span></span>;       <span class="comment">// 重命名文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                           <span class="comment">// 取消path的链接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;                      <span class="comment">// 获取当前工作目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_getdirentry</span><span class="params">(<span class="keyword">int</span> fd, struct dirent *direntp)</span></span>;        <span class="comment">// 在DIR中获取文件条目</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_dup</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span></span>;                              <span class="comment">// 复制文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_pipe</span><span class="params">(<span class="keyword">int</span> *fd_store)</span></span>;                                <span class="comment">// 建造管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> open_flags)</span></span>;      <span class="comment">// 生成命名管道</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_open：打开或创建一个文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path, <span class="keyword">uint32_t</span> open_flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;path, __path)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = file_open(path, open_flags);</span><br><span class="line">    kfree(path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_close：关闭一个打开的vnode</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_close</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> file_close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_read：读文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!file_testfd(fd, <span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *buffer;</span><br><span class="line">    <span class="keyword">if</span> ((buffer = kmalloc(IOBUF_SIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> copied = <span class="number">0</span>, alen;</span><br><span class="line">    <span class="keyword">while</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((alen = IOBUF_SIZE) &gt; len) &#123;</span><br><span class="line">            alen = len;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = file_read(fd, buffer, alen, &amp;alen);</span><br><span class="line">        <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">            lock_mm(mm);</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(mm, base, buffer, alen)) &#123;</span><br><span class="line">                    assert(len &gt;= alen);</span><br><span class="line">                    base += alen, len -= alen, copied += alen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    ret = -E_INVAL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            unlock_mm(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> || alen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    kfree(buffer);</span><br><span class="line">    <span class="keyword">if</span> (copied != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> copied;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_write：写文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!file_testfd(fd, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> *buffer;</span><br><span class="line">    <span class="keyword">if</span> ((buffer = kmalloc(IOBUF_SIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> copied = <span class="number">0</span>, alen;</span><br><span class="line">    <span class="keyword">while</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((alen = IOBUF_SIZE) &gt; len) &#123;</span><br><span class="line">            alen = len;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_mm(mm);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!copy_from_user(mm, buffer, base, alen, <span class="number">0</span>)) &#123;</span><br><span class="line">                ret = -E_INVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_mm(mm);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            ret = file_write(fd, buffer, alen, &amp;alen);</span><br><span class="line">            <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">                assert(len &gt;= alen);</span><br><span class="line">                base += alen, len -= alen, copied += alen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span> || alen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    kfree(buffer);</span><br><span class="line">    <span class="keyword">if</span> (copied != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> copied;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_seek：寻找文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_seek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> pos, <span class="keyword">int</span> whence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> file_seek(fd, pos, whence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_fstat：统计文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *__stat)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> __<span class="title">local_stat</span>, *<span class="title">stat</span> =</span> &amp;__local_stat;</span><br><span class="line">    <span class="keyword">if</span> ((ret = file_fstat(fd, stat)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock_mm(mm);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!copy_to_user(mm, __stat, stat, <span class="keyword">sizeof</span>(struct stat))) &#123;</span><br><span class="line">            ret = -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mm(mm);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_fsync：同步文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> file_fsync(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_chdir：改变DIR(页目录表) </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;path, __path)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = vfs_chdir(path);</span><br><span class="line">    kfree(path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_mkdir：创建DIR(页目录表)，ucore没有该接口，它采用另一种方式实现</li>
<li>sysfile_link：设置path1的链接设置为path2</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path1, <span class="keyword">const</span> <span class="keyword">char</span> *__path2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *old_path, *new_path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;old_path, __path1)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;new_path, __path2)) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(old_path);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = vfs_link(old_path, new_path);</span><br><span class="line">    kfree(old_path), kfree(new_path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_rename：重命名文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path1, <span class="keyword">const</span> <span class="keyword">char</span> *__path2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *old_path, *new_path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;old_path, __path1)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;new_path, __path2)) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(old_path);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = vfs_rename(old_path, new_path);</span><br><span class="line">    kfree(old_path), kfree(new_path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_unlink：取消path的链接</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;path, __path)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = vfs_unlink(path);</span><br><span class="line">    kfree(path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_getcwd：获取当前工作目录</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL;</span><br><span class="line">    lock_mm(mm);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (user_mem_check(mm, (<span class="keyword">uintptr_t</span>)buf, len, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> __<span class="title">iob</span>, *<span class="title">iob</span> =</span> iobuf_init(&amp;__iob, buf, len, <span class="number">0</span>);</span><br><span class="line">            ret = vfs_getcwd(iob);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mm(mm);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_getdirentry：在DIR中获取文件条目</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_getdirentry</span><span class="params">(<span class="keyword">int</span> fd, struct dirent *__direntp)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">direntp</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((direntp = kmalloc(<span class="keyword">sizeof</span>(struct dirent))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    lock_mm(mm);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!copy_from_user(mm, &amp;(direntp-&gt;offset), &amp;(__direntp-&gt;offset), <span class="keyword">sizeof</span>(direntp-&gt;offset), <span class="number">1</span>)) &#123;</span><br><span class="line">            ret = -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mm(mm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span> || (ret = file_getdirentry(fd, direntp)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock_mm(mm);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!copy_to_user(mm, __direntp, direntp, <span class="keyword">sizeof</span>(struct dirent))) &#123;</span><br><span class="line">            ret = -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mm(mm);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    kfree(direntp);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_dup：复制文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_dup</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> file_dup(fd1, fd2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_pipe：创建管道（未完成）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_pipe</span><span class="params">(<span class="keyword">int</span> *fd_store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -E_UNIMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sysfile_mkfifo：生成命名管道（未完成）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sysfile_mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__name, <span class="keyword">uint32_t</span> open_flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> -E_UNIMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些 <code>sysfile_xx</code> 函数本质上就是更底层的 <code>file_xx</code> 函数（直接控制文件的函数）的外包装，可以说 <code>file_xx</code> 函数再外加一些对文件系统的操作就是 <code>sysfile_xx</code> 了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_seek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> pos, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *stat)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_getdirentry</span><span class="params">(<span class="keyword">int</span> fd, struct dirent *dirent)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_dup</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_pipe</span><span class="params">(<span class="keyword">int</span> fd[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> open_flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通常来讲，这些函数都会操作当前进程访问文件的数据接口，即 <code>current-&gt;filesp</code>（这也是进程描述结构体 proc_struct 新增的条目-filesp）</p>
<h2 id="文件系统-抽象层"><a href="#文件系统-抽象层" class="headerlink" title="文件系统-抽象层"></a>文件系统-抽象层</h2><p>文件系统抽象层是把 <strong>不同文件系统</strong> 的 <strong>对外共性接口</strong> 提取出来，形成一个函数指针数组，这样，通用文件系统访问接口层只需访问文件系统抽象层，而不需关心具体文件系统的实现细节和接口（有点面向对象的味道）</p>
<p><strong>VFS虚拟文件系统-实现抽象层的技术</strong></p>
<p>系统接口（通用文件系统访问接口层）再下一层就到了 VFS 虚拟文件系统</p>
<p>虚拟文件系统（VFS）是 <strong>物理文件系统与服务之间的一个接口层</strong>（用于在文件系统与服务之间进行最初的解析），它对 Linux 的每个文件系统的所有细节进行抽象，使得不同的文件系统在 Linux 核心以及系统中运行的其他进程看来都是相同的</p>
<p>虚拟文件系统中，所使用的相关函数接口分别是 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 虚拟文件系统vfs初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 虚拟文件系统vfs清除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_devlist_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_set_curdir</span><span class="params">(struct inode *dir)</span></span>; <span class="comment">// 通过inode更改当前线程的当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_curdir</span><span class="params">(struct inode **dir_store)</span></span>; <span class="comment">// 检索当前线程的当前目录的inode</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_root</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct inode **root_store)</span></span>; <span class="comment">// 获取名为DEVNAME的文件系统的根inode</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">vfs_get_devname</span><span class="params">(struct fs *fs)</span></span>; <span class="comment">// 获取传入的文件系统的挂载设备名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags, struct inode **inode_store)</span></span>; <span class="comment">// 打开或创建文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_close</span><span class="params">(struct inode *node)</span></span>; <span class="comment">// 关闭文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_link</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>; <span class="comment">// 创建指向文件的硬链接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_symlink</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>; <span class="comment">// 创建包含内容的符号链接路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_readlink</span><span class="params">(<span class="keyword">char</span> *path, struct iobuf *iob)</span></span>; <span class="comment">// 将符号链接的内容读入uio(内核驱动)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_mkdir</span><span class="params">(<span class="keyword">char</span> *path)</span></span>; <span class="comment">// 创建一个目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unlink</span><span class="params">(<span class="keyword">char</span> *path)</span></span>; <span class="comment">// 删除文件/目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_rename</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>; <span class="comment">// 重命名文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_chdir</span><span class="params">(<span class="keyword">char</span> *path)</span></span>; <span class="comment">// 按名称更改当前线程的当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_getcwd</span><span class="params">(struct iobuf *iob)</span></span>; <span class="comment">// 检索当前线程当前目录的名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_lookup</span><span class="params">(<span class="keyword">char</span> *path, struct inode **node_store)</span></span>; <span class="comment">// 查找文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_lookup_parent</span><span class="params">(<span class="keyword">char</span> *path, struct inode **node_store, <span class="keyword">char</span> **endp)</span></span>; <span class="comment">// 查找父目录</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_set_bootfs</span><span class="params">(<span class="keyword">char</span> *fsname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_bootfs</span><span class="params">(struct inode **node_store)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_add_fs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_add_dev</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct inode *devnode, <span class="keyword">bool</span> mountable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">int</span> (*mountfunc)(struct device *dev, struct fs **fs_store))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unmount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unmount_all</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ucore 虚拟文件系统中有四大对象：<strong>SuperBlock、inode、dentry、file</strong></p>
<ul>
<li><strong>超级块（SuperBlock）</strong></li>
</ul>
<p>超级块主要从文件系统的全局角度描述特定文件系统的全局信息，它的作用范围是整个OS空间</p>
<p>ucore 中有如下结构体来描述超级块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                                 <span class="comment">/* 魔数,必须是SFS_MAGIC */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* fs中的块数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> unused_blocks;                         <span class="comment">/* fs中未使用的区块 */</span></span><br><span class="line">    <span class="keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">/* sfs的info(信息) */</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>PS：内核通过 magic 来检查磁盘镜像是否是合法的 SFS 镜像</p>
<ul>
<li><strong>索引节点（inode）</strong></li>
</ul>
<p>UNIX 将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点（每个文件都有一个 inode）</p>
<p>Linux 系统为每一个文件都分配了一个 inode 编号，这个编号中记录了文件相关的一些元信息，通过这些元信息可以用来唯一标识一个文件（操作系统上的 inode 并非无穷无尽，通常在你安装操作系统后，系统上的 inode 数量就已经确定了下来）</p>
<p>ucore 中的 inode 由如下结构体确定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span> <span class="comment">/* 设备结点 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span> <span class="comment">/* 文件/目录节点 */</span></span><br><span class="line">    &#125; in_info; </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type; <span class="comment">/* 类型 */</span></span><br><span class="line">    <span class="keyword">int</span> ref_count; <span class="comment">/* 引用次数 */</span></span><br><span class="line">    <span class="keyword">int</span> open_count; <span class="comment">/* 打开次数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span> <span class="comment">/* 相关联的文件系统 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span> <span class="comment">/* 当前结构所对应的操作集合(inode接口) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来看看几种类型的索引结点：</p>
<p>一，磁盘索引结点——保存在硬盘中的索引结点</p>
<ul>
<li>sfs_disk_inode 结构记录了文件或目录的内容存储的索引信息，该数据结构在硬盘里储存，需要时读入内存：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                  <span class="comment">/* 文件大小 */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                  <span class="comment">/* 目标类型(文件,目录,链接) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                                <span class="comment">/* 此文件的硬链接 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* 此文件的块 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="comment">/* 直接指向了保存文件内容数据的数据块索引值 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                              <span class="comment">/* 指向的是间接数据块 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于普通文件：索引值 direct 指向的 block 中保存的是文件中的数据</li>
<li>对于目录：索引值 direct 指向的数据保存的是目录下所有的文件名，以及对应的索引节点所在的索引块（磁盘块）所形成的数组，数据结构如下：（其实就是它就是目录项）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode编号 */</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">/* 文件名称 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>不管是文件还是目录，磁盘索引结点都需要与内存索引结点进行“绑定”，这样才可以操控磁盘上的数据</li>
<li>当 uCore 创建一个“用于存储文件/目录”的 inode 结构时（即该 inode -&gt; in_info 成员变量为 sfs_inode 类型），程序会执行函数 sfs_create_inode，该函数会将 inode -&gt; sfs_inode 成员与磁盘对应结点 sfs_disk_inode 相关联，从而使得只凭 inode 即可操作该结点</li>
<li>PS：用于描述设备 device 的 inode 会在其他函数中被初始化，不会执行函数 sfs_create_inode</li>
</ul>
<p>二，内存索引结点——保存在内存中的索引结点（inode 结构体的条目之一）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* 磁盘索引节点 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode编号 */</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">/* 如果inode被修改,则为true */</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">/* 如果它为&#x27;0&#x27;就杀死inode  */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">/* din(磁盘索引节点)的信号量 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">/* inode链表的入口 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         <span class="comment">/* inode哈希链表的入口 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>SFS 中的内存 sfs_inode 包含SFS的硬盘 sfs_disk_inode 信息，而且还增加了其他一些信息，这些信息用于：判断相关硬盘位置是否改写、互斥操作、回收和快速地定位</li>
<li>PS：一个内存 sfs_inode 是在打开一个文件后才创建的，如果关机则相关信息都会消失，而硬盘 sfs_disk_inode 的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</li>
</ul>
<p>三，文件结点——用于指向磁盘索引结点的结点（有助于硬链接的实现）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino; <span class="comment">/* inode编号(指向了sfs_disk_inode磁盘索引结点) */</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>]; <span class="comment">/* 文件名称 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>inode-&gt;in_ops 指向 inode 接口，是对常规文件、目录、设备文件所有操作的一个抽象函数表示</p>
<p>对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了（用户进程无需了解具体文件系统的实现细节）</p>
<p>inode_ops 采用如下结构体进行组织：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>inode 结构是与文件系统相关的，<strong>不同文件系统所实现的 inode 结构是不同的</strong>（主要体现在 inode_ops 条目），它的存在可以让 VFS 忽略更下一级的文件系统差异，使之注重于提供一个统一的文件系统接口</p>
<p>inode_ops 根据其 in_info 的不同而实现其不同的功能：（目录，文件，外设）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sfs特定的dir操作对应于inode上的抽象操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_namefile                   = sfs_namefile,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sfs特定的file操作对应于inode上的抽象操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_tryseek                    = sfs_tryseek,</span><br><span class="line">    .vop_truncate                   = sfs_truncfile,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sfs特定的dev操作对应于inode上的抽象操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">dev_node_ops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = dev_open,</span><br><span class="line">    .vop_close                      = dev_close,</span><br><span class="line">    .vop_read                       = dev_read,</span><br><span class="line">    .vop_write                      = dev_write,</span><br><span class="line">    .vop_fstat                      = dev_fstat,</span><br><span class="line">    .vop_ioctl                      = dev_ioctl,</span><br><span class="line">    .vop_gettype                    = dev_gettype,</span><br><span class="line">    .vop_tryseek                    = dev_tryseek,</span><br><span class="line">    .vop_lookup                     = dev_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>目录项（dentry）</strong></li>
</ul>
<p>目录项不是目录，而是目录的组成部分</p>
<p>目录项是描述文件的逻辑属性，只存在于内存中，并没有实际对应的磁盘上的描述，更确切的说是存在于内存的目录项缓存，为了提高查找性能而设计</p>
<ul>
<li>UNIX 中目录被看作一种特定的文件，而目录项是文件路径中的一部分</li>
<li>如一个文件路径名是 “/test/testfile” ，则包含的目录项为：<ul>
<li>根目录 “/” ，目录 “test” 和文件 “testfile” ，这三个都是目录项</li>
</ul>
</li>
<li>一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点位置</li>
</ul>
<p>注意：目录也是一种文件，所以也存在对应的 inode，打开目录，实际上就是打开对应的目录文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode编号 */</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">/* 文件名称 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dentry（具体为struct sfs_disk_entry）就是一个内存实体：其中的 ino 成员指向对应的 inode number，另外一个成员是 file name</p>
<ul>
<li><strong>文件（file）</strong></li>
</ul>
<p>它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息，它的作用范围是某一具体进程</p>
<p>下面是用于描述文件的结构体：file（又称打开的文件描述）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;</span><br><span class="line">    <span class="keyword">bool</span> readable; <span class="comment">/* 读权限标记位 */</span></span><br><span class="line">    <span class="keyword">bool</span> writable; <span class="comment">/* 写权限标记位 */</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">off_t</span> pos; <span class="comment">/* 当前读取位置(下一次写入的起始位置) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span> <span class="comment">/* 文件系统中与硬盘特定区域所对应的结点(索引节点inode) */</span></span><br><span class="line">    <span class="keyword">int</span> open_count; <span class="comment">/* 打开的引用次数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 file 只是对一个文件而言，对于一个进程(用户)来说，可以同时处理多个文件，所以需要另一个结构来管理所有的 files：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// 当前工作目录的inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// 打开的文件数组(存放file结构体)</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// 打开的文件数</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// 对应的信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="文件系统-文件系统层"><a href="#文件系统-文件系统层" class="headerlink" title="文件系统-文件系统层"></a>文件系统-文件系统层</h2><p>从 VFS 向下一层，就是 SFS（Simple FS，文件系统层，简称 SFS）</p>
<p>ucore 内核把所有文件都看作是字节流，任何内部逻辑结构都是专用的，由应用程序负责解释，但是 ucore 区分文件的物理结构，ucore 目前支持如下几种类型的文件： </p>
<ul>
<li>常规文件：文件中包括的内容信息是由应用程序输入，SFS 文件系统在普通文件上不强加任何内部结构，把其文件内容信息看作为字节</li>
<li>目录：包含一系列的 entry，每个 entry 包含文件名和指向与之相关联的索引节点（index node）的指针，目录是按层次结构组织的</li>
<li>链接文件：实际上一个链接文件是一个已经存在的文件的另一个可选择的文件名</li>
<li>设备文件：不包含数据，但是提供了一个映射物理设备（如串口、键盘等）到一个文件名的机制，可通过设备文件访问外围设备</li>
<li>管道：管道是进程间通讯的一个基础设施，管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能一个先进先出的方式来接受数据</li>
</ul>
<p>SFS 文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中，SFS 通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中</p>
<p><strong>函数接口与数据结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_sfs_fs</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_sfs_io</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_sfs_fs</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_sfs_io</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_rblock</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_wblock</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_rbuf</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_wbuf</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_sync_super</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_sync_freemap</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_clear_block</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_load_inode</span><span class="params">(struct sfs_fs *sfs, struct inode **node_store, <span class="keyword">uint32_t</span> ino)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_sync</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode* <span class="title">sfs_get_root</span><span class="params">(struct fs *fs)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_unmount</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sfs_cleanup</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fs_init_read</span><span class="params">(struct device *dev, <span class="keyword">uint32_t</span> blkno, <span class="keyword">void</span> *blk_buffer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fs_do_mount</span><span class="params">(struct device *dev, struct fs **fs_store)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PS：函数定义多的一批，这里就不挂了 */</span></span><br></pre></td></tr></table></figure>
<p>在 <code>SFS</code> 中涉及到了两种文件系统结构，分别是 <code>fs</code> 和 <code>sfs_fs</code> </p>
<ul>
<li><code>fs</code> 结构是我们 <strong>在上层函数调用中所直接操作</strong> 的抽象文件系统结构</li>
<li><code>sfs_fs</code> 结构则是 <strong>在下层函数中所使用的</strong></li>
</ul>
<p>在原先 <code>sfs_fs</code> 上抽象出一层 <code>fs</code> 结构有助于忽略不同文件系统的差异，其实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span> &#123;</span> <span class="comment">/* 上层函数直接操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span>                   </span><br><span class="line">    &#125; fs_info;                                     <span class="comment">// 特定于文件系统的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type;                                     <span class="comment">// 文件系统的类型</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_sync)(struct fs *fs);                 <span class="comment">// 将所有脏缓冲区刷新到磁盘</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span>   <span class="comment">// 返回文件系统的根索引节点</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_unmount)(struct fs *fs);              <span class="comment">// 尝试卸载文件系统</span></span><br><span class="line">    <span class="keyword">void</span> (*fs_cleanup)(struct fs *fs);             <span class="comment">// 清理文件系统</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span> <span class="comment">/* 对接下层函数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>                         <span class="comment">/* 磁盘上超级块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                             <span class="comment">/* 指向设备安装位置 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>                         <span class="comment">/* 正在使用的块被标记为&#x27;0&#x27; */</span></span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                               <span class="comment">/* 是否修改了super/freemap */</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                               <span class="comment">/* 用于non-block对齐的缓冲区 */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                             <span class="comment">/* fs的信号量 */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             <span class="comment">/* io的信号量 */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          <span class="comment">/* 用于链接/取消链接和重命名的信号量 */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;                        <span class="comment">/* 索引节点链表(inode链表) */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;                        <span class="comment">/* 索引节点哈希链表 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sfs_fs</code> 结构中包含了底层设备的超级块 <code>superblock</code> 、所挂载的设备 <code>dev</code> 、以及底层设备中用于表示空间分配情况的 <code>freemap</code> 等</li>
</ul>
<p><strong>文件系统布局</strong> </p>
<p>文件系统通常保存在磁盘上</p>
<p>在本实验中，第三个磁盘（即 disk0，前两个磁盘分别是 ucore.img 和 swap.img）用于存放一个SFS文件系统（Simple Filesystem），通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 block （4K，与内存 page 大小相等）为基本单位</p>
<p>SFS文件系统的布局如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------+---------+-------------------------------------+</span><br><span class="line">| superblock | root-dir | freemap | Inode / File Data / Dir Data blocks |</span><br><span class="line">+------------+----------+---------+-------------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>第0个块是超级块（superblock）<ul>
<li>它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存</li>
</ul>
</li>
<li>第1个块放了一个 root-dir 的 inode，用来记录根目录的相关信息<ul>
<li>root-dir 是 SFS 文件系统的根结点</li>
<li>通过这个 root-dir 的 inode 信息就可以定位并查找到根目录下的所有文件信息</li>
</ul>
</li>
<li>从第2个块开始，根据 SFS 中所有块的数量，用1个bit来表示一个块的占用和未被占用的情况<ul>
<li>这个区域称为 SFS 的 freemap 区域，这将占用若干个块空间（为了更好地记录和管理 freemap 区域）</li>
</ul>
</li>
<li>最后在剩余的磁盘空间中，存放了所有其他目录和文件的inode信息和内容数据信息<ul>
<li>需要注意的是：虽然 inode 的大小小于一个块的大小（4096B），但为了实现简单，每个 inode 都占用一个完整的 block</li>
</ul>
</li>
</ul>
<h2 id="文件系统-外设接口层"><a href="#文件系统-外设接口层" class="headerlink" title="文件系统-外设接口层"></a>文件系统-外设接口层</h2><p>再底层一点就是 I/O 设备的相关实现，例如结构体 <code>device</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;</span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;</span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体支持对块设备、字符设备的表示，完成对设备的基本操作</p>
<p><strong>结构体 device 只表示了一个设备所能使用的功能，我们需要一个数据结构用于将 device 和 fs 关联</strong>，同时，为了将连接的所有设备连接在一起，uCore定义了一个链表，通过该链表即可访问到所有设备，而这就是定义 <code>vfs_dev_t</code> 结构体的目的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname; <span class="comment">/* 结构体device的名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span> <span class="comment">/* 结构体device的索引节点(inode) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span> <span class="comment">/* 被关联的fs结构(上层函数直接操作的接口) */</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;</span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link; <span class="comment">/* vdev链表 */</span></span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br></pre></td></tr></table></figure>
<h2 id="文件系统挂载流程"><a href="#文件系统挂载流程" class="headerlink" title="文件系统挂载流程"></a>文件系统挂载流程</h2><p>一个文件系统在使用前，需要将其挂载至内核中（使一个存储设备上的计算机文件和目录，可供用户通过计算机的文件系统访问的一个过程），在 uCore 里，硬盘 <code>disk0</code> 的挂载流程如下：</p>
<p>程序会先执行 fs_init 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">fs_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    vfs_init(); <span class="comment">/* 初始化vfs虚拟文件系统 */</span></span><br><span class="line">    dev_init(); <span class="comment">/* 初始化dev外设接口层 */</span></span><br><span class="line">    sfs_init(); <span class="comment">/* 初始化sfs文件系统 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>vfs_init：初始化 vfs 虚拟文件系统 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> bootfs_sem; <span class="comment">/* fs文件系统的信号量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> vdev_list_sem; <span class="comment">/* vdev链表的信号量 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> vdev_list; <span class="comment">/* vdev链表头 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    sem_init(&amp;bootfs_sem, <span class="number">1</span>); <span class="comment">/* 初始化fs信号量 */</span></span><br><span class="line">    vfs_devlist_init(); <span class="comment">/* 初始化vdev结构体 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_devlist_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    list_init(&amp;vdev_list); <span class="comment">/* 初始化vdev链表 */</span></span><br><span class="line">    sem_init(&amp;vdev_list_sem, <span class="number">1</span>); <span class="comment">/* 初始化vdev链表信号量 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sem_init</span><span class="params">(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    sem-&gt;value = value; <span class="comment">/* 初始化value(信号量关键整数) */</span></span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue)); <span class="comment">/* 初始化信号量等待队列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dev_init：初始化 dev 外设接口层</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">dev_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    init_device(<span class="built_in">stdin</span>);</span><br><span class="line">    init_device(<span class="built_in">stdout</span>);</span><br><span class="line">    init_device(disk0); <span class="comment">/* 我们只关注这一个 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_device(x)                                  \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        extern void dev_init_##x(void);                 \</span></span><br><span class="line"><span class="meta">        dev_init_##x();                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0) <span class="comment">/* 这个循环八成是为了效率 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">dev_init_disk0</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">/* 初始化disk0(超级块) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = dev_create_inode()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 为dev创建inode */</span></span><br><span class="line">        panic(<span class="string">&quot;disk0: dev_create_node.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    disk0_device_init(vop_info(node, device)); <span class="comment">/* 根据inode初始化dev */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_add_dev(<span class="string">&quot;disk0&quot;</span>, node, <span class="number">1</span>)) != <span class="number">0</span>) &#123; <span class="comment">/* 把该dev添加到vdev链表 */</span></span><br><span class="line">        panic(<span class="string">&quot;disk0: vfs_add_dev: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sfs_init：初始化 sfs 文件系统</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_mount(<span class="string">&quot;disk0&quot;</span>)) != <span class="number">0</span>) &#123; <span class="comment">/* 挂载sfs文件系统 */</span></span><br><span class="line">        panic(<span class="string">&quot;failed: sfs: sfs_mount: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vfs_mount(devname, sfs_do_mount); <span class="comment">/* 挂载vfs虚拟文件系统 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">int</span> (*mountfunc)(struct device *dev, struct fs **fs_store))</span> </span>&#123; <span class="comment">/* 执行完毕后,文件系统就成功挂载了 */</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    lock_vdev_list();</span><br><span class="line">    <span class="keyword">vfs_dev_t</span> *vdev;</span><br><span class="line">    <span class="keyword">if</span> ((ret = find_mount(devname, &amp;vdev)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vdev-&gt;fs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -E_BUSY;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(vdev-&gt;devname != <span class="literal">NULL</span> &amp;&amp; vdev-&gt;mountable);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> vop_info(vdev-&gt;devnode, device);</span><br><span class="line">    <span class="keyword">if</span> ((ret = mountfunc(dev, &amp;(vdev-&gt;fs))) == <span class="number">0</span>) &#123; <span class="comment">/* 执行sfs_do_mount(挂载函数) */</span></span><br><span class="line">        assert(vdev-&gt;fs != <span class="literal">NULL</span>);</span><br><span class="line">        cprintf(<span class="string">&quot;vfs: mount %s.\n&quot;</span>, vdev-&gt;devname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    unlock_vdev_list();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用流程为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfs_init -&gt; sfs_mount -&gt; vfs_mount -&gt; sfs_do_mount</span><br></pre></td></tr></table></figure>
<p>sfs_do_mount 挂载函数会执行以下几个操作：</p>
<ul>
<li>从待挂载设备中读取超级块，并验证超级块中，魔数与总块数是否存在错误</li>
<li>初始化哈希链表</li>
<li>从待挂载设备中读入 <code>freemap</code> 并测试其正确性</li>
<li>设置 <code>fs</code> 结构的相关信息，并在函数最后将该信息设置为传入的 <code>device</code> 结构体中的 <code>fs</code> 成员变量</li>
</ul>
<h2 id="文件打开流程"><a href="#文件打开流程" class="headerlink" title="文件打开流程"></a>文件打开流程</h2><p>用户进程调用 open 函数时，调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -&gt; sysfile_open -&gt; file_open(包含vfs_open)</span><br></pre></td></tr></table></figure>
<p>file_open 的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">file_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> readable = <span class="number">0</span>, writable = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY: readable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY: writable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        readable = writable = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = fd_array_alloc(NO_FD, &amp;file)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 在当前进程的文件管理结构filesp中,获取一个空闲的file对象 */</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_open(path, open_flags, &amp;node)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 调用vfs_open函数,并存储该函数返回的inode结构 */</span></span><br><span class="line">        fd_array_free(file);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file-&gt;pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_APPEND) &#123;</span><br><span class="line">        <span class="comment">/* 如果打开方式是append,则还会设置file的pos成员为当前文件的大小 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> __<span class="title">stat</span>, *<span class="title">stat</span> =</span> &amp;__stat;</span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_fstat(node, stat)) != <span class="number">0</span>) &#123;</span><br><span class="line">            vfs_close(node);</span><br><span class="line">            fd_array_free(file);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        file-&gt;pos = stat-&gt;st_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 根据上一步返回的inode,设置file对象的属性 */</span></span><br><span class="line">    file-&gt;node = node;</span><br><span class="line">    file-&gt;readable = readable;</span><br><span class="line">    file-&gt;writable = writable;</span><br><span class="line">    fd_array_open(file);</span><br><span class="line">    <span class="keyword">return</span> file-&gt;fd; <span class="comment">/* 返回file-&gt;fd */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vfs_open 的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vfs_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags, struct inode **node_store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> can_write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        can_write = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!can_write) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> excl = (open_flags &amp; O_EXCL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> create = (open_flags &amp; O_CREAT) != <span class="number">0</span>;</span><br><span class="line">    ret = vfs_lookup(path, &amp;node); <span class="comment">/* 调用vfs_lookup搜索给出的路径,判断是否存在该文件,如果存在,则vfs_lookup函数(sfs_lookup)返回该文件所对应的inode节点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 如果给出的路径不存在,即文件不存在,则根据传入的flag,选择调用vop_create创建新文件或直接返回错误信息 */</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-16</span> &amp;&amp; (create)) &#123;</span><br><span class="line">            <span class="keyword">char</span> *name;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = vfs_lookup_parent(path, &amp;dir, &amp;name)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = vop_create(dir, name, excl, &amp;node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (excl &amp;&amp; create) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(node != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = vop_open(node, open_flags)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 调用vop_open函数(sfs_openfile)尝试打开文件(打开文件的主体) */</span></span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vop_open_inc(node);</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC || create) &#123;</span><br><span class="line">        <span class="comment">/* 如果文件打开正常,则根据当前函数传入的open_flags参数来判断是否需要将当前文件截断至&#x27;0&#x27;(即清空) */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_truncate(node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 如果需要截断,则执行vop_truncate函数(sfs_truncfile) */</span></span><br><span class="line">            vop_open_dec(node);</span><br><span class="line">            vop_ref_dec(node);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件读取流程"><a href="#文件读取流程" class="headerlink" title="文件读取流程"></a>文件读取流程</h2><p>用户进程调用 read 函数时，调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -&gt; sysfile_read -&gt; file_read -&gt; sfs_read -&gt; sfs_io -&gt; sfs_io_nolock</span><br></pre></td></tr></table></figure>
<p>file_read 的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">file_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    *copied_store = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ret = fd2file(fd, &amp;file)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!file-&gt;readable) &#123; <span class="comment">/* 测试当前待读取的文件是否存在读权限 */</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_array_acquire(file);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> __<span class="title">iob</span>, *<span class="title">iob</span> =</span> iobuf_init(&amp;__iob, base, len, file-&gt;pos); <span class="comment">/* 在内核中创建一块缓冲区 */</span></span><br><span class="line">    ret = vop_read(file-&gt;node, iob); <span class="comment">/* 实际上执行sfs_read,将数据读取至缓冲区iob */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> copied = iobuf_used(iob);</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;status == FD_OPENED) &#123;</span><br><span class="line">        file-&gt;pos += copied;</span><br><span class="line">    &#125;</span><br><span class="line">    *copied_store = copied;</span><br><span class="line">    fd_array_release(file);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>file_read 中涉及到 IO 缓冲区，在 ucore 中，IO 缓冲区由如下结构体进行管理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *io_base;     <span class="comment">// IO缓冲区的内存地址</span></span><br><span class="line">    <span class="keyword">off_t</span> io_offset;   <span class="comment">// 当前读取/写入的地址</span></span><br><span class="line">    <span class="keyword">size_t</span> io_len;     <span class="comment">// 缓冲区的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> io_resid;   <span class="comment">// 剩余尚未读取/写入的内存空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>file_read 会进一步调用 vop_read，将数据读取至缓冲区 iob，最终调用 sfs_io_nolock：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_read</span><span class="params">(struct inode *node, struct iobuf *iob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sfs_io(node, iob, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_io</span><span class="params">(struct inode *node, struct iobuf *iob, <span class="keyword">bool</span> write)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(vop_fs(node), sfs);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> =</span> vop_info(node, sfs_inode);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    lock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> alen = iob-&gt;io_resid;</span><br><span class="line">        ret = sfs_io_nolock(sfs, <span class="built_in">sin</span>, iob-&gt;io_base, iob-&gt;io_offset, &amp;alen, write);</span><br><span class="line">        <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 果当前缓冲区中存在尚未读取/写入的数据,则跳过该部分数据 */</span></span><br><span class="line">            iobuf_skip(iob, alen); <span class="comment">/* 写入/读取至该块数据的下一个地址处 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sfs_io_nolock 函数将在练习1中详细讲解</li>
</ul>
<h2 id="练习0-把-lab7-的内容复制粘贴到-lab8"><a href="#练习0-把-lab7-的内容复制粘贴到-lab8" class="headerlink" title="练习0-把 lab7 的内容复制粘贴到 lab8"></a>练习0-把 lab7 的内容复制粘贴到 lab8</h2><h2 id="练习1-完成读文件操作的实现"><a href="#练习1-完成读文件操作的实现" class="headerlink" title="练习1-完成读文件操作的实现"></a>练习1-完成读文件操作的实现</h2><p>用户进程调用 read 函数时，调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -&gt; sysfile_read -&gt; file_read -&gt; sfs_read -&gt; sfs_io -&gt; sfs_io_nolock</span><br></pre></td></tr></table></figure>
<p>前面几个函数都可以跳过了，我们的任务就是补全最后一个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_io_nolock</span><span class="params">(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line">    <span class="comment">/* 计算缓冲区读取/写入的终止位置 */</span></span><br><span class="line">    <span class="keyword">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset == endpos) &#123;</span><br><span class="line">        <span class="comment">/* 如果偏移与终止位置相同,及欲读取/写入0字节的数据 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!write) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;size) &#123;</span><br><span class="line">            <span class="comment">/* 如果是读取数据,并冲区中剩余的数据超出一个硬盘节点的数据大小 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;size) &#123;</span><br><span class="line">            endpos = din-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 根据不同的执行函数,设置对应的函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset);</span><br><span class="line">    <span class="keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="comment">/* Rd/Wr起始块的编号 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="comment">/* Rd/Wr块的大小 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- start ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- end ----&gt; */</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sfs_io_nolock</span><span class="params">(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line">    <span class="comment">/* 计算缓冲区读取/写入的终止位置 */</span></span><br><span class="line">    <span class="keyword">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset == endpos) &#123;</span><br><span class="line">        <span class="comment">/* 如果偏移与终止位置相同,及欲读取/写入0字节的数据 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!write) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;size) &#123;</span><br><span class="line">            <span class="comment">/* 如果是读取数据,并冲区中剩余的数据超出一个硬盘节点的数据大小 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;size) &#123;</span><br><span class="line">            endpos = din-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 根据不同的执行函数,设置对应的函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset);</span><br><span class="line">    <span class="keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="comment">/* Rd/Wr起始块的编号 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="comment">/* Rd/Wr块的大小 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- start ----&gt; */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 对齐偏移,如果偏移没有对齐第一个基础块,则多读取/写入第一个基础块的末尾数据 */</span></span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 获取第一个基础块所对应的block的编号ino */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 通过上一步取出的ino,读取/写入一部分第一个基础块的末尾数据 */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>) &#123; <span class="comment">/* 循环读取/写入对齐好的数据 */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">/* 获取inode对应的基础块编号 */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 单次读取/写入一基础块的数据 */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size, buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 如果末尾位置没有与最后一个基础块对齐,则多读取/写入一点末尾基础块的数据 */</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- end ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习2-完成基于文件系统的执行程序机制的实现"><a href="#练习2-完成基于文件系统的执行程序机制的实现" class="headerlink" title="练习2-完成基于文件系统的执行程序机制的实现"></a>练习2-完成基于文件系统的执行程序机制的实现</h2><p>基于文件系统的执行程序机制，有几部分地方需要添加代码，分别是 <code>alloc_proc</code> 、 <code>do_fork</code> 、 <code>load_icode</code> 三个函数</p>
<ul>
<li>alloc_proc：分配一个 proc_struct，用于描述进程的信息（在之前实验已经实现过了）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *</span></span><br><span class="line"><span class="function"><span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;rq = <span class="literal">NULL</span>;</span><br><span class="line">        list_init(&amp;(proc-&gt;run_link));</span><br><span class="line">        proc-&gt;time_slice = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = proc-&gt;lab6_run_pool.parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;lab6_stride = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_priority = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;filesp = <span class="literal">NULL</span>; <span class="comment">/* lab8新添:proc-&gt;filesp,用于描述进程的文件相关信息 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增的条目为 <code>files_struct</code> 结构体：（用于在进程中管理多个 <code>file</code> 结构体）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// 当前工作目录的inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// 打开的文件数组(存放file结构体)</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// 打开的文件数</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// 对应的信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>do_fork：创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同，在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态（在之前实验已经实现过了）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 分配一个物理页,作为proc_struct */</span></span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proc-&gt;parent = current; <span class="comment">/* 设置父进程为当前进程 */</span></span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>); <span class="comment">/* lab5新增:断言进程为等待态 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123; <span class="comment">/* 分配内核栈 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_fs(clone_flags, proc) != <span class="number">0</span>) &#123; <span class="comment">/* lab8新添:将当前进程的fs复制到,fork出的进程中 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123; <span class="comment">/* 将所有虚拟页数据复制过去 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf); <span class="comment">/* 复制线程的状态,包括寄存器上下文等等 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag); <span class="comment">/* 阻塞中断 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid(); <span class="comment">/* 为进程分配唯一的PID */</span></span><br><span class="line">        hash_proc(proc); <span class="comment">/* 将proc添加到进程哈希链表中 */</span></span><br><span class="line">        set_links(proc); <span class="comment">/* lab5改动:取消list_add,采用set_links */</span></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag); <span class="comment">/* 解除中断的阻塞 */</span></span><br><span class="line">    wakeup_proc(proc); <span class="comment">/* 设置新的子进程可执行(唤醒该进程) */</span></span><br><span class="line">    ret = proc-&gt;pid; <span class="comment">/* 设置返回值为pid */</span></span><br><span class="line">    </span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_fs: <span class="comment">/* lab8新添:goto标志位 */</span></span><br><span class="line">    put_fs(proc);</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>load_icode：加载并解析一个处于内存中的ELF执行文件格式的应用程序（函数改动较大）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">load_icode</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> argc, <span class="keyword">char</span> **kargv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fd:对应的文件描述符</span></span><br><span class="line">    <span class="comment">// argc:传入load_icode函数的参数个数</span></span><br><span class="line">    <span class="comment">// kargv:传入的各个参数</span></span><br><span class="line">    assert(argc &gt;= <span class="number">0</span> &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123; <span class="comment">/* 检查当前进程是否为NULL */</span></span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">/* mm_struct结构体:用于描述虚拟内存区域(vma)的各种信息 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123; <span class="comment">/* 创建一片虚拟内存 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_mm; <span class="comment">/* 创建失败,直接返回 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123; <span class="comment">/* 新建一个页目录表,每个进程都需要一个页目录表 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm; <span class="comment">/* 创建失败,执行mm_destroy */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> __<span class="title">elf</span>, *<span class="title">elf</span> =</span> &amp;__elf; <span class="comment">/* lab8改动:获取的二进制文件的基础信息 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="keyword">sizeof</span>(struct elfhdr), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 获取的二进制文件的文件头 */</span></span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123; <span class="comment">/* 检查该程序的魔数是否正确 */</span></span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 遍历程序头表,并构建vma ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> __<span class="title">ph</span>, *<span class="title">ph</span> =</span> &amp;__ph;</span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm, phnum;</span><br><span class="line">    <span class="keyword">for</span> (phnum = <span class="number">0</span>; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123; <span class="comment">/* 遍历整个程序头表(ph就是各个段头表) */</span></span><br><span class="line">        <span class="keyword">off_t</span> phoff = elf-&gt;e_phoff + <span class="keyword">sizeof</span>(struct proghdr) * phnum;</span><br><span class="line">        <span class="keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="keyword">sizeof</span>(struct proghdr), phoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="comment">/* 遍历寻找到ELF_PT_LOAD为止,在ucore中,该段是TEXT/DATA */</span></span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            <span class="comment">/* 文件中段的大小 &gt; 内存中段的大小 */</span></span><br><span class="line">            <span class="comment">/* 内存中p_memsz大于p_filesz的原因是,可加载段可能包含一个.bss部分,没有此部分则是等于状态,绝对不可能是小于状态 */</span></span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;---- 根据标志位进行初始化,准备构建vma ----&gt; */</span></span><br><span class="line">        </span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* 调用mm_map,为目标段构建新的vma */</span></span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;---- 建立并分配页目录表,复制TEXT/DATA段到进程的内存(建立映射) ----&gt; */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">off_t</span> offset = ph-&gt;p_offset; <span class="comment">/* 获取TEXT/DATA的段地址 */</span></span><br><span class="line">        <span class="keyword">size_t</span> off, size;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line">        <span class="comment">/* start:初始化为段起始地址(映射段的虚拟地址) */</span></span><br><span class="line">        <span class="comment">/* la(可变参数):start进行内存页对齐后(只舍不进)的地址 */</span></span><br><span class="line">        </span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        <span class="comment">/* end:初始化为段结束地址(映射段的虚拟地址+文件中段的大小) */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123; <span class="comment">/* 持续为pgdir分配页表,直到整个段都完成映射 */</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* 分配一块物理页(作为页表),设置页表项(对应la),插入页表目录(pgdir) */</span></span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la; <span class="comment">/* 更新偏移 */</span></span><br><span class="line">            <span class="comment">/* 第一次: off=&#x27;start为了页对齐而舍弃的数值&#x27;(正) */</span></span><br><span class="line">            <span class="comment">/* 后续: off=&#x27;0&#x27; */</span></span><br><span class="line">            size = PGSIZE - off; <span class="comment">/* 更新已分配的段大小(每次增加PGSIZE) */</span></span><br><span class="line">            la += PGSIZE; <span class="comment">/* 更新当前的物理地址(每次增加PGSIZE) */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end; <span class="comment">/* 获取准确的段大小 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="comment">/* 获取页目录表的虚拟地址,通过off计算出对应页目录表项,用memcpy在其中填入from(TEXT/DATA段的起始地址) */</span> </span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">            <span class="comment">/* 第一次: start增加的值比la小一些 */</span></span><br><span class="line">            <span class="comment">/* 后续: start和la都增加相同的值(PGSIZE),并且地址也相同 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* &lt;---- 分配内存,建立并分配页目录表,建立BSS段(建立映射) ----&gt; */</span></span><br><span class="line">        </span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz; <span class="comment">/* end:初始化为段结束地址(映射段的虚拟地址+内存中段的大小) */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123; <span class="comment">/* start最后会小于等于la,以下代码就是为了当&quot;start&lt;la&quot;时,实现&quot;start=la&quot;,并且置空原start距新start多出的部分 */</span></span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            <span class="comment">/* 获取页目录表的虚拟地址,通过off计算出对应页目录表项,并使用memset置空 */</span></span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123; <span class="comment">/* 持续为pgdir分配页表,直到整个段都完成映射 */</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            <span class="comment">/* 获取页目录表的虚拟地址,通过off计算出对应页目录表项,并使用memset置空 */</span></span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 构建用户堆栈内存 ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    sysfile_close(fd);</span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap; <span class="comment">/* 调用exit_mmap */</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 设置当前进程的mm,sr3,设置CR3寄存器 ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    mm_count_inc(mm); <span class="comment">/* 设置并返回&quot;共享该虚拟内存空间mva的进程数&quot; */</span></span><br><span class="line">    current-&gt;mm = mm; <span class="comment">/* 设置当前进程的&quot;proc_struct-&gt;mm&quot;为该虚拟内存空间mva */</span></span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir); <span class="comment">/* 设置当前进程的&quot;proc_struct-&gt;cr3&quot;为该页目录表的地址 */</span></span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir)); <span class="comment">/* 设置CR3寄存器为当前页目录表的物理地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &lt;---- lab8新增:设置execve所启动的程序参数 ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> argv_size=<span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> stacktop = USTACKTOP - (argv_size/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">char</span>** uargv=(<span class="keyword">char</span> **)(stacktop  - argc * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    </span><br><span class="line">    argv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++) &#123; <span class="comment">/* 直接将传入的参数压入至新栈的底部 */</span></span><br><span class="line">        uargv[i] = <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">        argv_size +=  strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stacktop = (<span class="keyword">uintptr_t</span>)uargv - <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    *(<span class="keyword">int</span> *)stacktop = argc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* &lt;---- 为用户环境设置trapframe ----&gt; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf; <span class="comment">/* 构建中断帧 */</span></span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe)); <span class="comment">/* 把trapframe清零 */</span></span><br><span class="line">    tf-&gt;tf_cs = USER_CS; <span class="comment">/* 初始化中断帧的各个条目 */</span></span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/miscellaneous/" rel="tag"><i class="fa fa-tag"></i> miscellaneous</a>
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/Kernel/" rel="tag"><i class="fa fa-tag"></i> Kernel</a>
              <a href="/tags/Ucore/" rel="tag"><i class="fa fa-tag"></i> Ucore</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/01/Ucore-Lab7/" rel="prev" title="Ucore-Lab7">
      <i class="fa fa-chevron-left"></i> Ucore-Lab7
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/05/Machine-Learning-Lab1/" rel="next" title="Machine-Learning-Lab1">
      Machine-Learning-Lab1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%96%87%E4%BB%B6"><span class="nav-number">1.</span> <span class="nav-text">文件系统和文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">文件系统-访问接口层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%8A%BD%E8%B1%A1%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">文件系统-抽象层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="nav-number">4.</span> <span class="nav-text">文件系统-文件系统层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E5%A4%96%E8%AE%BE%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="nav-number">5.</span> <span class="nav-text">文件系统-外设接口层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">文件系统挂载流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%B5%81%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">文件打开流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">文件读取流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A00-%E6%8A%8A-lab7-%E7%9A%84%E5%86%85%E5%AE%B9%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E5%88%B0-lab8"><span class="nav-number">9.</span> <span class="nav-text">练习0-把 lab7 的内容复制粘贴到 lab8</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01-%E5%AE%8C%E6%88%90%E8%AF%BB%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.</span> <span class="nav-text">练习1-完成读文件操作的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02-%E5%AE%8C%E6%88%90%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.</span> <span class="nav-text">练习2-完成基于文件系统的执行程序机制的实现</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:38</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
