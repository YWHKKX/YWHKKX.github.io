<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="伙伴系统伙伴关系 伙伴关系的定义为：由一个母实体分成的两个各方面属性一致的两个子实体，这两个子实体就处于伙伴关系  在操作系统分配内存的过程中，一个内存块经常被分成两个大小相等的内存块，这两个大小相等的内存块就处于伙伴关系 它满足3个条件： 两个块具有相同大小 物理地址是连续的 从同一个大块中拆分出来    伙伴系统 伙伴系统（buddy system）是内核中用来管理物理内存的一种算法，Linu">
<meta property="og:type" content="article">
<meta property="og:title" content="BuddySystem&amp;Slub">
<meta property="og:url" content="http://example.com/2022/05/23/BuddySystem&Slab/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="伙伴系统伙伴关系 伙伴关系的定义为：由一个母实体分成的两个各方面属性一致的两个子实体，这两个子实体就处于伙伴关系  在操作系统分配内存的过程中，一个内存块经常被分成两个大小相等的内存块，这两个大小相等的内存块就处于伙伴关系 它满足3个条件： 两个块具有相同大小 物理地址是连续的 从同一个大块中拆分出来    伙伴系统 伙伴系统（buddy system）是内核中用来管理物理内存的一种算法，Linu">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/05/23/BuddySystem&Slab/1653288150250-1653726952169-1655875583491.png">
<meta property="og:image" content="http://example.com/2022/05/23/BuddySystem&Slab/1653445033299-1655875583491.png">
<meta property="og:image" content="http://example.com/2022/05/23/BuddySystem&Slab/1653288462902-1653726952170-1655875583491.png">
<meta property="og:image" content="http://example.com/2022/05/23/BuddySystem&Slab/1653447102092-1655875583491.png">
<meta property="og:image" content="http://example.com/2022/05/23/BuddySystem&Slab/1653288764042-1653726952170-1655875583491.png">
<meta property="og:image" content="http://example.com/2022/05/23/BuddySystem&Slab/1653447624502-1655875583492.png">
<meta property="og:image" content="http://example.com/2022/05/23/BuddySystem&Slab/1653305919635-1653726952170-1655875583492.png">
<meta property="og:image" content="http://example.com/2022/05/23/BuddySystem&Slab/1653316705399-1653726952170-1655875583492.png">
<meta property="og:image" content="http://example.com/2022/05/23/BuddySystem&Slab/1653927280497-1655875583493.png">
<meta property="article:published_time" content="2022-05-23T15:39:41.000Z">
<meta property="article:modified_time" content="2022-06-22T05:26:30.000Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="buddy system">
<meta property="article:tag" content="slub">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/05/23/BuddySystem&Slab/1653288150250-1653726952169-1655875583491.png">

<link rel="canonical" href="http://example.com/2022/05/23/BuddySystem&Slab/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>BuddySystem&Slub | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/23/BuddySystem&Slab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          BuddySystem&Slub
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-23 23:39:41" itemprop="dateCreated datePublished" datetime="2022-05-23T23:39:41+08:00">2022-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-22 13:26:30" itemprop="dateModified" datetime="2022-06-22T13:26:30+08:00">2022-06-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><p><strong>伙伴关系</strong></p>
<p>伙伴关系的定义为：由一个母实体分成的两个各方面属性一致的两个子实体，这两个子实体就处于伙伴关系</p>
<ul>
<li>在操作系统分配内存的过程中，一个内存块经常被分成两个大小相等的内存块，这两个大小相等的内存块就处于伙伴关系</li>
<li>它满足3个条件：<ul>
<li>两个块具有相同大小</li>
<li>物理地址是连续的</li>
<li>从同一个大块中拆分出来</li>
</ul>
</li>
</ul>
<p><strong>伙伴系统</strong></p>
<p>伙伴系统（buddy system）是内核中用来管理物理内存的一种算法，Linux2.6 为每个管理区使用不同的伙伴系统，内核空间分为三种区，DMA，NORMAL，HIGHMEM，对于每一种区，都有对应的伙伴算法</p>
<ul>
<li>我们知道内存中有一些是被内核代码占用，还有一些是被特殊用途所保留，那么剩余的空闲内存都会交给内核内存管理系统来进行统一管理和分配</li>
<li>内核中会把内存按照页来组织分配，随着进程的对内存的申请和释放，系统的内存会不断的区域碎片化</li>
<li>到最后会发现，明明系统还有很多空闲内存，却无法分配出一块连续的内存，这对于系统来说并不是好事</li>
</ul>
<p>伙伴系统（buddy system）把系统中要管理的物理内存按照页面个数分为了 11 个组，分别对应11种大小不同的连续内存块，每组中的内存块大小都相等，且必须是 2 的 n 次幂 (Pow(2, n))，即 1, 2, 4, 8, 16, 32, 64, 128 … 1024 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include\linux\mmzone.h */</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ORDER 11</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span> <span class="comment">/* 不同大小的空闲区域 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span> <span class="comment">/* 内存块链表连接时只需把内存块的第一个页关联即可(都是连续的) */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_free; <span class="comment">/* 表示这种内存块(包括所有迁移类型)的数量 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>那么系统中就存在 2^0~2^10 这么11种大小不同的内存块，对应内存块大小为 4KB ~ 4M 内核用 11 个链表来管理 11 种大小不同的内存块</li>
</ul>
<p>伙伴分配器的数据结构在逻辑上的表示就像是一个完全二叉树，大概像这样： </p>
<img src="/2022/05/23/BuddySystem&Slab/1653288150250-1653726952169-1655875583491.png" class width="1653288150250">  
<ul>
<li>当然实际编码过程中并不会使用一个 struct TreeNode 的形式去把二叉树的各个节点用指针连起来，因为是这个树一定是完全二叉树，所以可以使用一个数组来表示树的结构</li>
<li>用这一个数组，就可以表示所有节点的位置信息</li>
</ul>
<p>当一个页面被等分时，它自己也就不存在了：</p>
<img src="/2022/05/23/BuddySystem&Slab/1653445033299-1655875583491.png" class width="1653445033299"> 
<p><strong>位图管理</strong></p>
<p>为了便于页面的维护，将多个页面组成内存块，每个内存块都有 “2的方幂” 个页，方幂的指数被称为阶</p>
<p>在操作内存时，经常将这些内存块分成大小相等的两个块，分成的两个内存块被称为伙伴块，采用 “一位二进制数” 来表示它们的伙伴关系</p>
<p>系统根据该位为 “0” 或位为 “1” 来决定是否使用或者分配该页面块，系统每次分配和回收伙伴块时都要对它们的伙伴位跟 “1” 进行异或运算</p>
<ul>
<li>刚开始时，父块还没有等分，所以伙伴块不存在（也可以认为是：两个伙伴块都空闲），它们的伙伴位为 “0”</li>
<li>如果需要等分，则把第一块插入下一级，第二块分配出去，异或后得 “1”（只使用了一个块）</li>
<li>如果另一块也被使用，异或后得 “0”（两个块都使用了）</li>
<li>如果前面一块回收了异或后得 “1”</li>
<li>如果另一块也回收了异或后得 “0”</li>
</ul>
<p>整理一下便是：</p>
<ul>
<li>当这个位为 “1”，表示其中一块在使用</li>
<li>当这个位为 “0”，表示两个页面块都在使用（一个完整的块不会分为两个空块）</li>
</ul>
<p>注意：这个 “一位二进制数” 存储在 “位图 map” 中</p>
<p><strong>空闲内存块管理</strong></p>
<p>下图可以展示 free_area 的整体结构：</p>
<img src="/2022/05/23/BuddySystem&Slab/1653288462902-1653726952170-1655875583491.png" class width="1653288462902">  
<img src="/2022/05/23/BuddySystem&Slab/1653447102092-1655875583491.png" class width="1653447102092"> 
<ul>
<li>free_area 就是一个数组，存放有许多 free_list</li>
<li>每个 free_list（free_area[x]）都有一个 map 位图（用于表示各个伙伴块的关系）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下图就是一个 free_list（free_area[x]）的结构：</p>
<img src="/2022/05/23/BuddySystem&Slab/1653288764042-1653726952170-1655875583491.png" class width="1653288764042"> 
<img src="/2022/05/23/BuddySystem&Slab/1653447624502-1655875583492.png" class width="1653447624502"> 
<ul>
<li>free_list（free_area[x]）用于链接 “2的n次方” 组成的内存块</li>
<li>map 中的一个“二进制位”表示两个伙伴块的关系</li>
</ul>
<p><strong>重要结构体</strong></p>
<ul>
<li>页（page）：一个 page 结构表示一个物理内存页面</li>
<li>区（zone）：因为硬件限制，Linux 内核不能把所有的物理内存页统一对待，把属性相同的物理内存页面归结到了一个区中</li>
<li>节点（pglist_data）：pglist_data 结构中包含了 zonelist 数组，第一个 zonelist 类型的元素指向本节点内的 zone 数组，第二个 zonelist 类型的元素指向其它节点的 zone 数组，而一个 zone 结构中的 free_area 数组中又挂载着 page 结构</li>
</ul>
<img src="/2022/05/23/BuddySystem&Slab/1653305919635-1653726952170-1655875583492.png" class width="1653305919635"> 
<p><strong>伙伴算法-分配流程</strong></p>
<p>我先从 free_area 的角度继续分析，假如系统需要 4(2x2) 个页面大小的内存块：</p>
<ul>
<li>该算法首先到 free_area[2] 中查找：<ul>
<li>如果链表中有空闲块：就直接从中摘下并分配出去</li>
<li>如果没有：算法将顺着数组向上查找 free_area[3]<ul>
<li>如果 free_area[3] 中有空闲块：则将其从链表中摘下，分成等大小的两部分，前 4 个页面作为一个块插入 free_area[2] 的链表头部，后 4 个页面分配出去</li>
<li>如果 free_area[3] 中也没有：就再向上查找 free_area[4]<ul>
<li>如果 free_area[4] 中有：就将这 16(2x2x2x2) 个页面等分成两份，前一半的 8 个页挂 free_area[3] 的链表头部，后一半的 8 个页再次等分为 2 个 4 页，前一半挂 free_area[2] 的链表中，后一半分配出去</li>
<li>假如 free_area[4] 也没有：则重复上面的过程，知道到达 free_area 数组的最后，如果还没有则放弃分配</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>free_area 中只存放空闲块，从空闲块的视角来看的话：<ul>
<li>从小到大进行查找，优先分配小块</li>
<li>如果没有小块，就等分大块，前半部分插入下一级链表头部，后半部分进行分配</li>
<li>如果后半部分仍然可以等分，就重复进行“等分插链”的操作</li>
</ul>
</li>
</ul>
<p><strong>伙伴算法-释放流程</strong></p>
<p>内存的释放是分配的逆过程，也可以看作是伙伴的合并过程</p>
<ul>
<li>当释放一个块时，先在其对应的链表中考查是否有伙伴存在<ul>
<li>如果没有伙伴块：就直接把要释放的块挂入链表头</li>
<li>如果有：则从链表中摘下伙伴，合并成一个大块，然后继续考察合并后的块在更大一级链表中是否有伙伴存在，直到不能合并或者已经合并到了最大的块</li>
</ul>
</li>
</ul>
<p>PS：整个过程中，位图扮演了重要的角色，位图的某一位对应两个互为伙伴的块</p>
<ul>
<li>为“1”表示其中一块已经分配出去了，为“0”表示两块都都分配出去了</li>
<li>伙伴中无论是分配还是释放都只是相对的位图进行异或操作，释放过程根据位图判断伙伴是否存在<ul>
<li>如果对相应位的异或操作得“1”（原本是“0”），代表没有伙伴可以合并</li>
<li>如果异或操作得“0”（原本是“1”），代表伙伴块中的另一个已经空闲，可以进行合并</li>
<li>并且继续按这种方式合并伙伴，直到不能合并为止</li>
</ul>
</li>
</ul>
<h2 id="Slab分配器"><a href="#Slab分配器" class="headerlink" title="Slab分配器"></a>Slab分配器</h2><p><strong>slab的出现</strong></p>
<p>我们知道内核中的物理内存由伙伴系统（buddy system）进行管理，它的分配粒度是以物理页帧（page）为单位的，但内核中有大量的数据结构只需要若干 bytes 的空间，倘若仍按页来分配，势必会造成大量的内存被浪费掉</p>
<p>slab 分配器的出现（而 slub 是 slab 的衍生产物），就是为了解决内核中这些小块内存分配与管理的难题</p>
<p>slab 分配器，把常用的数据结构都看成一个个对象</p>
<ul>
<li>我们知道 buddy 分配器的分配单元是以页为单位的，然后将不同 order 的空闲物理页帧串成若干链表，分配时从对应链表里取出</li>
<li>而 slab 分配器则是以目标数据结构为单分配单元，且会将目标数据结构提前分配并串成链表，分配时从中取用</li>
</ul>
<p>从 2.6 内核开始对 slab 分配器的实现添加了两个备选方案 slub 和 slob（用 slub 比较多）</p>
<ul>
<li>slub 就是在之前 slab 上优化后的一个产物，去除了许多臃肿的实现，逐渐会完全替代老的 slab</li>
<li>而 slob 则是一个很轻量级的 slab 实现，代码量不大，官方说适合一些嵌入式设备</li>
</ul>
<img src="/2022/05/23/BuddySystem&Slab/1653316705399-1653726952170-1655875583492.png" class width="1653316705399">  
<p><strong>重要结构体</strong></p>
<p>这里有个复杂且重要的结构体：struct kmem_cache，即 <strong>缓存描述符</strong>（缓存器），准确的来说它并不包含实际的缓存空间，而是包含了一些缓存的管理数据，和指向实际缓存空间的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* \linux-4.19.26\include\linux\slab_def.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> __<span class="title">percpu</span> *<span class="title">cpu_cache</span>;</span> <span class="comment">/* 本地高速缓存,每CPU结构对象释放时,优先放入这个本地CPU高速缓存中 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1) Cache tunables. Protected by slab_mutex */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> batchcount; </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> limit; <span class="comment">/* 本地高速缓存中entry数组中空闲obj的最大数目 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> shared; <span class="comment">/* CPU共享高速缓存标志,实际地址保存在kmem_cache_node结构中 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">/* 对象长度+填充字节 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_buffer_size</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 2) touched by every alloc &amp; free from the backend */</span></span><br><span class="line">	<span class="keyword">slab_flags_t</span> flags; <span class="comment">/* 属性的flag标志,如果SLAB管理结构放在外部,则CFLAGS_OFF_SLAB置&#x27;1&#x27; */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num; <span class="comment">/* 每个slab中obj数量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3) cache_grow/shrink */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> gfporder; <span class="comment">/* 每个slab页块的阶(一个slab由2^gfporder个页构) */</span></span><br><span class="line">	<span class="keyword">gfp_t</span> allocflags; <span class="comment">/* 从伙伴系统分配页,补足slab时,页分配的gfp码 */</span></span><br><span class="line">	<span class="keyword">size_t</span> colour; <span class="comment">/* 缓存着色范围 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> colour_off; <span class="comment">/* 一个cache colour的长度(和一个cache line的大小相同) */</span></span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">freelist_cache</span>;</span> <span class="comment">/* 空闲对象链表放在slab外部时使用,管理用于slab对象管理结构中freelist成员的缓存,也就是又一个新缓存 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> freelist_size; <span class="comment">/* 空闲对象链表的大小 */</span></span><br><span class="line">	<span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *obj); <span class="comment">/* 创建高速缓存时的构造函数指针,一半为null */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4) cache creation/removal */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/* slab缓存名字 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">/* slab缓存描述符双向链表指针 */</span></span><br><span class="line">	<span class="keyword">int</span> refcount;</span><br><span class="line">	<span class="keyword">int</span> object_size; <span class="comment">/* slab中每个obj的大小 */</span></span><br><span class="line">	<span class="keyword">int</span> align; <span class="comment">/* obj对齐字节 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5) statistics */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SLAB</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> num_active;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> num_allocations;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> high_mark;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> grown;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> reaped;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> errors;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> max_freeable;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_allocs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_frees;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_overflow;</span><br><span class="line">	<span class="keyword">atomic_t</span> allochit;</span><br><span class="line">	<span class="keyword">atomic_t</span> allocmiss;</span><br><span class="line">	<span class="keyword">atomic_t</span> freehit;</span><br><span class="line">	<span class="keyword">atomic_t</span> freemiss;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SLAB_LEAK</span></span><br><span class="line">	<span class="keyword">atomic_t</span> store_user_clean;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> obj_offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEBUG_SLAB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">memcg_cache_params</span> <span class="title">memcg_params</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span> <span class="comment">/* slab节点链表组,对于NUMA系统中每个节点都会有一个struct kmem_cache_node数据结构 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>slab cache 中所有 slab 的大小一致，由一个或多个连续页组成（通常为一个page，伙伴系统提供）</li>
<li>每个 slab 中的 obj 大小和数量也是相同的</li>
</ul>
<p>slab cache 描述符 struct kmem_cache 中除了相关的管理数据外，有两个很重要的成员： </p>
<ul>
<li>struct array_cache __percpu *cpu_cache：<ul>
<li>cpu_cache 是一个 Per-CPU 数据结构，每个 CPU 独享（相当于函数和它局部变量的关系），用来表示本地 CPU 的 slab cache 对象缓冲池（注意是 slab cache obj 缓冲池不是 slab cache slab 缓冲池）</li>
<li>CPU 都有自己的硬件高速缓存，当前 CPU 上释放对象时，这个对象很可能还在 CPU 的硬件高速缓存中，这时使用这个对象的代价是非常小的，不需要重新装载到硬件高速缓存中，离 CPU 又最近，同时还可以减少锁的竞争，尤其是在多个 CPU 同时申请同样 size 或者同个缓存对象时，无需加锁即可操作</li>
<li>array_cache中 的 entry 空数组，就是用于保存本地 cpu 刚释放的 obj，所以该数组初始化时为空，只有本地 cpu 释放 slab cache 的 obj 后才会将此 obj 装入到 entry 数组 array_cache 的 entry 成员数组中保存的 obj 数量是由成员 limit 控制的，超过该限制后会将 entry 数组中的 batchcount 个 obj 迁移到对应节点 cpu 共享的空闲对象链表中</li>
<li>entry 数组的访问机制是 LIFO（last in fist out），此种设计非常巧妙，能保证本地 cpu 最近释放该 slab cache 的 obj 立马被下一个 slab 内存申请者获取到（有很大概率此 obj 仍然在本地 cpu 的硬件高速缓存中）</li>
</ul>
</li>
<li>struct kmem_cache_node *node[MAX_NUMNODES]：<ul>
<li>slab 缓存会为不同的节点维护一个自己的 slab 链表，用来缓存和管理自己节点的 slab obj，这通过 kmem_cache 中 node 数组成员来实现，node 数组中的每个数组项都为其对应的节点分配了一个 struct kmem_cache_node 结构</li>
<li>struct kmem_cache_node 结构定义的变量是一个每 node 变量，相比于 struct array_cache 定义的每 cpu 变量，kmem_cache_node 管理的内存区域粒度更大，因为kmem_cache_node 维护的对象是 slab，而 array_cache 维护的对象是 slab 中的 obj（一个 kmem_cache 可能包含一个或多个 slab，而一个 slab 中可能包含一个或多个 slab obj）</li>
<li>通过下面 struct kmem_cache_node 结构的代码实现我们来分析该结构体如何实现对本地节点指定 slab cache 中所有的 slab 进行管理的</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* 该链表中存储的所有slab中只有部分obj是空闲的 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span> <span class="comment">/* 该链表中存储的所有slab中不存在空闲的obj */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span> <span class="comment">/* 该链表中存储的所有slab中每个obj都是空闲的 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> total_slabs; <span class="comment">/* 该节点中此kmem_cache的slab总数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> free_slabs; <span class="comment">/* 该节点中此kmem_cache空闲slab总数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> free_objects; <span class="comment">/* 该节点中此kmem_cache空闲obj总数 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> free_limit; <span class="comment">/* 该节点中此kmem_cache中空闲obj数量的上限,多了就会回收到伙伴系统的空闲链表中 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> colour_next; <span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* 该节点上所有cpu共享的本地高速缓存 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* 其他节点上所有cpu共享的本地高速缓存 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> next_reap; <span class="comment">/* updated without locking */</span></span><br><span class="line">	<span class="keyword">int</span> free_touched; <span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_partial;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> nr_slabs;</span><br><span class="line">	<span class="keyword">atomic_long_t</span> total_objects;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>由上代码可以看出，struct kmem_cache_node 对于本节点中 slab 的管理主要分了3个链表:<ul>
<li>部分空闲 slab 链表（slabs_partial）</li>
<li>全空闲 slab 链表（slabs_free）</li>
<li>非空闲 slab 链表（slabs_full）</li>
</ul>
</li>
<li>单个 slab 可以在不同的链表之间移动，例如当一个 slab 被分配完，就会从 slab_partial 移动到 slabs_full，当一个 slab 中有对象被释放后，就会从 slab_full 再次回到 slab_partial，所有对象都被释放完的话，就会从 slab_partial 移动到 slabs_free</li>
<li>struct kmem_cache_node 还会将本地节点中需要节点共享的 slab obj 缓存在它的 shared 成员中，若本地节点向访问其他节点贡献的 slab obj，可以利用 struct kmem_cache_node 中的 alien 成员去获取</li>
</ul>
<p><strong>slab机制</strong></p>
<p>slab 算法在伙伴算法的基础上，对小内存的场景专门做了优化，采用了内存池的方案，解决内部碎片问题</p>
<p>先挂一张图片： </p>
<img src="/2022/05/23/BuddySystem&Slab/1653927280497-1655875583493.png" class width="1653927280497"> 
<p><strong>从 buddy 分配出来的那一份份连续的 page 就是一个 slab</strong></p>
<ul>
<li>首先我们要知道是 slab 分配器是基于 buddy 分配器的，即 slab 需要从 buddy 分配器获取连续的物理页帧作为制造对象的原材料</li>
<li>简单来说，就是基于 buddy 分配器获得连续的 pages，作为某数据结构对象的缓存，再将这段连续的 pages 从内部切割成一个个对齐的对象，使用时从中取用，这样一段连续的 page 我们称为一个 slab</li>
</ul>
<p><strong>把各个 slab 分组管理，每一个组对应一个 kmem_cache，对应一种分配“规则”</strong></p>
<ul>
<li>在 slab 算法中维护着大小不同的 slab 集合，在最顶层是 cache_chain，cache_chain 中维护着一组 kmem_cache 引用</li>
<li>kmem_cache 负责管理一块固定大小的对象池，通常会提前分配一块内存，然后将这块内存划分为大小相同的 object（分配给用户的对象），不会对内存块再进行合并，同时使用位图 bitmap 记录每个 object 的使用情况</li>
<li>把各个 slab 进行分组管理，每个组分别包含 2^3，2^4，2^5 … 2^11 … 个字节（在 4K 页大小的默认情况下），另外还有两个特殊的组，分别是 96B 和 192B，每个组就是一个 kmem_cache</li>
<li>不同内核版本的分组数不同（大约20个），比如我的内核就分配了26个组：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">kmalloc_index</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!size)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt;= KMALLOC_MIN_SIZE)</span><br><span class="line">		<span class="keyword">return</span> KMALLOC_SHIFT_LOW;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">32</span> &amp;&amp; size &gt; <span class="number">64</span> &amp;&amp; size &lt;= <span class="number">96</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (KMALLOC_MIN_SIZE &lt;= <span class="number">64</span> &amp;&amp; size &gt; <span class="number">128</span> &amp;&amp; size &lt;= <span class="number">192</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=          <span class="number">8</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=         <span class="number">16</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=         <span class="number">32</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=         <span class="number">64</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=        <span class="number">128</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=        <span class="number">256</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=        <span class="number">512</span>) <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=       <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=   <span class="number">2</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=   <span class="number">4</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=   <span class="number">8</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">128</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">512</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;=  <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="keyword">return</span> <span class="number">26</span>;</span><br><span class="line">	BUG();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>slab 分配器并非一开始就能智能的根据内存分档值分配相应长度的内存的，它需要先创建一个这样的“规则”式的东西，之后才可以根据这个“规则”分配相应长度的内存 </li>
<li>内核 slab 分配器之所以能够默认的提供26种内存长度分档，肯定也需要创建这样26个“规则”，这是由函数 kmem_cache_init 在初始化时创建的</li>
<li>比如现在有一个内核模块想要申请一种它自创的结构，这个结构是111字节，并且它不想获取128字节内存就想获取111字节长度内存，那么它需要在 slab 分配器中创建一个这样的“规则”，这个规则规定 slab 分配器当按这种“规则”分配时要给我111字节的内存，这个“规则”的创建方法就是调用函数 kmem_cache_create</li>
<li>函数 kmem_cache_destroy 可以销毁 kmem_cache_create 创建的“规则”，而这个“规则”就是“缓存描述符 kmem_cache”</li>
</ul>
<p><strong>slub接口</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分配一块给某个数据结构使用的kmem_cache(缓存描述符) */</span></span><br><span class="line"><span class="function">struct kmem_cache *<span class="title">kmem_cache_create</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> align, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags， <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span>*))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 销毁kmem_cache_create分配的kmem_cache */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmem_cache_destroy</span><span class="params">(struct kmem_cache *cachep)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从目标kmem_cache中分配一个object */</span>  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">kmem_cache_alloc</span><span class="params">(struct kmem_cache* cachep, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放object,把它返还给原先的kmem_cache */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_free</span><span class="params">(struct kmem_cache* cachep,  <span class="keyword">void</span>* objp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入想要的size,分配一个object,其他工作交给伙伴系统和slub */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入目标obj,释放它,其他工作交给伙伴系统和slub */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *objp)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>先通过 kmem_cache_create 创建一个缓存管理描述符 kmem_cache</li>
<li>使用 kmem_cache_alloc 从缓存 kmem_cache 中申请 object 使用</li>
<li>函数 kmem_cache_init 在初始化时会自动创建默认的 kmem_cache </li>
</ul>
<h2 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h2><p>kmalloc 本质上是调用 __kmalloc：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-4.20.1\mm\slub.c */</span></span><br><span class="line"><span class="keyword">void</span> *__kmalloc(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line">		<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">	s = kmalloc_slab(size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	ret = slab_alloc(s, flags, _RET_IP_); <span class="comment">/* 从对应的kmem_cache中分配对象 */</span></span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, flags);</span><br><span class="line"></span><br><span class="line">	kasan_kmalloc(s, ret, size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kmalloc);</span><br></pre></td></tr></table></figure>
<ul>
<li>kmalloc() 先根据 size 找到对应的 <code>struct kmem_cache</code> 然后调用 <code>slab_alloc()</code> 从中分配对象</li>
</ul>
<p>slab_alloc：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-4.20.1\mm\slub.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">slab_alloc</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">gfp_t</span> gfpflags, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后在 <code>slab_alloc()</code> 中调用 <code>slab_alloc_node</code></li>
</ul>
<p>slab_alloc_node：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">slab_alloc_node</span><span class="params">(struct kmem_cache *s,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">gfp_t</span> gfpflags, <span class="keyword">int</span> node, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *object;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> tid;</span><br><span class="line"></span><br><span class="line">	s = slab_pre_alloc_hook(s, gfpflags);</span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">redo:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        必须通过本cpu指针去读kmem_cache中的cpu相关数据, </span></span><br><span class="line"><span class="comment">        当读一个CPU区域内的数据时有可能在cpu直接来回切换</span></span><br><span class="line"><span class="comment">        只要我们在执行cmpxchg时再次使用原始 cpu，这并不重要</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        必须保证tid和kmem_cache都是通过同一个CPU获取的</span></span><br><span class="line"><span class="comment">        如果开启了CONFIG_PREEMPT(内核抢占), 那么有可能获取tid之后被换出, 导致tid与c不对应, 所以这里需要一个检查</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);</span><br><span class="line">		c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	&#125; <span class="keyword">while</span> (IS_ENABLED(CONFIG_PREEMPT) &amp;&amp;</span><br><span class="line">		 unlikely(tid != READ_ONCE(c-&gt;tid)));</span><br><span class="line"></span><br><span class="line">	barrier(); <span class="comment">// 编译屏障, 防止指令乱序</span></span><br><span class="line"></span><br><span class="line">	object = c-&gt;freelist; <span class="comment">// 获取空闲链表中的对象</span></span><br><span class="line">	page = c-&gt;page; <span class="comment">// 正在被用来分配对象的页</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!object || !node_match(page, node))) &#123;</span><br><span class="line">        <span class="comment">/* 如果空闲链表为空或者page不属于要求的节点,那么就进入slowpath部分 */</span></span><br><span class="line">		object = __slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">		stat(s, ALLOC_SLOWPATH);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 否则进入fastpath,通过CPU缓存中的freelist进行分配 */</span></span><br><span class="line">		<span class="keyword">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*这里要执行链表的取出操作, this_cpu_cmpxchg_double()作用为:</span></span><br><span class="line"><span class="comment">        如果s-&gt;cpu_slab-&gt;freelist==object, 那么s-&gt;cpu_slab-&gt;freelist=next_object</span></span><br><span class="line"><span class="comment">        如果s-&gt;cpu_slab-&gt;tid==tid, 那么s-&gt;cpu_slab-&gt;tid=next_tid(tid), next_tid(tid)</span></span><br><span class="line"><span class="comment">        如果执行到一半s-&gt;cpu_slab被其他slub拿去使用, 那么compare失败, 不执行写入, 返回redo重新试一下</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(</span><br><span class="line">				s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,</span><br><span class="line">				object, tid,</span><br><span class="line">				next_object, next_tid(tid)))) &#123; <span class="comment">// next_tid(tid)相当于tid+1</span></span><br><span class="line"></span><br><span class="line">			note_cmpxchg_failure(<span class="string">&quot;slab_alloc&quot;</span>, s, tid);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		&#125;</span><br><span class="line">		prefetch_freepointer(s, next_object); <span class="comment">// 把预读进缓存</span></span><br><span class="line">		stat(s, ALLOC_FASTPATH); <span class="comment">// 记录状态</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(gfpflags &amp; __GFP_ZERO) &amp;&amp; object) <span class="comment">// 如果flag要求清0</span></span><br><span class="line">		<span class="built_in">memset</span>(object, <span class="number">0</span>, s-&gt;object_size);</span><br><span class="line"></span><br><span class="line">	slab_post_alloc_hook(s, gfpflags, <span class="number">1</span>, &amp;object); <span class="comment">// 空操作</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里我们主要考虑 fastpath，也就是使用 freelist 的这种情况</li>
</ul>
<p>get_freepointer_safe：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">get_freepointer_safe</span><span class="params">(struct kmem_cache *s, <span class="keyword">void</span> *object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> freepointer_addr;</span><br><span class="line">	<span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!debug_pagealloc_enabled()) <span class="comment">/* 如果没开启CONFIG_DEBUG_PAGEALLOC,那么就会进入get_freepointer() */</span></span><br><span class="line">		<span class="keyword">return</span> get_freepointer(s, object);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 否则就会进行加密 */</span></span><br><span class="line">	freepointer_addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)object + s-&gt;offset;</span><br><span class="line">	probe_kernel_read(&amp;p, (<span class="keyword">void</span> **)freepointer_addr, <span class="keyword">sizeof</span>(p));</span><br><span class="line">	<span class="keyword">return</span> freelist_ptr(s, p, freepointer_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这就是 Harden_freelist 保护（使用 <code>s-&gt;random</code> 与 <code>指针所在地址</code>  去加密原空闲指针）</li>
<li>加固指针 = 空闲指针 ^ 空闲指针地址 ^ 随机数R，只要知道这些值就可以绕过 Harden_freelist </li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/kernel/" rel="tag"><i class="fa fa-tag"></i> kernel</a>
              <a href="/tags/buddy-system/" rel="tag"><i class="fa fa-tag"></i> buddy system</a>
              <a href="/tags/slub/" rel="tag"><i class="fa fa-tag"></i> slub</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/21/kernel%20attack/" rel="prev" title="kernel attack（持续更新）">
      <i class="fa fa-chevron-left"></i> kernel attack（持续更新）
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/05/24/Machine-Learning-Lab6/" rel="next" title="Machine-Learning-Lab6">
      Machine-Learning-Lab6 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">伙伴系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slab%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">Slab分配器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kmalloc"><span class="nav-number">3.</span> <span class="nav-text">kmalloc</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">331</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">170</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">74:46</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
