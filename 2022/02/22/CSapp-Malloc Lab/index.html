<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Malloc Lab学生实现他们自己版本的 malloc，free 和 realloc，当然不仅要正确的实现相关功能，也要满足速度效率等要求 开始实验之前需要一些前置知识 动态内存分配器动态内存分配器维护了一个进程的虚拟内存区域（被称为堆）   对于每个进程，内核维护着一个变量brk（break），它指向堆的顶部 动态内存分配器把堆视为一组 不同大小的块 的集合体，每个块就是一个连续的虚拟内存片（">
<meta property="og:type" content="article">
<meta property="og:title" content="CSapp-Malloc Lab">
<meta property="og:url" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="Malloc Lab学生实现他们自己版本的 malloc，free 和 realloc，当然不仅要正确的实现相关功能，也要满足速度效率等要求 开始实验之前需要一些前置知识 动态内存分配器动态内存分配器维护了一个进程的虚拟内存区域（被称为堆）   对于每个进程，内核维护着一个变量brk（break），它指向堆的顶部 动态内存分配器把堆视为一组 不同大小的块 的集合体，每个块就是一个连续的虚拟内存片（">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645162398804-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645164203076-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645171751808-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645171798997-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645172644765-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645175108729-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645175149618-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645175191867-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645175625736-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645175557203-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645180305941-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645180491268-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645520942860-1651211896145.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645521531541-1651211896146.png">
<meta property="og:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/Users/ywx813/Desktop/CSAPP/Mylabs/8.malloc%20lab/malloc/1645520942860.png">
<meta property="article:published_time" content="2022-02-22T09:59:22.000Z">
<meta property="article:modified_time" content="2022-10-09T16:08:54.618Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="labs">
<meta property="article:tag" content="CSapp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/02/22/CSapp-Malloc%20Lab/1645162398804-1651211896145.png">

<link rel="canonical" href="http://example.com/2022/02/22/CSapp-Malloc%20Lab/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CSapp-Malloc Lab | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/22/CSapp-Malloc%20Lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSapp-Malloc Lab
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-22 17:59:22" itemprop="dateCreated datePublished" datetime="2022-02-22T17:59:22+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-10 00:08:54" itemprop="dateModified" datetime="2022-10-10T00:08:54+08:00">2022-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>52k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>47 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Malloc-Lab"><a href="#Malloc-Lab" class="headerlink" title="Malloc Lab"></a>Malloc Lab</h2><p>学生实现他们自己版本的 malloc，free 和 realloc，当然不仅要正确的实现相关功能，也要满足速度效率等要求</p>
<p>开始实验之前需要一些前置知识</p>
<h2 id="动态内存分配器"><a href="#动态内存分配器" class="headerlink" title="动态内存分配器"></a>动态内存分配器</h2><p>动态内存分配器维护了一个进程的虚拟内存区域（被称为堆）</p>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645162398804-1651211896145.png" class width="1645162398804"> 
<p>对于每个进程，内核维护着一个变量brk（break），它指向堆的顶部</p>
<p>动态内存分配器把堆视为一组 <strong>不同大小的块</strong> 的集合体，每个块就是一个连续的虚拟内存片（chunk），它有两种状态：已分配（allocated），空闲（free）</p>
<p>动态内存分配器有两种风格，两个风格都要求应用 <strong>显式地</strong> 分配内存，不同之处在于哪个实体来负责释放已分配的块</p>
<ul>
<li>显式分配器：要求应用 <strong>显式地</strong> 释放已分配的块（主动释放，只有调用相应的函数才能将chunk释放掉），比如：C中的 malloc 和 free，C++中的 new 和 delete</li>
<li>隐式分配器：要求应用 <strong>隐式地</strong> 释放已分配的块（自动释放，要求分配器自己检测chunk何时不被程序利用），比如：java，ML，Lisp都依赖 “垃圾收集” 来释放chunk</li>
</ul>
<h2 id="分配器的基本规则"><a href="#分配器的基本规则" class="headerlink" title="分配器的基本规则"></a>分配器的基本规则</h2><p>在写分配器前，先要了解malloc的功能的特点：</p>
<p><strong>基础功能</strong></p>
<p>malloc 可以在 heap 获取一片内存（由数据结构chunk进行管理），并返回“chunk-&gt;FD”</p>
<p>如果 malloc 遇到问题（例如，程序要求的内存块比可用的虚拟内存还要大），那么它就返回 NULL，并设置 errno </p>
<p>free 可以释放一片内存空间</p>
<p><strong>内存对齐</strong></p>
<p>malloc 会返回至少为“chunk-&gt;size”字节的的chunk，chunk的大小也会受 <strong>内存对齐</strong> 的影响</p>
<p>案例：32位程序，一个空格代表4字节，初始16字，双字对齐</p>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645164203076-1651211896145.png" class width="1645164203076"> + 

+ 1：malloc申请了4字大小的chunk，实际上申请了4字
+ 2：malloc申请了5字大小的chunk，实际上申请了6字（双字对齐）
+ 3：malloc申请了6字大小的chunk，实际上申请了6字
+ 4：free释放了P2
+ 5：malloc申请了2字大小的chunk，优先占用了P2的 free chunk（fastbin & Tcachebin）

**内存管理**

内存管理可以分为以下几个问题：

+ 空闲块的组织方式
+ 空闲块的再申请
+ 空闲块的分割
+ 空闲块的合并

为了应对这些问题，我们需要学习相应的技术

**必要检查**

先抛开安全方面的检查，malloc必须要满足一些约束条件：

+ 每个释放请求必须对应一个当前已分配的块，这个块是由一个以前的分配请求获得到的
+ 立刻响应请求
+ 不修改已经分配的chunk（申请的chunk不重叠）

##  内存块组织技术

针对空闲块的组织方法有以下三种：

+ 隐式空闲链表(implicit free list)
+ 显式空闲链表(explicit free list)
+ 分离空闲链表(segregated free list) 

这里主要介绍前两种

**隐式空间链表**

任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块，大多数分配器将这些信息嵌入块本身：

<img src="/2022/02/22/CSapp-Malloc%20Lab/1645171751808-1651211896145.png" class width="1645171751808"> 
<p>隐式空闲链表就是一种简单空闲块组织结构，可以把堆 <strong>按地址顺序</strong> 组织成一个连续的，包含allocated chunk和free chunk的链表</p>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645171798997-1651211896145.png" class width="1645171798997">  
<p>阴影部分是已分配块，没有阴影的部分是空闲块，头部标记为（size / flag） </p>
<p>因为分配器需要通过 flag 才能辨别该chunk的类型，所以它在重新申请chunk时，需要遍历整个链表，以获取合适的free chunk</p>
<p><strong>显式空闲链表</strong> </p>
<p>块分配与堆块的总数呈线性关系，所以对于通用的分配器，隐式空闲链表是不适合的，一种更好的方法是 <strong>将空闲块组织为某种形式</strong> 的显式数据结构</p>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645172644765-1651211896145.png" class width="1645172644765"> 
<p>通过“free chunk-&gt;FD”和“free chunk-&gt;BK”把free chunk连接为一个双向链表</p>
<p>此后进行遍历时，就不用对allocated chunk进行操作了</p>
<h2 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h2><p>为了提高内存利用率，空闲块的再申请是必不可少的，想要获取合适的空闲块，程序必须先进行搜索，分配器执行这种搜索的方式是由放置策略（placement policy）确定的，一些常见的策略是：</p>
<ul>
<li>首次适配（first-fit）</li>
<li>下次适配（next-fit）</li>
<li>最佳适配（best-fit）</li>
</ul>
<p>比如：隐式空闲链表中的最佳适配，就是采用遍历所有chunk方式</p>
<p><strong>首次适配</strong></p>
<p>首次适配算法的分配内存的设计思路是：物理内存页管理器顺着双向链表进行搜索空闲内存区域，直到找到一个足够大的空闲区域，然后立刻将其进行分配（或分割后分配），此后的内存块都不做处理</p>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645175108729-1651211896145.png" class width="1645175108729"> 
<p>优点：速度迅速</p>
<p>缺点：分割后剩下的内存块会越来越难以利用</p>
<p><strong>下次适配</strong></p>
<p>下次适配和首次适配相似，只不过不是每次都从链表的起始处开始搜索，而是从上一次查询结束的地方开始</p>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645175149618-1651211896145.png" class width="1645175149618"> 
<p><strong>最佳适配</strong></p>
<p>每一次都遍历所有内存块，获取最合适的</p>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645175191867-1651211896145.png" class width="1645175191867"> 
<p>优点：剩下的内存块利用率较高</p>
<p>缺点：速度缓慢</p>
<h2 id="空闲块分割"><a href="#空闲块分割" class="headerlink" title="空闲块分割"></a>空闲块分割</h2><p>在 “空闲块再申请” 的过程中，不一定每一次都可以刚好分离相同大小的空闲块，所以在必要时刻需要对空闲块进行分割</p>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645175625736-1651211896145.png" class width="1645175625736"> 
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645175557203-1651211896145.png" class width="1645175557203"> 
<p>对其再申请4字后，剩下的4字大小的free chunk更加难以利用了</p>
<h2 id="边界标记"><a href="#边界标记" class="headerlink" title="边界标记"></a>边界标记</h2><p>边界标记（boundary tag），允许在常数时间内进行对前面块的合并</p>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645180305941-1651211896145.png" class width="1645180305941"> 
<p>在每个块的结尾处添加一个<strong>脚部</strong>（footer，边界标记）</p>
<p>​        // 原本内存块的 <strong>头部</strong> 就可以标记chunk的状态，脚部只是头部的一个副本</p>
<p>如果每个块包括这样一个脚部，那么分配器就可以通过检査它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置一个字的距离</p>
<p>考虑当分配器释放当前块时所有可能存在的情况：</p>
<ul>
<li>情况1：前面的块和后面的块都是已分配的</li>
<li>情况2：前面的块是已分配的，后面的块是空闲的</li>
<li>情况3：前面的块是空闲的，而后面的块是已分配的</li>
<li>情况4：前面的和后面的块都是空闲的</li>
</ul>
<p>有3个独立的内存块，释放中间那个内存块：</p>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645180491268-1651211896145.png" class width="1645180491268"> 
<ul>
<li>情况1：不进行合并</li>
<li>情况2：通过更新脚部的位置，和后面的块进行合并</li>
<li>情况3：通过更新头部的位置，和前面的块进行合并</li>
<li>情况4：同时更新头部和脚部的位置，和相邻两个块进行合并</li>
</ul>
<p>缺陷：它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销</p>
<h2 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h2><p>当所有malloc的基础要求完成过后，我们就需要考虑它的性能，分配器的编写者往往需要实现 <strong>吞吐率</strong> 最大化，和 <strong>内存使用率最大化</strong> ，但是这两个性能又往往是冲突的</p>
<p><strong>吞吐率最大化</strong></p>
<p>吞吐率：单位时间里完成的请求数，比如：1秒完成500次申请请求，500次释放请求，那么它的吞吐率就是每秒1000次操作</p>
<p>合理性能：分配请求的 最糟运行时间 与 空闲块数量 形成的线性关系</p>
<p><strong>内存利用率最大化</strong></p>
<p>一个系统内所有进程分配的虚拟内存大全部数量，受磁盘上交换空间的数量限制</p>
<p>峰值利用率：用来描述分配器使用堆的效率</p>
<h2 id="实验程序介绍"><a href="#实验程序介绍" class="headerlink" title="实验程序介绍"></a>实验程序介绍</h2><p>实验给出了“memlib.c”，提供了一个内存系统模拟程序，可以在不干涉系统内存的前提下进行实验</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * memlib.c - a module that simulates the memory system.  Needed because it </span></span><br><span class="line"><span class="comment"> *            allows us to interleave calls from the student&#x27;s malloc package </span></span><br><span class="line"><span class="comment"> *            with the system&#x27;s malloc package in libc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* private variables */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mem_start_brk;  <span class="comment">/* points to first byte of heap */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mem_brk;        <span class="comment">/* points to last byte of heap */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *mem_max_addr;   <span class="comment">/* largest legal heap address */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mem_init - initialize the memory system model</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* allocate the storage we will use to model the available VM */</span></span><br><span class="line">    <span class="keyword">if</span> ((mem_start_brk = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(MAX_HEAP)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;mem_init_vm: malloc error\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mem_max_addr = mem_start_brk + MAX_HEAP;  <span class="comment">/* max legal heap address */</span></span><br><span class="line">    mem_brk = mem_start_brk;                  <span class="comment">/* heap is empty initially */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mem_deinit - free the storage used by the memory system model</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_deinit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(mem_start_brk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mem_reset_brk - reset the simulated brk pointer to make an empty heap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_reset_brk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mem_brk = mem_start_brk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mem_sbrk - simple model of the sbrk function. Extends the heap </span></span><br><span class="line"><span class="comment"> *    by incr bytes and returns the start address of the new area. In</span></span><br><span class="line"><span class="comment"> *    this model, the heap cannot be shrunk.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mem_sbrk</span><span class="params">(<span class="keyword">int</span> incr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *old_brk = mem_brk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (incr &lt; <span class="number">0</span>) || ((mem_brk + incr) &gt; mem_max_addr)) &#123;</span><br><span class="line">	errno = ENOMEM;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: mem_sbrk failed. Ran out of memory...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mem_brk += incr;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)old_brk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mem_heap_lo - return address of the first heap byte</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mem_heap_lo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)mem_start_brk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mem_heap_hi - return address of last heap byte</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mem_heap_hi</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)(mem_brk - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mem_heapsize() - returns the heap size in bytes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">mem_heapsize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>)(mem_brk - mem_start_brk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mem_pagesize() - returns the page size of the system</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">mem_pagesize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>)getpagesize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>void *mem sbrk(int incr)：和系统的 sbrk 一致，用于分配内存</li>
<li>void *mem_heap_lo(void)：返回指向堆的第一个字节的指针 </li>
<li>void *mem_heap_hi(void)：返回指向堆的最后一个字节的指针</li>
<li>size_t mem_heapsize(void)：返回当前的堆大小 </li>
<li>size_t mem_pagesize(void)：返回系统的 page size（页大小）</li>
</ul>
<p>分配器包含在“mm.c”，需要完成下面几个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 初始化分配器，成功返回0，否则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>最后，实验还给出了调试程序“mdriver.c”，可以给你的作品打分</p>
<h2 id="隐式空闲链表-首次适配"><a href="#隐式空闲链表-首次适配" class="headerlink" title="隐式空闲链表+首次适配"></a>隐式空闲链表+首次适配</h2><p>第一次实验采用CSAPP上的案例，后续在进行修改</p>
<p>写程序之前需要先写入基本宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic constants and macros */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4             <span class="comment">/* Word and header/footer size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8             <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12)   <span class="comment">/* Extend heap by this amount (bytes) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)       (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val)  (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)       ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br></pre></td></tr></table></figure>
<ul>
<li>PACK(size, alloc)：把”chunk-&gt;size”和”P”包装为1位</li>
<li>GET(p)：从 p 中读取4字节的数据（ 这里强制类型转换是至关重要的 ）</li>
<li>PUT(p, val) ：将 val 存放在参数 p 指向的地址中</li>
<li>GET_SIZE(p)：获取头部的SIZE（通过GET(p)获取头部，接着“UNPACK”）</li>
<li>GET_ALLOC(p)：获取”P位”</li>
<li>HDRP(bp)：返回指向当前块头部的指针（减去一字刚好计算出头部） </li>
<li>FTRP(bp)：返回指向当前块脚部的指针（加上SIZE后，相当于多加了一个脚部，所以减两字）</li>
<li>NEXT_BLKP(bp)：返回指向后面块BP的指针（从当前块的头部获取SIZE，相加）</li>
<li>PREV_BLKP(bp)：返回指向前面块BP的指针（从上一个块的脚部获取SIZE，相减）</li>
</ul>
<p>注意：因为“FTRP”是根据“HDRP”计算出的，所以必须先写入头部，才能写入脚部</p>
<p>对堆进行初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>); </span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>)); <span class="comment">// 初始化头部(4~8)</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>)); <span class="comment">// 初始化脚部(8~12)</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">// 初始化下一个头部(12~16)</span></span><br><span class="line">    heap_listp += (<span class="number">2</span> * WSIZE);</span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个空的空闲链表（采用隐式空间链表）：</p>
<ul>
<li>heap_listp用于记录第一个内存块的数据区（与脚部重合，但是可以被宏定义识别）</li>
<li>第一个内存块不写入数据（没有意义，后续操作都将会跳过它，直接获取下一个内存块）</li>
</ul>
<p>接着它调用 extend_heap 函数</p>
<p>这个函数用于申请内存块，初始化使将堆扩展 CHUNKSIZE 字节，并且创建初始的空闲块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize free block header/footer and the epilogue header */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* Free block header */</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* Free block footer */</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">/* New epilogue header */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Coalesce if the previous block was free */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>extend_heap保证了，“mem_sbrk(size)”的size大小为8的倍数（内存对齐）</p>
<p>后续的PUT填入了当前块的头部和脚部，和下一个块的头部</p>
<p>函数coalesce用于合并堆块，在mm_free中也会使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;            <span class="comment">/* Case 1 */</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;      <span class="comment">/* Case 2 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;      <span class="comment">/* Case 3 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;                                    <span class="comment">/* Case 4 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>coalesce先获取了上一个块的脚部，下一个块的头部，和当前的SIZE</p>
<ul>
<li>case1：上一个块allocated，下一个块allocated，不合并</li>
<li>case2：上一个块allocated，下一个块free，把“SIZE”加上“NEXT_BLKP-&gt;SIZE”，更新脚部</li>
<li>case3：上一个块free，下一个块allocated，把“SIZE”加上“PREV_BLKP-&gt;SIZE”，更新头部</li>
<li>case4：上一个块free，下一个块free，把“SIZE”同时加上前后两者的“SIZE”，更新头部&amp;脚部</li>
</ul>
<p>mm_malloc函数会先检查请求的真假，然后进行申请，必须保证8字节对齐，另外需要8字节来存放头部和脚部，对于超过8字节的请求，一般的规则是加上开销字节，然后向上舍入到最接近的8的整数倍 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">/* Adjusted block size */</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize; <span class="comment">/* Amount to extend heap if no fit */</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ignore spurious requests */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Adjust block size to include overhead and alignment reqs. */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / DSIZE);</span><br><span class="line">    <span class="comment">/* Search the free list for a fit */</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* No fit found. Get more memory and place the block */</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mm_malloc中的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asize = DSIZE * ((size + (DSIZE) + (DSIZE - <span class="number">1</span>)) / DSIZE);</span><br></pre></td></tr></table></figure>
<p>保证了用于申请的asize一定为8的倍数，并且留有8字节头部和脚部的空间</p>
<p>find_fit用于查找合适的空闲块，place用于放置空闲块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp = heap_listp;</span><br><span class="line">    <span class="keyword">size_t</span> alloc;</span><br><span class="line">    <span class="keyword">size_t</span> size; <span class="comment">/* heap_listp 指向第一个内存块，没有意义，直接获取下一个内存块 */</span></span><br><span class="line">    <span class="keyword">while</span> (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        alloc = GET_ALLOC(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (alloc) <span class="keyword">continue</span>;</span><br><span class="line">        size = GET_SIZE(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (size &lt; asize) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用首次适配（first-fit）：遇到allocated chunk，或者free chunk的size不够，就重新循环 </p>
<p>直到找寻到合适的空闲块后，输出其BP（数据区指针）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((size - asize) &gt;= (<span class="number">2</span>*DSIZE)) &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)),PACK(size - asize,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size - asize,<span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为内存块最小为“ 2*DSIZE ”（16字节），所以如果切割剩余内存块小于16字节就不能进行切割，利用边界标记技术，可以通过“添加内存块边界”来进行切割</p>
<p>更新一下mm_realloc：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">	<span class="keyword">void</span>* newptr = mm_malloc(size);</span><br><span class="line">	<span class="keyword">if</span> (!newptr)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!ptr)</span><br><span class="line">		<span class="keyword">return</span> newptr;</span><br><span class="line">	<span class="built_in">memcpy</span>(newptr, ptr, (size &lt; oldsize ? size : oldsize));</span><br><span class="line">	mm_free(ptr);</span><br><span class="line">	<span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体逻辑：</p>
<ul>
<li>先用“extend_heap”初始化一个大小为CHUNKSIZE的大内存块，使其为free状态</li>
<li>后续的malloc都在这个大内存块中分割</li>
<li>如果大内存块不够用，就再次调用“extend_heap”进行申请</li>
</ul>
<p>打分&amp;完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 隐式空闲链表+首次适配 */</span></span><br><span class="line">➜  [/home/ywhkkx/malloclab-handout] ./mdriver -v</span><br><span class="line">Team Name:ateam</span><br><span class="line">Member <span class="number">1</span> :Harry Bovik:bovik@cs.cmu.edu</span><br><span class="line">Using <span class="keyword">default</span> tracefiles in /home/ywhkkx/malloclab-handout/traces/</span><br><span class="line"><span class="function">Measuring performance with <span class="title">gettimeofday</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Results <span class="keyword">for</span> mm <span class="built_in">malloc</span>:</span></span><br><span class="line"><span class="function">trace  valid  util     ops      secs  Kops</span></span><br><span class="line"><span class="function"> 0       yes   99%    5694  0.006554   869</span></span><br><span class="line"><span class="function"> 1       yes   99%    5848  0.005849  1000</span></span><br><span class="line"><span class="function"> 2       yes   99%    6648  0.010224   650</span></span><br><span class="line"><span class="function"> 3       yes  100%    5380  0.006037   891</span></span><br><span class="line"><span class="function"> 4       yes   66%   14400  0.000076188976</span></span><br><span class="line"><span class="function"> 5       yes   92%    4800  0.005052   950</span></span><br><span class="line"><span class="function"> 6       yes   92%    4800  0.006428   747</span></span><br><span class="line"><span class="function"> 7       yes   55%   12000  0.070162   171</span></span><br><span class="line"><span class="function"> 8       yes   51%   24000  0.237273   101</span></span><br><span class="line"><span class="function"> 9       yes   27%   14401  0.047580   303</span></span><br><span class="line"><span class="function">10       yes   34%   14401  0.001504  9575</span></span><br><span class="line"><span class="function">Total          74%  112372  0.396739   283</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Perf index </span>= <span class="number">44</span> (util) + <span class="number">19</span> (thru) = <span class="number">63</span>/<span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memlib.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(X, Y) ((X) &gt; (Y) ? (X) : (Y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(unsigned int*)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val) (*(unsigned int*)(p) = (val))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(P) (GET(P) &amp; ~0X7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(P) (GET(P) &amp; 0X1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char*)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE(((char*)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char*)(bp) - GET_SIZE(((char*)(bp) - DSIZE)))</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp,<span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *heap_listp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    heap_listp += (<span class="number">2</span> * WSIZE);</span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* bp;</span><br><span class="line">	<span class="keyword">size_t</span> size;</span><br><span class="line">	size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">	PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">	PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">	<span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">	<span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">	<span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">		<span class="keyword">return</span> bp;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)&#123;</span><br><span class="line">		size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">		PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">		PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">		size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">		PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">		PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">		bp = PREV_BLKP(bp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">		PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">		PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">		bp = PREV_BLKP(bp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line">	<span class="keyword">size_t</span> extendsize;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">		asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		asize = DSIZE * ((size + DSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE);</span><br><span class="line">	<span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		place(bp, asize);</span><br><span class="line">		<span class="keyword">return</span> bp;</span><br><span class="line">	&#125;</span><br><span class="line">	extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">	<span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	place(bp, asize);</span><br><span class="line">	<span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> size = GET_SIZE(HDRP(ptr));</span><br><span class="line">	PUT(HDRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">	PUT(FTRP(ptr), PACK(size, <span class="number">0</span>));</span><br><span class="line">	coalesce(ptr);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp = heap_listp;</span><br><span class="line">    <span class="keyword">size_t</span> alloc;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">while</span> (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        alloc = GET_ALLOC(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (alloc) <span class="keyword">continue</span>;</span><br><span class="line">        size = GET_SIZE(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (size &lt; asize) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((size - asize) &gt;= (<span class="number">2</span>*DSIZE)) &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)),PACK(size - asize,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size - asize,<span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">	<span class="keyword">void</span>* newptr = mm_malloc(size);</span><br><span class="line">	<span class="keyword">if</span> (!newptr)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!ptr)</span><br><span class="line">		<span class="keyword">return</span> newptr;</span><br><span class="line">	<span class="built_in">memcpy</span>(newptr, ptr, (size &lt; oldsize ? size : oldsize));</span><br><span class="line">	mm_free(ptr);</span><br><span class="line">	<span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隐式空闲链表-下次适配"><a href="#隐式空闲链表-下次适配" class="headerlink" title="隐式空闲链表+下次适配"></a>隐式空闲链表+下次适配</h2><p>想要实现下次适配的代码和书上有所不同，需要有所改进</p>
<p>首先需要一个全局指针来记录“上一次操作”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* pre_listp;</span><br></pre></td></tr></table></figure>
<p>在一些函数快结束时（不包括“place”和“coalesce”），该指针都要更新为当前块的BP（指向数据区的指针）</p>
<p>另外，“find_fit”需要重写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp = pre_listp;</span><br><span class="line">    <span class="keyword">size_t</span> alloc;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">while</span> (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        alloc = GET_ALLOC(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (alloc) <span class="keyword">continue</span>;</span><br><span class="line">        size = GET_SIZE(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (size &lt; asize) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125; </span><br><span class="line">    bp = heap_listp; <span class="comment">/* 这里也是跳过第一个内存块，直接获取下一个 */</span></span><br><span class="line">    <span class="keyword">while</span> (bp != pre_listp) &#123;</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        alloc = GET_ALLOC(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (alloc) <span class="keyword">continue</span>;</span><br><span class="line">        size = GET_SIZE(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (size &lt; asize) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意：</p>
<ul>
<li>当下次适配遍历完所有的空闲块时，需要把BP重置为heap_listp（第一个内存块）</li>
<li>只需要“mm_malloc”中记录一下“pre_listp”，重复记录可能会报错</li>
<li>可以把“pre_listp”初始化为第二个内存块的BP（比如本程序），也可以初始化为第一个</li>
</ul>
<p>打分&amp;完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 隐式空闲链表+下次适配 */</span></span><br><span class="line">➜  [/home/ywhkkx/malloclab-handout] ./mdriver -v</span><br><span class="line">Team Name:ateam</span><br><span class="line">Member <span class="number">1</span> :Harry Bovik:bovik@cs.cmu.edu</span><br><span class="line">Using <span class="keyword">default</span> tracefiles in /home/ywhkkx/malloclab-handout/traces/</span><br><span class="line"><span class="function">Measuring performance with <span class="title">gettimeofday</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Results <span class="keyword">for</span> mm <span class="built_in">malloc</span>:</span></span><br><span class="line"><span class="function">trace  valid  util     ops      secs  Kops</span></span><br><span class="line"><span class="function"> 0       yes   89%    5694  0.001789  3183</span></span><br><span class="line"><span class="function"> 1       yes   91%    5848  0.001089  5371</span></span><br><span class="line"><span class="function"> 2       yes   95%    6648  0.003659  1817</span></span><br><span class="line"><span class="function"> 3       yes   97%    5380  0.002975  1808</span></span><br><span class="line"><span class="function"> 4       yes   66%   14400  0.000112128228</span></span><br><span class="line"><span class="function"> 5       yes   92%    4800  0.003465  1385</span></span><br><span class="line"><span class="function"> 6       yes   90%    4800  0.002659  1805</span></span><br><span class="line"><span class="function"> 7       yes   55%   12000  0.006609  1816</span></span><br><span class="line"><span class="function"> 8       yes   51%   24000  0.006411  3744</span></span><br><span class="line"><span class="function"> 9       yes   27%   14401  0.041252   349</span></span><br><span class="line"><span class="function">10       yes   30%   14401  0.001649  8734</span></span><br><span class="line"><span class="function">Total          71%  112372  0.071668  1568</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Perf index </span>= <span class="number">43</span> (util) + <span class="number">40</span> (thru) = <span class="number">83</span>/<span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x) &gt; (y)? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size,alloc) ((size) | (alloc))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)      (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p,val)  (*(unsigned int *)(p) = (val))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)     (GET(p) &amp; ~0x7) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p)    (GET(p) &amp; 0x1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)        ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)        ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)   ((char*)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)   ((char*)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* heap_listp;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* pre_listp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    heap_listp += (<span class="number">2</span> * WSIZE);</span><br><span class="line">    pre_listp = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)heap_listp + DSIZE;</span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    pre_listp = coalesce(bp);</span><br><span class="line">    <span class="keyword">return</span> pre_listp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) +</span><br><span class="line">            GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line">    <span class="keyword">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + DSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        pre_listp = bp;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    pre_listp = bp;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    pre_listp = coalesce(bp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp = pre_listp;</span><br><span class="line">    <span class="keyword">size_t</span> alloc;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">while</span> (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        alloc = GET_ALLOC(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (alloc) <span class="keyword">continue</span>;</span><br><span class="line">        size = GET_SIZE(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (size &lt; asize) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = heap_listp;</span><br><span class="line">    <span class="keyword">while</span> (bp != pre_listp) &#123;</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        alloc = GET_ALLOC(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (alloc) <span class="keyword">continue</span>;</span><br><span class="line">        size = GET_SIZE(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (size &lt; asize) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((size - asize) &gt;= (<span class="number">2</span> * DSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)), PACK(size - asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size - asize, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">void</span>* newptr = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pre_listp = newptr; </span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span> newptr;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, ptr, (size &lt; oldsize ? size : oldsize));</span><br><span class="line">    mm_free(ptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="显式空间链表-首次适配-LIFO队列"><a href="#显式空间链表-首次适配-LIFO队列" class="headerlink" title="显式空间链表+首次适配+LIFO队列"></a>显式空间链表+首次适配+LIFO队列</h2><p>上两次试验采用了隐式空间链表，这次尝试一些显示空间链表</p>
<p>显示空间链表需要把空闲块链接到一起，所以需要一个宏定义来指向下一个空闲块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_RP(bp)  ((unsigned int)(bp)+WSIZE) <span class="comment">/*指向下一空闲块指针*/</span></span></span><br></pre></td></tr></table></figure>
<p>显示空间链表采用双向链表，至少需要16字节，在空闲块中：</p>
<ul>
<li>BP 指向（前驱）：上一个空闲块</li>
<li>BP+4 指向（后继）：下一个空闲块</li>
</ul>
<p>另外还需要两个含函数来进行“插入”和“脱链”操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __insert(<span class="keyword">char</span> *bp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *next = GET(root); <span class="comment">/* 读取4字节的内容,转化为指针(数据可以随便转指针) */</span></span><br><span class="line">    <span class="keyword">if</span>(next != <span class="literal">NULL</span>) <span class="comment">// 如果是root的第一个chunk,那么&quot;next==NULL&quot;</span></span><br><span class="line">        PUT(next, bp);</span><br><span class="line">    PUT(NEXT_RP(bp), next); </span><br><span class="line">    PUT(root,bp); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __remove(<span class="keyword">char</span> *bp)&#123;</span><br><span class="line">    <span class="keyword">char</span> *pre = GET((bp)); <span class="comment">/* 读取前4字节(指向前一个chunk) */</span></span><br><span class="line">    <span class="keyword">char</span> *next = GET(NEXT_RP(bp)); <span class="comment">/* 读取后4字节(指向后一个chunk) */</span></span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span>(next != <span class="literal">NULL</span>)</span><br><span class="line">            PUT(next,<span class="number">0</span>); <span class="comment">/* 前无后有 */</span></span><br><span class="line">        PUT(root,next); <span class="comment">/* 前无后无 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(next != <span class="literal">NULL</span>) </span><br><span class="line">            PUT((next),pre); <span class="comment">/* 前有后有 */</span></span><br><span class="line">        PUT(NEXT_RP(pre),next); <span class="comment">/* 前有后无 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    PUT(NEXT_RP(bp),<span class="number">0</span>);</span><br><span class="line">    PUT(bp,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在显式空间链表采用专门的链表来管理空闲块，这里采用后入先出队列</p>
<p>插入的逻辑：把root当成第一个空闲块，以后的空闲块都插入root的前驱（先写旧空闲块的后驱，再写新内存块的前驱）</p>
<p>脱链的逻辑：分为4种情况</p>
<ul>
<li>前有后有：中间某个 chunk，修改 nextchunk-&gt;last 为 lastchunk，修改 lastchunk-&gt;next 为 nextchunk，置空 chunk</li>
<li>前有后无：root 的最后一个chunk，置空 lastchunk-&gt;next，置空 chunk</li>
<li>前无后有：root 的第一个chunk，置空 nextchunk-&gt;last，修改 root 为 nextchunk，置空 chunk</li>
<li>前无后无：root 的第一个并且是唯一一个chunk，直接置空 root，置空 chunk</li>
</ul>
<p>下面是root依次插入 A，B，C，D 时的反应：（经典插头）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root(<span class="literal">NULL</span>)</span><br><span class="line">root(A) =&gt; A(/<span class="literal">NULL</span>)</span><br><span class="line">root(B) =&gt; B(/A) =&gt; A(B/<span class="literal">NULL</span>)</span><br><span class="line">root(C) =&gt; C(/B) =&gt; B(C/A) =&gt; A(B/<span class="literal">NULL</span>)</span><br><span class="line">root(D) =&gt; D(/C) =&gt; C(D/B) =&gt; B(C/A) =&gt; A(B/<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>
<p>下面是root分别释放 A，B，C，D 时的反应：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: root(D) =&gt; D(/C) =&gt; C(D/B) =&gt; B(C/<span class="literal">NULL</span>)</span><br><span class="line">B: root(D) =&gt; D(/C) =&gt; C(D/A) =&gt; A(C/<span class="literal">NULL</span>)</span><br><span class="line">C: root(D) =&gt; D(/B) =&gt; B(D/A) =&gt; A(B/<span class="literal">NULL</span>)</span><br><span class="line">D: root(C) =&gt; C(/B) =&gt; B(C/A) =&gt; A(B/<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>
<p>初始化函数发生了变化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((heap_listp = mem_sbrk(<span class="number">6</span>*WSIZE))==(<span class="keyword">void</span> *)<span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp,<span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp+(<span class="number">1</span>*WSIZE),<span class="number">0</span>); <span class="comment">// 初始化前驱</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">2</span>*WSIZE),<span class="number">0</span>); <span class="comment">// 初始化后继</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">3</span>*WSIZE),PACK(DSIZE,<span class="number">1</span>)); <span class="comment">// 初始化头(12~16)</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">4</span>*WSIZE),PACK(DSIZE,<span class="number">1</span>)); <span class="comment">// 初始化脚(16~20)</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">5</span>*WSIZE),PACK(<span class="number">0</span>,<span class="number">1</span>)); <span class="comment">// 初始化下一个头部(20~~24)</span></span><br><span class="line">    root = heap_listp + (<span class="number">1</span>*WSIZE); <span class="comment">// 初始化根节点</span></span><br><span class="line">    heap_listp += (<span class="number">4</span>*WSIZE);</span><br><span class="line">    <span class="keyword">if</span>((extend_heap(CHUNKSIZE/DSIZE)) == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根节点就是第一次内存块的前驱（在root用完之前都是不变的）</p>
<p>合并模块对空闲块的管理更为复杂了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>  prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span>  next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span>  size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*coalesce the block and change the point*/</span></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        __remove(NEXT_BLKP(bp)); <span class="comment">/*使用了这个块，切记移除它*/</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        __remove(PREV_BLKP(bp));<span class="comment">/*使用了这个块，切记移除它*/</span></span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; !next_alloc)&#123;</span><br><span class="line">        size +=GET_SIZE(FTRP(NEXT_BLKP(bp)))+ GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        __remove(PREV_BLKP(bp));<span class="comment">/*使用了这个块，切记移除它*/</span></span><br><span class="line">        __remove(NEXT_BLKP(bp));<span class="comment">/*使用了这个块，切记移除它*/</span></span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    __insert(bp);<span class="comment">/*新的空闲块，记住插入*/</span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要空闲块发生过合并，就会被“remove”移出链表，在最后“insert”插入链表最前端</p>
<p>现在查找模块只需要在空闲块链表中查询就行了：（从头开始寻找）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*first fit*/</span></span><br><span class="line">    <span class="keyword">char</span> *bp = GET(root); <span class="comment">/* 获取空闲链表头 */</span></span><br><span class="line">    <span class="keyword">while</span>(bp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_SIZE(HDRP(bp)) &gt;= size) </span><br><span class="line">            <span class="keyword">return</span> bp;  </span><br><span class="line">        bp = GET(NEXT_RP(bp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先获取链表最前端的空闲块，依次向后索引</p>
<p>放置模块需要多考虑前驱和后继的初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp,<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    __remove(bp);   <span class="comment">/*使用了这个块，切记移除它*/</span></span><br><span class="line">    <span class="keyword">if</span>(csize-asize &gt;= <span class="number">2</span> *DSIZE)&#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)),PACK(csize-asize,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(csize-asize,<span class="number">0</span>));</span><br><span class="line">        PUT(NEXT_RP(bp),<span class="number">0</span>);</span><br><span class="line">        PUT((NEXT_BLKP(bp)),<span class="number">0</span>);</span><br><span class="line">        coalesce(NEXT_BLKP(bp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他模块和书上的代码差不多，需要注意一下：何时该“插入”，何时该“脱链”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 显式空间链表+LIFO队列+首次适配 */</span></span><br><span class="line">➜  [/home/ywhkkx/malloclab-handout] ./mdriver -v</span><br><span class="line">Team Name:ateam</span><br><span class="line">Member <span class="number">1</span> :Harry Bovik:bovik@cs.cmu.edu</span><br><span class="line">Using <span class="keyword">default</span> tracefiles in /home/ywhkkx/malloclab-handout/traces/</span><br><span class="line"><span class="function">Measuring performance with <span class="title">gettimeofday</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Results <span class="keyword">for</span> mm <span class="built_in">malloc</span>:</span></span><br><span class="line"><span class="function">trace  valid  util     ops      secs  Kops</span></span><br><span class="line"><span class="function"> 0       yes   89%    5694  0.000167 34157</span></span><br><span class="line"><span class="function"> 1       yes   92%    5848  0.000093 62747</span></span><br><span class="line"><span class="function"> 2       yes   94%    6648  0.000327 20355</span></span><br><span class="line"><span class="function"> 3       yes   96%    5380  0.000195 27661</span></span><br><span class="line"><span class="function"> 4       yes   99%   14400  0.000093155005</span></span><br><span class="line"><span class="function"> 5       yes   88%    4800  0.000390 12301</span></span><br><span class="line"><span class="function"> 6       yes   85%    4800  0.000413 11625</span></span><br><span class="line"><span class="function"> 7       yes   55%   12000  0.001840  6522</span></span><br><span class="line"><span class="function"> 8       yes   51%   24000  0.001684 14249</span></span><br><span class="line"><span class="function"> 9       yes   26%   14401  0.041531   347</span></span><br><span class="line"><span class="function">10       yes   34%   14401  0.001982  7266</span></span><br><span class="line"><span class="function">Total          74%  112372  0.048714  2307</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Perf index </span>= <span class="number">44</span> (util) + <span class="number">40</span> (thru) = <span class="number">84</span>/<span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x) &gt; (y)? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size,alloc) ((size) | (alloc))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)      (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p,val)  (*(unsigned int *)(p) = (val))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)     (GET(p) &amp; ~0x7) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p)    (GET(p) &amp; 0x1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)        ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)        ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)   ((char*)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)   ((char*)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_RP(bp)     ((unsigned int)(bp)+WSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_check</span><span class="params">(<span class="keyword">char</span>* function)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"><span class="keyword">void</span> __insert(<span class="keyword">char</span>* p);</span><br><span class="line"><span class="keyword">void</span> __remove(<span class="keyword">char</span>* p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* heap_listp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">6</span> * WSIZE)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">4</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">5</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    root = heap_listp + (<span class="number">1</span> * WSIZE);</span><br><span class="line">    heap_listp += (<span class="number">4</span> * WSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((extend_heap(CHUNKSIZE / DSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * DSIZE : words * DSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    PUT(NEXT_RP(bp), <span class="number">0</span>);</span><br><span class="line">    PUT(bp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        __remove(NEXT_BLKP(bp));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        __remove(PREV_BLKP(bp));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) +</span><br><span class="line">            GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        __remove(PREV_BLKP(bp));</span><br><span class="line">        __remove(NEXT_BLKP(bp));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    __insert(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line">    <span class="keyword">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + DSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / DSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(NEXT_RP(bp), <span class="number">0</span>);</span><br><span class="line">    PUT(bp, <span class="number">0</span>);</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">char</span>* bp = GET(root);</span><br><span class="line">    <span class="keyword">while</span> (bp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span> (GET_SIZE(HDRP(bp)) &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        bp = GET(NEXT_RP(bp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    __remove(bp);</span><br><span class="line">    <span class="keyword">if</span> ((size - asize) &gt;= (<span class="number">2</span> * DSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)), PACK(size - asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size - asize, <span class="number">0</span>));</span><br><span class="line">        PUT(NEXT_RP(bp), <span class="number">0</span>);</span><br><span class="line">        PUT((NEXT_BLKP(bp)), <span class="number">0</span>);</span><br><span class="line">        coalesce(NEXT_BLKP(bp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* newptr = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, ptr, oldsize &lt; size ? oldsize : size);</span><br><span class="line">    mm_free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __insert(<span class="keyword">char</span>* bp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* next = GET(root);</span><br><span class="line">    <span class="keyword">if</span> (next != <span class="literal">NULL</span>)</span><br><span class="line">        PUT(next, bp);</span><br><span class="line">    PUT(NEXT_RP(bp), next);</span><br><span class="line">    PUT(root, bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __remove(<span class="keyword">char</span>* bp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* pre = GET((bp));</span><br><span class="line">    <span class="keyword">char</span>* next = GET(NEXT_RP(bp));</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="literal">NULL</span>)</span><br><span class="line">            PUT(next, <span class="number">0</span>);</span><br><span class="line">        PUT(root, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="literal">NULL</span>)</span><br><span class="line">            PUT((next), pre);</span><br><span class="line">        PUT(NEXT_RP(pre), next);</span><br><span class="line">    &#125;</span><br><span class="line">    PUT(NEXT_RP(bp), <span class="number">0</span>);</span><br><span class="line">    PUT(bp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隐式空闲链表-下次适配-增添标记位"><a href="#隐式空闲链表-下次适配-增添标记位" class="headerlink" title="隐式空闲链表+下次适配+增添标记位"></a>隐式空闲链表+下次适配+增添标记位</h2><p>和第二次试验很相似，只不过需要去除ALLOC内存块的脚部，并在一些位置进行修改</p>
<p>开始实验之前先进行一下思考：假设ALLOC内存块没有脚部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br></pre></td></tr></table></figure>
<p>那么，宏定义“PREV_BLKP(bp)”将会失效，ALLOC内存块将不能获取它前面的内存块，回看第二次实验的代码，发现就只有合并模块会受到影响：刚刚被free的ALLOC内存块不清楚上一个内存块是否为ALLOC</p>
<p>解决办法：对标记位进行操作，使头部可以表示上一个内存块的状态</p>
<p>分配的内存块大小为8的倍数，最后3位数值恒定，理论上有3个标志位可以用，以上代码中，最后一个标志位被用于记录“当前内存块是否为ALLOC”，与之类似，我们可以使用倒数第二个标志位来记录“上一个内存块是否为ALLOC”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREALLOC(x) ((!x) ? 0 : 2) <span class="comment">// 根据&quot;x&quot;中是否有数据来获取&quot;0 &amp; 2&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, prealloc, alloc) ((size) | (PREALLOC(prealloc)) | (alloc))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_PREALLOC(p) (GET(p) &amp; 0x2) <span class="comment">// 获取倒数第二个标志位</span></span></span><br></pre></td></tr></table></figure>
<p>这些宏定义可以简化我们的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_next_prealloc</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> prealloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(NEXT_BLKP(bp))); <span class="comment">// 获取下一个内存块的size</span></span><br><span class="line">    <span class="keyword">size_t</span> alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); <span class="comment">// 获取下一个内存块的alloc</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(size,prealloc,alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数可以根据当前内存块的状态，来更新下一个内存块的头部</p>
<p>接下来的代码和第二次实验区别不大，但需要注意一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line">    <span class="keyword">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= WSIZE) </span><br><span class="line"> <span class="comment">// if (size &lt;= DSIZE)   </span></span><br><span class="line">        asize = DSIZE;</span><br><span class="line">    <span class="comment">//  asize = 2 * DSIZE;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + WSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE);</span><br><span class="line">    <span class="comment">//  asize = DSIZE * ((size + DSIZE + (DSIZE - 1)) / DSIZE);</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“mm_malloc”获取ALLOC内存块时，不用写入脚部，可以少申请4字节，最小字节数可以变为“8”</p>
<p>打分&amp;完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 隐式空闲链表+下次适配 */</span></span><br><span class="line">➜  [/home/ywhkkx/malloclab-handout] ./mdriver -v</span><br><span class="line">Team Name:ateam</span><br><span class="line">Member <span class="number">1</span> :Harry Bovik:bovik@cs.cmu.edu</span><br><span class="line">Using <span class="keyword">default</span> tracefiles in /home/ywhkkx/malloclab-handout/traces/</span><br><span class="line"><span class="function">Measuring performance with <span class="title">gettimeofday</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Results <span class="keyword">for</span> mm <span class="built_in">malloc</span>:</span></span><br><span class="line"><span class="function">trace  valid  util     ops      secs  Kops</span></span><br><span class="line"><span class="function"> 0       yes   89%    5694  0.002184  2607</span></span><br><span class="line"><span class="function"> 1       yes   92%    5848  0.001025  5704</span></span><br><span class="line"><span class="function"> 2       yes   95%    6648  0.003881  1713</span></span><br><span class="line"><span class="function"> 3       yes   97%    5380  0.002774  1939</span></span><br><span class="line"><span class="function"> 4       yes   66%   14400  0.000101142292</span></span><br><span class="line"><span class="function"> 5       yes   92%    4800  0.004425  1085</span></span><br><span class="line"><span class="function"> 6       yes   91%    4800  0.003771  1273</span></span><br><span class="line"><span class="function"> 7       yes   55%   12000  0.007433  1614</span></span><br><span class="line"><span class="function"> 8       yes   51%   24000  0.007050  3404</span></span><br><span class="line"><span class="function"> 9       yes   27%   14401  0.042339   340</span></span><br><span class="line"><span class="function">10       yes   30%   14401  0.001879  7663</span></span><br><span class="line"><span class="function">Total          71%  112372  0.076863  1462</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Perf index </span>= <span class="number">43</span> (util) + <span class="number">40</span> (thru) = <span class="number">83</span>/<span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x) &gt; (y)? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREALLOC(x) ((!x) ? 0 : 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size,prealloc,alloc) ((size) | (PREALLOC(prealloc)) | (alloc))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)      (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p,val)  (*(unsigned int *)(p) = (val))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)     (GET(p) &amp; ~0x7) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p)    (GET(p) &amp; 0x1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_PREALLOC(p) (GET(p) &amp; 0x2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)        ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)        ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)   ((char*)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)   ((char*)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_next_prealloc</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> prealloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* heap_listp;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* pre_listp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    heap_listp += (<span class="number">2</span> * WSIZE);</span><br><span class="line">    pre_listp = heap_listp;</span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line">    <span class="keyword">size_t</span> size, prealloc;</span><br><span class="line"></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    prealloc = GET_PREALLOC(HDRP(bp));</span><br><span class="line">    PUT(HDRP(bp), PACK(size, prealloc, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, prealloc, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_PREALLOC(HDRP((bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        set_next_prealloc(bp, <span class="number">0</span>);</span><br><span class="line">        pre_listp = bp;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) +</span><br><span class="line">            GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    set_next_prealloc(bp, <span class="number">0</span>);</span><br><span class="line">    pre_listp = bp;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line">    <span class="keyword">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= WSIZE)</span><br><span class="line">        asize = DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + WSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        pre_listp = bp;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    pre_listp = bp;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">size_t</span> prealloc = GET_PREALLOC(HDRP(bp));</span><br><span class="line">    PUT(HDRP(bp), PACK(size, prealloc, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, prealloc, <span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp = pre_listp;</span><br><span class="line">    <span class="keyword">size_t</span> alloc;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">while</span> (GET_SIZE(HDRP(NEXT_BLKP(bp))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        alloc = GET_ALLOC(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (alloc) <span class="keyword">continue</span>;</span><br><span class="line">        size = GET_SIZE(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (size &lt; asize) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    bp = heap_listp;</span><br><span class="line">    <span class="keyword">while</span> (bp != pre_listp) &#123;</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        alloc = GET_ALLOC(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (alloc) <span class="keyword">continue</span>;</span><br><span class="line">        size = GET_SIZE(HDRP(bp));</span><br><span class="line">        <span class="keyword">if</span> (size &lt; asize) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((size - asize) &gt;= DSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)), PACK(size - asize, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size - asize, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        set_next_prealloc(bp, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        set_next_prealloc(bp, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pre_listp = bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">void</span>* newptr = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pre_listp = newptr;</span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span> newptr;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, ptr, (size &lt; oldsize ? size : oldsize));</span><br><span class="line">    mm_free(ptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_next_prealloc</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> prealloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(size, prealloc, alloc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分离式空闲链表-首次适配"><a href="#分离式空闲链表-首次适配" class="headerlink" title="分离式空闲链表+首次适配"></a>分离式空闲链表+首次适配</h2><p>分离式空闲链表（Segregated Free Lists），采用了 <strong>分离存储</strong> 技术，同时维护多个空闲链表，其中每个链表中的块有大致相等的大小 </p>
<p>实现 分离存储 有许多中方法，CSAPP简单提及了三种：</p>
<ul>
<li>简单分离存储</li>
<li>分离适配</li>
<li>伙伴系统</li>
</ul>
<p>这里采用 <strong>简单分离存储</strong> 的方式实现分离式空闲链表，同一区域的空闲块用前驱和后继指针进行连接</p>
<p>多了两个宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_LINKNODE_RP(bp) ((char*)(bp))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_LINKNODE_RP(bp) ((char*)(bp)+WSIZE)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>PREV_LINKNODE_RP(bp)：获取上一个空闲块</li>
<li>NEXT_LINKNODE_RP(bp)：获取下一个空闲块</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((heap_listp = mem_sbrk(<span class="number">14</span>*WSIZE))==(<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp,<span class="number">0</span>);              <span class="comment">/*block size list&lt;=8*/</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">1</span>*WSIZE),<span class="number">0</span>);    <span class="comment">/*block size list&lt;=16*/</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">2</span>*WSIZE),<span class="number">0</span>);    <span class="comment">/*block size list&lt;=32*/</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">3</span>*WSIZE),<span class="number">0</span>);    <span class="comment">/*block size list&lt;=64*/</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">4</span>*WSIZE),<span class="number">0</span>);    <span class="comment">/*block size list&lt;=128*/</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">5</span>*WSIZE),<span class="number">0</span>);    <span class="comment">/*block size list&lt;=256*/</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">6</span>*WSIZE),<span class="number">0</span>);    <span class="comment">/*block size list&lt;=512*/</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">7</span>*WSIZE),<span class="number">0</span>);    <span class="comment">/*block size list&lt;=2048*/</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">8</span>*WSIZE),<span class="number">0</span>);    <span class="comment">/*block size list&lt;=4096*/</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">9</span>*WSIZE),<span class="number">0</span>);    <span class="comment">/*block size list&gt;4096*/</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">10</span>*WSIZE),<span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp+(<span class="number">11</span>*WSIZE),PACK(DSIZE,<span class="number">1</span>)); <span class="comment">// 初始化头部</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">12</span>*WSIZE),PACK(DSIZE,<span class="number">1</span>)); <span class="comment">// 初始化脚部</span></span><br><span class="line">    PUT(heap_listp+(<span class="number">13</span>*WSIZE),PACK(<span class="number">0</span>,<span class="number">1</span>)); <span class="comment">// 初始化下一个内存块的头部</span></span><br><span class="line"></span><br><span class="line">    block_list_start = heap_listp;</span><br><span class="line">    heap_listp += (<span class="number">12</span>*WSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((extend_heap(CHUNKSIZE/DSIZE))==<span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始的第一个内存块的前面：定义了若干个分离的空间链表</p>
<p>“extend_heap”，“mm_malloc”和第三次实验（显示空间链表）的差别不大</p>
<p>“find_fit”和“place”需要重写（首次适配）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*first fit*/</span> </span><br><span class="line">    <span class="keyword">char</span> *root = find_list_root(size); <span class="comment">// 根据size获取相应的空间链表</span></span><br><span class="line">    <span class="keyword">for</span>(root; root!=(heap_listp-(<span class="number">2</span>*WSIZE)); root+=WSIZE) </span><br><span class="line">    &#123; <span class="comment">/* root+WSIZE：指向有更大空闲块的空闲链表 */</span></span><br><span class="line">        <span class="keyword">char</span> *tmpP = GET(root); <span class="comment">// 获取当前空间链表中最前面的内存块</span></span><br><span class="line">        <span class="keyword">while</span>(tmpP != <span class="literal">NULL</span>) </span><br><span class="line">        &#123; <span class="comment">/* 遍历当前空间链表：从前往后 */</span></span><br><span class="line">            <span class="keyword">if</span>(GET_SIZE(HDRP(tmpP))&gt;=size)</span><br><span class="line">                <span class="keyword">return</span> tmpP;</span><br><span class="line">            tmpP = GET(NEXT_LINKNODE_RP(tmpP));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp,<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    fix_linklist(bp); <span class="comment">/* 脱链 */</span></span><br><span class="line">    <span class="keyword">if</span>((csize-asize)&gt;=(<span class="number">2</span>*DSIZE)) <span class="comment">// 切割</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>)); <span class="comment">// 重置头部</span></span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>)); <span class="comment">// 重置脚部</span></span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line"></span><br><span class="line">        PUT(HDRP(bp),PACK(csize-asize,<span class="number">0</span>)); <span class="comment">// 初始化头部</span></span><br><span class="line">        PUT(FTRP(bp),PACK(csize-asize,<span class="number">0</span>)); <span class="comment">// 初始化脚部</span></span><br><span class="line">        PUT(NEXT_LINKNODE_RP(bp),<span class="number">0</span>); <span class="comment">// 初始化后继</span></span><br><span class="line">        PUT(PREV_LINKNODE_RP(bp),<span class="number">0</span>); <span class="comment">// 初始化前继</span></span><br><span class="line">        coalesce(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 刚好合适</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Find_fit 的逻辑：首先根据size获取相应的空间链表，遍历当前链表所以的空闲块，如果没有合适的空闲块就“root+=WSIZE”，在有更大空闲块的空间链表中寻找，获取合适的空间链表后，先获取该链表中最前面的那个空闲块，再从前往后进行遍历</li>
<li>Place的逻辑：在判断是否切割前先脱链，接着完成后续操作</li>
</ul>
<p>这里引入了两个对空间链表进行操作的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> *<span class="title">find_list_root</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(size&lt;=<span class="number">8</span>) i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">16</span>) i= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">32</span>) i= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">64</span>) i= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">128</span>) i= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">256</span>) i= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">512</span>) i= <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">2048</span>) i= <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">4096</span>) i= <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span> i= <span class="number">9</span>;</span><br><span class="line">    <span class="comment">/*find the index of bin which will put this block */</span></span><br><span class="line">    <span class="keyword">return</span> block_list_start+(i*WSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据“size”获取对应空间链表的位置，不多说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix_linklist</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *root = find_list_root(GET_SIZE(HDRP(p)));</span><br><span class="line">    <span class="keyword">char</span> *prevp = GET(PREV_LINKNODE_RP(p));</span><br><span class="line">    <span class="keyword">char</span> *nextp = GET(NEXT_LINKNODE_RP(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prevp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nextp != <span class="literal">NULL</span>)PUT(PREV_LINKNODE_RP(nextp),<span class="number">0</span>);</span><br><span class="line">        PUT(root,nextp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nextp != <span class="literal">NULL</span>)PUT(PREV_LINKNODE_RP(nextp),prevp);</span><br><span class="line">        PUT(NEXT_LINKNODE_RP(prevp),nextp);</span><br><span class="line">    &#125;</span><br><span class="line">    PUT(NEXT_LINKNODE_RP(p),<span class="literal">NULL</span>);</span><br><span class="line">    PUT(PREV_LINKNODE_RP(p),<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>脱链操作，跟第三次实验中的“__remove”功能类似</p>
<p>“mm_free”的变化不大，主要是“coalesce”变化较大：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>  prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span>  next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        insert_to_list(bp); <span class="comment">// 插入对应空间链表的头部</span></span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        fix_linklist(NEXT_BLKP(bp)); <span class="comment">// 把下一个空闲块脱链</span></span><br><span class="line">        PUT(HDRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        fix_linklist(PREV_BLKP(bp)); <span class="comment">// 把上一个空闲块脱链</span></span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size +=GET_SIZE(FTRP(NEXT_BLKP(bp)))+ GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        fix_linklist(PREV_BLKP(bp)); <span class="comment">// 把上一个空闲块脱链</span></span><br><span class="line">        fix_linklist(NEXT_BLKP(bp)); <span class="comment">// 把下一个空闲块脱链</span></span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    insert_to_list(bp); <span class="comment">// 插入对应空间链表的头部</span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在合并之后，需要把被合并的空闲块脱链，最后新的空闲块插入对应的空间链表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert_to_list</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *root = find_list_root(GET_SIZE(HDRP(p))); </span><br><span class="line">    <span class="keyword">char</span> *prevp = root; <span class="comment">// 获取root的地址</span></span><br><span class="line">    <span class="keyword">char</span> *nextp = GET(root); <span class="comment">// 获取root指向的那个空闲块(可能为NULL)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(nextp!=<span class="literal">NULL</span>) <span class="comment">// 优化操作，写上可以增加1分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GET_SIZE(HDRP(nextp))&gt;=GET_SIZE(HDRP(p))) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        prevp = nextp;</span><br><span class="line">        nextp = GET(NEXT_LINKNODE_RP(nextp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prevp == root) <span class="comment">// 插入该空间链表的头部(没有进行优化操作)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(root,p); <span class="comment">/* PUT(prevp,p); */</span></span><br><span class="line">        PUT(NEXT_LINKNODE_RP(p),nextp);</span><br><span class="line">        PUT(PREV_LINKNODE_RP(p),<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(nextp!=<span class="literal">NULL</span>) <span class="comment">// 根据优化操作进行调整</span></span><br><span class="line">            PUT(PREV_LINKNODE_RP(nextp),p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 插入该空间链表的中段（受优化操作影响）</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_LINKNODE_RP(prevp),p);</span><br><span class="line">        PUT(PREV_LINKNODE_RP(p),prevp);</span><br><span class="line">        PUT(NEXT_LINKNODE_RP(p),nextp);</span><br><span class="line">        <span class="keyword">if</span>(nextp!=<span class="literal">NULL</span>) </span><br><span class="line">            PUT(PREV_LINKNODE_RP(nextp),p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本逻辑：</p>
<p>一，先获取当前空间链表，进行优化操作：</p>
<ul>
<li>在同一个空间链表中，空闲块的大小也是有差异的，该优化操作会获取“root指向的那个空闲块”（第一个空闲块）比较改空闲块的大小，如果不符合条件，程序就会把“下一个空闲块”当做“root”继续进行后续操作（相当于把“root”和“第一个空闲块”向后“平移”了1个单位），这样操作保证了：小内存块在前，大内存块在后</li>
</ul>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645520942860-1651211896145.png" class width="1645520942860">  
<p>二，后续操作要分情况进行：</p>
<ul>
<li>插入该空间链表的头部：在“root”中写入指向它前驱的指针，在它的前驱中写入NULL，后继中写入第一个内存块的地址，最后调整第一个内存块的前驱指针</li>
</ul>
<img src="/2022/02/22/CSapp-Malloc%20Lab/1645521531541-1651211896146.png" class width="1645521531541"> 
<ul>
<li>插入该空间链表的中段：在“prevp”的后继中写入它自己的指针，在它的前驱中写入“prevp”，后继中写入“nextp”，最后调整“nextp”（第一个内存块）的前驱指针</li>
</ul>
<p><img src="/2022/02/22/CSapp-Malloc%20Lab/Users/ywx813/Desktop/CSAPP/Mylabs/8.malloc lab/malloc/1645520942860.png" alt="1645520942860"> </p>
<p>整体逻辑：</p>
<p>结合“find_fit”来看，本程序才用了 <strong>半个LIFO队列</strong> （后入先出，但又不完全是）</p>
<ul>
<li>获取空闲块时：从前往后进行遍历</li>
<li>插入空闲块时：尽可能插入头部</li>
</ul>
<p>这种对内存块进行大小排序，优先获取小内存块的做法的确提高了效率（指多打了1分）</p>
<p>打分&amp;完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  分离式空闲链表+首次适配 */</span></span><br><span class="line">➜  [/home/ywhkkx/malloclab-handout] ./mdriver -v</span><br><span class="line">Team Name:ateam</span><br><span class="line">Member <span class="number">1</span> :Harry Bovik:bovik@cs.cmu.edu</span><br><span class="line">Using <span class="keyword">default</span> tracefiles in /home/ywhkkx/malloclab-handout/traces/</span><br><span class="line"><span class="function">Measuring performance with <span class="title">gettimeofday</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Results <span class="keyword">for</span> mm <span class="built_in">malloc</span>:</span></span><br><span class="line"><span class="function">trace  valid  util     ops      secs  Kops</span></span><br><span class="line"><span class="function"> 0       yes   99%    5694  0.000104 54645</span></span><br><span class="line"><span class="function"> 1       yes   99%    5848  0.000097 60538</span></span><br><span class="line"><span class="function"> 2       yes   99%    6648  0.000271 24559</span></span><br><span class="line"><span class="function"> 3       yes  100%    5380  0.000103 52182</span></span><br><span class="line"><span class="function"> 4       yes   99%   14400  0.000096150000</span></span><br><span class="line"><span class="function"> 5       yes   95%    4800  0.001038  4624</span></span><br><span class="line"><span class="function"> 6       yes   95%    4800  0.000852  5636</span></span><br><span class="line"><span class="function"> 7       yes   55%   12000  0.000177 67912</span></span><br><span class="line"><span class="function"> 8       yes   51%   24000  0.000557 43103</span></span><br><span class="line"><span class="function"> 9       yes   22%   14401  0.042128   342</span></span><br><span class="line"><span class="function">10       yes   30%   14401  0.002138  6737</span></span><br><span class="line"><span class="function">Total          77%  112372  0.047560  2363</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Perf index </span>= <span class="number">46</span> (util) + <span class="number">40</span> (thru) = <span class="number">86</span>/<span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;memlib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* single word (4) or double word (8) alignment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x) &gt; (y)? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREALLOC(x) ((!x) ? 0 : 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size,alloc)    ((size) | (alloc))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)      (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p,val)  (*(unsigned int *)(p) = (val))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)     (GET(p) &amp; ~0x7) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p)    (GET(p) &amp; 0x1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_PREALLOC(p) (GET(p) &amp; 0x2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)        ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)   ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_LINKNODE_RP(bp) ((char*)(bp))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_LINKNODE_RP(bp) ((char*)(bp)+WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)   ((char*)(bp) + GET_SIZE(((char *)(bp) - WSIZE)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)   ((char*)(bp) - GET_SIZE(((char *)(bp) - DSIZE)))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_to_list</span><span class="params">(<span class="keyword">char</span>* p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fix_linklist</span><span class="params">(<span class="keyword">char</span>* p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">find_list_root</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* heap_listp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* block_list_start = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_init - initialize the malloc package.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">14</span> * WSIZE)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">4</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">5</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">6</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">7</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">8</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">9</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">10</span> * WSIZE), <span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">11</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">12</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">13</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    block_list_start = heap_listp;</span><br><span class="line">    heap_listp += (<span class="number">12</span> * WSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((extend_heap(CHUNKSIZE / DSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> dwords)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    size = (dwords % <span class="number">2</span>) ? (dwords + <span class="number">1</span>) * DSIZE : dwords * DSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == (<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(PREV_LINKNODE_RP(bp), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(NEXT_LINKNODE_RP(bp), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">coalesce</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span>  prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span>  next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*coalesce the block and change the point*/</span></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        insert_to_list(bp);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        fix_linklist(NEXT_BLKP(bp));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        fix_linklist(PREV_BLKP(bp));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(FTRP(NEXT_BLKP(bp))) + GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        fix_linklist(PREV_BLKP(bp));</span><br><span class="line">        fix_linklist(NEXT_BLKP(bp));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    insert_to_list(bp);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span></span><br><span class="line"><span class="comment"> *     Always allocate a block whose size is a multiple of the alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line">    <span class="keyword">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = (DSIZE) * ((size + (DSIZE)+(DSIZE - <span class="number">1</span>)) / (DSIZE));</span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / DSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Freeing a block does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bp == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(NEXT_LINKNODE_RP(bp), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(PREV_LINKNODE_RP(bp), <span class="literal">NULL</span>);</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* root = find_list_root(size);</span><br><span class="line">    <span class="keyword">for</span> (root; root != (heap_listp - (<span class="number">2</span> * WSIZE)); root += WSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* tmpP = GET(root);</span><br><span class="line">        <span class="keyword">while</span> (tmpP != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GET_SIZE(HDRP(tmpP)) &gt;= size)</span><br><span class="line">                <span class="keyword">return</span> tmpP;</span><br><span class="line">            tmpP = GET(NEXT_LINKNODE_RP(tmpP));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp, <span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    fix_linklist(bp);</span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span> * DSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        </span><br><span class="line">        PUT(HDRP(bp), PACK((csize - asize), <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK((csize - asize), <span class="number">0</span>));</span><br><span class="line">        PUT(NEXT_LINKNODE_RP(bp), <span class="number">0</span>);</span><br><span class="line">        PUT(PREV_LINKNODE_RP(bp), <span class="number">0</span>);</span><br><span class="line">        coalesce(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">void</span>* newptr = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">        <span class="keyword">return</span> newptr;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, ptr, (size &lt; oldsize ? size : oldsize));</span><br><span class="line">    mm_free(ptr);</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">find_list_root</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">8</span>) i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">16</span>) i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">32</span>) i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">64</span>) i = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">128</span>) i = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">256</span>) i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">512</span>) i = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">2048</span>) i = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">4096</span>) i = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span> i = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">return</span> block_list_start + (i * WSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fix_linklist</span><span class="params">(<span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* root = find_list_root(GET_SIZE(HDRP(p)));</span><br><span class="line">    <span class="keyword">char</span>* prevp = GET(PREV_LINKNODE_RP(p));</span><br><span class="line">    <span class="keyword">char</span>* nextp = GET(NEXT_LINKNODE_RP(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prevp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextp != <span class="literal">NULL</span>)PUT(PREV_LINKNODE_RP(nextp), <span class="number">0</span>);</span><br><span class="line">        PUT(root, nextp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextp != <span class="literal">NULL</span>)PUT(PREV_LINKNODE_RP(nextp), prevp);</span><br><span class="line">        PUT(NEXT_LINKNODE_RP(prevp), nextp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PUT(NEXT_LINKNODE_RP(p), <span class="literal">NULL</span>);</span><br><span class="line">    PUT(PREV_LINKNODE_RP(p), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert_to_list</span><span class="params">(<span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* root = find_list_root(GET_SIZE(HDRP(p)));</span><br><span class="line">    <span class="keyword">char</span>* prevp = root;</span><br><span class="line">    <span class="keyword">char</span>* nextp = GET(root); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nextp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GET_SIZE(HDRP(nextp)) &gt;= GET_SIZE(HDRP(p)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        prevp = nextp;</span><br><span class="line">        nextp = GET(NEXT_LINKNODE_RP(nextp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prevp == root)</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(root, p);</span><br><span class="line">        PUT(NEXT_LINKNODE_RP(p), nextp);</span><br><span class="line">        PUT(PREV_LINKNODE_RP(p), <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextp != <span class="literal">NULL</span>)</span><br><span class="line">            PUT(PREV_LINKNODE_RP(nextp), p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(NEXT_LINKNODE_RP(prevp), p);</span><br><span class="line">        PUT(PREV_LINKNODE_RP(p), prevp);</span><br><span class="line">        PUT(NEXT_LINKNODE_RP(p), nextp);</span><br><span class="line">        <span class="keyword">if</span> (nextp != <span class="literal">NULL</span>)</span><br><span class="line">            PUT(PREV_LINKNODE_RP(nextp), p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/labs/" rel="tag"><i class="fa fa-tag"></i> labs</a>
              <a href="/tags/CSapp/" rel="tag"><i class="fa fa-tag"></i> CSapp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/09/Ptmalloc%E7%AE%97%E6%B3%95%EF%BC%9AUnsortedbin%20Attack/" rel="prev" title="Ptmalloc算法：Unsortedbin Attack">
      <i class="fa fa-chevron-left"></i> Ptmalloc算法：Unsortedbin Attack
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/23/CSapp-Attack%20Lab/" rel="next" title="CSapp-Attack Lab">
      CSapp-Attack Lab <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Malloc-Lab"><span class="nav-number">1.</span> <span class="nav-text">Malloc Lab</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">动态内存分配器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="nav-number">3.</span> <span class="nav-text">分配器的基本规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5"><span class="nav-number">4.</span> <span class="nav-text">放置策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%9D%97%E5%88%86%E5%89%B2"><span class="nav-number">5.</span> <span class="nav-text">空闲块分割</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%A0%87%E8%AE%B0"><span class="nav-number">6.</span> <span class="nav-text">边界标记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="nav-number">7.</span> <span class="nav-text">性能提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%A8%8B%E5%BA%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">8.</span> <span class="nav-text">实验程序介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8-%E9%A6%96%E6%AC%A1%E9%80%82%E9%85%8D"><span class="nav-number">9.</span> <span class="nav-text">隐式空闲链表+首次适配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8-%E4%B8%8B%E6%AC%A1%E9%80%82%E9%85%8D"><span class="nav-number">10.</span> <span class="nav-text">隐式空闲链表+下次适配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%A9%BA%E9%97%B4%E9%93%BE%E8%A1%A8-%E9%A6%96%E6%AC%A1%E9%80%82%E9%85%8D-LIFO%E9%98%9F%E5%88%97"><span class="nav-number">11.</span> <span class="nav-text">显式空间链表+首次适配+LIFO队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8-%E4%B8%8B%E6%AC%A1%E9%80%82%E9%85%8D-%E5%A2%9E%E6%B7%BB%E6%A0%87%E8%AE%B0%E4%BD%8D"><span class="nav-number">12.</span> <span class="nav-text">隐式空闲链表+下次适配+增添标记位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E5%BC%8F%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8-%E9%A6%96%E6%AC%A1%E9%80%82%E9%85%8D"><span class="nav-number">13.</span> <span class="nav-text">分离式空闲链表+首次适配</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">198</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">2.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">39:32</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
