<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Go 是一种新的语言，一种并发的、带垃圾回收的、快速编译的语言，结合了解释型语言的游刃有余，动态类型语言的开发效率，以及静态类型的安全性 查看二进制文件的 go 语言版本： 1go version test 数据结构基本类型 12345678910111213package mainimport &quot;log&quot;func main() &amp;#123;	i :&#x3D; 1234	j :&#x3D; in">
<meta property="og:type" content="article">
<meta property="og:title" content="深入解析Go">
<meta property="og:url" content="http://example.com/2024/03/24/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Go/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:description" content="Go 是一种新的语言，一种并发的、带垃圾回收的、快速编译的语言，结合了解释型语言的游刃有余，动态类型语言的开发效率，以及静态类型的安全性 查看二进制文件的 go 语言版本： 1go version test 数据结构基本类型 12345678910111213package mainimport &quot;log&quot;func main() &amp;#123;	i :&#x3D; 1234	j :&#x3D; in">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/03/24/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Go/20200519101221568.png">
<meta property="og:image" content="http://example.com/2024/03/24/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Go/1711269291386.png">
<meta property="article:published_time" content="2024-03-24T11:09:28.000Z">
<meta property="article:modified_time" content="2024-03-24T11:11:07.484Z">
<meta property="article:author" content="yhellow">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/03/24/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Go/20200519101221568.png">

<link rel="canonical" href="http://example.com/2024/03/24/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Go/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>深入解析Go | Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/24/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入解析Go
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-03-24 19:09:28 / Modified: 19:11:07" itemprop="dateCreated datePublished" datetime="2024-03-24T19:09:28+08:00">2024-03-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>40k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>36 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Go 是一种新的语言，一种并发的、带垃圾回收的、快速编译的语言，结合了解释型语言的游刃有余，动态类型语言的开发效率，以及静态类型的安全性</p>
<p>查看二进制文件的 go 语言版本：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> version test</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>基本类型</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1234</span></span><br><span class="line">	j := <span class="keyword">int32</span>(<span class="number">1</span>)</span><br><span class="line">	f := <span class="keyword">float32</span>(<span class="number">3.14</span>)</span><br><span class="line">	bytes := [<span class="number">5</span>]<span class="keyword">byte</span>&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line">	primes := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">	log.Fatalf(<span class="string">&quot;%d %d %f %s %v&quot;</span>, i, j, f, bytes, primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>基础类型 go 与 c 几乎一致</li>
</ul>
<p><strong>结构体和指针</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">int</span> &#125;</span><br><span class="line"><span class="keyword">type</span> Rect1 <span class="keyword">struct</span>&#123; Min, Max Point &#125;</span><br><span class="line"><span class="keyword">type</span> Rect2 <span class="keyword">struct</span>&#123; Min, Max *Point &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	point := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 生成结构体</span></span><br><span class="line">	pointp := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 生成结构体,生成结构体指针指向该结构体</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(point.X, point.Y, point, pointp.X, pointp.Y, pointp)</span><br><span class="line"></span><br><span class="line">	r1 := Rect1&#123;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, Point&#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;</span><br><span class="line">	r2 := Rect2&#123;&amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &amp;Point&#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;</span><br><span class="line">	fmt.Println(r1, r2, r2.Max, r2.Min)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> &#123;<span class="number">1</span> <span class="number">2</span>&#125; <span class="number">1</span> <span class="number">2</span> &amp;&#123;<span class="number">1</span> <span class="number">2</span>&#125;</span><br><span class="line">&#123;&#123;<span class="number">1</span> <span class="number">2</span>&#125; &#123;<span class="number">3</span> <span class="number">4</span>&#125;&#125; &#123;<span class="number">0xc00001e100</span> <span class="number">0xc00001e110</span>&#125; &amp;&#123;<span class="number">3</span> <span class="number">4</span>&#125; &amp;&#123;<span class="number">1</span> <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不同于 c 语言 go 对指针进行了限制，生成指针后必须为其赋值</li>
</ul>
<p><strong>字符串</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;hello&quot;</span>	<span class="comment">// ptr=&amp;&quot;hello&quot;,len=5</span></span><br><span class="line">	t := s[<span class="number">2</span>:<span class="number">3</span>]		<span class="comment">// ptr=&amp;&quot;llo&quot;,len=1</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(s, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串在 go 语言内存模型中用一个 16 字节的数据结构表示，它包含一个指向字符串存储数据的指针和一个长度数据 </li>
<li>因为 string 类型是不可变的，对于多字符串共享同一个存储数据是安全的</li>
</ul>
<p><strong>切片和数组</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// 创建一个包含五个值的数组</span></span><br><span class="line">	y := x[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// 并不分配更多的数据,生成一个新的slice结构来引用相同的存储数据</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>] [<span class="number">2</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>切片是对数组的一个连续片段的引用，片段可以是整个数组，也可以是数组的一部分</li>
<li>在内存中，它是一个包含3个域的结构体：（数组的 slice 并不会实际复制一份数据，它只是创建一个新的数据结构）<ul>
<li>指向 slice 中第一个元素的指针</li>
<li>slice 的长度（下标操作的上界）</li>
<li>slice 的容量（分割操作的上界）</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">(x []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">	x = <span class="built_in">append</span>(x, <span class="number">6</span>) <span class="comment">/* 发生扩容,生成新的空间 */</span></span><br><span class="line">	x[<span class="number">1</span>] = <span class="number">200</span></span><br><span class="line">	fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Println(x)</span><br><span class="line"></span><br><span class="line">	fun1(x)</span><br><span class="line">	fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">100</span> <span class="number">200</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>] </span><br><span class="line">[<span class="number">100</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>在对 slice/array 进行 append 等操作时，可能会造成 slice 的自动扩容规则为：<ul>
<li>如果新的大小是当前大小2倍以上，则大小增长为新大小</li>
<li>否则循环以下操作：如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长，直到增长的大小超过或等于新大小</li>
</ul>
</li>
<li>扩容时生成了新的空间，导致 <code>x[1] = 200</code> 没有写入 main 中的数组</li>
<li>另外 main 中的 x 和 fun1 中的 x 是两个不同的对象，它们指向同一个数组但却拥有彼此独立的长度（main 中的 x 长度为 “5”，fun1 中的 x 长度为 “6”） </li>
</ul>
<p><strong>映射</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Map len = %d\n&quot;</span>, <span class="built_in">len</span>(m))</span><br><span class="line"></span><br><span class="line">	m[<span class="string">&quot;zero&quot;</span>] = <span class="number">0</span></span><br><span class="line">	m[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br><span class="line">	m[<span class="string">&quot;two&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Map len = %d\n&quot;</span>, <span class="built_in">len</span>(m))</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;zero = %T, %v\n&quot;</span>, m[<span class="string">&quot;zero&quot;</span>], m[<span class="string">&quot;zero&quot;</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;one = %T, %v\n&quot;</span>, m[<span class="string">&quot;one&quot;</span>], m[<span class="string">&quot;one&quot;</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;two = %T, %v\n&quot;</span>, m[<span class="string">&quot;two&quot;</span>], m[<span class="string">&quot;two&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map len = <span class="number">0</span></span><br><span class="line">Map len = <span class="number">3</span></span><br><span class="line">zero = <span class="keyword">int</span>, <span class="number">0</span></span><br><span class="line">one = <span class="keyword">int</span>, <span class="number">1</span></span><br><span class="line">two = <span class="keyword">int</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Map 是一种键值对的无序集合（go 中的 map 在底层是用哈希表实现的）</li>
</ul>
<p><strong>动态内存分配 make 和 new</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := <span class="built_in">new</span>(user)</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(u)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock sync.Mutex</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于动态内存申请，go 有两个不同的关键字 make 和 new：</p>
<ul>
<li>make 的作用是初始化内置的数据结构（slice ，map，channel）</li>
<li>new 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x4804e0</span> &lt;main.main+<span class="number">32</span>&gt;    call   <span class="number">40</span>c100h                       &lt;runtime[newobject]&gt; <span class="comment">/* new */</span></span><br><span class="line">    </span><br><span class="line">RAX  <span class="number">0x48f5e0</span> (type:*+<span class="number">58848</span>) ◂— <span class="number">0x20</span> <span class="comment">/* &#x27; &#x27; */</span></span><br><span class="line">RBX  <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x480500</span> &lt;main.main+<span class="number">64</span>&gt;    call   <span class="number">445f</span>a0h                       &lt;runtime[makeslice]&gt; <span class="comment">/* make */</span></span><br><span class="line">    </span><br><span class="line">RAX  <span class="number">0x487e80</span> (type:*+<span class="number">28288</span>) ◂— <span class="number">0x8</span></span><br><span class="line">RBX  <span class="number">0x5</span></span><br><span class="line">RCX  <span class="number">0x64</span></span><br></pre></td></tr></table></figure>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p><strong>调用约定</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addtest</span><span class="params">(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	addtest(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x4805f8</span> &lt;main.main+<span class="number">24</span>&gt;    mov    qword ptr [rsp], <span class="number">0</span>ah</span><br><span class="line">  <span class="number">0x480600</span> &lt;main.main+<span class="number">32</span>&gt;    mov    qword ptr [rsp + <span class="number">8</span>], <span class="number">0b</span>h</span><br><span class="line">  <span class="number">0x480609</span> &lt;main.main+<span class="number">41</span>&gt;    mov    qword ptr [rsp + <span class="number">10</span>h], <span class="number">0</span>ch</span><br><span class="line">  <span class="number">0x480612</span> &lt;main.main+<span class="number">50</span>&gt;    mov    qword ptr [rsp + <span class="number">18</span>h], <span class="number">0</span>dh</span><br><span class="line">  <span class="number">0x48061b</span> &lt;main.main+<span class="number">59</span>&gt;    mov    qword ptr [rsp + <span class="number">20</span>h], <span class="number">0</span>eh</span><br><span class="line">  <span class="number">0x480624</span> &lt;main.main+<span class="number">68</span>&gt;    mov    qword ptr [rsp + <span class="number">28</span>h], <span class="number">0f</span>h</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x48062d</span> &lt;main.main+<span class="number">77</span>&gt;     mov    eax, <span class="number">1</span>                        &lt;main.main&gt;</span><br><span class="line">  <span class="number">0x480632</span> &lt;main.main+<span class="number">82</span>&gt;     mov    ebx, <span class="number">2</span></span><br><span class="line">  <span class="number">0x480637</span> &lt;main.main+<span class="number">87</span>&gt;     mov    ecx, <span class="number">3</span></span><br><span class="line">  <span class="number">0x48063c</span> &lt;main.main+<span class="number">92</span>&gt;     mov    edi, <span class="number">4</span></span><br><span class="line">  <span class="number">0x480641</span> &lt;main.main+<span class="number">97</span>&gt;     mov    esi, <span class="number">5</span></span><br><span class="line">  <span class="number">0x480646</span> &lt;main.main+<span class="number">102</span>&gt;    mov    r8d, <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前9个参数进入寄存器，后续参数存放入栈中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0xc00007cef0</span> —▸ <span class="number">0x480665</span> (main.main+<span class="number">133</span>) ◂— mov    rbp, qword ptr [rsp + <span class="number">78</span>h]</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0xc00007cef8</span> ◂— <span class="number">0xa</span> <span class="comment">/* &#x27;\n&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0xc00007cf00</span> ◂— <span class="number">0xb</span> <span class="comment">/* &#x27;\x0b&#x27; */</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0xc00007cf08</span> ◂— <span class="number">0xc</span> <span class="comment">/* &#x27;\x0c&#x27; */</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0xc00007cf10</span> ◂— <span class="number">0xd</span> <span class="comment">/* &#x27;\r&#x27; */</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0xc00007cf18</span> ◂— <span class="number">0xe</span></span><br></pre></td></tr></table></figure>
<p><strong>多值返回</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retest</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(retest())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RAX  <span class="number">0x498948</span> (go:<span class="built_in">string</span>.*+<span class="number">1328</span>) ◂— <span class="number">0x3131313131313131</span> (<span class="string">&#x27;11111111&#x27;</span>)</span><br><span class="line">RBX  <span class="number">0x7</span></span><br><span class="line">RCX  <span class="number">0x498956</span> (go:<span class="built_in">string</span>.*+<span class="number">1342</span>) ◂— <span class="number">0x3332323232323232</span> (<span class="string">&#x27;22222223&#x27;</span>)</span><br><span class="line">RDX  <span class="number">0x8</span></span><br><span class="line">RDI  <span class="number">0x7</span></span><br><span class="line">RSI  <span class="number">0x49895d</span> (go:<span class="built_in">string</span>.*+<span class="number">1349</span>) ◂— <span class="number">0x3933333333333333</span> (<span class="string">&#x27;33333339&#x27;</span>)</span><br><span class="line">R8   <span class="number">0x7</span></span><br><span class="line">R9   <span class="number">0x0</span></span><br><span class="line">R10  <span class="number">0x60</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回值会使用9个寄存器，剩下的存储在栈中</li>
</ul>
<p><strong>闭包</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incSeq</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="comment">/* 这个函数中本身没有定义变量i,而是引用了它所在的环境中的变量i */</span></span><br><span class="line">		i++</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	next := incSeq()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;start = %d\n&quot;</span>, next())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;index(%d) = %d\n&quot;</span>, i, next())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start = <span class="number">1</span></span><br><span class="line">index(<span class="number">1</span>) = <span class="number">2</span></span><br><span class="line">index(<span class="number">2</span>) = <span class="number">3</span></span><br><span class="line">index(<span class="number">3</span>) = <span class="number">4</span></span><br><span class="line">index(<span class="number">4</span>) = <span class="number">5</span></span><br><span class="line">index(<span class="number">5</span>) = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>闭包是由函数及其相关引用环境组合而成的实体</li>
<li>返回闭包时并不是单纯返回一个函数，而是返回了一个结构体，记录有函数的返回地址和引用环境中的变量地址</li>
<li>最后还有一个小问题，<code>var i = 0</code> 原本应该分配到栈上，但 go 编译器会自动识别这种情况并将其分配到堆上</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incSeq</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	next := incSeq()</span><br><span class="line">	next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build --gcflags=-m test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 escape analyze</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">3</span>:<span class="number">6</span>: can inline incSeq</span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">9</span>: can inline incSeq.func1</span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">12</span>:<span class="number">16</span>: inlining call to incSeq</span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">9</span>: can inline main.func1</span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">13</span>:<span class="number">6</span>: inlining call to main.func1</span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">4</span>:<span class="number">6</span>: moved to heap: i <span class="comment">/* 被转移到堆空间 */</span></span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">9</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">./test.<span class="keyword">go</span>:<span class="number">12</span>:<span class="number">16</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">does</span> <span class="title">not</span> <span class="title">escape</span></span></span><br></pre></td></tr></table></figure>
<p><strong>关键字-go</strong></p>
<p>go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine（协程，轻量级线程）即可</p>
<ul>
<li>协程：子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotest</span><span class="params">(a, b, c <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(a, b, c)</span><br><span class="line">	<span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> gotest(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>go 关键字的底层其实是调用 runtime.newproc 函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x4805e0</span> &lt;main.main+<span class="number">32</span>&gt;    call   <span class="number">43b</span>c80h                       &lt;runtime[newproc]&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAX  <span class="number">0x4a0970</span> (<span class="keyword">go</span>:<span class="keyword">func</span>.*+<span class="number">552</span>) —▸ <span class="number">0x480600</span> (main.main.func1) ◂— cmp    rsp, qword ptr [r14 + <span class="number">10</span>h]</span><br><span class="line">RBX  <span class="number">0x0</span></span><br><span class="line">RCX  <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数 runtime.newproc 负责启动一个新的线程（协程），新建一个栈空间，将栈参数拷贝到新栈空间中并让栈指针指向参数 </li>
<li>另外编译器会为 gotest 生成一个辅助函数，IDA 分析如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __golang <span class="title">main_main_func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 v0; <span class="comment">// rbp</span></span><br><span class="line">    <span class="keyword">int</span> v1; <span class="comment">// r14</span></span><br><span class="line">    <span class="keyword">char</span> **v2; <span class="comment">// r12</span></span><br><span class="line">    __int64 v3[<span class="number">4</span>]; <span class="comment">// [rsp-18h] [rbp-20h] BYREF</span></span><br><span class="line">    <span class="keyword">void</span> *retaddr; <span class="comment">// [rsp+8h] [rbp+0h] BYREF</span></span><br><span class="line">    <span class="keyword">char</span> v5; <span class="comment">// [rsp+10h] [rbp+8h] BYREF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;retaddr &lt;= *(_QWORD *)(v1 + <span class="number">16LL</span>) )</span><br><span class="line">        runtime_morestack_noctxt();</span><br><span class="line">    v3[<span class="number">3LL</span>] = v0;</span><br><span class="line">    v2 = *(<span class="keyword">char</span> ***)(v1 + <span class="number">32LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v2 &amp;&amp; *v2 == &amp;v5 )</span><br><span class="line">        *v2 = (<span class="keyword">char</span> *)v3;</span><br><span class="line">    main_gotest(v3[<span class="number">0LL</span>], v3[<span class="number">1LL</span>], v3[<span class="number">2LL</span>]); <span class="comment">/* 执行原函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键字-defer</strong></p>
<p>defer 用于资源的释放，会在函数返回之前进行调用（defer 语句保证了不论是在正常情况下，还是非正常情况下，函数或方法都能够执行）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    A()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 return 之前，程序会调用 defer 表达式</li>
<li>如果有多个 defer 表达式，调用顺序类似于栈，越后面的 defer 表达式越先被调用</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t := <span class="number">5</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t = t + <span class="number">5</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        r = r + <span class="number">5</span></span><br><span class="line">    &#125;(r)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(f())</span><br><span class="line">    fmt.Println(f2())</span><br><span class="line">    fmt.Println(f3())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>return 这一条语句并不是一条原子指令，它拥有赋值和返回两个步骤，而 defer 语句则会在这两个步骤之间运行</li>
<li>因此上面的样例可以等价修改成下面的代码：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* 返回值为&#x27;1&#x27; */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t := <span class="number">5</span></span><br><span class="line">    r = t</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t = t + <span class="number">5</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* 返回值为&#x27;5&#x27; */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    r = <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        r = r + <span class="number">5</span></span><br><span class="line">    &#125;(r)</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* 返回值为&#x27;1&#x27; */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(f())</span><br><span class="line">    fmt.Println(f2())</span><br><span class="line">    fmt.Println(f3())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译器会先为每个 defer 语句生成一个辅助函数，然后在返回值赋值以后函数执行 ret 指令之前调用该函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x458096</span> &lt;main[A]+<span class="number">86</span>&gt;     call   <span class="number">458100</span>h                       &lt;main.A.func1&gt;</span><br></pre></td></tr></table></figure>
<p><strong>分段栈和连续栈</strong></p>
<p>goroutine 可以初始时只给栈分配很小的空间，然后随着使用过程中的需要自动地增长 </p>
<ul>
<li>每次执行函数调用时 Go 的 runtime 都会进行检测，若当前栈的大小不够用，则会触发“中断”，从当前函数进入到 Go 的运行时库</li>
<li>然后分配一个新的足够大的栈空间，接下来的处理有不同的策略</li>
</ul>
<p>在 IDA 的伪代码中经常可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;retaddr &lt;= *(_QWORD *)(v1 + <span class="number">16LL</span>) )</span><br><span class="line">  runtime_morestack_noctxt();</span><br></pre></td></tr></table></figure>
<ul>
<li>函数 morestack_noctxt 用于扩展栈 </li>
</ul>
<p>在 go-1.3 版本之前，使用的栈结构是分段栈：</p>
<ul>
<li>随着 goroutine 调用的函数层级的深入或者局部变量需要的越来越多时，栈空间可能会出现不够用的情况</li>
<li>在运行时会调用 runtime.morestack 和 runtime.newstack 创建一个新的栈空间，这些栈空间是不连续的，当前 goroutine 的多个栈空间会以双向链表的形式串联起来，运行时会通过指针找到各个栈片段</li>
<li>当调用回溯的时候，不再使用的栈空间将会被系统回收</li>
</ul>
<p>但分段栈有一个问题，如果当前 goroutine 的栈几乎充满，那么任意的函数调用都会触发栈的扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题</p>
<p>连续栈可以解决分段栈中存在的两个问题：</p>
<ul>
<li>其核心原理就是每当程序的栈空间不足时，初始化一片比旧栈大两倍的新栈并将原栈中的所有值都迁移到新的栈中，新的局部变量或者函数调用就有了充足的内存空间</li>
</ul>
<p>使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：</p>
<ul>
<li>调用用 runtime.newstack 在内存空间中分配更大的栈内存空间</li>
<li>使用 runtime.copystack 将旧栈中的所有内容复制到新的栈中</li>
<li>将指向旧栈对应变量的指针重新指向新栈</li>
<li>调用 runtime.stackfree 销毁并回收旧栈的内存空间</li>
</ul>
<p><strong>系统调用</strong></p>
<p>go 的 syscall 库中提供了对系统调用的封装，它会在真正执行系统调用之前先调用函数 entersyscall，并在系统调用函数返回后调用 exitsyscall 函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">syscall_syscall</span><span class="params">(fn, a1, a2, a3 <span class="keyword">uintptr</span>)</span> <span class="params">(r1, r2, err <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">	args := <span class="keyword">struct</span>&#123; fn, a1, a2, a3, r1, r2, err <span class="keyword">uintptr</span> &#125;&#123;fn, a1, a2, a3, r1, r2, err&#125;</span><br><span class="line">	entersyscall()</span><br><span class="line">	libcCall(unsafe.Pointer(abi.FuncPCABI0(syscall)), unsafe.Pointer(&amp;args))</span><br><span class="line">	exitsyscall()</span><br><span class="line">	<span class="keyword">return</span> args.r1, args.r2, args.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数就是通知 go 的运行时库这个 goroutine 进入了系统调用或者完成了系统调用，调度器会做相应的调度</p>
<ul>
<li>entersyscall：<ul>
<li>把当前 M 的 P 设置为 _Psyscall 状态，打上标识解绑 P -&gt; M 的绑定，但 M 还保留 P 的指针</li>
</ul>
</li>
<li>existsyscall：<ul>
<li>由于 M 到 P 的指向还在，那么优先还是用原来的 P，如果原来的 P 被处理掉了，那么就去用一个新的 P，如果还没有，那就只能把 G 挂到全局队列了</li>
<li>Go 的 sysmon（内部监控线程）发现有这种卡了超过 10 ms 的 M ，那么就会把 P 剥离出来，给到其他的 M 去处理执行，M 数量不够就会新创建</li>
</ul>
</li>
</ul>
<h2 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h2><p>go 的调度的实现，涉及到几个重要的数据结构，运行时库用这几个数据结构来实现 goroutine 的调度，管理 goroutine 和物理线程的运行，这些数据结构分别是结构体G，结构体M，结构体P，以及Sched结构体 </p>
<ul>
<li>定义在文件 runtime/runtime2.go 中</li>
<li>源码地址：<a target="_blank" rel="noopener" href="https://github1s.com/golang/go/blob/master/src/runtime/runtime2.go">runtime2.go - golang/go - GitHub1s</a> </li>
</ul>
<p><strong>结构体G</strong></p>
<p>G 是 goroutine 的缩写，相当于操作系统中的进程控制块，在这里就是 goroutine 的控制结构，是对 goroutine 的抽象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack       stack   <span class="comment">// offset known to runtime/cgo</span></span><br><span class="line">    <span class="comment">/*	type stack struct &#123;</span></span><br><span class="line"><span class="comment">            lo uintptr // 该协程拥有的栈低位</span></span><br><span class="line"><span class="comment">            hi uintptr // 该协程拥有的栈高位</span></span><br><span class="line"><span class="comment">    	&#125; */</span></span><br><span class="line">    stackguard0 <span class="keyword">uintptr</span> <span class="comment">// 检查栈空间是否足够的值,低于这个值会扩张栈</span></span><br><span class="line">    stackguard1 <span class="keyword">uintptr</span> <span class="comment">// 检查栈空间是否足够的值,低于这个值会扩张栈</span></span><br><span class="line"></span><br><span class="line">    _panic    *_panic <span class="comment">// innermost panic - offset known to liblink</span></span><br><span class="line">    _defer    *_defer <span class="comment">// innermost defer</span></span><br><span class="line">    m         *m      <span class="comment">// current m; offset known to arm liblink</span></span><br><span class="line">    sched     gobuf   <span class="comment">// 用于记录协程切换的上下文</span></span><br><span class="line">    syscallsp <span class="keyword">uintptr</span> <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span></span><br><span class="line">    syscallpc <span class="keyword">uintptr</span> <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span></span><br><span class="line">    stktopsp  <span class="keyword">uintptr</span> <span class="comment">// expected sp at top of stack, to check in traceback</span></span><br><span class="line">    <span class="comment">// param is a generic pointer parameter field used to pass</span></span><br><span class="line">    <span class="comment">// values in particular contexts where other storage for the</span></span><br><span class="line">    <span class="comment">// parameter would be difficult to find. It is currently used</span></span><br><span class="line">    <span class="comment">// in four ways:</span></span><br><span class="line">    <span class="comment">// 1. When a channel operation wakes up a blocked goroutine, it sets param to</span></span><br><span class="line">    <span class="comment">//    point to the sudog of the completed blocking operation.</span></span><br><span class="line">    <span class="comment">// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed</span></span><br><span class="line">    <span class="comment">//    the GC cycle. It is unsafe to do so in any other way, because the goroutine&#x27;s</span></span><br><span class="line">    <span class="comment">//    stack may have moved in the meantime.</span></span><br><span class="line">    <span class="comment">// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a</span></span><br><span class="line">    <span class="comment">//    closure in the runtime is forbidden.</span></span><br><span class="line">    <span class="comment">// 4. When a panic is recovered and control returns to the respective frame,</span></span><br><span class="line">    <span class="comment">//    param may point to a savedOpenDeferState.</span></span><br><span class="line">    param        unsafe.Pointer <span class="comment">// 用于传递参数,睡眠时其它goroutine设置param,唤醒时此goroutine可以获取</span></span><br><span class="line">    atomicstatus atomic.Uint32</span><br><span class="line">    stackLock    <span class="keyword">uint32</span> <span class="comment">// sigprof/scang lock; <span class="doctag">TODO:</span> fold in to atomicstatus</span></span><br><span class="line">    goid         <span class="keyword">uint64</span> <span class="comment">// goroutine的id号</span></span><br><span class="line">    schedlink    guintptr</span><br><span class="line">    waitsince    <span class="keyword">int64</span>      <span class="comment">// approx time when the g become blocked</span></span><br><span class="line">    waitreason   waitReason <span class="comment">// if status==Gwaiting</span></span><br><span class="line"></span><br><span class="line">    preempt       <span class="keyword">bool</span> <span class="comment">// preemption signal, duplicates stackguard0 = stackpreempt</span></span><br><span class="line">    preemptStop   <span class="keyword">bool</span> <span class="comment">// transition to _Gpreempted on preemption; otherwise, just deschedule</span></span><br><span class="line">    preemptShrink <span class="keyword">bool</span> <span class="comment">// shrink stack at synchronous safe point</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// asyncSafePoint is set if g is stopped at an asynchronous</span></span><br><span class="line">    <span class="comment">// safe point. This means there are frames on the stack</span></span><br><span class="line">    <span class="comment">// without precise pointer information.</span></span><br><span class="line">    asyncSafePoint <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    paniconfault <span class="keyword">bool</span> <span class="comment">// panic (instead of crash) on unexpected fault address</span></span><br><span class="line">    gcscandone   <span class="keyword">bool</span> <span class="comment">// g has scanned stack; protected by _Gscan bit in status</span></span><br><span class="line">    throwsplit   <span class="keyword">bool</span> <span class="comment">// must not split stack</span></span><br><span class="line">    <span class="comment">// activeStackChans indicates that there are unlocked channels</span></span><br><span class="line">    <span class="comment">// pointing into this goroutine&#x27;s stack. If true, stack</span></span><br><span class="line">    <span class="comment">// copying needs to acquire channel locks to protect these</span></span><br><span class="line">    <span class="comment">// areas of the stack.</span></span><br><span class="line">    activeStackChans <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// parkingOnChan indicates that the goroutine is about to</span></span><br><span class="line">    <span class="comment">// park on a chansend or chanrecv. Used to signal an unsafe point</span></span><br><span class="line">    <span class="comment">// for stack shrinking.</span></span><br><span class="line">    parkingOnChan atomic.Bool</span><br><span class="line">    <span class="comment">// inMarkAssist indicates whether the goroutine is in mark assist.</span></span><br><span class="line">    <span class="comment">// Used by the execution tracer.</span></span><br><span class="line">    inMarkAssist <span class="keyword">bool</span></span><br><span class="line">    coroexit     <span class="keyword">bool</span> <span class="comment">// argument to coroswitch_m</span></span><br><span class="line"></span><br><span class="line">    raceignore    <span class="keyword">int8</span>  <span class="comment">// ignore race detection events</span></span><br><span class="line">    nocgocallback <span class="keyword">bool</span>  <span class="comment">// whether disable callback from C</span></span><br><span class="line">    tracking      <span class="keyword">bool</span>  <span class="comment">// whether we&#x27;re tracking this G for sched latency statistics</span></span><br><span class="line">    trackingSeq   <span class="keyword">uint8</span> <span class="comment">// used to decide whether to track this G</span></span><br><span class="line">    trackingStamp <span class="keyword">int64</span> <span class="comment">// timestamp of when the G last started being tracked</span></span><br><span class="line">    runnableTime  <span class="keyword">int64</span> <span class="comment">// the amount of time spent runnable, cleared when running, only used when tracking</span></span><br><span class="line">    lockedm       muintptr <span class="comment">// G被锁定只能在这个M上运行</span></span><br><span class="line">    sig           <span class="keyword">uint32</span></span><br><span class="line">    writebuf      []<span class="keyword">byte</span></span><br><span class="line">    sigcode0      <span class="keyword">uintptr</span></span><br><span class="line">    sigcode1      <span class="keyword">uintptr</span></span><br><span class="line">    sigpc         <span class="keyword">uintptr</span></span><br><span class="line">    parentGoid    <span class="keyword">uint64</span>          <span class="comment">// 父类goroutine的goid</span></span><br><span class="line">    gopc          <span class="keyword">uintptr</span>         <span class="comment">// 创建这个goroutine的go表达式的pc</span></span><br><span class="line">    ancestors     *[]ancestorInfo <span class="comment">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)</span></span><br><span class="line">    startpc       <span class="keyword">uintptr</span>         <span class="comment">// pc of goroutine function</span></span><br><span class="line">    racectx       <span class="keyword">uintptr</span></span><br><span class="line">    waiting       *sudog         <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span></span><br><span class="line">    cgoCtxt       []<span class="keyword">uintptr</span>      <span class="comment">// cgo traceback context</span></span><br><span class="line">    labels        unsafe.Pointer <span class="comment">// profiler labels</span></span><br><span class="line">    timer         *timer         <span class="comment">// cached timer for time.Sleep</span></span><br><span class="line">    sleepWhen     <span class="keyword">int64</span>          <span class="comment">// when to sleep until</span></span><br><span class="line">    selectDone    atomic.Uint32  <span class="comment">// are we participating in a select and did someone win the race?</span></span><br><span class="line"></span><br><span class="line">    coroarg *coro <span class="comment">// argument during coroutine transfers</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// goroutineProfiled indicates the status of this goroutine&#x27;s stack for the</span></span><br><span class="line">    <span class="comment">// current in-progress goroutine profile</span></span><br><span class="line">    goroutineProfiled goroutineProfileStateHolder</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-G tracer state.</span></span><br><span class="line">    trace gTraceState</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-G GC state</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcAssistBytes is this G&#x27;s GC assist credit in terms of</span></span><br><span class="line">    <span class="comment">// bytes allocated. If this is positive, then the G has credit</span></span><br><span class="line">    <span class="comment">// to allocate gcAssistBytes bytes without assisting. If this</span></span><br><span class="line">    <span class="comment">// is negative, then the G must correct this by performing</span></span><br><span class="line">    <span class="comment">// scan work. We track this in bytes to make it fast to update</span></span><br><span class="line">    <span class="comment">// and check for debt in the malloc hot path. The assist ratio</span></span><br><span class="line">    <span class="comment">// determines how this corresponds to scan work debt.</span></span><br><span class="line">    gcAssistBytes <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>goroutine 切换时，上下文信息保存在结构体的 sched 域中，goroutine 切换时并不必陷入到操作系统内核中</li>
</ul>
<p><strong>结构体M</strong></p>
<p>M 是 machine 的缩写，是对机器的抽象，每个 M 都是对应到一条操作系统的物理线程 </p>
<ul>
<li>M 必须关联了 P 才可以执行 go 代码</li>
<li>当它处理阻塞或者系统调用时，可以不需要关联 P</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g     <span class="comment">// 带有调度栈的goroutine</span></span><br><span class="line">    morebuf gobuf  <span class="comment">// gobuf arg to morestack</span></span><br><span class="line">    divmod  <span class="keyword">uint32</span> <span class="comment">// div/mod denominator for arm - known to liblink</span></span><br><span class="line">    _       <span class="keyword">uint32</span> <span class="comment">// align next field to 8 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields not known to debuggers.</span></span><br><span class="line">    procid        <span class="keyword">uint64</span>            <span class="comment">// for debuggers, but offset not hard-coded</span></span><br><span class="line">    gsignal       *g                <span class="comment">// 关联P以执行Go代码</span></span><br><span class="line">    goSigStack    gsignalStack      <span class="comment">// Go-allocated signal handling stack</span></span><br><span class="line">    sigmask       sigset            <span class="comment">// storage for saved signal mask</span></span><br><span class="line">    tls           [tlsSlots]<span class="keyword">uintptr</span> <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    curg          *g       <span class="comment">// M中当前运行的goroutine</span></span><br><span class="line">    caughtsig     guintptr <span class="comment">// goroutine running during fatal signal</span></span><br><span class="line">    p             puintptr <span class="comment">// attached p for executing go code (nil if not executing go code)</span></span><br><span class="line">    nextp         puintptr</span><br><span class="line">    oldp          puintptr <span class="comment">// the p that was attached before executing a syscall</span></span><br><span class="line">    id            <span class="keyword">int64</span></span><br><span class="line">    mallocing     <span class="keyword">int32</span>	<span class="comment">// 状态</span></span><br><span class="line">    throwing      throwType</span><br><span class="line">    preemptoff    <span class="keyword">string</span> <span class="comment">// if != &quot;&quot;, keep curg running on this m</span></span><br><span class="line">    locks         <span class="keyword">int32</span></span><br><span class="line">    dying         <span class="keyword">int32</span></span><br><span class="line">    profilehz     <span class="keyword">int32</span></span><br><span class="line">    spinning      <span class="keyword">bool</span> <span class="comment">// m is out of work and is actively looking for work</span></span><br><span class="line">    blocked       <span class="keyword">bool</span> <span class="comment">// m is blocked on a note</span></span><br><span class="line">    newSigstack   <span class="keyword">bool</span> <span class="comment">// minit on C thread called sigaltstack</span></span><br><span class="line">    printlock     <span class="keyword">int8</span></span><br><span class="line">    incgo         <span class="keyword">bool</span>          <span class="comment">// m is executing a cgo call</span></span><br><span class="line">    isextra       <span class="keyword">bool</span>          <span class="comment">// m is an extra m</span></span><br><span class="line">    isExtraInC    <span class="keyword">bool</span>          <span class="comment">// m is an extra m that is not executing Go code</span></span><br><span class="line">    isExtraInSig  <span class="keyword">bool</span>          <span class="comment">// m is an extra m in a signal handler</span></span><br><span class="line">    freeWait      atomic.Uint32 <span class="comment">// Whether it is safe to free g0 and delete m (one of freeMRef, freeMStack, freeMWait)</span></span><br><span class="line">    needextram    <span class="keyword">bool</span></span><br><span class="line">    traceback     <span class="keyword">uint8</span></span><br><span class="line">    ncgocall      <span class="keyword">uint64</span>        <span class="comment">// number of cgo calls in total</span></span><br><span class="line">    ncgo          <span class="keyword">int32</span>         <span class="comment">// number of cgo calls currently in progress</span></span><br><span class="line">    cgoCallersUse atomic.Uint32 <span class="comment">// if non-zero, cgoCallers in use temporarily</span></span><br><span class="line">    cgoCallers    *cgoCallers   <span class="comment">// cgo traceback if crashing in cgo call</span></span><br><span class="line">    park          note</span><br><span class="line">    alllink       *m <span class="comment">// 用于链接allm</span></span><br><span class="line">    schedlink     muintptr</span><br><span class="line">    lockedg       guintptr</span><br><span class="line">    createstack   [<span class="number">32</span>]<span class="keyword">uintptr</span> <span class="comment">// stack that created this thread, it&#x27;s used for StackRecord.Stack0, so it must align with it.</span></span><br><span class="line">    lockedExt     <span class="keyword">uint32</span>      <span class="comment">// tracking for external LockOSThread</span></span><br><span class="line">    lockedInt     <span class="keyword">uint32</span>      <span class="comment">// tracking for internal lockOSThread</span></span><br><span class="line">    nextwaitm     muintptr    <span class="comment">// next m waiting for lock</span></span><br><span class="line"></span><br><span class="line">    mLockProfile mLockProfile <span class="comment">// fields relating to runtime.lock contention</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait* are used to carry arguments from gopark into park_m, because</span></span><br><span class="line">    <span class="comment">// there&#x27;s no stack to put them on. That is their sole purpose.</span></span><br><span class="line">    waitunlockf          <span class="function"><span class="keyword">func</span><span class="params">(*g, unsafe.Pointer)</span> <span class="title">bool</span></span></span><br><span class="line">    waitlock             unsafe.Pointer</span><br><span class="line">    waitTraceBlockReason traceBlockReason</span><br><span class="line">    waitTraceSkip        <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    syscalltick <span class="keyword">uint32</span></span><br><span class="line">    freelink    *m <span class="comment">// on sched.freem</span></span><br><span class="line">    trace       mTraceState</span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are here because they are too large to be on the stack</span></span><br><span class="line">    <span class="comment">// of low-level NOSPLIT functions.</span></span><br><span class="line">    libcall   libcall</span><br><span class="line">    libcallpc <span class="keyword">uintptr</span> <span class="comment">// for cpu profiler</span></span><br><span class="line">    libcallsp <span class="keyword">uintptr</span></span><br><span class="line">    libcallg  guintptr</span><br><span class="line">    syscall   libcall <span class="comment">// stores syscall parameters on windows</span></span><br><span class="line"></span><br><span class="line">    vdsoSP <span class="keyword">uintptr</span> <span class="comment">// SP for traceback while in VDSO call (0 if not in call)</span></span><br><span class="line">    vdsoPC <span class="keyword">uintptr</span> <span class="comment">// PC for traceback while in VDSO call</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// preemptGen counts the number of completed preemption</span></span><br><span class="line">    <span class="comment">// signals. This is used to detect when a preemption is</span></span><br><span class="line">    <span class="comment">// requested, but fails.</span></span><br><span class="line">    preemptGen atomic.Uint32</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Whether this is a pending preemption signal on this M.</span></span><br><span class="line">    signalPending atomic.Uint32</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pcvalue lookup cache</span></span><br><span class="line">    pcvalueCache pcvalueCache</span><br><span class="line"></span><br><span class="line">    dlogPerM</span><br><span class="line"></span><br><span class="line">    mOS</span><br><span class="line"></span><br><span class="line">    chacha8   chacha8rand.State</span><br><span class="line">    cheaprand <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Up to 10 locks held by this m, maintained by the lock ranking code.</span></span><br><span class="line">    locksHeldLen <span class="keyword">int</span></span><br><span class="line">    locksHeld    [<span class="number">10</span>]heldLockInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>普通的 goroutine 的栈是在堆上分配的可增长的栈，而 g0 的栈是 M 对应的线程的栈</li>
<li>所有调度相关的代码，会先切换到该 goroutine 的栈中再执行 </li>
</ul>
<p><strong>结构体P</strong></p>
<p>P 是 Processor 逻辑处理器的缩写，每个 P 拥有一个本地队列并为 G 在 M 上的运行提供本地化资源</p>
<ul>
<li>M 代表 OS 线程，P 代表 go 代码执行时需要的资源，当 M 执行 go 代码时，它需要关联一个 P</li>
<li>所有的 P 被组织为一个数组，在 P 上实现了工作流窃取的调度器 </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    id          <span class="keyword">int32</span></span><br><span class="line">    status      <span class="keyword">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line">    link        puintptr</span><br><span class="line">    schedtick   <span class="keyword">uint32</span>     <span class="comment">// 每次调度时将它+1</span></span><br><span class="line">    syscalltick <span class="keyword">uint32</span>     <span class="comment">// incremented on every system call</span></span><br><span class="line">    sysmontick  sysmontick <span class="comment">// last tick observed by sysmon</span></span><br><span class="line">    m           muintptr   <span class="comment">// back-link to associated m (nil if idle)</span></span><br><span class="line">    mcache      *mcache	   <span class="comment">// 系统线程缓存</span></span><br><span class="line">    pcache      pageCache</span><br><span class="line">    raceprocctx <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    deferpool    []*_defer <span class="comment">// pool of available defer structs (see panic.go)</span></span><br><span class="line">    deferpoolbuf [<span class="number">32</span>]*_defer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line">    goidcache    <span class="keyword">uint64</span></span><br><span class="line">    goidcacheend <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue of runnable goroutines. Accessed without lock.</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    <span class="comment">// runnext, if non-nil, is a runnable G that was ready&#x27;d by</span></span><br><span class="line">    <span class="comment">// the current G and should be run next instead of what&#x27;s in</span></span><br><span class="line">    <span class="comment">// runq if there&#x27;s time remaining in the running G&#x27;s time</span></span><br><span class="line">    <span class="comment">// slice. It will inherit the time left in the current time</span></span><br><span class="line">    <span class="comment">// slice. If a set of goroutines is locked in a</span></span><br><span class="line">    <span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span><br><span class="line">    <span class="comment">// unit and eliminates the (potentially large) scheduling</span></span><br><span class="line">    <span class="comment">// latency that otherwise arises from adding the ready&#x27;d</span></span><br><span class="line">    <span class="comment">// goroutines to the end of the run queue.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note that while other P&#x27;s may atomically CAS this to zero,</span></span><br><span class="line">    <span class="comment">// only the owner P can CAS it to a valid G.</span></span><br><span class="line">    runnext guintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Available G&#x27;s (status == Gdead)</span></span><br><span class="line">    gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">        gList</span><br><span class="line">        n <span class="keyword">int32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache of mspan objects from the heap.</span></span><br><span class="line">    mspancache <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// We need an explicit length here because this field is used</span></span><br><span class="line">        <span class="comment">// in allocation codepaths where write barriers are not allowed,</span></span><br><span class="line">        <span class="comment">// and eliminating the write barrier/keeping it eliminated from</span></span><br><span class="line">        <span class="comment">// slice updates is tricky, more so than just managing the length</span></span><br><span class="line">        <span class="comment">// ourselves.</span></span><br><span class="line">        <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">        buf [<span class="number">128</span>]*mspan</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache of a single pinner object to reduce allocations from repeated</span></span><br><span class="line">    <span class="comment">// pinner creation.</span></span><br><span class="line">    pinnerCache *pinner</span><br><span class="line"></span><br><span class="line">    trace pTraceState</span><br><span class="line"></span><br><span class="line">    palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-P GC state</span></span><br><span class="line">    gcAssistTime         <span class="keyword">int64</span> <span class="comment">// Nanoseconds in assistAlloc</span></span><br><span class="line">    gcFractionalMarkTime <span class="keyword">int64</span> <span class="comment">// Nanoseconds in fractional mark worker (atomic)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// limiterEvent tracks events for the GC CPU limiter.</span></span><br><span class="line">    limiterEvent limiterEvent</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcMarkWorkerMode is the mode for the next mark worker to run in.</span></span><br><span class="line">    <span class="comment">// That is, this is used to communicate with the worker goroutine</span></span><br><span class="line">    <span class="comment">// selected for immediate execution by</span></span><br><span class="line">    <span class="comment">// gcController.findRunnableGCWorker. When scheduling other goroutines,</span></span><br><span class="line">    <span class="comment">// this field must be set to gcMarkWorkerNotWorker.</span></span><br><span class="line">    gcMarkWorkerMode gcMarkWorkerMode</span><br><span class="line">    <span class="comment">// gcMarkWorkerStartTime is the nanotime() at which the most recent</span></span><br><span class="line">    <span class="comment">// mark worker started.</span></span><br><span class="line">    gcMarkWorkerStartTime <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcw is this P&#x27;s GC work buffer cache. The work buffer is</span></span><br><span class="line">    <span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line">    <span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">    gcw gcWork</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbBuf is this P&#x27;s GC write barrier buffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Consider caching this in the running G.</span></span><br><span class="line">    wbBuf wbBuf</span><br><span class="line"></span><br><span class="line">    runSafePointFn <span class="keyword">uint32</span> <span class="comment">// if 1, run sched.safePointFn at next safe point</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// statsSeq is a counter indicating whether this P is currently</span></span><br><span class="line">    <span class="comment">// writing any stats. Its value is even when not, odd when it is.</span></span><br><span class="line">    statsSeq atomic.Uint32</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Timer heap.</span></span><br><span class="line">    timers timers</span><br><span class="line"></span><br><span class="line">    <span class="comment">// maxStackScanDelta accumulates the amount of stack space held by</span></span><br><span class="line">    <span class="comment">// live goroutines (i.e. those eligible for stack scanning).</span></span><br><span class="line">    <span class="comment">// Flushed to gcController.maxStackScan once maxStackScanSlack</span></span><br><span class="line">    <span class="comment">// or -maxStackScanSlack is reached.</span></span><br><span class="line">    maxStackScanDelta <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gc-time statistics about current goroutines</span></span><br><span class="line">    <span class="comment">// Note that this differs from maxStackScan in that this</span></span><br><span class="line">    <span class="comment">// accumulates the actual stack observed to be used at GC time (hi - sp),</span></span><br><span class="line">    <span class="comment">// not an instantaneous measure of the total stack size that might need</span></span><br><span class="line">    <span class="comment">// to be scanned (hi - lo).</span></span><br><span class="line">    scannedStackSize <span class="keyword">uint64</span> <span class="comment">// stack size of goroutines scanned by this P</span></span><br><span class="line">    scannedStacks    <span class="keyword">uint64</span> <span class="comment">// number of goroutines scanned by this P</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// preempt is set to indicate that this P should be enter the</span></span><br><span class="line">    <span class="comment">// scheduler ASAP (regardless of what G is running on it).</span></span><br><span class="line">    preempt <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pageTraceBuf is a buffer for writing out page allocation/free/scavenge traces.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Used only if GOEXPERIMENT=pagetrace.</span></span><br><span class="line">    pageTraceBuf pageTraceBuf</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Padding is no longer needed. False sharing is now not a worry because p is large enough</span></span><br><span class="line">    <span class="comment">// that its size class is an integer multiple of the cache line size (for any of our architectures).</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 P 中有一个 Grunnable 的 goroutine 队列，这是一个 P 的局部队列</li>
<li>当 P 执行 go 代码时，它会优先从自己的这个局部队列中取，这时可以不用加锁，提高了并发度</li>
<li>如果发现这个队列空了，则去其它 P 的队列中拿一半过来，这样实现工作流窃取的调度（这种情况下是需要给调用器加锁的）</li>
</ul>
<p><strong>结构体 Sched</strong></p>
<p>Sched 是调度实现中使用的数据结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    goidgen   atomic.Uint64</span><br><span class="line">    lastpoll  atomic.Int64 <span class="comment">// time of last network poll, 0 if currently polling</span></span><br><span class="line">    pollUntil atomic.Int64 <span class="comment">// time to which current poll is sleeping</span></span><br><span class="line"></span><br><span class="line">    lock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be</span></span><br><span class="line">    <span class="comment">// sure to call checkdead().</span></span><br><span class="line"></span><br><span class="line">    midle        muintptr <span class="comment">// idle m&#x27;s waiting for work</span></span><br><span class="line">    nmidle       <span class="keyword">int32</span>    <span class="comment">// number of idle m&#x27;s waiting for work</span></span><br><span class="line">    nmidlelocked <span class="keyword">int32</span>    <span class="comment">// number of locked m&#x27;s waiting for work</span></span><br><span class="line">    mnext        <span class="keyword">int64</span>    <span class="comment">// number of m&#x27;s that have been created and next M ID</span></span><br><span class="line">    maxmcount    <span class="keyword">int32</span>    <span class="comment">// maximum number of m&#x27;s allowed (or die)</span></span><br><span class="line">    nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m&#x27;s not counted for deadlock</span></span><br><span class="line">    nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m&#x27;s</span></span><br><span class="line"></span><br><span class="line">    ngsys atomic.Int32 <span class="comment">// number of system goroutines</span></span><br><span class="line"></span><br><span class="line">    pidle        puintptr <span class="comment">// idle p&#x27;s</span></span><br><span class="line">    npidle       atomic.Int32	<span class="comment">// idle P的数量</span></span><br><span class="line">    nmspinning   atomic.Int32  <span class="comment">// See &quot;Worker thread parking/unparking&quot; comment in proc.go.</span></span><br><span class="line">    needspinning atomic.Uint32 <span class="comment">// See &quot;Delicate dance&quot; comment in proc.go. Boolean. Must hold sched.lock to set to 1.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global runnable queue.</span></span><br><span class="line">    runq     gQueue</span><br><span class="line">    runqsize <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// disable controls selective disabling of the scheduler.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Use schedEnableUser to control this.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// disable is protected by sched.lock.</span></span><br><span class="line">    disable <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// user disables scheduling of user goroutines.</span></span><br><span class="line">        user     <span class="keyword">bool</span></span><br><span class="line">        runnable gQueue <span class="comment">// pending runnable Gs</span></span><br><span class="line">        n        <span class="keyword">int32</span>  <span class="comment">// length of runnable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global cache of dead G&#x27;s.</span></span><br><span class="line">    gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">        lock    mutex</span><br><span class="line">        stack   gList <span class="comment">// Gs with stacks</span></span><br><span class="line">        noStack gList <span class="comment">// Gs without stacks</span></span><br><span class="line">        n       <span class="keyword">int32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Central cache of sudog structs.</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Central pool of available defer structs.</span></span><br><span class="line">    deferlock mutex</span><br><span class="line">    deferpool *_defer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// freem is the list of m&#x27;s waiting to be freed when their</span></span><br><span class="line">    <span class="comment">// m.exited is set. Linked through m.freelink.</span></span><br><span class="line">    freem *m</span><br><span class="line"></span><br><span class="line">    gcwaiting  atomic.Bool <span class="comment">// gc is waiting to run</span></span><br><span class="line">    stopwait   <span class="keyword">int32</span></span><br><span class="line">    stopnote   note</span><br><span class="line">    sysmonwait atomic.Bool</span><br><span class="line">    sysmonnote note</span><br><span class="line"></span><br><span class="line">    <span class="comment">// safePointFn should be called on each P at the next GC</span></span><br><span class="line">    <span class="comment">// safepoint if p.runSafePointFn is set.</span></span><br><span class="line">    safePointFn   <span class="function"><span class="keyword">func</span><span class="params">(*p)</span></span></span><br><span class="line">    safePointWait <span class="keyword">int32</span></span><br><span class="line">    safePointNote note</span><br><span class="line"></span><br><span class="line">    profilehz <span class="keyword">int32</span> <span class="comment">// cpu profiling rate</span></span><br><span class="line"></span><br><span class="line">    procresizetime <span class="keyword">int64</span> <span class="comment">// nanotime() of last change to gomaxprocs</span></span><br><span class="line">    totaltime      <span class="keyword">int64</span> <span class="comment">// ∫gomaxprocs dt up to procresizetime</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sysmonlock protects sysmon&#x27;s actions on the runtime.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Acquire and hold this mutex to block sysmon from interacting</span></span><br><span class="line">    <span class="comment">// with the rest of the runtime.</span></span><br><span class="line">    sysmonlock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timeToRun is a distribution of scheduling latencies, defined</span></span><br><span class="line">    <span class="comment">// as the sum of time a G spends in the _Grunnable state before</span></span><br><span class="line">    <span class="comment">// it transitions to _Grunning.</span></span><br><span class="line">    timeToRun timeHistogram</span><br><span class="line"></span><br><span class="line">    <span class="comment">// idleTime is the total CPU time Ps have &quot;spent&quot; idle.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Reset on each GC cycle.</span></span><br><span class="line">    idleTime atomic.Int64</span><br><span class="line"></span><br><span class="line">    <span class="comment">// totalMutexWaitTime is the sum of time goroutines have spent in _Gwaiting</span></span><br><span class="line">    <span class="comment">// with a waitreason of the form waitReasonSync&#123;RW,&#125;Mutex&#123;R,&#125;Lock.</span></span><br><span class="line">    totalMutexWaitTime atomic.Int64</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stwStoppingTimeGC/Other are distributions of stop-the-world stopping</span></span><br><span class="line">    <span class="comment">// latencies, defined as the time taken by stopTheWorldWithSema to get</span></span><br><span class="line">    <span class="comment">// all Ps to stop. stwStoppingTimeGC covers all GC-related STWs,</span></span><br><span class="line">    <span class="comment">// stwStoppingTimeOther covers the others.</span></span><br><span class="line">    stwStoppingTimeGC    timeHistogram</span><br><span class="line">    stwStoppingTimeOther timeHistogram</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stwTotalTimeGC/Other are distributions of stop-the-world total</span></span><br><span class="line">    <span class="comment">// latencies, defined as the total time from stopTheWorldWithSema to</span></span><br><span class="line">    <span class="comment">// startTheWorldWithSema. This is a superset of</span></span><br><span class="line">    <span class="comment">// stwStoppingTimeGC/Other. stwTotalTimeGC covers all GC-related STWs,</span></span><br><span class="line">    <span class="comment">// stwTotalTimeOther covers the others.</span></span><br><span class="line">    stwTotalTimeGC    timeHistogram</span><br><span class="line">    stwTotalTimeOther timeHistogram</span><br><span class="line"></span><br><span class="line">    <span class="comment">// totalRuntimeLockWaitTime (plus the value of lockWaitTime on each M in</span></span><br><span class="line">    <span class="comment">// allm) is the sum of time goroutines have spent in _Grunnable and with an</span></span><br><span class="line">    <span class="comment">// M, but waiting for locks within the runtime. This field stores the value</span></span><br><span class="line">    <span class="comment">// for Ms that have exited.</span></span><br><span class="line">    totalRuntimeLockWaitTime atomic.Int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中有 M 的 idle 队列，P 的 idle 队列，以及一个全局的就绪的 G 队列</li>
</ul>
<p><strong>G-P-M 模型</strong></p>
<p>G-P-M 模型是基于线程池演化而来：</p>
<ul>
<li>把每个工作线程叫 worker 的话，每条线程运行一个 worker</li>
<li>每个 worker 做的事情就是不停地从队列中取出任务并执行 </li>
</ul>
<p>在 G-P-M 模型中：</p>
<ul>
<li>G 就是我们需要完成的任务</li>
<li>M 就是一个 worker（一条线程）</li>
<li>Sched 相当于管理可运行 G 的全局任务队列（当然也包括了其他的辅助信息）</li>
<li>P 则是在 go-1.1 中才引入的内容，为了解决 G 阻塞导致的 M 资源浪费问题</li>
</ul>
<p>G-P-M 模型图解：</p>
<img src="/2024/03/24/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Go/20200519101221568.png" class width="20200519101221568">   
<ul>
<li>G：goroutine 协程<ul>
<li>通过 go 关键字创建，封装了所要执行的代码逻辑</li>
<li>属于用户级资源，对 OS 透明，具备轻量级，可以大量创建，上下文切换成本地等特点</li>
</ul>
</li>
<li>P：Processor 逻辑处理器<ul>
<li>默认 go 运行时的 Processor 数量等于 CPU 数量，也可以通过 GOMAXPROCS 函数指定 P 的数量</li>
<li>P 的主要作用是管理 G 运行，每个 P 拥有一个本地队列并为 G 在 M 上的运行提供本地化资源</li>
</ul>
</li>
<li>M：Machine 操作系统创建的系统线程<ul>
<li>作用是执行 G 中包装的并行任务，被称为物理处理器</li>
<li>其属于 OS 资源，可以创建的数量上也受限与 OS，通常情况下 G 的数量都多于活跃的 M</li>
<li>go 运行时调度器将 G 公平合理的安排到多个 M 上去执行</li>
</ul>
</li>
<li>G和M的关系：<ul>
<li>G是要执行的任务，M是具体执行G的工作线程，通过P建立G和M的联系从而执行</li>
</ul>
</li>
<li>G和P的关系：<ul>
<li>P是G的管理者，P将G交由M执行，并管理一定系统资源供G使用，一个P管理存储在其本地队列的所有G（P和G是1:n的关系）</li>
</ul>
</li>
<li>P和M的关系：<ul>
<li>P将管理的G交由M具体执行，当遇到阻塞时，P可以与M解绑，并找到空闲的M进行绑定继续执行队列中其他可执行的G（P和M是1:1的关系）</li>
</ul>
</li>
</ul>
<p>P 会从 Sched 中拿取 G 并加入自己的任务队列（在该任务队列中使用轻量级切换，不涉及内核），然后 P 将自己任务队列中的 G 交给 M 执行，一旦 G 阻塞，P 就会与 M 解除绑定，并寻找空闲的 M 继续执行任务队列中的 G，如果 P 中的任务队列全部执行完毕，则 P 会随机从其它 P 中窃取一半的可运行的 G</p>
<p><strong>创建&amp;销毁 goroutine</strong></p>
<p>函数 runtime.newproc 会创建一个新的 G 结构体（核心工作由 runtime.newproc1 完成）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, callergp *g, callerpc <span class="keyword">uintptr</span>, parked <span class="keyword">bool</span>, waitreason waitReason)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">        fatal(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp := acquirem() <span class="comment">/* 获取当前的结构体M */</span></span><br><span class="line">    pp := mp.p.ptr() <span class="comment">/* 获取当前结构体M的P队列 */</span></span><br><span class="line">    newg := gfget(pp) <span class="comment">/* 查找是否有可用的结构体G */</span></span><br><span class="line">    <span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">        newg = malg(stackMin) <span class="comment">/* 创建一个拥有StackMin大小的栈的g */</span></span><br><span class="line">        casgstatus(newg, _Gidle, _Gdead) <span class="comment">/* 将新创建的g从_Gidle更新为_Gdead状态 */</span></span><br><span class="line">        allgadd(newg) <span class="comment">/* 将它挂到runtime的相关队列(allg)中 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> newg.stack.hi == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;newproc1: newg missing stack&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> readgstatus(newg) != _Gdead &#123;</span><br><span class="line">        throw(<span class="string">&quot;newproc1: new g is not Gdead&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totalSize := <span class="keyword">uintptr</span>(<span class="number">4</span>*goarch.PtrSize + sys.MinFrameSize) <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">    totalSize = alignUp(totalSize, sys.StackAlign)</span><br><span class="line">    sp := newg.stack.hi - totalSize</span><br><span class="line">    <span class="keyword">if</span> usesLR &#123;</span><br><span class="line">        <span class="comment">// caller&#x27;s LR</span></span><br><span class="line">        *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">        prepGoExitFrame(sp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> GOARCH == <span class="string">&quot;arm64&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// caller&#x27;s FP</span></span><br><span class="line">        *(*<span class="keyword">uintptr</span>)(unsafe.Pointer(sp - goarch.PtrSize)) = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">    newg.sched.sp = sp <span class="comment">/* 将sp,pc等上下文环境保存在g的sched域 */</span></span><br><span class="line">    newg.stktopsp = sp</span><br><span class="line">    newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">    newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">    gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">    newg.parentGoid = callergp.goid</span><br><span class="line">    newg.gopc = callerpc</span><br><span class="line">    newg.ancestors = saveAncestors(callergp)</span><br><span class="line">    newg.startpc = fn.fn</span><br><span class="line">    <span class="keyword">if</span> isSystemGoroutine(newg, <span class="literal">false</span>) &#123;</span><br><span class="line">        sched.ngsys.Add(<span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Only user goroutines inherit pprof labels.</span></span><br><span class="line">        <span class="keyword">if</span> mp.curg != <span class="literal">nil</span> &#123;</span><br><span class="line">            newg.labels = mp.curg.labels</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> goroutineProfile.active &#123;</span><br><span class="line">            <span class="comment">// A concurrent goroutine profile is running. It should include</span></span><br><span class="line">            <span class="comment">// exactly the set of goroutines that were alive when the goroutine</span></span><br><span class="line">            <span class="comment">// profiler first stopped the world. That does not include newg, so</span></span><br><span class="line">            <span class="comment">// mark it as not needing a profile before transitioning it from</span></span><br><span class="line">            <span class="comment">// _Gdead.</span></span><br><span class="line">            newg.goroutineProfiled.Store(goroutineProfileSatisfied)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Track initial transition?</span></span><br><span class="line">    newg.trackingSeq = <span class="keyword">uint8</span>(cheaprand())</span><br><span class="line">    <span class="keyword">if</span> newg.trackingSeq%gTrackingPeriod == <span class="number">0</span> &#123;</span><br><span class="line">        newg.tracking = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    gcController.addScannableStack(pp, <span class="keyword">int64</span>(newg.stack.hi-newg.stack.lo)) <span class="comment">/* 分配goroutine id */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get a goid and switch to runnable. Make all this atomic to the tracer.</span></span><br><span class="line">    trace := traceAcquire()</span><br><span class="line">    <span class="keyword">var</span> status <span class="keyword">uint32</span> = _Grunnable</span><br><span class="line">    <span class="keyword">if</span> parked &#123;</span><br><span class="line">        status = _Gwaiting</span><br><span class="line">        newg.waitreason = waitreason</span><br><span class="line">    &#125;</span><br><span class="line">    casgstatus(newg, _Gdead, status)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将初始化完成的结构体G,挂到当前M的P的队列中 */</span></span><br><span class="line">    <span class="keyword">if</span> pp.goidcache == pp.goidcacheend &#123;</span><br><span class="line">        <span class="comment">// Sched.goidgen is the last allocated id,</span></span><br><span class="line">        <span class="comment">// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].</span></span><br><span class="line">        <span class="comment">// At startup sched.goidgen=0, so main goroutine receives goid=1.</span></span><br><span class="line">        pp.goidcache = sched.goidgen.Add(_GoidCacheBatch)</span><br><span class="line">        pp.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">        pp.goidcacheend = pp.goidcache + _GoidCacheBatch</span><br><span class="line">    &#125;</span><br><span class="line">    newg.goid = pp.goidcache</span><br><span class="line">    pp.goidcache++</span><br><span class="line">    newg.trace.reset()</span><br><span class="line">    <span class="keyword">if</span> trace.ok() &#123;</span><br><span class="line">        trace.GoCreate(newg, newg.startpc, parked)</span><br><span class="line">        traceRelease(trace)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up race context.</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        newg.racectx = racegostart(callerpc)</span><br><span class="line">        newg.raceignore = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> newg.labels != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// See note in proflabel.go on labelSync&#x27;s role in synchronizing</span></span><br><span class="line">            <span class="comment">// with the reads in the signal handler.</span></span><br><span class="line">            racereleasemergeg(newg, unsafe.Pointer(&amp;labelSync))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wakep 函数唤醒 P 时，调度器会试着寻找一个可用的 M 来绑定 P，必要的时候会新建 M，之后的调用链如下：</p>
<ul>
<li>newproc -&gt; newproc1 -&gt; wakep(如果P数目没到上限) -&gt; startm -&gt; newm -&gt; newosproc -&gt; mstart(线程入口) -&gt; schedule -&gt; execute -&gt; goroutine 协程运行</li>
<li>execute 会恢复 newproc1 中设置的上下文，这样就跳转到新的 goroutine 去执行了</li>
</ul>
<p>当 fnstart 函数执行完返回时，它会返回到 runtime.exit 中，这时 runtime.exit 中会做一些回收工作，会将 G 的状态设置为 Gdead 等，并将 G 挂到 P 的 free 队列中</p>
<p><strong>抢占式 goroutine</strong></p>
<p>go 只是引入了一些很初级的抢占，并没有像操作系统调度那么复杂，没有对 goroutine 分时间片，设置优先级等，只有长时间阻塞于系统调用，或者运行了较长时间才会被抢占</p>
<p>runtime 开了一条后台线程，运行一个 sysmon 函数，这个函数会周期性地做 epoll 操作，同时它还会检测每个 P 是否运行了较长时间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	sched.nmsys++</span><br><span class="line">	checkdead()</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">	delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// start with 20us sleep...</span></span><br><span class="line">			delay = <span class="number">20</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// start doubling the sleep after 1ms...</span></span><br><span class="line">			delay *= <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">// up to 10ms</span></span><br><span class="line">			delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">		&#125;</span><br><span class="line">		usleep(delay)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// sysmon should not enter deep sleep if schedtrace is enabled so that</span></span><br><span class="line">		<span class="comment">// it can print that information at the right time.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// It should also not enter deep sleep if there are any active P&#x27;s so</span></span><br><span class="line">		<span class="comment">// that it can retake P&#x27;s from syscalls, preempt long running G&#x27;s, and</span></span><br><span class="line">		<span class="comment">// poll the network if all P&#x27;s are busy for long stretches.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// It should wakeup from deep sleep if any P&#x27;s become active either due</span></span><br><span class="line">		<span class="comment">// to exiting a syscall or waking up due to a timer expiring so that it</span></span><br><span class="line">		<span class="comment">// can resume performing those duties. If it wakes from a syscall it</span></span><br><span class="line">		<span class="comment">// resets idle and delay as a bet that since it had retaken a P from a</span></span><br><span class="line">		<span class="comment">// syscall before, it may need to do it again shortly after the</span></span><br><span class="line">		<span class="comment">// application starts work again. It does not reset idle when waking</span></span><br><span class="line">		<span class="comment">// from a timer to avoid adding system load to applications that spend</span></span><br><span class="line">		<span class="comment">// most of their time sleeping.</span></span><br><span class="line">		now := nanotime()</span><br><span class="line">		<span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting.Load() || sched.npidle.Load() == gomaxprocs) &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> sched.gcwaiting.Load() || sched.npidle.Load() == gomaxprocs &#123;</span><br><span class="line">				syscallWake := <span class="literal">false</span></span><br><span class="line">				next := timeSleepUntil()</span><br><span class="line">				<span class="keyword">if</span> next &gt; now &#123;</span><br><span class="line">					sched.sysmonwait.Store(<span class="literal">true</span>)</span><br><span class="line">					unlock(&amp;sched.lock)</span><br><span class="line">					<span class="comment">// Make wake-up period small enough</span></span><br><span class="line">					<span class="comment">// for the sampling to be correct.</span></span><br><span class="line">					sleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">					<span class="keyword">if</span> next-now &lt; sleep &#123;</span><br><span class="line">						sleep = next - now</span><br><span class="line">					&#125;</span><br><span class="line">					shouldRelax := sleep &gt;= osRelaxMinNS</span><br><span class="line">					<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">						osRelax(<span class="literal">true</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					syscallWake = notetsleep(&amp;sched.sysmonnote, sleep)</span><br><span class="line">					<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">						osRelax(<span class="literal">false</span>)</span><br><span class="line">					&#125;</span><br><span class="line">					lock(&amp;sched.lock)</span><br><span class="line">					sched.sysmonwait.Store(<span class="literal">false</span>)</span><br><span class="line">					noteclear(&amp;sched.sysmonnote)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> syscallWake &#123;</span><br><span class="line">					idle = <span class="number">0</span></span><br><span class="line">					delay = <span class="number">20</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lock(&amp;sched.sysmonlock)</span><br><span class="line">		<span class="comment">// Update now in case we blocked on sysmonnote or spent a long time</span></span><br><span class="line">		<span class="comment">// blocked on schedlock or sysmonlock above.</span></span><br><span class="line">		now = nanotime()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// trigger libc interceptors if needed</span></span><br><span class="line">		<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">			asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// poll network if not polled for more than 10ms</span></span><br><span class="line">		lastpoll := sched.lastpoll.Load()</span><br><span class="line">		<span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">			sched.lastpoll.CompareAndSwap(lastpoll, now)</span><br><span class="line">			list, delta := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">			<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">				<span class="comment">// Need to decrement number of idle locked M&#x27;s</span></span><br><span class="line">				<span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">				<span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">				<span class="comment">// injectglist grabs all P&#x27;s but before it starts M&#x27;s to run the P&#x27;s,</span></span><br><span class="line">				<span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">				<span class="comment">// observes that there is no work to do and no other running M&#x27;s</span></span><br><span class="line">				<span class="comment">// and reports deadlock.</span></span><br><span class="line">				incidlelocked(<span class="number">-1</span>)</span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				incidlelocked(<span class="number">1</span>)</span><br><span class="line">				netpollAdjustWaiters(delta)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> GOOS == <span class="string">&quot;netbsd&quot;</span> &amp;&amp; needSysmonWorkaround &#123;</span><br><span class="line">			<span class="comment">// netpoll is responsible for waiting for timer</span></span><br><span class="line">			<span class="comment">// expiration, so we typically don&#x27;t have to worry</span></span><br><span class="line">			<span class="comment">// about starting an M to service timers. (Note that</span></span><br><span class="line">			<span class="comment">// sleep for timeSleepUntil above simply ensures sysmon</span></span><br><span class="line">			<span class="comment">// starts running again when that timer expiration may</span></span><br><span class="line">			<span class="comment">// cause Go code to run again).</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// However, netbsd has a kernel bug that sometimes</span></span><br><span class="line">			<span class="comment">// misses netpollBreak wake-ups, which can lead to</span></span><br><span class="line">			<span class="comment">// unbounded delays servicing timers. If we detect this</span></span><br><span class="line">			<span class="comment">// overrun, then startm to get something to handle the</span></span><br><span class="line">			<span class="comment">// timer.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// See issue 42515 and</span></span><br><span class="line">			<span class="comment">// https://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=50094.</span></span><br><span class="line">			<span class="keyword">if</span> next := timeSleepUntil(); next &lt; now &#123;</span><br><span class="line">				startm(<span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> scavenger.sysmonWake.Load() != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Kick the scavenger awake if someone requested it.</span></span><br><span class="line">			scavenger.wake()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// retake P&#x27;s blocked in syscalls</span></span><br><span class="line">		<span class="comment">// and preempt long running G&#x27;s</span></span><br><span class="line">		<span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">			idle = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			idle++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// check if we need to force a GC</span></span><br><span class="line">		<span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; forcegc.idle.Load() &#123;</span><br><span class="line">			lock(&amp;forcegc.lock)</span><br><span class="line">			forcegc.idle.Store(<span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">var</span> list gList</span><br><span class="line">			list.push(forcegc.g)</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">			unlock(&amp;forcegc.lock)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="keyword">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">			lasttrace = now</span><br><span class="line">			schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.sysmonlock)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果检测到某个 P 的状态为 Prunning，并且它已经运行了超过10ms，则会将 P 的当前的 G 的 stackguard 设置为 StackPreempt</li>
<li>这个操作其实是相当于加上一个标记，通知这个 G 在合适时机进行调度</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>go 是一门带垃圾回收的语言，go 内存管理机制主要有两个方面：</p>
<ul>
<li>一个方面是内存池</li>
<li>一个方面是垃圾回收</li>
</ul>
<p><strong>内存池</strong></p>
<p>go 的内存分配器采用了跟 tcmalloc 库相同的实现，是一个带内存池的分配器，底层直接调用操作系统的 mmap 等函数</p>
<ul>
<li>在多线程方面，每条线程都有自己的本地的内存，当某个线程中内存不足后就向全局分配链中申请内存 </li>
<li>在避免内存碎片方面，大块内存直接按页为单位分配，小块内存会切成各种不同的固定大小的块，申请做任意字节内存时会向上取整到最接近的块，将整块分配给申请者以避免随意切割 </li>
</ul>
<p>go 中为每个系统线程分配一个本地的 MCache（结构体 M 中的 MCache 域）</p>
<ul>
<li>少量的地址分配就直接从 MCache 中分配，并且定期做垃圾回收</li>
<li>大对象直接从全局控制堆上以页（4k）为单位进行分配</li>
</ul>
<p>分配器的数据结构包括：</p>
<ul>
<li>FixAlloc：固定大小(128kB)的对象的空闲链分配器，被分配器用于管理存储</li>
<li>MHeap：分配堆，按页的粒度进行管理(4kB)</li>
<li>MSpan：一些由 MHeap 管理的页（分配内存时的基本单元），会切分为等大的内存块</li>
<li>MCentral：对于给定尺寸类别的共享的 free list（本质上是空闲列表）</li>
<li>MCache：用于小对象的每 M 一个的 cache</li>
</ul>
<img src="/2024/03/24/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Go/1711269291386.png" class width="1711269291386"> 
<p><strong>垃圾收集</strong></p>
<p>go 语言的垃圾收集有两个策略：</p>
<ul>
<li>标记清扫算法（go-1.3）<ul>
<li>判断一个对象是否为垃圾（从 root 区域的对象是否有直接或间接的引用到这个对象）</li>
<li>开始标记，从根对象出发查找并标记堆中所有存活的对象</li>
<li>遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表 </li>
</ul>
</li>
<li>三色标记法（go-1.5）<ul>
<li>黑色 Black：表示对象是可达的，即使用中的对象，黑色是已经被扫描的对象</li>
<li>灰色 Gary：表示被黑色对象直接引用的对象，但还没对它进行扫描</li>
<li>白色 White：白色是对象的初始颜色，如果扫描完成后，对象依然还是白色的，说明此对象是垃圾对象</li>
<li>三色标记规则：黑色不能指向白色对象，即黑色可以指向灰色，灰色可以指向白色</li>
</ul>
</li>
<li>增量收集器（go-1.8）<ul>
<li>三色标记 + 混合写屏障</li>
</ul>
</li>
</ul>
<h2 id="运行时符号信息"><a href="#运行时符号信息" class="headerlink" title="运行时符号信息"></a>运行时符号信息</h2><p>go 语言 panic 时会有 traceback，不仅有函数调用，还有文件名和行号等信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;err&quot;</span>) <span class="comment">/* panic会导致程序提前返回,同时调用defer语句 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    k := i / j</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d / %d = %d\n&quot;</span>, i, j, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">panic: err</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">	/home/yhellow/桌面/gotest/test.go:<span class="number">13</span> +<span class="number">0x49</span></span><br></pre></td></tr></table></figure>
<p>虽然 C 语言的 assert 也能实现这个效果，但底层原理完全不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__assert_fail(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;test.c&quot;</span>, <span class="number">8u</span>, <span class="string">&quot;main&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>C 语言编译器直接将要输出的数据写入 <code>__assert_fail</code> 函数</li>
</ul>
<p><strong>pclntab 简析</strong></p>
<p>编译器在编译的时候会生成一些额外信息（会记录下函数地址对应的源文件行号，也就是 <code>pc-&gt;line</code> 的一张表，简称 pclntab），运行时符号信息就是这样生成的</p>
<p>pclntab 全名是 Program Counter Line Table 程序计数器行数映射表，概要结构如下：</p>
<ul>
<li>Magic Number：魔数</li>
<li>instruction size quantum</li>
<li>ptr size</li>
<li>functions number：函数数量</li>
<li>srcfile count number：源文件数量</li>
<li>text section start addr：代码段基址</li>
<li>func names table offset：函数名称表偏移</li>
<li>src file table offset：源码路径表偏移</li>
<li>pc table offset：PC表偏移</li>
<li>func table offset：函数表偏移</li>
</ul>
<p>使用 go_parser-master 处理后的 IDA 分析数据如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.gopclntab:<span class="number">00000000004B</span>8220 F1 FF FF FF                   runtime_symtab dd <span class="number">0F</span>FFFFFF1h            ; DATA XREF: LOAD:<span class="number">0000000000400398</span>↑o</span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8220                                                                       ; .noptrdata:runtime_firstmoduledata↓o</span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8220                                                                       ; Magic Number</span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8224 <span class="number">00</span> <span class="number">00</span>                         dw <span class="number">0</span></span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8226 <span class="number">01</span>                            db    <span class="number">1</span>                                 ; instruction size quantum</span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8227 <span class="number">08</span>                            db    <span class="number">8</span>                                 ; ptr size</span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8228 <span class="number">9B</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq <span class="number">59B</span>h                                 ; Functions number</span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8230 B1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq <span class="number">0B</span>1h                                 ; srcfile count number</span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8238 <span class="number">00</span> <span class="number">10</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq offset internal_cpu_Initialize       ; text section start addr, =firstmoduladata.text</span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8240 <span class="number">60</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq <span class="number">60</span>h                                  ; func names table offset, real addr: <span class="number">0x4b8280</span></span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8248 A0 C1 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq <span class="number">0</span>C1A0h                               ; Source file table addr: <span class="number">0x4c4b60</span></span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8250 <span class="number">40</span> C9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq <span class="number">0</span>C940h                               ; src file table offset, real addr: <span class="number">0x4c4b60</span></span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8258 C0 E3 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq <span class="number">0E3</span>C0h                               ; pc table offset, real addr: <span class="number">0x4c65e0</span></span><br><span class="line">.gopclntab:<span class="number">00000000004B</span>8260 <span class="number">00</span> A9 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       dq <span class="number">3</span>A900h                               ; func table offset, real addr: <span class="number">0x4f2b20</span></span><br></pre></td></tr></table></figure>
<p>每个函数都可以拥有一些元数据和 PC-Value 表，运行时符号信息由编译器在编译的时候生成，存放在可执行文件中，当程序被执行时，这张表被加载到内存，用于程序运行时辅助 go 的运行时库执行一些处理</p>
<p>一个函数符号表的形式就是一张 PC 的查找表，IDA 分析数据如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.gopclntab:<span class="number">00000000004F</span>2B20 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   runtime_functab dd <span class="number">0</span>                    ; DATA XREF: .noptrdata:<span class="number">0000000000517</span>D28↓o</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>2B20                                                                       ; .noptrdata:<span class="number">0000000000517</span>D40↓o</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>2B20                                                                       ; Function internal_cpu_Initialize @ <span class="number">0x401000</span></span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>2B24 E0 <span class="number">2</span>C <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">2</span>CE0h                                ; Func Struct @ <span class="number">0x4f5800</span></span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>2B28 <span class="number">60</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">60</span>h                                  ; Function internal_cpu_processOptions @ <span class="number">0x401060</span></span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>2B2C <span class="number">38</span> <span class="number">2</span>D <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">2</span>D38h                                ; Func Struct @ <span class="number">0x4f5858</span></span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>2B30 C0 <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">5</span>C0h                                 ; Function internal_cpu_doinit @ <span class="number">0x4015c0</span></span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>2B34 <span class="number">90</span> <span class="number">2</span>D <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">2</span>D90h                                ; Func Struct @ <span class="number">0x4f58b0</span></span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>2B38 <span class="number">40</span> <span class="number">0</span>E <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">0E40</span>h                                ; Function internal_cpu_cpuid @ <span class="number">0x401e40</span></span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>2B3C D8 <span class="number">2</span>D <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">2</span>DD8h                                ; Func Struct @ <span class="number">0x4f58f8</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一个条目是函数地址，第二个条目是 Func Struct（用于描述该函数的信息）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.gopclntab:<span class="number">00000000004F</span>5800 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">0</span>                                    ; Func Entry @ <span class="number">0x401000</span></span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>5804 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">0</span></span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>5808 <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">10</span>h                                  ; args</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>580C <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">0</span>                                    ; deferreturn</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>5810 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">1</span>                                    ; pcsp</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>5814 <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">8</span>                                    ; pcfile</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>5818 <span class="number">0B</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">0B</span>h                                  ; pcln</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>581C <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">4</span>                                    ; npcdata</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>5820 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">0</span>                                    ; cuOffset</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>5824 <span class="number">7</span>D <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   dd <span class="number">7</span>Dh                                  ; startline</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>5828 <span class="number">00</span>                            db    <span class="number">0</span>                                 ; func_type: normal</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>5829 <span class="number">00</span>                            db    <span class="number">0</span>                                 ; func_flag</span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>582A <span class="number">00</span>                            db    <span class="number">0</span></span><br><span class="line">.gopclntab:<span class="number">00000000004F</span>582B <span class="number">07</span>                            db    <span class="number">7</span>                                 ; nfuncdata</span><br></pre></td></tr></table></figure>
<ul>
<li>在 go 源码中对应的结构体如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _func <span class="keyword">struct</span> &#123;</span><br><span class="line">	sys.NotInHeap <span class="comment">// Only in static data</span></span><br><span class="line"></span><br><span class="line">	entryOff <span class="keyword">uint32</span> <span class="comment">// start pc, as offset from moduledata.text/pcHeader.textStart</span></span><br><span class="line">	nameOff  <span class="keyword">int32</span>  <span class="comment">// function name, as index into moduledata.funcnametab.</span></span><br><span class="line"></span><br><span class="line">	args        <span class="keyword">int32</span>  <span class="comment">// in/out args size</span></span><br><span class="line">	deferreturn <span class="keyword">uint32</span> <span class="comment">// offset of start of a deferreturn call instruction from entry, if any.</span></span><br><span class="line"></span><br><span class="line">	pcsp      <span class="keyword">uint32</span></span><br><span class="line">	pcfile    <span class="keyword">uint32</span></span><br><span class="line">	pcln      <span class="keyword">uint32</span></span><br><span class="line">	npcdata   <span class="keyword">uint32</span></span><br><span class="line">	cuOffset  <span class="keyword">uint32</span>     <span class="comment">// runtime.cutab offset of this function&#x27;s CU</span></span><br><span class="line">	startLine <span class="keyword">int32</span>      <span class="comment">// line number of start of function (func keyword/TEXT directive)</span></span><br><span class="line">	funcID    abi.FuncID <span class="comment">// set for certain special runtime functions</span></span><br><span class="line">	flag      abi.FuncFlag</span><br><span class="line">	_         [<span class="number">1</span>]<span class="keyword">byte</span> <span class="comment">// pad</span></span><br><span class="line">	nfuncdata <span class="keyword">uint8</span>   <span class="comment">// must be last, must end on a uint32-aligned boundary</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The end of the struct is followed immediately by two variable-length</span></span><br><span class="line">	<span class="comment">// arrays that reference the pcdata and funcdata locations for this</span></span><br><span class="line">	<span class="comment">// function.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pcdata contains the offset into moduledata.pctab for the start of</span></span><br><span class="line">	<span class="comment">// that index&#x27;s table. e.g.,</span></span><br><span class="line">	<span class="comment">// &amp;moduledata.pctab[_func.pcdata[_PCDATA_UnsafePoint]] is the start of</span></span><br><span class="line">	<span class="comment">// the unsafe point table.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// An offset of 0 indicates that there is no table.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// pcdata [npcdata]uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// funcdata contains the offset past moduledata.gofunc which contains a</span></span><br><span class="line">	<span class="comment">// pointer to that index&#x27;s funcdata. e.g.,</span></span><br><span class="line">	<span class="comment">// *(moduledata.gofunc +  _func.funcdata[_FUNCDATA_ArgsPointerMaps]) is</span></span><br><span class="line">	<span class="comment">// the argument pointer map.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// An offset of ^uint32(0) indicates that there is no entry.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// funcdata [nfuncdata]uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"><i class="fa fa-tag"></i> golang</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/21/DubheCTF2024/" rel="prev" title="DubheCTF2024">
      <i class="fa fa-chevron-left"></i> DubheCTF2024
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/29/L3HCTF2024/" rel="next" title="L3HCTF2024">
      L3HCTF2024 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">函数调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">3.</span> <span class="nav-text">协程调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AC%A6%E5%8F%B7%E4%BF%A1%E6%81%AF"><span class="nav-number">5.</span> <span class="nav-text">运行时符号信息</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">320</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">169</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">4.8m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">73:23</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
